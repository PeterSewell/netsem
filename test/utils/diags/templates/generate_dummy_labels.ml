(* hackery taken from lts_to_latex to construct roman numerals *)

(* find first pair with key less than or equal to search key *)
let rec gassoc i = function
  | [] -> None
  | ((n,x)::nxs) ->
      if i >= n then
        Some (n,x)
      else
        gassoc i nxs

let rec roman_pos uc i =
  let letters =
    if uc then
      [(1000,"M"); (900,"CM"); (500,"D"); (400,"CD");
       (100,"C"); (90,"XC"); (50,"L"); (40,"XL");
       (10,"X"); (9,"IX"); (5,"V"); (4,"IV"); (1,"I")]
    else
      [(1000,"m"); (900,"cm"); (500,"d"); (400,"cd");
       (100,"c"); (90,"xc"); (50,"l"); (40,"xl");
       (10,"x"); (9,"ix"); (5,"v"); (4,"iv"); (1,"i")]
  in
  match gassoc i letters with
  | Some (n,s) ->
      s ^ roman_pos uc (i-n)
  | None ->
      if i = 0 then
        ""
      else
        raise (Failure ("roman: "^string_of_int i))

let roman uc i =
  if i < 0 then
    (if uc then "N" else "n")^roman_pos uc (-i)
  else if i > 0 then
    roman_pos uc i
  else
    (if uc then "Z" else "z")

let texify_index s =
  "\\label" ^ roman true (int_of_string (s))

let texify_index_b s =
  "\\label" ^ roman true (int_of_string (s)) ^ "b"


let _ = print_string "% dummy label file for build-diags2, autogenerated by generate_dummy_labels.ml (note it's munged in doc/tr but not in the standalone traceNNNN.annotated.ps.tz build process)\n"
let _ = for i=0 to 100 do (
        print_string ("\\newcommand{\\labelstep" ^ roman true (2*i) ^"}{"^ roman true (2*i) ^"}\n");
        print_string ("\\newcommand{\\labelstep" ^ roman true (2*i) ^"b}{"^ roman true (2*i) ^"b}\n")
) done
