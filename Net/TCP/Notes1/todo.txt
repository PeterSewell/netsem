Short-term planning:
~~~~~~~~~~~~~~~~~~~~

- need a description (in HOL) of the TCP segments we will use for
  levels 2 and 3.

==> mostly done I think.

- explain the mapping between the above and what *really* goes on in
  the network, e.g. fragmentation, IP options we don't consider, ARP,
  routing?, ...

  - make reassembly return a timestamped datagram
  - do UDP and ICMP too

  - do identity testing both ways; test reass code

==> hmm, working on an implementation, but do need to write some text
here.

- install NTP on testnet.  How accurate is it?

  (been reading various things about this - NTP is already there in
    BSD, and presumably can be put in in Linux.  The lab machines are
    already all running it.  Right now astrocyte claims an estimated
    error of 16.041 milliseconds from UTC, and thalamus 34.774
    milliseconds.  Stability: dunno.)

  ntp setup documented in ntp.txt.


- TESTING - we still have very little idea how to do this.

  - write LIB in Ocaml so we can do ad-hoc testing.

     - sort out strings/byte lists etc
     - sort out error type
     - lifted ports, ips, fds: hmm - ponder: makes sense to have IPs
       abstract since you always construct them by conversion from a
       string etc, but ports one could reasonably expect to be
       integers.  A socket-savvy programmer will also expect fds to be
       integers (the first one being 3).  But that isn't true for
       Winsock... it's a SOCKET.

     - NB will need unix and windows versions of LIB


  - write a remote tester to support the above?
    - possibly a C program, a daemon, that accepts LIB syscalls and
      performs them, and returns the results.  Might save us from
      installing OCaml on any new machine we want to test.
    - OTOH, probably a lot easier to write in OCaml!!
  - do ad-hoc automated testing.
  - figure out how to do automated testing for TCP.

  - figure out how to snarf the tcpcb stuff using SO_DEBUG, in BSD
    (TCPv2p916) (and in Linux??).  (yech - very whitebox...)

  - design a language for describing tests.

  - combination of an instrumented LIB and a suitably-configured
    tcpdump, generating some file that can be processed by HOL or
    Mosml.  (this file format should be similar to the test-describing
    language)
  - compare what HOL says to what the remote tester sees.

  - could hack the kernel to (a) stop the TCP timers ticking, and (b)
    stop TCP packets going out / coming in (or is the latter implied
    by the former?).

  - would be good if the automated tester tested all OSs
    *simultaneously*; this would ensure we don't let any OS slip
    behind and get forgotten.

- wiring eth0 to HOL (via netfilter and libipq).
  - hmm, actually running {tcpdump or libpcap} and raw sockets.
  - running live TCP.

- using HOL for checking traces.


** Michael says it's perfectly possible to trick the parser into
   treating a nested record as a flat record, with appropriate
   redefinitions and overloadings of the record selector and updator
   functions.


SO: we need to design the testing language.  What is it to do?

Before we design the language, do some ad-hoc tests written in just
OCAML.  Notice that in OCAML we can do marshalling between identical
binaries, so we can do the remote stuff just by marshalling the
function to call(!!).

Language must be able to express:
  - describe sequences of system calls
  - describe internal states?  at least *name* states, so we can
    inspect the HOL state at these points (and whatever of the OS
    state we can see).
  - describe expected returns from system calls
  - timestamps (wall-clock)
  - data on wire

  - note that some of this will be nondeterministic; how to cope with
    this?  symbolic evaluation?

Language will be used for:
  - being executed by HOL
  - being executed by OS (via driver/interpreter/daemon)
  - recording results of OS calls
  - recording results of HOL evaluation
  - recording tcpdump output or raw sockets output
  - recording timestamps etc from above and from instrumented LIB
  - being read by HOL to compare results of different OSs or HOL
  - being generated by a HOL test-script-generator

Important note:
  - *all* the testing should be remote; for the UDP stuff we had a
    local end and a remote end, but that doesn't scale so well.  We
    want to be able to implement only the remote daemon on the new
    architecture, and go from there.


- host states for level 2 (i.e., how do we represent the TCPCB).
  Probably pretty similar / identical to level 3.  (except that some
  flow control algs keep historical data to control flow with).

==> not thought about at all yet.





---------------

Note the 'socket debug options' mentioned in TCPv1p497, which suggests
we can get some(?) of the TCP control block state.

To further explicate our abstraction, I reckon we should write
instrumented C libraries for each architecture (BSD,Linux,WXP) which
have exactly the same interface as the respective usual sockets
libraries and dump logs of calls and returns.

The fact that we can do this will confirm the completeness of our LIB.

These logs should be in the same format as our instrumented OCaml
library.  That format should be human-readable. It's a bit tempting to
make it look like OCaml source code, but I think better to make it
look like HOL term syntax, as HOL values are really what we are
injecting into.

These C libraries could do their work either by calling the underlying
C sockets libraries directly or by calling our OCaml (instrumented) library.
Advantages to both: the former will be clearer to others and involves
less infrastucture; the latter avoids some repetition of
instrumentation work and enforces a bit more consistency.  I reckon
the former - to remove OCaml from the things that must be understood
by any systems guy coming to this stuff.  The OCaml and HOL libs are
annoyingly not quite isomorphic - different numeric types and
different abstractnessess of ip etc.

The instrumented OCaml LIB (which I guess we still want for writing our
tests in) should then just be linked in to the instrumented C.

==> after talking (K/P):

  want to keep OCaml out of the picture.  So we build a library that
  implements the socket operations in terms of the real C calls, but
  also logs to a file.  We give a semantics for this library.  OCaml
  LIB can also be implemented in terms of this library.

  Typing: we want to keep the HOL spec typed, for (extreme)
  convenience.  So the instrumentation layer will have to do some
  checking (and EINVAL-returning) by itself to bring things in line.

  send/sendto/sendmsg: all three calls will be translated and logged
  and then go through the same OS call (probably sendmsg; makes more
  sense to turn a buffer into an iovec than the other way around!).

  Doing the soxify thing is not on the critical path; not clear that
  traces collected in the wild will be manageable or technically
  interesting.  Just give new names to the existing calls, and modify
  some open source and recompile/link.  (Or maybe some tricks can be
  played with `ar' to make `socket' link to our code, rather than to
  the libc code.  Hmm.  Or maybe just #defines.)  ns_socket() etc.
  (ns for netsem, not nameserver!).

If we were being really cute, we'd nick the implementation of the
SOCKS thing (that intercepts socket calls) and use that tech to
dynamically link in our instrumented library - then can get test data
from runs of any binary.  Of course, for most things we can get the
sources and link normally, so the extra effort might be stupid.  In
any case, no guarantee we'll be able to handle non-tiny tests...


Minor pretty-printing point: should we make the TCP slurper output
look like TCPDUMP, for comprehensibility by the outside world?  Guess
primarily not, as it should be HOL terms... but then should be able to
pretty-print HOL label lists treating the I/O in a tcpdumpy way.

==> but if possible it should be easily readable by the
  TCPdump-influenced world.

TCP rule tactics: I reckon we should echo TCPv1 and do the whole
connection establishment/teardown story, ignoring data transmission,
first.  That's `almost' `finite' state...

Some tests will talk to two remote-socket-call daemons; some tests may
talk to one remote-socket-call daemon and one tcp-segment-injector daemon.

Some tests (eg simultaneous open/close) require a significant network
delay.  Use some distant machine (but then we have less clue about ntp
timing?) or a dialup laptop?


As far as possible, we should have tests for all the RFC1122
must/should/etc items.  Should look at the fingerprinting tools too.

Perhaps we should have two specs, or a parameter: a MAY level spec is
a looser one than a SHOULD level is a looser than a MUST level spec.
(or whatever).

-----

I (K) just noticed that BSD semantics for SO_REUSEADDR differs from Linux;
this indicates a patch required to UDP.  See TCPv2pp720f.  (note also
the existence of SO_REUSEPORT, with similar semantics to Linux's
SO_REUSEADDR).

-----

Musings by K:  Ultimately, I'm pretty sure we *don't* want the spec to
slavishly follow the BSD implementation.  There are a lot of things we
can do clearer and better in HOL; we should do them that way.  There
are also things we want to make nondeterministic, some of which
presumably can only be made so if we step back a little and don't
constrain everything to the particular implementation we're looking
at.  Sure we want names of objects in common to be the same, but this
doesn't mean we must *have* all the objects that BSD has.

I think the iobc type versus TCP_HA{VE,D}DATA issue is simply a matter
of giving sensible types, and so corresponds to mapping bitflags to a
total function.  There's no need to be pointedly primitive in typing.

More musings by K:  in some cases, there's an interesting conflict
here.  If we aim to be *clear* (e.g., by separating logical timers
that share a physical timer), then we lose the efficiency hacks BSD
have put in over time.  This is a loss for embedded systems people, at
least; possibly for others too.  Maybe we want two specs - a
perspicuous one, and a refinement into a space-efficient one?  This is
at least future work: "prove that the BSD efficiency-hacks do not
affect the semantics of the stack".  (I'm writing this as I read about
the treatment of t_rtt in the two cases, with timestamps and without,
on TCPv2p837).


Typesetting todos:
~~~~~~~~~~~~~~~~~~

* Michael has written Net_HOLextras, which makes each theory generate
  a .imn file.  He's pointed out that this code goes to some effort to
  examine only the current segment; it would be equally possible to
  write an ML program that looked over the entire database (once it's
  all built) and dumped *all* the type, constructor, field, and
  definition names.  This is how the theory-graph generation works.

  - this would require the entire system to be built for it to work
    (not necessarily a problem; just keep an old .imn file around, as
    we do now, while things aren't properly built).

  - this would be (a little) more work, and it's not essential now.

  - there's a little hack we do for LIB identifiers: we use a sed
    script to change every constructor (CON_LIST) in TCP1_LIBinterface
    into a library identifier (LIB_LIST).  Trickier to do in the above
    style, although we could change it to look for (or print out) the
    type to which each constructor belongs.

  - BONUS: it would mean that all the predefined things would also get
    dumped to the file; this would be nice.

  - more information than just the categories could be printed out
    here; all sorts of information might be useful to a clever
    typesetter.

* We need to parse auxiliary definitions, and be able to dump them
  (one-by-one) into LaTeX in the same way as the rules are currently
  processed.  Maybe have a LaTeX "holfrags" package.  Michael thinks
  it would be best to do this in the script file, using something like
  a Fancy_HOL_Datatype command rather than HOL_Datatype as at
  present.  This would take the LaTeX command name as an argument.

* Need to modify the lexer to keep track of token coordinates (Michael
  has put in a lot of groundwork for this).

* Is there some way, for the rules that have two possible labels and
  two possible sets of side conditions, to generate something that
  looks like this in the LaTeX:

           (1): tid.accept(fd)
           (2): tau
        ------------------------>

Testing conclusions 2002-09-02:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the text below, I've labelled programs that should perform a
listen() as SERVER, and programs that should perform a connect() as
CLIENT.

* write a C library publishing the standard sockets interface, but as
  ns_socket() etc instead of socket() etc.  [CLIENT]

  - rejects really stupid arguments immediately with EINVAL (i.e.,
    things that aren't representable in our HOL representation)
  - prints the HOL-format call label Lh_call socket() or whatever
  - calls socket() etc
  - prints the HOL-format return label Lh_ret (FD 3) or whatever

  - all this printing goes to some standard socket, so we can use it
    remotely.  (maybe should pick a very large FD to use here, so as
    not to interfere with FDs 3 4 etc.)

  - NB: if we start worrying about signals, we should make sure that
    this code never makes library calls (part 3), only system calls
    (part 2), since it could be executed from a signal handler.

* write an Ocaml binding for the above C library, which publishes
  exactly the LIB interface (and is as trivial as possible).

* write an Ocaml program using the binding, which reads HOL call
  representations, does them, and throws away the answer.  [SERVER]

  - input comes from another high-numbered socket.
  - (for completeness, could format the return as HOL return label and
    echo it, but no need because the C layer does it).  Would at least
    be a nice crosscheck, but low priority.

* do all of this for FreeBSD, Linux, WinXP.  Do it with #ifdefs, not
  separate sources.

* Wire sniffing: modify slurp.ml (which reads a tcpdump capture
  stream) to output HOL-format network labels.  [CLIENT]

  - output obviously goes to a socket.

  - maybe instead of using a pipe or file, arrange to be called back
    from libpcap on every packet.  This has the advantage of getting
    online responses, rather than waiting for a write buffer to fill
    (and getting several seconds latency).

  - (note that HOL-format network labels will change from their
    2002-09-02 status, becoming less lossy).

  - in the first instance, Linux only required (although it will use
    libpcap, which is widely supported).

  - *** We will also want to use this to capture traces in testing
    etc, not just as part of the psyche virtual TCP/IP stack.  For
    this use, it is important that we distinguish packets' direction.
    So add a feature that allows a host to be specified, and labels
    packets destined for that host as received, packets emitted from
    that host as sent, and simply drops other packets.

* Wire injection: write Ocaml code that reads a HOL-format
  packet/segment/datagram and injects it onto the wire.  [SERVER]

  - again, reads from a socket.  (of course, should echo at least "OK"
    after each command).

  - in the first instance, Linux only required.


** META-COMMENT: echo current time with every output line, in all of
   these.  (may need to apply ntp's correction, but don't bother for
   now.  Make sure to record with at least microsecond accuracy from
   the system clock, though).

* TCP Testing (h) Executive Engine (TThEE):

  - This will read the Test Description Language, drive the various
    other things, collect the responses together, and write out a
    readable report, and the whole sequence of labels collected.

  - is the TDL just OCaml?  In the first instance, we want to be able
    to write little tiny ad-hoc tests easily, so just write them in
    OCaml (ish).  Then maybe generalise to an ASCII TDL (which will
    look very HOLish).  (or maybe *really* HOL with Michael's
    evaluation engine).

  - prettification of the total report into a diagram like that on,
    e.g, TCPv1p308.  (the zig-zaggy diagrams).


** update Linux to something sensible, and document accurately, and
   make sure we have matching source code.

** get WinXP or whatever installed, note down ServicePack number and
   winsock version etc.

** we believe (on BSD at least) that TCP_DEBUG will give us access to
   most or all of the TCP control block, which would let us see most
   of the state that we care about.  to investigate...


Spec things DONE
~~~~~~~~~~~~~~~~

think about adding an inq. In UDP the difference between network-card
buffering and network delay wasn't observable; now it is - though,
unless the network card buffer is non-negligible, the window of
potential mismatch is narrow - you need to do a socket call between
a packet going by on the wire and the associated tcp_input call.  It's
no big deal to add an inq to the model, but it may make Michael's life
harder.

done: think about simultaneous open (currently have bogus deliver_in_1a)
Recall that BSD resolves tstamp and MSS and stuff quite late; we do
this rather earlier.  This means that even though the BSD code for
simultaneous open doesn't resolve these things, we must.

deal with FIN in del_in_1, del_in_2 etc.
- to make our spec like BSD, we should ignore data and FIN in
del_in_1.  But other architectures may well process it; it's
well-defined what to do in TCP.  So delay this choice, or nondet it,
or parameterise it?
[what do you do?  Process data as usual.  If FIN received, set a flag,
so that when ACK at end of 3WHS is received, move directly to
CLOSE_WAIT instead of ESTABLISHED.]
- del_in_2 in BSD does handle data and FIN (with SYN,ACK) normally.
[intriguingly, BSD (and hence we) don't allow a server to be so eager
that it sends data with the SYN,ACK.  Maybe we should?]

tcp_timer.c:397 says turn off WS, TS, and CC requests if we have
retransmitted a SYN three times, to work around broken remote
clients.  Do it.

make sure t_rcvtime and keepalive timer are updated on almost all
inputs, as specified in tcp_input.c:886ff.  Ouch!
  We should also update tt_fin_wait_2 in these places if we're in
  FIN_WAIT_2, because we don't believe in the silly
  check-every-75-seconds nonsense espoused by BSD and Stevens
  (TCPv2p826).
  - deliver_in_3, _1? _2? and any of the _7* (RST) rules that don't
  actually zap the socket.

sort out timer rules, of which the substantial undone ones seem to be:
  timer_tt_rexmt_1 /* misc (* retransmit timer expires *) */
  timer_tt_fin_wait_2_1 /* misc (* FIN_WAIT_2 timer expires *) */
  timer_tt_2msl_1 /* misc (* TIME_WAIT timer expires *) */
  timer_tt_persist_1
  timer_tt_delack_1

sequencing stuff at the bottom of tcp_output auxiliary - ie (P guesses
this means) think about tcp_output self-calls.

get rid of nasty monadic stuff where it actively gets in the way,
e.g., "does dropwithreset touch sock?". (even reidiom it elsewhere
when we think of a better way).

sort out deliver_in_9 (* receive SYN in non-{CLOSED;LISTEN;SYN_SENT} state *)  (*
roughly, if st=TIME_WAIT then drop this connection and make a new one,
otherwise send a RST *)

check for ps1=ps2 is1=is2 as tcp_input:789-798

finish cb-ifying all the make_*_segments, for use in retransmit

finish cb-ifying all the make_*_segments, for clarity
  - close_3 and close_8 should share a make_rst_from_cb
  - deliver_in_5 and dropwithreset should share a make_rst_from_seg
  - tt_keep_1 should be left alone, because it's unusual.

fix ts_val in { n | T }; should use tcp_now now.

In normal usage, we don't expect loss on output due to [running out of
MBUFS, running out of IP queue space, running out of network card
space]. We therefore plan to test with INFINITE_RESOURCES=T, which
prevents enqueue from losing.  For input, P guesses that in normal
usage there may be some packet loss, but if we get it we're stuffed,
as our capture-machine may lose different packets.  Therefore, we plan
to have INFINITE_RESOURCES control the input queue in the same way.

Because we're assuming a fairly stable machine (user doesn't do
arbitrary sysctls, they're constants defined in TCP1_aux), we can
assume that the outgoing i/f's MTU does not change during the lifetime
of a connection.  This means that EMSGSIZE will never be returned from
ip_output, thus eliminating tcp_output.c:917-926.

Choose ISNs better.  At the moment, we pick them arbitrarily.  The RFC
says that the ISN should increment by around 1e6/sec, to avoid
confusion between old and new connections.  In practice, both BSD and
Linux compute a hash of the connection 4-tuple plus a random seed, and
increment *that* by 1e6/sec; BSD by default never reseeds this, but
can be told to do so; Linux (2.2) by default reseeds every 5mins.
Doing this properly, and then understanding its relationship with
real traces, would be too hard, so we won't bother.

Figure out how to handle various sloppinesses of timing: the
200ms/500ms resolution of (almost?) all TCP things, and the 75second
resolution of testing of tt_fin_wait_2, inter alia.

    Furthermore, the timestamp values in outgoing segments need to be a
    little fuzzy if we are to match any traces.
      - Observe: h.ticks is used just for this, nothing else.  So it is
      sufficient to make ticks increment a little fuzzily: have a min and
      max tick interval, and be nondet in that.

    Make Timed() and TimeWindow() contain: current elapsed, min deadline,
    max deadline.  Current elapsed counts upwards, it can fire anywhere
    between min and max deadline (inclusive), and is urgent only at the
    max deadline.

    Acc. Stevens, only delack is fast; the others are all slow.

    Think about fuzzifying stopwatches too (for idletime only; wait and
    see what we use it for).

    Must fuzzify ticks - fuzzify its increment to the RFC-specified
    range.  Actually, probably don't fuzzify it that much because it
    will be used for other things, such as RST rate limiting.

Fix weirdness: urgency shouldn't be nondet.  Initially I (K) had some
Time_Pass functions with type dur -> foo -> foo option -> bool, but
that made urgency nondet.  The type is now dur -> foo -> foo set
option, i.e., dur -> foo -> (foo -> bool) option.  Much better.

Make ifds a finite map.

Guard all the badfails with ~INFINITE_RESOURCES (if appropriate).

model bandlimiting of (certain) RSTs somehow.  note that for testing,
we'll want to turn this off and make sure we stay within the limits,
otherwise it would be silly (an implementation should *try* to send
all the RSTs it is supposed to).

  - for plug-n-play-ability, model by a function and some private
    state
    - each time you want to generate a RST, call the function, passing
    the segment, the time (ticks), and the reason; it returns a bool
    and side-effects the state.
    - an obvious-enough implementation is for the private state to be
    a list of all these triples (that we've ever seen).
    - the BSD version will inspect these and see how many have been
    sent since the last second / in the last second (depending on how
    true we're being - the truth is the former).
    - don't see any reason to make it possible to turn off - just set
    the limit high enough, or only do slow tests.
==> MOSTLY DONE, but not quite right in deliver_in_3 because of
    interaction with "monadic" idiom.
==> Looks like it was all done on 2003/02/27.

Add "privs" field to host, noting whether host has root/CAP_NET_ADMIN
privilege or not.

FIX semantics of get/setfilebfl, so can be inverted in tester.  Ugh.
Remove the nice regular interface to fcntl(F_[GS]ETFL), and replace it
with one that is usable for nssock.  The regular interface suffers
from the fact that though implementable, the implementation is
noninvertible: from a C socket call, you can't tell which flag was
being got or set.  Old interface was:
      | getfilebfl  of (fd # filebflag)
      | setfilebfl  of (fd # filebflag # bool)
      /\ retType (setfilebfl  _) = TLty_one
      /\ retType (getfilebfl  _) = TLty_bool

- deliver_in_3: move handshaken socket from lis.q0 to q

Syncache retransmits of SYN,ACK continue only for 3 counts, not 12 -
see tcp_syncache.c.

Implement lis.qlimit.  FreeBSD 4.6-RELEASE's semantics seems a bit
weird, because of syncaches.  The actual socket code (in sonewconn3)
says the following:
  - if trying to add an incomplete connection (onto q0), do:
    - if LENGTH lis.q > 3 * lis.qlimit / 2 then
        drop the new connection
      else
        if LENGTH lis.q0 > lis.qlimit then
          drop the OLDEST connection on q0
        fi;
        add the new connection to q0
      fi
  - if trying to add a completed connection (onto q), do:
    - if LENGTH lis.q > 3 * lis.qlimit / 2 then
        drop the new connection
      else
        add the new connection to q0
      fi
But in fact it's only called with completed connections.
*
The question then becomes, how do the syncaches handle qlimit?  The
answer is a bit weird.  Firstly, if LENGTH lis.q > lis.qlimit, then
the new connection is dropped.  Otherwise, if the relevant hash bucket
overflows (tcp_syncache.bucket_limit=30), the oldest entry in that
queue is dropped; if the overall cache overflows
(tcp_syncache.cache_limit=512*30=15360) or the allocator can't
allocate a record, the oldest entry in the cache is dropped.  The hash
is based on the remote IP and the local,remote port pair.  In any
case, lis.q and lis.q0 are untouched wrt their lengths.
*
Note that "drop the new connection" means simply drop it on the floor;
no need to send a RST or anything like that.  FreeBSD comment says (in
tcp_syncache.c:syncache_socket()):
		/*
		 * Drop the connection; we will send a RST if the peer
		 * retransmits the ACK,
		 */
Fair enough.
==> ended up adding auxiliary functions accept_incoming_{q0,q},
drop_from_q0, which do the testing.  These also incorporate the old
backlog_fudge, so I don't apply that to qlimit any more in listen_1.

- apply the new choose idiom to make_rst_segment_from_cb,
  make_rst_segment_from_seg.

- deliver_in_1,2 bw_delay_product_for_rt: read from routing cache or
  nondetify
  ==> decided to nondetify; implementing all that routing-cache
  nonsense (see net/route.h:struct rt_metrics, for example) would be a
  *LOT* of work.

Add this stupid routing table. - make sure it's used in the right places.
Add little routing table, both so we can cache congestion control data
and so we can get the right error when there is no route to foo.
==> checked it is indeed used correctly.  Note an invariant relating
    it to h.ifds.
==> for the moment, *not* caching route metrics, since that would be
    Too Hard.  Can reconsider later.  Note that the metrics (would) live
    in the route *cache*, whereas the info for error generation comes
    from the routing *table*.  They're different things.  Our spec has
    a routing table, but not a route cache yet.

- deliver_in_1,2,3, timer_tt_rexmtsyn_1, timer_tt_rexmt_1: which timer
  for ts_recent?
  ==> interesting question.  The actual behaviour is that expiry
  happens *on receipt of a message*, just before testing ts_recent.
  So it would seem appropriate to use the kern_timer here (the ticks
  rate).

Why are all the deliver_in_* rules marked urgent?  Is this necessary?
==> think they *shouldn't* be urgent, but deliver_in_99 *should* be.
    This way, as soon as a message becomes available it is placed on
    the inqueue, but then it can be taken off at any time, subject to
    the diq constraint.
    Done.

Instead of `?ts_val. ts_val IN { n | T } /\ ...` write `choose ts_val
from { n | T } in ...`.
==> done, but still need the magic syntax
==> Michael says no magic syntax forthcoming, but I could use ?x::A.e
    for CHOOSE A \ x.e.  I'm not going to for now.

- deliver_in_5: Matching in LISTEN is different. CLOSED: careful.
- deliver_in_5: seg.is2 = NONE?  B/cast m/cast to exclude.
- deliver_in_5: make auxiliary, so can use in deliver_in_9,
  dropwithreset.  ==> actually, used existing auxiliaries.

Clarify explicit trichotomy of tcp_output states: either idle, or
persisting, or (re/)transmitting.  See clear exposition in
tcp_output.c:356ff.  Maybe this should be explicit in our model.

set tt_persist somewhere (it's never set at present!)  Should be set
when the snd_wnd shrinks to zero, or when we have data to send but are
prevented from doing so because there's a zero or tiny window, or by
Nagle(?), or ... .  Note that when it's set, we probably need
explicitly to stop tt_rexmt also.
[from TODO:]
- start persisting sometimes, in tcp_output_required?
- window shrinking, tcp_output_really
- can tt_persist-setting be moved to deliver_out_1 rule from
  tcp_output_really?
[grep through FreeBSD 4.6-RELEASE code:
  tt_persist is touched (possibly via tcp_setpersist):
  y:- tcp_output:212: if force but win nonzero, stop persisting
  y:- ditto:266,267: if len < 0 and win exactly 0 (window shrank all the way to
       zero), cancel retransmit, pull back to snd_una, and persist.
       Here win is the min of snd_wnd and snd_cwnd, or 1 if we're
       forcing.  Note that we may still go on to send a segment (e.g.,
       if we can advertise a larger window ourselves, or we have a
       snd_up to send, or ACKNOW is set).
  y:tcp_output:379 deciding whether to persist (if after all the
    tests, there's data to send and we're not retransmitting and we're
    not persisting, persist).
  y:tcp_output:805: be sure we're not persisting before starting rexmt
    tcp_output:977: def of setpersist (start/restart persist timer)
    tcp_timer: tcp_canceltimers cancels this timer too
    tcp_timer: tcp_timer_persist, obviously
  tt_persist is examined:
    tcp_input:1001,1783 check if not persisting before rexmting.
    tcp_output:689: if persisting, seg's seq should be snd_nxt
    tcp_output:767: another state check (if not persisting do normal
    stuff, otherwise do persist stuff)
    tcp_output:899: error handling: if we got an error and we weren't
    persisting, then undo some state changes
    tcp_output:911: if not rexmting or persisting, rexmt.
Looks like we really need to code up that trichotomy.
==> coded up.
==> persist really needs to be set at the point of
    tcp_output_required, since it happens when we *don't* send
    something (even though sometimes it also happens when we do,
    possibly).
==> all above occurrences checked; I believe they are all correctly
represented in the code.

- tcp_output_really: should cancel persist.
  ==> think this is related to the "three modes" item elsewhere: there
  are three TCP output modes, and starting retransmit timer means
  shifting from persist (if in it) to (re)transmit.

Why is the delayed ACK timer never set?
Do delayed acks properly.  This includes adding the TF_RXWIN0SENT
flag, amongst many other things.
- RXWIN0SENT, tt_delack, ... in tcp_output_really
==> should be set somewhere.
==> done.
From looking at BSD source:
- only set in tcp_input.c.
- DELAY_ACK(tp) if enabled, and not tt_delack pending, and not
  TF_RXWIN0SENT.
- this condition always guards a call to start the timer.  The calls
  are (on input):
- on -RST SYN -ACK, after establishing a TAO connection, if there is a
  FIN or there is some data and the connection is local, delay the ack
  else send the ack now.  (not relevant: no TAO)
- on -RST SYN ACK, if there's data, don't ack just now (unless there's
  a FIN, in which case it will ack now(?); since tcp_output clears
  delack, that's OK).
  ==> ok, done
- on receiving a seg, if there's data or FIN, and we're not
  TIME_WAIT(!!), and this was in order (seq=rcv_nxt), and there was no
  reass q, and we're established, then start the delack timer if we
  can else ack now.
  ==> tricky: we don't ever "ack now" in this situation at present, we
  just leave it nondeterministic.  This is not good - no ack clock!
  ==> fixed, with tf_outnow
- if we receive a FIN, and we're not TIME_WAIT(!!), and NEEDSYN, then
  delay the ack if we can else ack now.
  ==> NEEDSYN only applies to T/TCP connections, so don't count.
That's it.

- deliver_in_3: start_tt_rexmt: second arg F or something else?

- deliver_in_3: sort out RTT estimators, t_rtseq, time valid
Round-trip times:
The parameters are as follows, with *all* their uses (I carefully
grepped):
* int t_rtttime,tcp_seq t_rtseq: start time and sequence number of
  datagram being timed.
  - t_rtttime used as flag to see if we're timing a segment (the old
    way), t_rtseq to see if it's the right one, and t_rtttime used to
    compute the instantaneous rtt to pass to
    tcp_input.c:tcp_xmit_timer().
  - t_rtttime set to zero after processing an rtt estimate in
    tcp_input.c:tcp_xmit_timer().
  - in fast path: t_rtttime set to zero on third dup ack, unless doing
    new reno and ack<snd_recover, i.e., false retransmit, in which
    case tcp_output is called.
  - in normal path: t_rtttime set to zero on third dup ack, unless doing
    new reno and ack<snd_recover, i.e., false retransmit, in which
    case tcp_output is called.
  - in normal path: t_rtttime set to zero on >=3rd dup ack, when doing
    new reno and ack<snd_recover (in tcp_newreno()).
  - in tcp_output, set t_rtttime and t_rtseq if t_rtttime is currently
    zero, unless this is a persist-force packet.
  - set to zero on receiving an ICMP "need fragmentation" message.
  - set to zero before sending retransmission in tcp_timer_rexmt.
  - that's all, folks!
* int t_rxtcur: current retransmit value, already multiplied by the
  backoff factor, in ticks.
  - initialised to TCPTV_RTOBASE (= 3sec) when creating new tcpcb.
  - set (calculated as t_srtt/8 + t_rttvar/2 = 4*SRTT+8*RTTVAR) from
    route metric cache if available.  BUG!
  - set (using shift value) in tcp_input.c:tcp_xmit_timer(), as
    t_srtt/32 + t_rttvar/4 = SRTT+4*RTTVAR
  - set (using new shift value) when rexmt timer goes off.
  - used to reset tt_rexmt timer, and tt_2msl if CC (rfc1644),
    everywhere.
  - if we're outputting and it's >= t_rxtcur since the last packet
    received, close down cwnd: perform slow start.
  - that's all, folks.
* int t_rxtshift: current backoff index.
  - tested against 1 for badrxt recovery (in header prediction path
    and normal path).
  - reset to zero whenever tcp_input.c:tcp_xmit_timer() is invoked
    (i.e., when an ACK comes in yielding a new RTT estimate).
  - reset to zero when leaving persist.
  - reset to zero when entering persist.
  - use as shift, and increment it (up to TCP_MAXRXTSHIFT=12), for
    setting/restarting persist timer.
  - if not established, and shift >3, in tcp_notify(), make error
    hard, else soft.
  - if persist fires, and we're at max shift, and idle time is too
    big, and we've waited the maximum rexmt time, then ETIMEDOUT and
    drop.
  - if rexmt fires, increment shift (up to max); if we reach max, drop
    with error or ETIMEDOUT.
  - on increment to 1, save ssthresh and cwnd in case of badrxt.
  - in tcp_timer_rexmt, use to compute new t_rxtcur.
  - if shift=3 and we're in SYN_SENT, turn off rfc1323 and rfc1644.
  - if shift>(max/4 = 3), try and find a better route, and invalidate
    SRTT, but saving it cunningly in rttvar until we get a better.
  - no other uses.
* int t_srtt: current smoothed RTT estimate, in TCP_RTT_SCALEd ticks
    (=32).
  - in tcp_input.c:tcp_xmit_timer(), if zero, means we have no
    estimate yet, so just use new RTT (scaled) as the SRTT.
  - in tcp_input.c:tcp_xmit_timer(), if nonzero, do update
    computation (based on rtt input in ticks):
      delta = 4*(rtt-1) - t_srtt/8
      t_srtt = max(1,t_srtt+delta)
      deltavar = abs(delta) - t_rttvar/4
      t_rttvar = max(1,t_rttvar+deltavar)
    Multiplying delta by 8 and deltavar by 4 to make the arithmetic
    neater, this is:
      delta = 32*(rtt-1) - t_srtt
      t_srtt = max(1,t_srtt+delta/8)
      deltavar = abs(delta/2) - t_rttvar
      t_rttvar = max(1,t_rttvar+deltavar/4)
    and converting to seconds:
      DELTA    = (RTT - 1/HZ) - SRTT
      SRTT     = max(1/(32HZ), SRTT + DELTA/8)
      DELTAVAR = abs(DELTA) - RTTVAR
      RTTVAR   = max(1/(16HZ), RTTVAR+DELTAVAR/4)
  - used when updating from route metric cache: only if srtt=0 is this
    done, otherwise we assume we already have a good value.
  - set from route metric cache.
  - used to set rttvar if not rttvar present in route metric cache but
    srtt is: default is RTTVAR = SRTT (actually t_rttvar =
    t_srtt*16/32).
  - used to set initial t_rxtcur when setting from route metric
    cache.  BUG, see t_rxtcur.
  - t = t_srtt/8 + t_rttvar/2 (=4*SRTT+8*RTTVAR) used as base for
    persist timer in tcp_output.c:tcp_setpersist().
  - initialised to TCPTV_SRTTBASE (=0) on initialisation of tcpcb, to
    flag "not known yet".
  - stored in rmx if not locked.
  - used to compute t_badrxtwin: window is t_srtt/64 ticks = SRTT/2.
  - used to compute HACK t_rttvar = t_rttvar + t_srtt/32 =
    RTTVAR+SRTT/16, in an attempt to preserve the computed t_rxtcur
    values, in tcp_timer_rexmt, when shift passes max/4=3.  The
    attempt is vain, since t_rxtcur will work out to be
    SRTT/4+4*RTTVAR, not SRTT+4*RTTVAR.  Oops.  BUG.
  - set to zero as a flag when shift passes max/4=3 (i.e., 4th
    retransmit timeout).
  - used to compute t_rxtcur as described elsewhere.
  - that's all, folks.
* int t_rttvar: current RTT variance estimate, in TCP_RTTVAR_SCALEd
    ticks (=16).
  - in RTT update computation as t_srtt.
  - set to instantaneous rtt*8 = RTT/2 in absence of better
    estimate, in tcp_xmit_timer().
  - set from route metric cache, or to t_srtt*16/32 = SRTT if only
    SRTT in cache.
  - used to compute persist base as t_srtt.
  - initialised to 4*(TCPTV_RTOBASE - TCPTV_SRTTBASE) = 12
    = 0.75 ticks on new tcpcb.  No!  Really, this means 3 seconds
    initial.
  - stored in route metric cache if not locked (on close).
  - set to hack as described above in t_srtt on shift passing max/4=3.
  - used to compute t_rxtcur as described elsewhere.
  - that's all, folks.
* u_int t_rttmin: minimum RTT allowed, in ticks.
  - set to cached RTT in route metric cache, if the value has the lock
    bit set.
  - initialised to TCPTV_MIN = 1 second on tcpcb creation.
  - always used as a minimum for RTT calculation, sometimes in
    conjunction with an instantaneous-RTT-plus-two-ticks limit.
  - no other use.
* u_long t_rttupdated: number of RTT updates performed since
  tcpcb creation.
  - incremented in tcp_input.c:tcp_xmit_timer(), at the top.
  - only save srtt and rttvar in route metric cache if this is >=16.
  - no other use.
tcp_xmit_timer(), i.e. my update_rtt, is called in process_ACK, which
happens when the packet has ACK, and various tests have been passed.
It happens just before we test if ack==snd_max, and just after we test
if shift=1 /\ ticks < badrxtwin.
==> done, except for separate items pulled out below.

Miscellaneous: slow start if nothing has happened for a while:
  - if we're outputting and it's >= t_rxtcur since the last packet
    received, close down cwnd: perform slow start.

Investigate curious comment by Stevens, TCPv2p822 bottom line, that
tcp_output returns to slow start after an idle time of >=1 RTO (see
also TCPv2p852).
==>: when this happens, t_rxtcur should equal SRTT+4*RTTVAR, because
we are *idle*, not retransmitting, so the last thing we got must have
been an ACK, so we must have set RTT with update_rtt.  Oh, that's not
true, because we might not have timed that segment (in the case where
we're doing the old-style timing, rather than timestamps)... hmm...
So: whenever t_rttinf is updated, rxtcur can be calculated from it
directly, but if there have been one or more retransmits since that
last update, the shifted value of this calculation should be used.
That says that we should store the "last shift" in t_rttinf.  This
should be set to zero when we update the RTT (update_rtt), but not
touched if we just stop the retransmit timer for some other reason; it
should be incremented whenever the retransmit timer fires (and we
should note whether it's rexmt or rexmtsyn).  (Those other times, in
our code, are as follows: possibly when forcing a snd_urp or persist
segment [tcp_output], receiving ack for everything in del_in_2 or
del_in_3, doing fast retransmit in del_in_3, fast recovery in
del_in_3, receiving ACK of our FIN).

- deliver_in_3: invalidate t_rtttime in fast rexmt, fast recovery

Do incoming ICMPs.  Particularly, path MTU discovery (see ip_icmp,
tcp_subr: icmp_input() calls tcp_ctlinput() calls tcp_mtudisc().
Note that icmp_input() itself modifies the route MTU, and
tcp_mtudisc() is left merely to update t_maxseg (and resend).
==> done, as below, apart from path MTU discovery.

Possibly, do ICMP router advertisement and
solicitation (types 9 and 10) if they are still used.
==> router advertisement and solicitation are not used in BSD.

ICMP stuff relating to RTT:
- t_rttseg should be set to NONE on receiving an ICMP "need
  fragmentation" message.
- if not established, and t_rxtshift >3, in tcp_notify(), make error
  hard, else soft.

The truth about ICMPs:
- ip_input.c:ip_input() passes ICMP messages on to the ICMP protocol
  input routine, ip_icmp.c:icmp_input().
- ip_icmp.c:icmp_input() checks the message is long enough, checks the
  checksum, [does something special if it came in on an IFT_FAITH i/f],
  then switches on the type field (and then the code field).
  ICMP_UNREACH:
    - ICMP_UNREACH_{NET, HOST, SRCFAIL, NET_UNKNOWN, HOST_UNKNOWN,
    ISOLATED, TOSNET, TOSHOST, HOST_PRECEDENCE, PRECEDENCE_CUTOFF}:
    becomes PRC_UNREACH_NET;
    - ICMP_UNREACH_NEEDFRAG: becomes PRC_MSGSIZE;
    - ICMP_UNREACH_{PROTOCOL, PORT}: becomes PRC_UNREACH_PORT (with a
    note to see RFC1122, 3.2.2.1 and 4.2.3.9, treat subcodes 2,3 as
    immediate RST);
    - ICMP_UNREACH_{NET,HOST,FILTER}_PROHIB: becomes
    PRC_UNREACH_ADMIN_PROHIB;
    - anything else is "badcode"
  ICMP_TIMXCEED:
    - code 0,1: becomes PRC_TIMXCEED_INTRANS+0,1;
    - anything else is "badcode"
  ICMP_PARAMPROB:
    - code 0,1: becomes PRC_PARAMPROB;
    - anything else is "badcode"
  ICMP_SOURCEQUENCH:
    - code 0: becomes PRC_QUENCH;
    - anything else is "badcode"
  ==> in all cases so far, unless "badcode",
    - if len is too short or embedded IP is too short, drop it;
    - if embedded IP has src addr IN_MULTICAST, "badcode";
    - if PRC_MSGSIZE then do this and then continue:
      - let icmpsrc be the destination of the embedded IP packet.
      - do rtalloc1() for icmpsrc, with RTF_CLONING|RTF_PRCLONING
      - if get a result, and has flag RTF_HOST, and cached mtu for
        route in route metric cache is not locked,
        - pull out MTU from ICMP if present, else pick next smaller
        mtu after that in the route metric cache, in the table 65535,
        32000, 17914, 8166, 4352, 2002, 1492, 1006, 508, 296, 68, 0,
        at ip_icmp.c:791, ref to RFC 1191.  If that MTU is less than
        296, lock the previous MTU in the rmx cache, otherwise set the
        rmx cache value to the new one.
        - free the route if necessary
      [end of PRC_MSGSIZE special case]
    - notify relevant protocol via inetsw[].pr_ctlinput, and stop.
  ==> if "badcode",
    - stop
  ==> otherwise:
  ICMP_ECHO:
    - if icmpbmcastecho is not set, and flags say this ICMP is either
    MCAST or BCAST, then stop.
    - otherwise, set type to ICMP_ECHOREPLY and reflect it back,
    unless bandlim on BANDLIM_ICMP_ECHO says no.
  ICMP_TSTAMP:
    - if icmpbmcastecho is not set, and flags say this ICMP is either
    MCAST or BCAST, then stop.
    - if ICMP is too short for TSTAMP, stop.
    - otherwise, set type to ICMP_TSTAMPREPLY, both time fields to
    iptime() (!?: comment "bogus, do later!"), and reflect it back,
    unless bandlim on BANDLIM_ICMP_TSTAMP says no.
  ICMP_MASKREQ:
    - if icmpmaskrepl not set, stop
    - if too short, stop.
    - if dst addr was 0.0.0.0 or 255.255.255.255, reply to source of
    packet, otherwise reply to destination (?).
    - build an appropriate ICMP_MASKREPLY packet and reflect it,
    unless something goes wrong.
  ICMP_REDIRECT:
    - if drop_redirect, stop
    - if code >3, "badcode"
    - if too short or embedded IP too short, stop
    - do redirection by calling rtredirect, and also pass on to
    pfctlinput in case it's needed by, e.g., routed.
  ICMP_ECHOREPLY, ICMP_ROUTE{ADVERT,SOLICIT}, ICMP_TSTAMPREPLY,
  ICMP_IREQREPLY, ICMP_MASKREPLY, >max code, anything else:
    - do nothing, just...
    - rip_input() it.
- tcp_subr.c:tcp_ctlinput() looks at the PRC value, and decides what
  to call:
  If not from AF_INET, or from 0.0.0.0, stop.
  PRC_QUENCH: use tcp_quench
  PRC_UNREACH_{ADMIN_PROHIB,PORT} and icmp_may_rst and the ICMP had an
    embedded IP header: use tcp_drop_syn_sent
  PRC_MSGSIZE: use tcp_mtudisc
  PRC_REDIRECT_{NET,HOST,TOSNET,TOSHOST}: clear embedded IP header and
    use in_rtchange
  PRC_HOSTDEAD: clear embedded IP header and use tcp_notify
  too-big PRC or no entry in inetctlerrmap[]: stop.
    inetctlerrmap[] is as follows:
      PRC_IFDOWN                0
      PRC_ROUTEDEAD             0
      PRC_IFUP                  0
      PRC_QUENCH2               0
      PRC_QUENCH                0
      PRC_MSGSIZE               EMSGSIZE
      PRC_HOSTDEAD              EHOSTDOWN
      PRC_HOSTUNREACH           EHOSTUNREACH
      PRC_UNREACH_NET           EHOSTUNREACH
      PRC_UNREACH_HOST          EHOSTUNREACH
      PRC_UNREACH_PROTOCOL      ECONNREFUSED
      PRC_UNREACH_PORT          ECONNREFUSED
      /*PRC_UNREACH_NEEDFRAG*/  EMSGSIZE
      PRC_UNREACH_SRCFAIL       EHOSTUNREACH
      PRC_REDIRECT_NET          0
      PRC_REDIRECT_HOST         0
      PRC_REDIRECT_TOSNET       0
      PRC_REDIRECT_TOSHOST      0
      PRC_TIMXCEED_INTRANS      0
      PRC_TIMXCEED_REASS        0
      PRC_PARAMPROB             ENOPROTOOPT
      PRC_UNREACH_ADMIN_PROHIB  ECONNREFUSED
  Otherwise: use tcp_notify
  ==>
  if there is an embedded IP header,
  - find corresponding tcpcb
  If there is an embedded IP header,
  - find corresponding tcpcb
  - if there is one, and it has a socket, then
      - if embedded seq >= snd_una and embedded seq < snd_max, then
        notify with errno, else ignore
  - else (i.e., if no tcpcb or no socket), syncache_unreach().
  if there is no embedded IP header,
  - notify every tcpcb that has a socket and has a remote address
    equal to the source address of the ICMP datagram, using that
    notify routine and inetctlerrmap[] error.
- tcp_subr.c:tcp_quench() closes snd_cwnd to t_maxseg, if there's a
    tcpcb.  This is odd, because it makes no allowance for local nets.
- tcp_subr.c:tcp_drop_syn_sent() if there's a tcpcb, and it's in
    SYN_SENT, call tcp_drop with the relevant errno.
- tcp_subr.c:tcp_mtudisc()
  [note that some of this is said in a comment to duplicate tcp_mss()]
  [note that the work has already been done; here we are just
    resetting the other parameters to be sensible]
  - obtains the corresponding tcpcb if there is one (if not, stop).
  - lookup route; if not present or has no mtu in route metric cache,
    set t_maxopd = t_maxseg = tcp_mssdflt (=512) and stop.
  [we assume in what we say next that there's no TAO happening]
  - mss = route-cached MTU - sizeof(tcpiphdr) (min'd with the TAO
    offer if present, but it's not) (comment: this violates TCP spec,
    but we have to because otherwise we can't discover!)
  - if t_maxopd < mss then stop
  - otherwise set t_maxopd = mss
  - if TF_REQ_TSTMP /\ ~TF_NOOPT /\ TF_RCVD_TSTMP, subtract
    TCPOLEN_TSTAMP_APPA from mss
  - if TF_REQ_CC /\ ~TF_NOOPT /\ TF_RCVD_CC, subtract TCPOLEN_CC_APPA
    from mss
  - round mss down/equal to a multiple of MCLBYTES
  - if so_snd.sb_hiwat < mss, set mss to so_snd.sb_hiwat
  - set t_maxseg to mss
  - invalidate t_rttseg
  - set snd_nxt to snd_una
  - output a segment.
- tcp_syncache.c:syncache_unreach() look up the sc entry, if there is
    one (if not, ignore).  If icmp.seq <> sc_iss, ignore.  If scflags
    don't already say SCF_UNREACH and sc_rxtslot < 3, make flag say
    SCF_UNREACH; otherwise, syncache_drop().
- tcp_subr.c:tcp_notify() find tcpcb (there'd better be one, or we
    crash!);
  - if TCPS_ESTABLISHED and the error is EHOSTUNREACH or ENETUNREACH
    or EHOSTDOWN, ignore it.
  - if state < TCPS_ESTABLISHED and t_rxtshift > 3 and there's already
    a t_softerror, tcp_drop(error).  (that is, the new error).
  - otherwise, log the error in t_softerror.

Summarising:

  ICMP_UNREACH:
    - ICMP_UNREACH_{NET, HOST, SRCFAIL, NET_UNKNOWN, HOST_UNKNOWN,
    ISOLATED, TOSNET, TOSHOST, HOST_PRECEDENCE, PRECEDENCE_CUTOFF}:
    ==> PRC_UNREACH_NET

    - ICMP_UNREACH_NEEDFRAG
    ==> PRC_MSGSIZE

    - ICMP_UNREACH_{PROTOCOL, PORT}
    ==> PRC_UNREACH_PORT

    - ICMP_UNREACH_{NET,HOST,FILTER}_PROHIB
    ==> PRC_UNREACH_ADMIN_PROHIB

  ICMP_TIMXCEED:
    - code 0
    ==> PRC_TIMXCEED_INTRANS
    - code 1
    ==> PRC_TIMXCEED_REASS

  ICMP_PARAMPROB:
    - code 0,1
    ==> PRC_PARAMPROB

  ICMP_SOURCEQUENCH:
    - code 0
    ==> PRC_QUENCH

  ICMP_ECHO:
    ==> do echo here

  ICMP_TSTAMP:
    ==> do tstamp here

  ICMP_MASKREQ:
    ==> do maskreq here

  ICMP_REDIRECT:
    - code 0,1,2,3
    ==> do redirect here

  one of the above, but with a different code
    ==> stop (as bad code)

  something else
    ==> stop (ignore silently)

Once you've got a PRC code:
    - if len is too short or embedded IP is too short [i.e., whole IP
      header, plus 8 bytes of src/dst port and seq], stop;
    - if embedded IP has src addr IN_MULTICAST, stop (as bad code)
    - if PRC_MSGSIZE then do this and then continue:
      - let icmpsrc be the destination of the embedded IP packet.
      - attempt to obtain a route to icmpsrc.
      - if get a result, and it's a host route (not just a net route),
        and cached mtu for route in route metric cache is not locked,
        - pull out MTU from ICMP if present, else pick next smaller
        mtu after that in the route metric cache, in the table 65535,
        32000, 17914, 8166, 4352, 2002, 1492, 1006, 508, 296, 68, 0,
        at ip_icmp.c:791, ref to RFC 1191.  If that MTU is less than
        296, lock the previous MTU in the rmx cache, otherwise set the
        rmx cache value to the new one.
        - free the route if necessary
      [end of PRC_MSGSIZE special case]

Then, in tcp_subr.c:tcp_ctlinput(), do:
  - If not from AF_INET, or from 0.0.0.0, stop.

  - set errno from:
      PRC_QUENCH                0
      PRC_MSGSIZE               EMSGSIZE
      PRC_UNREACH_NET           EHOSTUNREACH
      PRC_UNREACH_PORT          ECONNREFUSED
      PRC_TIMXCEED_INTRANS      0
      PRC_TIMXCEED_REASS        0
      PRC_PARAMPROB             ENOPROTOOPT
      PRC_UNREACH_ADMIN_PROHIB  ECONNREFUSED

  PRC_QUENCH
  ==> use tcp_quench

  PRC_UNREACH_{ADMIN_PROHIB,PORT}
  - if icmp_may_rst [and the ICMP had an embedded IP header; this is
    always true]
  ==> use tcp_drop_syn_sent

  PRC_MSGSIZE
  ==> use tcp_mtudisc

  errno = 0 and none of above conditions apply (i.e.,
  PRC_TIMXCEED_{INTRANS, REASS})
  ==> stop

  otherwise
  - use tcp_notify

Using a notifier:

  [there is always an embedded IP header; it's never trashed by any
  of the limited set of paths we cover]
  - find corresponding tcpcb
  - if there is one, and it has a socket, then
      - if embedded seq >= snd_una and embedded seq < snd_max, then
        notify with errno, else ignore
  - else (i.e., if no tcpcb or no socket), syncache_unreach().

Doing those notifiers:

- tcp_subr.c:tcp_quench() closes snd_cwnd to t_maxseg, if there's a
    tcpcb.  This is odd, because it makes no allowance for local nets.

- tcp_subr.c:tcp_drop_syn_sent() if there's a tcpcb, and it's in
    SYN_SENT, call tcp_drop with the relevant errno.

- tcp_subr.c:tcp_mtudisc()
  [note that some of this is said in a comment to duplicate tcp_mss()]
  [note that the work has already been done; here we are just
    resetting the other parameters to be sensible]
  - obtains the corresponding tcpcb if there is one (if not, stop).
  - lookup route; if not present or has no mtu in route metric cache,
    set t_maxopd = t_maxseg = tcp_mssdflt (=512) and stop.
  [we assume in what we say next that there's no TAO happening]
  - mss = route-cached MTU - sizeof(tcpiphdr) (min'd with the TAO
    offer if present, but it's not) (comment: this violates TCP spec,
    but we have to because otherwise we can't discover!)
  - if t_maxopd < mss then stop
  - otherwise set t_maxopd = mss
  - if TF_REQ_TSTMP /\ ~TF_NOOPT /\ TF_RCVD_TSTMP, subtract
    TCPOLEN_TSTAMP_APPA from mss
  - if TF_REQ_CC /\ ~TF_NOOPT /\ TF_RCVD_CC, subtract TCPOLEN_CC_APPA
    from mss
  - round mss down/equal to a multiple of MCLBYTES
  - if so_snd.sb_hiwat < mss, set mss to so_snd.sb_hiwat
  - set t_maxseg to mss
  - invalidate t_rttseg
  - set snd_nxt to snd_una
  - output a segment.

- tcp_syncache.c:syncache_unreach() look up the sc entry, if there is
    one (if not, ignore).  If icmp.seq <> sc_iss, ignore.  If scflags
    don't already say SCF_UNREACH and sc_rxtslot < 3, make flag say
    SCF_UNREACH; otherwise, syncache_drop().

- tcp_subr.c:tcp_notify() find tcpcb (there'd better be one, or we
    crash!);
  - if TCPS_ESTABLISHED and the error is EHOSTUNREACH or ENETUNREACH
    or EHOSTDOWN, ignore it.
  - if state < TCPS_ESTABLISHED and t_rxtshift > 3 and there's already
    a t_softerror, tcp_drop(error).  (that is, the new error).
  - otherwise, log the error in t_softerror.

That's all, folks!
==> done, except for ICMP_REDIRECT (which we would like to do), and
ICMP_ECHO, ICMP_TSTAMP, ICMP_MASKREQ, which we have decided not to do.

tcp_usrreq.c:695 says connect() can truncate a TIME_WAIT state.  Do
it.
==> No, it can only do so if TF_RCVD_CC, which we are not
implementing.  On the other hand, it *can* give EADDRINUSE, which we
can't do yet, if there is already a connection (could be the same one)
with same remote IP/port and local IP/port (where local IP is the IP
of local i/f, if not specified).


Working on route_and_enqueue.  Should we (a) check if we can
route_and_enqueue, and if we can just put it on the queue, otherwise
not, setting cb' to the appropriate value in either case; or (b) set
cb', do route_and_enqueue, and if it fails, wind back the changes,
yielding cb''?
==> winding back changes.

When an enqueue fails, we should do roughly what tcp_output does.
Since it does several different things, we may need to nondet it (?).

What does it do?
Failure modes:
- ip_output may fail
- MGETHDR or mcopy may fail (obtain a header/data mbuf; always
  errno=ENOBUFS)
  - this skips over the set/reset of TF_RXWIN0SENT, set of snd_nxt
    [but not the set for moving into persist (to snd_una) or to iss
    for SYN], snd_max if necessary, and t_rtttime/t_rtseq, and
    possible start of rexmt timer (not the stop for enter persist).
* If ip_output fails, and not forcing or persisting, and not SYN, wind
  back snd_nxt by len, and fall through.
* In any case,
* If ENOBUFS, and not rexmt or persist, start rexmt timer, and do
  tcp_quench (i.e., set cwnd to 1MSS) and return 0.
* If EMSGSIZE, pass it on to tcp_mtudisc() and return 0 (will never
  happen, since we assume i/f MTU doesn't change over lifetime of a
  connection).
* If EHOSTUNREACH or ENETDOWN, and HAVERCVDSYN, store in t_softerror
  and return 0.
* Otherwise, return the error.
** Note that all this happens before the following effects:
  - rcv_adv updated
  - last_ack_sent updated
  - delack stopped
In other words, the following may occur:
- rcv_adv, last_ack_sent, delack not touched, AND
  - tf_rxwin0sent, snd_nxt (apart from enter persist/set to iss),
    snd_max, t_rttseg, rexmt (apart from enter persist) not touched,
    AND
    - if not rexmt or persist, start rexmt, and set cwnd to 1MSS, and
      no error
    - otherwise return error ENOBUFS.
  - (if not forcing or persisting and not SYN, snd_nxt wound back by
    len, else no change), AND
    - if not rexmt or persist, start rexmt, and set cwnd to 1MSS, and
      no error
    - rexmt or persist, and return error ENOBUFS.
    - HAVERCVDSYN, and t_softerror becomes EHOSTUNREACH/ENETDOWN, and no
      error.
    - not HAVERCVDSYN, and EHOSTUNREACH/ENETDOWN returned.
    - some other error returned.
Looks like the MGETHDR/mcopy error should be handled internally to
tcp_output_really (guarded by INFINITE_RESOURCES, of course!).  Hardly
anything is changed if this fires.
However, ip_output errors should be handled differently.  Don't touch
rcv_adv, last_ack_sent, delack; restore snd_nxt (i.e., don't touch it
either); if not rexmt or persist, start rexmt and close cwnd to 1MSS,
else do nothing (ENOBUFS).  What about the others?  Shouldn't
EHOSTUNREACH/ENETDOWN be derivable from the routing layer without
having to do tcp_output?  Are there any other errors, and how to
treat?  A failure to enqueue is really an ENOBUFS, surely (ah - could
be ENOMEM??).

Anyway, what happens to an error return from tcp_output()?
- Usually discarded; only used in:
  - connect(), shutdown(), send() (both normal and urgent),
    ctloutput():set TCP_NOPUSH to false (presumably setsockopt(SOL_TCP,
    TCP_NOPUSH, 0)?)
- enqueue_oq appears in the following rules:
  close_3,8
  connect_1
  deliver_in_1,1b,2,2a,3,5,8,9
  deliver_in_icmp_1,2,3,4
  timer_tt_rexmtsyn,rexmt,persist,keep,delack,conn_est _1
  deliver_out_1

Chunks:
- rcv_adv, last_ack_sent, delack - never touched if there's an error.
- snd_nxt - not touched (actually, wound back if not mbuf error,
  untouched if mbuf error) if there's an error.
- tf_rxwin0sent, snd_max, t_rttseg, rexmt - may or may not be
  touched if there's an ENOBUFS (is if mbuf, isn't if ip_output).
- start tt_rexmt and set snd_cwnd to 1MSS (if not rexmt or persist already)
- t_softerror becomes EHOSTUNREACH/ENETDOWN.

What about when *routing* fails?  In fact, as I have it, we only do
the routing a few times, when in fact we should reroute (or at least
check the possibility) for each segment (**I think**).
==> all done, now: routing failure and allocation failure.


Spec TODO
~~~~~~~~~

Specific important semantic bits
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Implement the non-POSIX helper functions.

Make tf_outnow = T do what it says, i.e., force output to occur
urgently.  In general, tighten up the present non-determinism in
output timing.

Do path MTU discovery: tcp_mtudisc() (in tcp_subr.c).
==> almost all done, but to do properly needs a route metric cache or equivalent.

Do ICMP redirects (type 5).

Deal with the cases where tcp_ctlinput would call syncache_unreach().

Deal with timeouts due to SO_SNDTIMEO/SO_RCVTIMEO in the blocking
send/recv rules (posix/bsd)

Implement a recv rule to unblock from RECV2 when an error or
disconnect or similar occurs during a call to recv with MSG_WAITALL
set (linux/windows/posix)

Deal properly in recv_7 and send_6 with when ENOTCONN is returned.  As
well as the TCP-state-dependent conditions listed there, there should
also be a test of whether (BSD's) tcp_close, tcp_disconnect,
tcp_usrclose have been called - any for recv_7 will cause a failure,
whereas only the first and last will for send_6.  This is what I think
is the case at the moment, anyway - see K log pp2178-9 for more info.

In most recv and send rules we enforce that st=ESTABLISHED. This is
not necessarily true, e.g. it is possible to send data if in CLOSE_WAIT...
More investigation required.

Observed close() behaviour: if linger is set to a non-zero time, but
O_NONBLOCK is set, BSD will send a FIN immediately (like in a soft
close), but return immediately (because of O_NONBLOCK). The close can
then proceed without the sndq being cleared. The TCP will be in state
FIN_WAIT_1.  On WinXP the behaviour is much worse. close() returns
immediately with EAGAIN (somewhat as expected) and TCP persists in
trying to send the data in its send queue. If the remote host does not
acknowledge the data (so the send queue remains non-empty) and close()
is called again (well after the linger time has expired), close()
continues to return immediately with EAGAIN. Of course, this sequence
*should* terminate when TCP eventually gives up trying to send the
data in sndq.

Deal properly with broadcast/multicast addresses in all deliver_in_n
rules. Some deliver_in rules ensure that i1 is IN local_ips and that
both i1 and i2 are not broadcast/multicast addresses. Other deliver_in
rules do not perform this test but just match the ip/ps quad
exactly. These rules should still check that that the destination
addresses are not broadcast/multicast as this is a dynamic condition
(dependent upon the local interface configuration). This test is
certainly performed upon all incoming segments in the BSD code.

TODO: for the recv rules, should deliver in any [[st >= ESTABLISHED]],
not just in [[ESTABLISHED]].  Note that even if data arrives before
[[ESTABLISHED]], it shouldn't be delivered until then.



General important semantic bits and investigations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CONTINUE WORKING THROUGH tcp_output.c from line 794 (just did t_rtttime).

work out what tcp_output leaves unchanged and when it's guaranteed to
fire - ie, walk through all the BSD code paths into it.  (make clear
in its type???)    Go through uses of output (eg of our dropafterack,
and others) and work out whether it's guaranteed that they won't
sendalot.

work out where Lh_trace will actually happen (tcp_trace, trpt(8)
stuff).
- input, output, usrreq, timer

go through all the timer stuff with the code, making sure all the
right timers are set and reset and cleared and set to the right times
everywhen/where.

Steve/Keith: why is there both tt_conn_est and tt_rexmt (RexmtSyn)?
Surely just the latter would be sufficient?  If so, would be nice to
tidy up the model to remove the former.
-
Steve observes that tt_rexmt(RexmtSyn) and tt_conn_est overlap in
semantics.  Both are started in connect_1, and both make it fail with
ETIMEDOUT when they expire (the former, when the max shift count is
reached).  Keith checked the FreeBSD code, and this is indeed the
actual behaviour.  tt_conn_est (actually tt_keep initialised to
keepinit) has a timeout of 75 seconds by default.  tt_rexmt when
started by tcp_output (in tcp_usr_connect) has a cumulative duration
of { 1, 1, 1, 1, 1, 2, 4, 8, 16, 32, 64, 64, 64 } = 259 * RTO.  I
think the initial RTO is 3 seconds, so that's 777 seconds (unless the
cached RTT knows the RTO is much smaller).
-
OTOH, the initial RTO will be much smaller if there's RTT data stored
in the route metric cache.  S/K think that this only happens for
non-local connections, which is why we haven't observed it.  We're
going to move emil to be nonlocal, so we can see this.
-
Should probably keep the two timers separate, even though they seem to
overlap, because they behave differently: conn_est is a hardcoded real
time; rexmt_syn is soft, and depends on RTO.  They're not synchronised
with each other in any way either.


Semantic bits we've decided not to do just now
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Things to do with RTT when we have a route metrics cache:
* int t_rxtcur: current retransmit value, already multiplied by the
  backoff factor, in ticks.
  - set (calculated as t_srtt/8 + t_rttvar/2 = 4*SRTT+8*RTTVAR) from
    route metric cache if available.  BUG!
* int t_srtt: current smoothed RTT estimate, in TCP_RTT_SCALEd ticks
    (=32).
  - used when updating from route metric cache: only if srtt=0 is this
    done, otherwise we assume we already have a good value.
  - set from route metric cache.
  - used to set rttvar if not rttvar present in route metric cache but
    srtt is: default is RTTVAR = SRTT (actually t_rttvar =
    t_srtt*16/32).
  - used to set initial t_rxtcur when setting from route metric
    cache.  BUG, see t_rxtcur.
  - stored in rmx if not locked.
* int t_rttvar: current RTT variance estimate, in TCP_RTTVAR_SCALEd
    ticks (=16).
  - set from route metric cache, or to t_srtt*16/32 = SRTT if only
    SRTT in cache.
  - stored in route metric cache if not locked (on close).
* u_int t_rttmin: minimum RTT allowed, in ticks.
  - set to cached RTT in route metric cache, if the value has the lock
    bit set.
* u_long t_rttupdated: number of RTT updates performed since
  tcpcb creation.
  - only save srtt and rttvar in route metric cache if this is >=16.


Model tuning/tweaking, to make it more pleasant
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Peter idea: dsched and a few other things (doq, e.g.): we have no idea
exactly what time to put in, and sometimes Michael gets burnt when we
get it wrong (not just for Michael: it's also so we don't bake in
unfounded values).  A possible way to cope: make them count-*up* not
down, not urgent, and when the transition happens, put the time it
actually took in the label (e.g., in the return label).  This is
better than trying to match calls and returns in the statement of the
theorem; we can just say "assuming for all ret(v,t), t <= 0.1 sec".

Phase 2: the rest.  This may be content-ful, as it will involve looking at
     the BSD error behaviour - so far, we just went by what POSIX
     said, and don't have much idea how much they differ.
       ==> should "parameterise", keeping the spec of the POSIX
       behaviour but adding the BSD behaviour also.  Not clear this
     makes sense, given that POSIX is not a whole TCP/IP/sockets
     stack, but just a loose spec of the topmost layer of that cake.

switch to non-lossy segment representation (and in Steve's test code).

Work out how we will write our annotated spec(s)

Constructorify "bool" in various places (and possibly "num" as well);
e.g., tcp_output_really's force_byte argument.

Morally speaking, one is either in "dup ACK" mode or not; so t_dupacks
shouldn't just be a num, it should have a more perspicuous type.

think about deliver_in_3: there are some multiple state changes in the
four phases, and this is confusing.  For example, synrcvdstuff can go
from SYN_RECEIVED to FIN_WAIT_1; ackstuff can go from FIN_WAIT_1 to
FIN_WAIT_2; and datastuff can go from FIN_WAIT_2 to TIME_WAIT.  We
*hope* that the side conditions on these transitions forbid them all
from happening at once, but it's still a weird and
difficult-to-understand way of expressing it.  If we're going to be
like this, at the very least we need a diagram of the state
transitions that can be caused by synrcvdstuff, ackstuff, and
datastuff (topstuff never transitions state I think).

Thoughts: if we're really going to use a *lossy* representation
(P: we're not), keeping only the meaningful content, then URG and urg
should be replaced by urg option, ditto for ACK and ack.

It's unsatisfactory that our deliver_out etc are not, in Level 3,
going to know about Nagle.  Level 3.5....  We can either: (a) really
recurse, or (b) call tcp_output wherever it might get called and have
deliver_out_1 deal with only the sendalot cases, if they can be
delimited nicely. Don't know.


TODOs listed in spec
~~~~~~~~~~~~~~~~~~~~

(exhaustive as of 2003-04-17T13:00, v1.208 --KW)

Keith:

- send rules (after send_8): EINTR, ENOBUFS
- deliver_out_1: _force_ implies the rule should be urgent (when doing
  OOB data)  Also: tf_outnow should make it urgent - and all the
  when-do-we-output stuff should be sorted, including not outputting
  tiny amounts of data (Nagle).
- in deliver_in_7, there's an assertion
     tcp_drop_and_close err sock (sock',[]) (* ASSERT: outsegs is empty because of state *)
  which P,K don't see the justification for
- connect_1 rule category: not necessarily blocking
- close rules (note after close_9): be parametric wrt BSD vs POSIX
- deliver_in_3: tidy up an ugly assert
- deliver_in_99, deliver_out_99: renumber rules more sensibly.
- (not until the end!) verify initial_cb lists every field

Not Keith:

- should we RST cwnd when checking tcp_output_required?
- ENOBUFS possible in tcp_output_really; other errors ditto?
- various rules: what if enqueue fails? (queue is full), or can't
  route?
- deliver_out_1: do whatever tcp_output() does when it *doesn't* emit
  a seg.
- silly windows, tcp_output_really
- close_6 et al: can I relax initial Sock state constraints?
- listen_1: should we allow multiple calls?
- shutdown_1: do we still ACK (and drop on floor) received data?
- send_1: if MSG_OOB, should send immediately (currently nondetified)
- deliver_in_1: if URG, notify application, pull up byte perhaps, etc
- deliver_in_1 dequeue: need rule to deal with non_TCP messages
- deliver_in_3: should we ack when we get completely old or too-new
  seg?
- deliver_in_8: when precisely should it fire?  SYN trimmed?
- deliver_in_10: check the socket state?
- timer_tt_rexmtsyn_1, timer_tt_rexmt_1: do in_losing(cb)
- timer_tt_keep_1: check if still probing
- timer_tt_rexmtsyn_1: is all this window manipulation necessary here?

- wait until we have *enough* data, in tcp_output_required, or be
  nondet?
- tcp_output_really: should underspecify sndurp?

- make_syn_segment: "is this the right place to assert [ws valid?]"
- make_ack_segment: "should we force [win] in range or clip?"
- tcp_output_really: force [win] in range or clip?
- can we make tcp_output_really's determinacy visible in type? [maybe
  it won't be deterministic in the end anyway]

Also various "proof obligations", and some things not marked with TODO.



Levels in more detail, as we now (2003-01-16) see them:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

After Phase 1 we should have a spec that can be used to start
serious testing, liberal enough to admit pretty much all real captured
traces.  (this is the definition of the end of Phase 1, in fact)

That will then need the Phase 2 things done to it (esp. making output
more controlled, unless we gather the will to do that in Phase 1), and
lots of testing, before we really like it. Call the result (3).

Eventually, we plan to have:

  1 stream-level spec  - a substantial abstraction of 3, for user-level documentation
  3 segment-level spec - our main spec, suitable for testing against and
                          for tcp-implementor documentation
  4 segment-level impl - a mild determinisation of 3, suitable for HOLTCP

We'd publish both 1 and 3 in full.



Conceivably also:

  2 segment-level spec - 3 with congestion control etc stripped out, for
                         adding fancy flow control to.

  5 real-code impl - a hand-or-machine translation of 4 into something
                     the world will recognise as "real code", as a
                     model implementation?




Steve TODO
~~~~~~~~~~

* make sure all existing tools work on Linux, BSD, WinXP.

* do a quick-n-dirty test harness that is capable of driving the other
  tools to do, for example, do system calls to put socket into a
  particular state, inject packet, observe behaviour.  Collect data
  and merge.

* discover if it's possible, and if possible how to, get some or all
  TCPDEBUG info from WinXP.


Thoughts on test cases
~~~~~~~~~~~~~~~~~~~~~~

- exercise each of our LTS rules
- get a connection into each of various dynamic states - bulk data,
   interactive data, sender/receiver limited, whatever. (In both
   directions, separately)

- comment from BSD source of syncache_add.  Check we handle repeated
  SYNs correctly.
	/*
	 * See if we already have an entry for this connection.
	 * If we do, resend the SYN,ACK, and reset the retransmit timer.
	 *
	 * XXX
	 * should the syncache be re-initialized with the contents
	 * of the new SYN here (which may have different options?)
	 */
