% auto-generated file; do not edit
\RequirePackage{ltsmunge}
\RequirePackage{tcp}

\let\mignore\relax
\newcommand{\mignore}[1]{}

\def\rulesrcsid{}

% load as late as possible
\RequirePackage[pdfpagelabels,linktocpage]{hyperref}
% Ugh, get rid of annoying warnings.  We will hope that the substitutions
% hyperref does to get a PDF-safe string for the various anchors are OK.
\makeatletter
\def\HyPsd@CatcodeWarning#1{}
\makeatother

\let\dumpallrules\relax
\let\dumpallrules\relax

%% PART TCP3\protect\textunderscore hostTypes

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: Spec3_alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPIIIThostTypes}{\chaptersection{ Host types}
\label{TCP3_hostTypes}%
\chapcomm{
This file defines types for the internal state of the host and its components:
files, TCP control blocks, sockets, interfaces, routing table, thread
states, and so on, culminating in the definition of the $\tstype{host}$ type.
%
It also defines TCP trace records, building on the definition of TCP control blocks.


Broadly following the implementations, each protocol endpoint has a
$\tstype{socket}$ structure which has some common fields (e.g.~the associated
IP addresses and ports), and some protocol-specific information.

For TCP, which involves a great deal of local state, the
protocol-specific information (of type $\tstype{tcp\_socket}$) consists of a
\emph{TCP state} ($\tscon{CLOSED}$, $\tscon{LISTEN}$, etc.), send and receive
queues, and a \emph{TCP control block}, of type $\tstype{tcpcb}$, with many
window parameters, timers, etc.
%
Roughly, the $\tstype{socket}$ structure and $\tstype{tcp\_socket}$ substructure contain all the information required by most sockets rules, whereas the $\tstype{tcpcb}$ contains fields required only by the protocol information.




}
}

\newcommand{\seccommhosttyTtcpcp}{\clustersection{(TCP only)}{The TCP control block}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{tcpcb}$
&
&  the TCP control block \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntcpcb}{\ddefnn{tcpcb}{\iA{tcpcb}}{\subddefnA[{ the TCP control block }]{tcpcb}{\tstype{tcpcb} = \Mmagiclrec {}\\{}
 {}\\{}
 \tsholcomm{ timers }{}\\{}
 \tsfield{tt\_keep}       : () \;\tsunknown{timed} \;\;\tstype{option};         \tsholcomm{ keepalive timer }{}\\{}
 {}\\{}
 \tsholcomm{ other }{}\\{}
 \tsfield{t\_softerror} : \tsunknown{error} \;\;\tstype{option}      \tsholcomm{ current transient error; reported only if failure becomes permanent }{}\\{}
 \tsholcomm{ could cut this down to the actually-possible errors? }{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\seccommhosttyTsockets}{\clustersection{(TCP and UDP)}{Sockets}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{tcp\_socket}$
&
&  details of a TCP socket \\
$\tsrule{protocol\_info}$
&
&  protocol-specific socket data \\
$\tsrule{socket}$
&
&  details of a socket \\
$\tsrule{TCP\_Sock0}$
&
&  helper constructor \\
$\tsrule{TCP\_Sock}$
&
&  helper constructor \\
$\tsrule{UDP\_Sock0}$
&
&  helper constructor \\
$\tsrule{UDP\_Sock}$
&
&  helper constructor \\
$\tsrule{Sock}$
&
&  helper constructor \\
$\tsrule{tcp\_sock\_of}$
&
&  helper accessor (beware ARBitrary behaviour on non-TCP socket) \\
$\tsrule{udp\_sock\_of}$
&
&  helper accessor (beware ARBitrary behaviour on non-UDP socket) \\
$\tsrule{proto\_of}$
&
&  helper accessor \\
$\tsrule{proto\_eq}$
&
&  compare protocol of two protocol info structures \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntcpTsocket}{\ddefnn{tcpTsocket}{\iA{tcp\_socket}}{\subddefnA[{ details of a TCP socket }]{tcp\_socket}{\tstype{tcp\_socket}{}\\{}
 = \Mmagiclrec  \tsvar{st}   : \tsunknown{tcpstate};  \tsholcomm{ here rather than in $\tstype{tcpcb}$ for convenience as heavily used.  Called \wasverb{t\textunderscore{}state} in BSD }{}\\{}
 \tsvar{cb}   : \tstype{tcpcb};{}\\{}
 \tsvar{lis}  : \tsunknown{socket\_listen} \;\;\tstype{option}; \tsholcomm{ invariant: $*$ iff not $\tscon{LISTEN}$ }{}\\{}
 \tsvar{sndq} : \tstype{byte} \;\tstype{list};{}\\{}
 \tsvar{rcvq} : \tstype{byte} \;\tstype{list}{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defnprotocolTinfo}{\ddefnn{protocolTinfo}{\iA{protocol\_info}}{\subddefnA[{ protocol-specific socket data }]{protocol\_info}{\tstype{protocol\_info} = \tscon{TCP\_PROTO} \;\Mof  \;\tstype{tcp\_socket}{}\\{}
\quad\quad\quad\quad\quad\quad \mid  \tscon{UDP\_PROTO} \;\Mof  \;\tsunknown{udp\_socket}}
}
{}
}

\newcommand{\defnsocket}{\ddefnn{socket}{\iA{socket}}{\subddefnA[{ details of a socket }]{socket}{\tstype{socket}{}\\{}
 = \Mmagiclrec  \tsvar{fid}  : \tsvar{fid} \;\;\tstype{option};    \tsholcomm{ associated open file description if any }{}\\{}
 \tsvar{sf}   : \tsunknown{sockflags};     \tsholcomm{ socket flags }{}\\{}
 \tsvar{is}_{1}  : \tsunknown{ip} \;\;\tstype{option};     \tsholcomm{ local IP address if any }{}\\{}
 \tsvar{ps}_{1}  : \tsunknown{port} \;\;\tstype{option};   \tsholcomm{ local port if any }{}\\{}
 \tsvar{is}_{2}  : \tsunknown{ip} \;\;\tstype{option};     \tsholcomm{ remote IP address if any }{}\\{}
 \tsvar{ps}_{2}  : \tsunknown{port} \;\;\tstype{option};   \tsholcomm{ remote port if any }{}\\{}
 \tsvar{es}   : \tsunknown{error} \;\;\tstype{option};  \tsholcomm{ pending error if any }{}\\{}
 \tsvar{cantsndmore} : \tstype{bool};   \tsholcomm{ output stream ends at end of send queue }{}\\{}
 \tsvar{cantrcvmore} : \tstype{bool};   \tsholcomm{ input stream ends at end of receive queue }{}\\{}
 \tsvar{pr}   : \tstype{protocol\_info}  \tsholcomm{ protocol-specific information }{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defnTCPTSockZ}{\ddefnc{TCPTSockZ}{\iA{TCP\_Sock0}}{\subddefnA[{ helper constructor }]{TCP\_Sock0}{\tsaux{TCP\_Sock0}(\tsvar{st}, \tsvar{cb}, \tsvar{lis}, \tsvar{sndq}, \tscomm{ X sndurp,X} \tsvar{rcvq} \tscomm{ X, rcvurp, iobc X }){}\\{}
 = \Mmagiclrec  \tsvar{st}\Mass \tsvar{st}; \tsvar{cb}\Mass \tsvar{cb}; \tsvar{lis}\Mass \tsvar{lis}; \tsvar{sndq}\Mass \tsvar{sndq};{}\\{}
 \tscomm{ X sndurp:=sndurp; X } \tsvar{rcvq}\Mass \tsvar{rcvq} \tscomm{ X ; rcvurp:=rcvurp; iobc:=iobc X } \Mmagicrrec }
}
{}
}

\newcommand{\defnTCPTSock}{\ddefnc{TCPTSock}{\iA{TCP\_Sock}}{\subddefnA[{ helper constructor }]{TCP\_Sock}{\tsaux{TCP\_Sock} \;\tsunknown{v} = \tscon{TCP\_PROTO}(\tsaux{TCP\_Sock0} \;\tsunknown{v})}
}
{}
}

\newcommand{\defnUDPTSockZ}{\ddefnc{UDPTSockZ}{\iA{UDP\_Sock0}}{\subddefnA[{ helper constructor }]{UDP\_Sock0}{(\tsaux{UDP\_Sock0}:\tsunknown{dgram} \;\tstype{list}\Mtotype \tsunknown{udp\_socket}) \tsvar{rcvq} = \Mmagiclrec  \tsvar{rcvq}\Mass \tsvar{rcvq} \Mmagicrrec }
}
{}
}

\newcommand{\defnUDPTSock}{\ddefnc{UDPTSock}{\iA{UDP\_Sock}}{\subddefnA[{ helper constructor }]{UDP\_Sock}{\tsaux{UDP\_Sock} \;\tsunknown{v} = \tscon{UDP\_PROTO}(\tsaux{UDP\_Sock0} \;\tsunknown{v})}
}
{}
}

\newcommand{\defnSock}{\ddefnc{Sock}{\iA{Sock}}{\subddefnA[{ helper constructor }]{Sock}{\tscon{Sock}(\tsvar{fid}, \tsvar{sf}, \tsvar{is}_{1}, \tsvar{ps}_{1}, \tsvar{is}_{2}, \tsvar{ps}_{2}, \tsvar{es}, \tsunknown{csm}, \tsunknown{crm}, \tsvar{pr}){}\\{}
 = \Mmagiclrec  \tsvar{fid}\Mass \tsvar{fid}; \tsvar{sf}\Mass \tsvar{sf}; \tsvar{is}_{1}\Mass \tsvar{is}_{1}; \tsvar{ps}_{1}\Mass \tsvar{ps}_{1}; \tsvar{is}_{2}\Mass \tsvar{is}_{2}; \tsvar{ps}_{2}\Mass \tsvar{ps}_{2};{}\\{}
 \tsvar{es}\Mass \tsvar{es}; \tsvar{cantsndmore} \Mass  \tsunknown{csm}; \tsvar{cantrcvmore} \Mass  \tsunknown{crm}; \tsvar{pr}\Mass \tsvar{pr} \Mmagicrrec }
}
{}
}

\newcommand{\defntcpTsockTof}{\ddefnc{tcpTsockTof}{\iA{tcp\_sock\_of}}{\subddefnA[{ helper accessor (beware ARBitrary behaviour on non-TCP socket) }]{tcp\_sock\_of}{\tsaux{tcp\_sock\_of} \;\tsunknown{sock} = \Mcase  \;\tsunknown{sock}.\tsvar{pr} \;\Mof  \;\tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mtotype  \tsunknown{tcp\_sock} \Mdpipe  \tsunknown{\_} \Mtotype  \tsunknown{ARB}}
}
{}
}

\newcommand{\defnudpTsockTof}{\ddefnc{udpTsockTof}{\iA{udp\_sock\_of}}{\subddefnA[{ helper accessor (beware ARBitrary behaviour on non-UDP socket) }]{udp\_sock\_of}{\tsaux{udp\_sock\_of} \;\tsunknown{sock} = \Mcase  \;\tsunknown{sock}.\tsvar{pr} \;\Mof  \;\tscon{UDP\_PROTO}(\tsunknown{udp\_sock}) \Mtotype  \tsunknown{udp\_sock} \Mdpipe  \tsunknown{\_} \Mtotype  \tsunknown{ARB}}
}
{}
}

\newcommand{\defnprotoTof}{\ddefnc{protoTof}{\iA{proto\_of}}{\subddefnA[{ helper accessor }]{proto\_of}{\tsaux{proto\_of} (\tscon{TCP\_PROTO}(\tsunknown{\_1})) = \tsunknown{PROTO\_TCP} \Mwedge {}\\{}
 \tsaux{proto\_of} (\tscon{UDP\_PROTO}(\tsunknown{\_3})) = \tsunknown{PROTO\_UDP}}
}
{}
}

\newcommand{\defnprotoTeq}{\ddefnc{protoTeq}{\iA{proto\_eq}}{\subddefnA[{ compare protocol of two protocol info structures }]{proto\_eq}{\tsaux{proto\_eq} \;\tsvar{pr} \;\tsvar{pr}' = (\tsaux{proto\_of} \;\tsvar{pr} = \tsaux{proto\_of} \;\tsvar{pr}')}
}
{\rulesubsection{Description}
Various convenience functions.


\rrulepad }
}

\newcommand{\seccommhosttyThost}{\clustersection{(TCP and UDP)}{The host}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{host}$
&
&  host details \\
$\tsrule{privileged\_ports}$
&
& \\
$\tsrule{ephemeral\_ports}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnhost}{\ddefnc{host}{\iA{host}}{\subddefnA[{ host details }]{host}{\tstype{host} = \Mmagiclrec {}\\{}
 \tsvar{arch}  : \tsvar{arch};  \tscomm{ architecture }{}\\{}
 \tsvar{privs} : \tstype{bool};  \tscomm{ whether process has root/CAP\textunderscore{}NET\textunderscore{}ADMIN privilege }{}\\{}
 \tsvar{ifds}  : \tsunknown{ifid} \mapsto  \tsunknown{ifd}; \tscomm{ interfaces }{}\\{}
 \tsvar{rttab} : \tsunknown{routing\_table};  \tscomm{ routing table }{}\\{}
 \tsvar{ts}    : \tsunknown{tid} \mapsto  \tsunknown{hostThreadState} \;\tsunknown{timed}; \tscomm{ host view of each thread state }{}\\{}
 \tsvar{files} : \tsvar{fid} \mapsto  \tsunknown{file}; \tscomm{ files }{}\\{}
 \tsvar{socks} : \tsunknown{sid} \mapsto  \tstype{socket}; \tscomm{ sockets }{}\\{}
 \tsvar{listen} : \tsunknown{sid} \;\tstype{list}; \tscomm{ list of listening sockets }{}\\{}
 \tsvar{bound} : \tsunknown{sid} \;\tstype{list}; \tscomm{ list of sockets bound: head of list was first to be bound }{}\\{}
 \tsvar{iq}    : \tsunknown{msg} \;\tstype{list} \;\tsunknown{timed}; \tscomm{ input queue }{}\\{}
 \tsvar{oq}    : \tsunknown{msg} \;\tstype{list} \;\tsunknown{timed}; \tscomm{ output queue }{}\\{}
 \tsvar{bndlm} : \tsunknown{bandlim\_state}; \tscomm{ bandlimiting }{}\\{}
 \tsvar{ticks} : \tsunknown{ticker};  \tscomm{ ticker }{}\\{}
 \tsvar{fds}   : \tsunknown{fd} \mapsto  \tsvar{fid}; \tscomm{ file descriptors (per-process) }{}\\{}
 \tsvar{params}: \tsunknown{hostParams} \tscomm{ configuration info}{}\\{}
 \Mmagicbolrrec }
}
{\rulesubsection{Description}
The input and output queue timers model the interrupt scheduling delay; the first element (if any) must be processed by the timer expiry.
\rrulepad }
}

\newcommand{\defnprivilegedTports}{\ddefnc{privilegedTports}{\iA{privileged\_ports}}{\subddefnA{privileged\_ports}{\tsaux{privileged\_ports} \;\tsunknown{h} = \{ \tscon{Port} \;\tsunknown{n} \mid  \tsunknown{n} < 1024 \}}
}
{}
}

\newcommand{\defnephemeralTports}{\ddefnc{ephemeralTports}{\iA{ephemeral\_ports}}{\subddefnA{ephemeral\_ports}{\tsaux{ephemeral\_ports} \;\tsunknown{h} = \{ \tscon{Port} \;\tsunknown{n} \mid  \tsunknown{n} \geq  \tsunknown{h}.\tsvar{params}.\tsunknown{min\_eph\_port} \Mwedge  \tsunknown{n} \leq  \tsunknown{h}.\tsvar{params}.\tsunknown{max\_eph\_port} \}}
}
{\rulesubsection{Description}
Ports below 1024 (on all systems that we know of) are reserved, and can be bound
by privileged users only.  Additionally there is a range of ports (1024 through
2048, 3072 or 4999 or 32768 through 61000 inclusive, depending on configuration,
are used for autobinding, when no specific port is specified; these ports are
called "ephemeral".

\rrulepad }
}

\newcommand{\seccommhosttyTtrace}{\clustersection{(TCP and UDP)}{Trace records}
\seccomm{
   For BSD testing we make use of the BSD \wasverb{TCP\textunderscore{}DEBUG} option, which
   enables TCP debug trace records at various points in the code.  This
   permits earlier resolution of nondeterminism in the trace checking
   process.

   Debug records contain IP and TCP headers, a timestamp, and a copy
   of the implementation TCP control block.
%
   Three issues complicate their use: firstly, not all the relevant
   state appears in the trace record; secondly, the model deviates in
   its internal structures from the BSD implementation in several
   ways; and thirdly, BSD generates trace records in the middle of
   processing messages, whereas the model performs atomic transitions
   (albeit split for blocking invocations).
 %
   These mean that in different circumstances we can use only some of
   the debug record fields.
%
   To save defining a whole new datatype, we reuse $\tstype{tcpcb}$.  However, we
   define a special equality that only inspects certain fields, and
   leaves the others unconstrained.

   Frustratingly, the \wasverb{is1} \wasverb{ps1} \wasverb{is2} \wasverb{ps2} are not always
   available, since although the TCP control block is structure-copied
   into the trace record, the embedded Internet control block is not!
   However, in cases where these are not available, the \wasverb{iss} should
   be sufficiently unique to identify the socket of interest.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{type\_abbrev\_tracerecord}$
&
& \\
$\tsrule{tracecb\_eq}$
&
&  compare two control blocks for "equality" modulo known issues \\
$\tsrule{tracesock\_eq}$
&
&  compare two sockets for "equality" modulo known issues \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntypeTabbrevTtracerecord}{\ddefnn{typeTabbrevTtracerecord}{\iA{type\_abbrev\_tracerecord}}{\subddefnA{type\_abbrev\_tracerecord}{\tsholop{type\_abbrev} \;\tsunknown{tracerecord} : \tsunknown{traceflavour}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \# \tsunknown{sid}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \# (\tsunknown{ip} \;\;\tstype{option} \tscomm{ is1 }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \# \tsunknown{port} \;\;\tstype{option} \tscomm{ ps1 }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \# \tsunknown{ip} \;\;\tstype{option} \tscomm{ is2 }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \# \tsunknown{port} \;\;\tstype{option} \tscomm{ ps2 }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad ) \;\tstype{option} \tscomm{ not always available! }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \# \tsunknown{tcpstate} \tscomm{ st }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \# \tstype{tcpcb} \tscomm{ cb subset }}
}
{}
}

\newcommand{\defntracecbTeq}{\ddefnn{tracecbTeq}{\iA{tracecb\_eq}}{\subddefnA[{ compare two control blocks for "equality" modulo known issues }]{tracecb\_eq}{\tsaux{tracecb\_eq} (\tsunknown{flav}:\tsunknown{traceflavour}) (\tsvar{st}:\tsunknown{tcpstate}) (\tsvar{es}:\tsunknown{error} \;\;\tstype{option}) (\tsvar{cb}:\tstype{tcpcb}) (\tsvar{cb}':\tstype{tcpcb}){}\\{}
 = \Mtrue  \tscomm{ Placeholder: probably remove this def }\tscomm{ X ((* X (                                cb.snd\textunderscore{}una       = cb'.snd\textunderscore{}una      ) /\textbackslash{} X }{}\\{}
\quad \tscomm{ X (if flav = TA\textunderscore{}OUTPUT then T else cb.snd\textunderscore{}max       = cb'.snd\textunderscore{}max      ) /\textbackslash{} X }{}\\{}
\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_OUTPUT} \Mvee  (\tsvar{st} = \tscon{SYN\_SENT} \Mwedge  \tsvar{es} \neq  *){}\\{}
\quad \Mthen  \;\Mtrue {}\\{}
\quad \Melse  \;\tsvar{cb}.\tsunknown{snd\_nxt}       = \tsvar{cb}'.\tsunknown{snd\_nxt}      ) \Mwedge   \tscomm{ only bad on error }{}\\{}
\quad (                                \tsvar{cb}.\tsunknown{snd\_wl1}       = \tsvar{cb}'.\tsunknown{snd\_wl1}      ) \Mwedge {}\\{}
\quad (                                \tsvar{cb}.\tsunknown{snd\_wl2}       = \tsvar{cb}'.\tsunknown{snd\_wl2}      ) \Mwedge {}\\{}
\quad (                                \tsvar{cb}.\tsunknown{iss}           = \tsvar{cb}'.\tsunknown{iss}          ) \Mwedge {}\\{}
\quad (                                \tsvar{cb}.\tsunknown{snd\_wnd}       = \tsvar{cb}'.\tsunknown{snd\_wnd}      ) \Mwedge {}\\{}
\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_OUTPUT} \;\Mthen  \;\Mtrue  \;\Melse  \;\tsvar{cb}.\tsunknown{snd\_cwnd}      = \tsvar{cb}'.\tsunknown{snd\_cwnd}     ) \Mwedge   \tscomm{ only bad on error }{}\\{}
\quad (                                \tsvar{cb}.\tsunknown{snd\_ssthresh}  = \tsvar{cb}'.\tsunknown{snd\_ssthresh} ) \Mwedge {}\\{}
 {}\\{}
\quad \tsholcomm{ Don't check equality of $\tsunknown{rcv\_wnd}$: we recalculate $\tsunknown{rcv\_wnd}$ lazily in $\tsunknown{tcp\_output}$ instead of after every successful $\tsunknown{recv}()$ call, so our value is often out of date. }{}\\{}
 {}\\{}
\quad \tsholcomm{ $(\Mif  \;\tsvar{st} = \tscon{SYN\_SENT}    \;\Mthen  \;\Mtrue  \;\Melse  \;\tsvar{cb}.\tsunknown{rcv\_wnd}       = \tsvar{cb}'.\tsunknown{rcv\_wnd}      ) \Mwedge  $ }{}\\{}
 {}\\{}
\quad \tslongcomm{ Removing this clause is an allowance for the fact that BSD chooses its
          window size rather late.  }{}\\{}
 {}\\{}
\quad \tslongcomm{ Note: we should check how it ensures that
          a window size it emits on a SYN retransmit is the same as on the initial transmit,
          and how it ensures it does not accidentally shrink the window on the next output
          segment (ACK of other end's SYN,ACK). }{}\\{}
 {}\\{}
\quad (                                \tsvar{cb}.\tsunknown{rcv\_nxt}       = \tsvar{cb}'.\tsunknown{rcv\_nxt}      ) \Mwedge {}\\{}
\quad (                                \tsvar{cb}.\tsunknown{rcv\_up}        = \tsvar{cb}'.\tsunknown{rcv\_up}       ) \Mwedge {}\\{}
\quad (                                \tsvar{cb}.\tsunknown{irs}           = \tsvar{cb}'.\tsunknown{irs}          ) \Mwedge {}\\{}
\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_OUTPUT} \Mvee  \tsunknown{flav} = \tscon{TA\_INPUT} \;\Mthen  \;\Mtrue  \;\Melse  \;\tsvar{cb}.\tsunknown{rcv\_adv}       = \tsvar{cb}'.\tsunknown{rcv\_adv}      ) \Mwedge {}\\{}
\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_OUTPUT} \Mvee  \tsvar{st} = \tscon{SYN\_SENT} \Mvee  \tsvar{st} = \tscon{TIME\_WAIT}{}\\{}
\quad\quad\quad \tsholcomm{ we store our initially-sent MSS in $\tsunknown{t\_maxseg}$,
              whereas BSD just recalculates it.  This test decouples
              the model from BSD in order to cope with this. }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mthen  \;\Mtrue  \;\Melse  \;\tsvar{cb}.\tsunknown{t\_maxseg}      = \tsvar{cb}'.\tsunknown{t\_maxseg}     ) \Mwedge   \tscomm{ only bad on error }{}\\{}
\quad (                                \tsvar{cb}.\tsunknown{t\_dupacks}     = \tsvar{cb}'.\tsunknown{t\_dupacks}    ) \Mwedge {}\\{}
\quad (                                \tsvar{cb}.\tsunknown{snd\_scale}     = \tsvar{cb}'.\tsunknown{snd\_scale}    ) \Mwedge {}\\{}
\quad (                                \tsvar{cb}.\tsunknown{rcv\_scale}     = \tsvar{cb}'.\tsunknown{rcv\_scale}    ) \Mwedge {}\\{}
\quad \tscomm{ t\textunderscore{}rtseq, if t\textunderscore{}rtttime \textless{}\textgreater{} 0; ignore t\textunderscore{}rtttime }  \tscomm{ only bad on error }{}\\{}
\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_OUTPUT} \Mvee  \tsunknown{flav} = \tscon{TA\_INPUT} \;\Mthen  \;\Mtrue  \;\Melse {}\\{}
\quad\quad\quad \tsholop{option\_map}\Mspii{\tsholop{SND}}{\tsvar{cb}.\tsunknown{t\_rttseg}} = \tsholop{option\_map}\Mspii{\tsholop{SND}}{\tsvar{cb}'.\tsunknown{t\_rttseg}} ) \Mwedge {}\\{}
\quad (                                \tsunknown{timewindow\_val\_of} \;\tsvar{cb}.\tsunknown{ts\_recent} = \tsunknown{timewindow\_val\_of} \;\tsvar{cb}'.\tsunknown{ts\_recent}) \Mwedge {}\\{}
\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_OUTPUT} \Mvee  \tsunknown{flav} = \tscon{TA\_INPUT} \;\Mthen  \;\Mtrue  \;\Melse  \;\tsvar{cb}.\tsunknown{last\_ack\_sent} = \tsvar{cb}'.\tsunknown{last\_ack\_sent})){}\\{}
\quad \tsholcomm{ also ignore, always: $\tsunknown{tt\_delack}$; in case of error: $\tsunknown{tt\_rexmt}$, $\tsfield{t\_softerror}$ } \tsunknown{X} *)}
}
{}
}

\newcommand{\defntracesockTeq}{\ddefnn{tracesockTeq}{\iA{tracesock\_eq}}{\subddefnA[{ compare two sockets for "equality" modulo known issues }]{tracesock\_eq}{\tsaux{tracesock\_eq} (\tsunknown{flav},\tsunknown{sid},\tsunknown{quad},\tsvar{st},\tsvar{cb}) \tsunknown{sid'} \;\tsunknown{sock}{}\\{}
 = (\tsaux{proto\_of} \;\tsunknown{sock}.\tsvar{pr} = \tsunknown{PROTO\_TCP} \Mwedge {}\\{}
\quad \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsunknown{sock} \;\Min {}\\{}
\quad \tsunknown{sid} = \tsunknown{sid'} \Mwedge {}\\{}
\quad \tsholcomm{ If trace is $\tscon{TA\_DROP}$ then the $\tsvar{is}_{2},\tsvar{ps}_{2}$ values in the trace may
          not match those in the socket record --- the segment is
          dropped because it is somehow invalid (and thus not safe to
          compare) }{}\\{}
\quad (\Mcase  \;\tsunknown{quad} \;\Mof {}\\{}
\quad\quad \Msome  (\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}) \Mtotype  \tsvar{is}_{1} = \tsunknown{sock}.\tsvar{is}_{1} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{ps}_{1} = \tsunknown{sock}.\tsvar{ps}_{1} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_DROP} \;\Mthen  \;\Mtrue  \;\Melse  \;\tsvar{is}_{2} = \tsunknown{sock}.\tsvar{is}_{2}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_DROP} \;\Mthen  \;\Mtrue  \;\Melse  \;\tsvar{ps}_{2} = \tsunknown{sock}.\tsvar{ps}_{2}) \Mdpipe {}\\{}
\quad\quad *                   \Mtotype  \Mtrue ) \Mwedge {}\\{}
\quad \tsvar{st}  = \tsunknown{tcp\_sock}.\tsvar{st} \Mwedge {}\\{}
\quad \tsaux{tracecb\_eq} \;\tsunknown{flav} \;\tsvar{st} \;\tsunknown{sock}.\tsvar{es} \;\tsvar{cb} \;\tsunknown{tcp\_sock}.\tsvar{cb})}
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPIIIThostTypes}
\showrule{\seccommhosttyTtcpcp}
\showrule{\defntcpcb}
\showrule{\seccommhosttyTsockets}
\showrule{\defntcpTsocket}
\showrule{\defnprotocolTinfo}
\showrule{\defnsocket}
\showrule{\defnTCPTSockZ}
\showrule{\defnTCPTSock}
\showrule{\defnUDPTSockZ}
\showrule{\defnUDPTSock}
\showrule{\defnSock}
\showrule{\defntcpTsockTof}
\showrule{\defnudpTsockTof}
\showrule{\defnprotoTof}
\showrule{\defnprotoTeq}
\showrule{\seccommhosttyThost}
\showrule{\defnhost}
\showrule{\defnprivilegedTports}
\showrule{\defnephemeralTports}
\showrule{\seccommhosttyTtrace}
\showrule{\defntypeTabbrevTtracerecord}
\showrule{\defntracecbTeq}
\showrule{\defntracesockTeq}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP3\protect\textunderscore streamTypes

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: Spec3_alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPITstreamTypes}{\chaptersection{ Stream types}
\label{TCP1_streamTypes}%
\chapcomm{
This file defines types for streams. FIXME


}
}

\newcommand{\seccommTCPITstreamTypesTFIXME}{\clustersection{(TCP and UDP)}{FIXME}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{type\_abbrev\_streamid}$
&
& \\
$\tsrule{streamFlags}$
&
&  stream control information \\
$\tsrule{tcpStream}$
&
&  unidirectional stream \\
$\tsrule{tcpStreams}$
&
&  bidirectional stream \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntypeTabbrevTstreamid}{\ddefnn{typeTabbrevTstreamid}{\iA{type\_abbrev\_streamid}}{\subddefnA{type\_abbrev\_streamid}{\tsholop{type\_abbrev} \;\tsunknown{streamid} :(\tsunknown{ip}\#\tsunknown{port}) \tstype{set}}
}
{}
}

\newcommand{\defnstreamFlags}{\ddefnn{streamFlags}{\iA{streamFlags}}{\subddefnA[{ stream control information }]{streamFlags}{\tstype{streamFlags} = \Mmagiclrec {}\\{}
 \tsvar{SYN} : \tstype{bool};    \tsholcomm{ $\tsvar{SYN}$, no $\tsunknown{ACK}$ }{}\\{}
 \tsvar{SYNACK} : \tstype{bool}; \tsholcomm{ $\tsvar{SYN}$ with $\tsunknown{ACK}$ }{}\\{}
 \tsvar{FIN} : \tstype{bool};{}\\{}
 \tsvar{RST} : \tstype{bool}{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defntcpStream}{\ddefnn{tcpStream}{\iA{tcpStream}}{\subddefnA[{ unidirectional stream }]{tcpStream}{\tstype{tcpStream} = \Mmagiclrec {}\\{}
 \tsvar{i} : \tsunknown{ip};      \tsholcomm{ source IP }{}\\{}
 \tsvar{p} : \tsunknown{port};    \tsholcomm{ source port }{}\\{}
 \tsvar{flgs} : \tstype{streamFlags};{}\\{}
 \tsvar{data} : \tstype{byte} \;\tstype{list};{}\\{}
 \tsvar{destroyed} : \tstype{bool}{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defntcpStreams}{\ddefnn{tcpStreams}{\iA{tcpStreams}}{\subddefnA[{ bidirectional stream }]{tcpStreams}{\tstype{tcpStreams} = \Mmagiclrec  \tsvar{streams} : \tstype{tcpStream} \;\tstype{set} \Mmagicrrec {}\\{}
 \tsholcomm{ always two $\tstype{tcpStream}$s in $\tsvar{streams}$ }}
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPITstreamTypes}
\showrule{\seccommTCPITstreamTypesTFIXME}
\showrule{\defntypeTabbrevTstreamid}
\showrule{\defnstreamFlags}
\showrule{\defntcpStream}
\showrule{\defntcpStreams}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP3\protect\textunderscore host0

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: Spec3_alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPIThostZ}{\chaptersection{ Host LTS labels and rule categories}
\label{TCP1_host0}%
\chapcomm{
This file defines the labels for the host labelled transition system,
characterising the possible interactions between a host and its environment.
It also defines various categories for the host LTS rules.


}
}

\newcommand{\seccommhostZTlabels}{\clustersection{(TCP and UDP)}{Transition labels}
\seccomm{
Host transition labels.

}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{Lhost0}$
&
&  Host transition labels \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnLhostZ}{\ddefnn{LhostZ}{\iA{Lhost0}}{\subddefnA[{ Host transition labels }]{Lhost0}{\tstype{Lhost0} ={}\\{}
\quad\quad \tscomm{ library interface }{}\\{}
\quad\quad\quad \tscon{Lh\_call} \Mof  \;\tsunknown{tid} \# \tsunknown{LIB\_interface}                        \tsholcomm{ invocation of LIB call, written e.g.~$\MLhcall{\tsunknown{tid}}{(\tstype{socket} (\tsunknown{socktype}))}$ } {}\\{}
\quad\quad \mid  \tscon{Lh\_return} \Mof  \;\tsunknown{tid} \# \tsunknown{TLang}                              \tsholcomm{ return result of LIB call, written $\MLhreturn{\tsunknown{tid}}{\tsunknown{v}} $ } {}\\{}
 {}\\{}
\quad\quad \tscomm{ message transmission and receipt }{}\\{}
\quad\quad \mid  \tscon{Lh\_senddatagram} \Mof  \;\tsunknown{msg}                               \tsholcomm{ output of message to the network, written $\MLhsenddatagram{\tsunknown{msg}}$ } {}\\{}
\quad\quad \mid  \tscon{Lh\_recvdatagram} \Mof  \;\tsunknown{msg}                              \tsholcomm{ input of message from the network, written $\MLhrecvdatagram{\tsunknown{msg}}$  } {}\\{}
\quad\quad \mid  \tscon{Lh\_loopdatagram} \Mof  \;\tsunknown{msg}                               \tsholcomm{ loopback output/input, written $\MLhloopdatagram{\tsunknown{msg}}$ } {}\\{}
 {}\\{}
\quad\quad \tscomm{ connectivity changes }{}\\{}
\quad\quad \mid  \tscon{Lh\_interface} \Mof  \;\tsunknown{ifid} \# \tstype{bool}                         \tsholcomm{ set interface status to boolean $\tsunknown{up}$, written $\tscon{Lh\_interface} (\tsunknown{ifid},\tsunknown{up})$ } {}\\{}
 {}\\{}
\quad\quad \tscomm{ miscellaneous }{}\\{}
\quad\quad \mid  \MLhtau                                               \tsholcomm{ internal transition, written $\MLhtau $ } {}\\{}
\quad\quad \mid  \tscon{Lh\_trace} \Mof  \;\tsunknown{tracerecord}                             \tsholcomm{ TCP trace record, written $\tscon{Lh\_trace} \;\tsunknown{tr}$ } }
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPIThostZ}
\showrule{\seccommhostZTlabels}
\showrule{\defnLhostZ}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP3\protect\textunderscore auxFns

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: Spec3_alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPITauxFns}{\chaptersection{ Auxiliary functions}
\label{TCP1_auxFns}%
\chapcomm{
This file defines a large number of auxiliary functions to the host
specification.


}
}

\newcommand{\defnFIXMEstreamTtestToutroute}{\ddefnn{FIXMEstreamTtestToutroute}{\iA{FIXMEstream\_test\_outroute}}{\subddefnA[{ if destination IP specified, do $\tsunknown{test\_outroute\_ip}$ }]{FIXMEstream\_test\_outroute}{\tsaux{FIXMEstream\_test\_outroute}(\tsvar{is}_{2},\tsvar{rttab},\tsvar{ifds},\tsvar{arch}){}\\{}
 = \Mcase  \;\tsvar{is}_{2} \;\Mof {}\\{}
\quad \Msome  \;\tsvar{i}_{2} \Mtotype  \Msome  (\tsunknown{test\_outroute\_ip}(\tsvar{i}_{2},\tsvar{rttab},\tsvar{ifds},\tsvar{arch})){}\\{}
 \Mdpipe  \tsunknown{\_} \Mtotype  *}
}
{}
}

\newcommand{\defnFIXMEstreamTloopbackTonTwire}{\ddefnn{FIXMEstreamTloopbackTonTwire}{\iA{FIXMEstream\_loopback\_on\_wire}}{\subddefnA[{ check if a message bears a loopback address }]{FIXMEstream\_loopback\_on\_wire}{\tsaux{FIXMEstream\_loopback\_on\_wire} (\tsvar{is}_{1},\tsvar{is}_{2}) (\tsvar{ifds}:\tsunknown{ifid} \mapsto  \tsunknown{ifd}) ={}\\{}
 \Mcase  (\tsvar{is}_{1}, \tsvar{is}_{2}) \Mof {}\\{}
\quad (*, *) \Mtotype  \Mfalse {}\\{}
 \Mdpipe  (*, \Msome  \;\tsunknown{j}) \Mtotype  \Mfalse {}\\{}
 \Mdpipe  (\Msome  \;\tsvar{i}, *) \Mtotype  \Mfalse {}\\{}
 \Mdpipe  (\Msome  \;\tsvar{i}, \Msome  \;\tsunknown{j}) \Mtotype  \tsunknown{in\_loopback} \;\tsvar{i} \Mwedge  \neg{}\tsunknown{in\_local} \;\tsvar{ifds} \;\tsunknown{j}}
}
{}
}

\newcommand{\seccommauxTfiles}{\clustersection{(TCP and UDP)}{Files, file descriptors, and sockets}
\seccomm{
   The open files of a host are modelled by a set of open file
   descriptions, indexed by $\tsvar{fid}$.  The open files of a process are
   identified by file descriptor $\tsunknown{fd}$, which is an index into a
   table of $\tsvar{fid}$s.  This table is modelled by a finite map.
   File descriptors are isomorphic to the natural numbers.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{sane\_socket}$
&
&  socket sanity invariants hold \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnsaneTsocket}{\ddefnc{saneTsocket}{\iA{sane\_socket}}{\subddefnA[{ socket sanity invariants hold }]{sane\_socket}{\tsaux{sane\_socket} \;\tsunknown{sock} = \Mcase  \;\tsunknown{sock}.\tsvar{pr} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscon{TCP\_PROTO} \;\tsunknown{tcp\_sock} \Mtotype {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscomm{LENGTH tcp\textunderscore{}sock.rcvq \textless{}= sock.sf.n(SO\textunderscore{}RCVBUF) /\textbackslash{}  (* true?? *)}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholop{LENGTH} \;\tsunknown{tcp\_sock}.\tsvar{rcvq} \leq  \tsunknown{TCP\_MAXWIN} \ll  \tsunknown{TCP\_MAXWINSCALE} \tscomm{/\textbackslash{}}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscomm{LENGTH tcp\textunderscore{}sock.sndq \textless{}= sock.sf.n(SO\textunderscore{}SNDBUF)     (* true?? *)}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mdpipe  \tscon{UDP\_PROTO} \;\tsunknown{udp\_sock} \Mtotype {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mtrue }
}
{\rulesubsection{Description}
 There are some demonstrable invariants on a socket; this definition
 asserts them.  These are largely here to provide explicit bounds to
 the symbolic evaluator.


\rrulepad }
}

\newcommand{\seccommauxTbinding}{\clustersection{(TCP and UDP)}{Binding}
\seccomm{
Both TCP and UDP have a concept of a socket being \emph{bound} to a
local port, which means that that socket may receive datagrams
addressed to that port.  A specific local IP address may also be
specified, and a remote IP address and/or port.  This `quadruple'
(really a quintuple, since the protocol is also relevant) is used to
determine the socket that best matches an incoming datagram.

The functions in this section determine this best-matching socket,
using rules appropriate to each protocol.  Support is also provided
for determining which ports are available to be bound by a new socket,
and for automatically choosing a port to bind to in cases where the
user does not specify one.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{bound\_ports\_protocol\_autobind}$
&
&  the set of ports currently bound by a socket for a protocol \\
$\tsrule{bound\_port\_allowed}$
&
&  is it permitted to bind the given (IP,port) pair? \\
$\tsrule{autobind}$
&
&  set of ports available for autobinding \\
$\tsrule{bound\_after}$
&
&  was $\tsunknown{sid}$ bound more recently than $\tsunknown{sid'}$? \\
$\tsrule{match\_score}$
&
&  score the match against the given pattern of the given quadruple \\
$\tsrule{lookup\_udp}$
&
&  the set of sockets matching an address quad, for UDP \\
$\tsrule{tcp\_socket\_best\_match}$
&
&  the set of sockets matching a quad, for TCP \\
$\tsrule{lookup\_icmp}$
&
&  the set of sockets matching a quad, for ICMP \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnboundTportsTprotocolTautobind}{\ddefnc{boundTportsTprotocolTautobind}{\iA{bound\_ports\_protocol\_autobind}}{\subddefnA[{ the set of ports currently bound by a socket for a protocol }]{bound\_ports\_protocol\_autobind}{\tsaux{bound\_ports\_protocol\_autobind} \;\tsvar{pr} \;\tsvar{socks} = \{\tsvar{p} \mid  \exists \tsvar{s}:\tsvar{socket}.{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{s} \;\in  \Mfrange{\tsvar{socks}} \Mwedge  \tsvar{s}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{proto\_of} \;\tsvar{s}.\tsvar{pr} = \tsvar{pr}\}}
}
{\rulesubsection{Description}
Rebinding of ports already bound is often restricted. $\tsaux{bound\_ports\_protocol\_autobind}$ is a list of all ports having
a socket of the given protocol binding that port.


\rrulepad }
}

\newcommand{\defnboundTportTallowed}{\ddefnc{boundTportTallowed}{\iA{bound\_port\_allowed}}{\subddefnA[{ is it permitted to bind the given (IP,port) pair? }]{bound\_port\_allowed}{\tsaux{bound\_port\_allowed} \;\tsvar{pr} \;\tsvar{socks} \;\tsvar{sf} \;\tsvar{arch} \;\tsunknown{is} \;\tsvar{p} ={}\\{}
 \tsvar{p} \;\notin {}\\{}
 \{\tsunknown{port} \mid  \exists \tsvar{s}:\tsvar{socket}.{}\\{}
\quad \tsvar{s} \;\in  \Mfrange{\tsvar{socks}} \Mwedge  \tsvar{s}.\tsvar{ps}_{1} = \Msome  \;\tsunknown{port} \Mwedge {}\\{}
\quad \tsaux{proto\_eq} \;\tsvar{s}.\tsvar{pr} \;\tsvar{pr} \Mwedge {}\\{}
\quad (\Mif  \;\tsunknown{bsd\_arch} \;\tsvar{arch} \Mwedge  \tscon{SO\_REUSEADDR} \;\in  \;\tsvar{sf}.\tsunknown{b} \;\Mthen {}\\{}
\quad\quad\quad \tsvar{s}.\tsvar{is}_{2} = * \Mwedge  \tsvar{s}.\tsvar{is}_{1} = \tsunknown{is}{}\\{}
\quad\quad \Melse  \;\Mif  \;\tsunknown{linux\_arch} \;\tsvar{arch} \Mwedge  \tscon{SO\_REUSEADDR} \;\in  \;\tsvar{sf}.\tsunknown{b} \Mwedge  \tscon{SO\_REUSEADDR} \;\in  \;\tsvar{s}.\tsvar{sf}.\tsunknown{b} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad ((\exists \tsunknown{tcp\_sock}. \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = \tsvar{s}.\tsvar{pr} \Mwedge  \neg{}(\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{LISTEN})) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad \exists \tsunknown{udp\_sock}. \tscon{UDP\_PROTO}(\tsunknown{udp\_sock}) = \tsvar{s}.\tsvar{pr}) \Mthen {}\\{}
\quad\quad\quad \Mfalse  \tscomm{ If socket is not in LISTEN state or is a UDP socket can always rebind here }{}\\{}
\quad\quad \Melse  \;\Mif  \;\tsunknown{windows\_arch} \;\tsvar{arch} \Mwedge  \tscon{SO\_REUSEADDR} \;\in  \;\tsvar{sf}.\tsunknown{b} \;\Mthen {}\\{}
\quad\quad\quad \Mfalse  \tscomm{ can rebind any UDP address; not sure about TCP - assume the same for now }{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad (\tsunknown{is} = * \Mvee  \tsvar{s}.\tsvar{is}_{1} = * \Mvee  (\exists \tsvar{i}:\tsvar{ip}. \tsunknown{is} = \Msome  \;\tsvar{i} \Mwedge  \tsvar{s}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}))) \}}
}
{\rulesubsection{Description}
   This determines whether binding a socket (of protocol $\tsvar{pr}$) to local address $\tsunknown{is},\tsvar{p}$ is
   permitted, by considering the other bound sockets on the host and the
   state of the sockets' $\tscon{SO\_REUSEADDR}$ flags.
   Note: SB believes this definition is correct for TCP and UDP on BSD
   and Linux through exhaustive manual verification.
   Note: WinXP is still to be checked.

\rrulepad }
}

\newcommand{\defnautobind}{\ddefnc{autobind}{\iA{autobind}}{\subddefnA[{ set of ports available for autobinding }]{autobind}{\tsaux{autobind}(\Msome  \;\tsvar{p},\tsunknown{\_},\tsunknown{\_},\tsunknown{\_}) = \{\tsvar{p}\} \Mwedge {}\\{}
 \tsaux{autobind}(*,\tsvar{pr},\tsunknown{h},\tsvar{socks}) = (\tsaux{ephemeral\_ports} \;\tsunknown{h}) \tsholop{DIFF} (\tsaux{bound\_ports\_protocol\_autobind} \;\tsvar{pr} \;\tsvar{socks})}
}
{\rulesubsection{Description}
Note that $\tscon{SO\_REUSEADDR}$ is not considered when choosing a port to
autobind to.


\rrulepad }
}

\newcommand{\defnboundTafter}{\ddefnc{boundTafter}{\iA{bound\_after}}{\subddefnA[{ was $\tsunknown{sid}$ bound more recently than $\tsunknown{sid'}$? }]{bound\_after}{\tsaux{bound\_after} \;\tsunknown{sid} \;\tsunknown{sid'} [\,] = \tsunknown{ASSERTION\_FAILURE} \text{``bound\textunderscore{}after''} \tscomm{ should never reach this case } \Mwedge {}\\{}
 \tsaux{bound\_after} \;\tsunknown{sid} \;\tsunknown{sid'} (\tsunknown{sid0}\Mcons \tsvar{bound}) ={}\\{}
 \Mif  \;\tsunknown{sid} = \tsunknown{sid0} \;\Mthen  \;\Mtrue   \tscomm{ newly-bound sockets are added to the head }{}\\{}
 \Melse  \;\Mif  \;\tsunknown{sid'} = \tsunknown{sid0} \;\Mthen  \;\Mfalse {}\\{}
\quad \Melse  \;\tsaux{bound\_after} \;\tsunknown{sid} \;\tsunknown{sid'} \;\tsvar{bound}}
}
{}
}

\newcommand{\defnmatchTscore}{\ddefnc{matchTscore}{\iA{match\_score}}{\subddefnA[{ score the match against the given pattern of the given quadruple }]{match\_score}{(\tsaux{match\_score} (\tsunknown{\_},*,\tsunknown{\_},\tsunknown{\_}) \tsunknown{\_} = 0n) \Mwedge {}\\{}
 (\tsaux{match\_score} (*, \Msome  \;\tsvar{p}_{1}, *, *) (\tsvar{i}_{3},\tsunknown{ps3},\tsvar{i}_{4},\tsunknown{ps4}) ={}\\{}
\quad \Mif  \;\tsunknown{ps4} = \Msome  \;\tsvar{p}_{1} \;\Mthen  \;1 \;\Melse  \;0) \Mwedge {}\\{}
 (\tsaux{match\_score} (\Msome  \;\tsvar{i}_{1}, \Msome  \;\tsvar{p}_{1}, *, *) (\tsvar{i}_{3},\tsunknown{ps3},\tsvar{i}_{4},\tsunknown{ps4}) ={}\\{}
\quad \Mif  (\tsvar{i}_{1} = \tsvar{i}_{4}) \Mwedge  (\Msome  \;\tsvar{p}_{1} = \tsunknown{ps4}) \Mthen  \;2 \;\Melse  \;0) \Mwedge {}\\{}
 (\tsaux{match\_score} (\Msome  \;\tsvar{i}_{1}, \Msome  \;\tsvar{p}_{1}, \Msome  \;\tsvar{i}_{2}, *) (\tsvar{i}_{3},\tsunknown{ps3},\tsvar{i}_{4},\tsunknown{ps4}) ={}\\{}
\quad \Mif  (\tsvar{i}_{2} = \tsvar{i}_{3}) \Mwedge  (\tsvar{i}_{1} = \tsvar{i}_{4}) \Mwedge  (\Msome  \;\tsvar{p}_{1} = \tsunknown{ps4}) \Mthen  \;3 \;\Melse  \;0) \Mwedge {}\\{}
 (\tsaux{match\_score} (\Msome  \;\tsvar{i}_{1}, \Msome  \;\tsvar{p}_{1}, \Msome  \;\tsvar{i}_{2}, \Msome  \;\tsvar{p}_{2}) (\tsvar{i}_{3},\tsunknown{ps3},\tsvar{i}_{4},\tsunknown{ps4}) ={}\\{}
\quad \Mif  (\Msome  \;\tsvar{p}_{2} = \tsunknown{ps3}) \Mwedge  (\tsvar{i}_{2} = \tsvar{i}_{3}) \Mwedge  (\tsvar{i}_{1} = \tsvar{i}_{4}) \Mwedge  (\Msome  \;\tsvar{p}_{1} = \tsunknown{ps4}) \Mthen  \;4{}\\{}
\quad \Melse  \;0)}
}
{\rulesubsection{Description}
These two functions are used to match an incoming UDP datagram to a
socket. The $\tsaux{bound\_after}$ function returns $\Mtrue $ if the socket
$\tsunknown{sid}$ (the first agrument) was bound after the socket $\tsunknown{sid'}$ (the
second argument) according to a list of bound sockets (the third
argument).

The $\tsaux{match\_score}$ function gives a score specifying how closely two
address quads, one from a socket and one from a datagram, correspond;
a higher score indicates a more specific match.


\rrulepad }
}

\newcommand{\defnlookupTudp}{\ddefnc{lookupTudp}{\iA{lookup\_udp}}{\subddefnA[{ the set of sockets matching an address quad, for UDP }]{lookup\_udp}{\tsaux{lookup\_udp} \;\tsvar{socks} \;\tsunknown{quad} \;\tsvar{bound} \;\tsvar{arch} ={}\\{}
\quad\quad\quad \{ \tsunknown{sid} \mid  \tsunknown{sid} \;\in  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mlet  \;\tsunknown{s} = \tsvar{socks} \Mfapply{}{\tsunknown{sid}} \Min {}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mlet  \;\tsunknown{sn} = \tsaux{match\_score} (\tsunknown{s}.\tsvar{is}_{1},\tsunknown{s}.\tsvar{ps}_{1},\tsunknown{s}.\tsvar{is}_{2},\tsunknown{s}.\tsvar{ps}_{2}) \tsunknown{quad} \;\Min {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{sn} > 0 \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mif  \;\tsunknown{windows\_arch} \;\tsvar{arch}  \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mif  \;\tsunknown{sn} = 1 \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \neg{}(\exists  (\tsunknown{sid'},\tsunknown{s'}) \Mcons  (\tsvar{socks} \backslash{}\backslash{} \tsunknown{sid}). \tsaux{match\_score} (\tsunknown{s'}.\tsvar{is}_{1},\tsunknown{s'}.\tsvar{ps}_{1},\tsunknown{s'}.\tsvar{is}_{2},\tsunknown{s'}.\tsvar{ps}_{2}) \tsunknown{quad} > \tsunknown{sn}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mtrue {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \neg{}(\exists (\tsunknown{sid'},\tsunknown{s'}) \Mcons  (\tsvar{socks} \backslash{}\backslash{} \tsunknown{sid}).{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsaux{match\_score} (\tsunknown{s'}.\tsvar{is}_{1},\tsunknown{s'}.\tsvar{ps}_{1},\tsunknown{s'}.\tsvar{is}_{2},\tsunknown{s'}.\tsvar{ps}_{2}) \tsunknown{quad} > \tsunknown{sn} \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsunknown{linux\_arch} \;\tsvar{arch} \Mwedge  \tsaux{match\_score} (\tsunknown{s'}.\tsvar{is}_{1},\tsunknown{s'}.\tsvar{ps}_{1},\tsunknown{s'}.\tsvar{is}_{2},\tsunknown{s'}.\tsvar{ps}_{2}) \tsunknown{quad} = \tsunknown{sn} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{bound\_after} \;\tsunknown{sid'} \;\tsunknown{sid} \;\tsvar{bound}))) \}}
}
{\rulesubsection{Description}
This function returns a set of UDP sockets which the datagram with
address quad $\tsunknown{quad}$ may be delivered to. For FreeBSD and Linux there
is only one such socket; for WinXP there may be multiple.

For each socket in the finite map of sockets $\tsvar{socks}$, the score,
$\tsunknown{sn}$, of the matching of the socket's address quad and $\tsunknown{quad}$ is
computed using \ltslink{matchTscore}{$\tsaux{match\_score}$}.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
For FreeBSD, the set contains the sockets for which  the score is greater than zero and there is no other
socket in $\tsvar{socks}$ with a higher score.

\\\hline
Linux
&
For Linux, the set contains the sockets for which the score is greater than zero, there are no sockets
with a higher score, and the socket was bound to its local port after
all the other sockets with the same score.

\\\hline
WinXP
&
For WinXP, the set contains all the sockets with score greater than one and also the sockets for which the score is one, $\tsunknown{sn}=1$, and there are no sockets
with greater scores.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\defntcpTsocketTbestTmatch}{\ddefnc{tcpTsocketTbestTmatch}{\iA{tcp\_socket\_best\_match}}{\subddefnA[{ the set of sockets matching a quad, for TCP }]{tcp\_socket\_best\_match}{\tsaux{tcp\_socket\_best\_match} (\tsvar{socks} : \tsunknown{sid} \mapsto  \tstype{socket}) (\tsunknown{sid},\tsunknown{sock}) (\tsunknown{seg} : \tsunknown{tcpSegment}) \tsvar{arch} ={}\\{}
 \tscomm{ is the socket sid the best match for segment seg? }{}\\{}
 \Mlet  \;\tsunknown{s} = \tsunknown{sock} \;\Min {}\\{}
 \Mlet  \;\tsunknown{score} = \tsaux{match\_score} (\tsunknown{s}.\tsvar{is}_{1}, \tsunknown{s}.\tsvar{ps}_{1}, \tsunknown{s}.\tsvar{is}_{2}, \tsunknown{s}.\tsvar{ps}_{2}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsholop{THE} \;\tsunknown{seg}.\tsvar{is}_{1}, \tsunknown{seg}.\tsvar{ps}_{1}, \tsholop{THE} \;\tsunknown{seg}.\tsvar{is}_{2}, \tsunknown{seg}.\tsvar{ps}_{2}) \Min {}\\{}
 \neg{}(\exists (\tsunknown{sid'},\tsunknown{s'}) \Mcons  \tsvar{socks} \backslash{}\backslash{} \tsunknown{sid}.{}\\{}
\quad\quad\quad\quad\quad \tsaux{match\_score} (\tsunknown{s'}.\tsvar{is}_{1}, \tsunknown{s'}.\tsvar{ps}_{1}, \tsunknown{s'}.\tsvar{is}_{2}, \tsunknown{s'}.\tsvar{ps}_{2}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsholop{THE} \;\tsunknown{seg}.\tsvar{is}_{1}, \tsunknown{seg}.\tsvar{ps}_{1}, \tsholop{THE} \;\tsunknown{seg}.\tsvar{is}_{2}, \tsunknown{seg}.\tsvar{ps}_{2}) > \tsunknown{score})}
}
{\rulesubsection{Description}
 This function determines whether a given socket $\tsunknown{sid}$ is the best match for a
 received TCP segment $\tsunknown{seg}$.

 The score (obtained using \ltslink{matchTscore}{$\tsaux{match\_score}$}) for the given
 socket is determined, and compared with the score for each other
 socket in $\tsvar{socks}$.  If none have a greater score, this is the best
 match and true is returned; otherwise, false is returned.


\rrulepad }
}

\newcommand{\defnlookupTicmp}{\ddefnc{lookupTicmp}{\iA{lookup\_icmp}}{\subddefnA[{ the set of sockets matching a quad, for ICMP }]{lookup\_icmp}{\tsaux{lookup\_icmp} \;\tsvar{socks} \;\tsunknown{icmp} \;\tsvar{arch} \;\tsvar{bound} ={}\\{}
\quad \{ \tsunknown{sid0} \mid  \exists  (\tsunknown{sid},\tsunknown{sock}) \Mcons  \tsvar{socks}.{}\\{}
\quad\quad\quad\quad\quad \tsunknown{sock}.\tsvar{ps}_{1} = \tsunknown{icmp}.\tsunknown{ps3} \Mwedge  \tsaux{proto\_of} \;\tsunknown{sock}.\tsvar{pr} = \tsunknown{icmp}.\tsunknown{proto} \Mwedge  \tsunknown{sid0} = \tsunknown{sid} \Mwedge {}\\{}
\quad\quad\quad\quad\quad \Mif  \;\tsunknown{windows\_arch} \;\tsvar{arch} \;\Mthen  \;\Mtrue {}\\{}
\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsunknown{sock}.\tsvar{is}_{1} = \tsunknown{icmp}.\tsunknown{is3} \Mwedge  \tsunknown{sock}.\tsvar{is}_{2} = \tsunknown{icmp}.\tsunknown{is4} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad (\tsunknown{sock}.\tsvar{ps}_{2} = \tsunknown{icmp}.\tsunknown{ps4} \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad (\tsunknown{linux\_arch} \;\tsvar{arch} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{proto\_of} \;\tsunknown{sock}.\tsvar{pr} = \tsunknown{PROTO\_UDP} \Mwedge  \tsunknown{sock}.\tsvar{ps}_{2} = * \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \neg{}(\exists  (\tsunknown{sid'},\tsunknown{s}) \Mcons  (\tsvar{socks} \backslash{}\backslash{} \tsunknown{sid}).{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{1} = \tsunknown{icmp}.\tsunknown{is3} \Mwedge  \tsunknown{s}.\tsvar{is}_{2} = \tsunknown{icmp}.\tsunknown{is4} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{s}.\tsvar{ps}_{1} = \tsunknown{icmp}.\tsunknown{ps3} \Mwedge  \tsunknown{s}.\tsvar{ps}_{2} = \tsunknown{icmp}.\tsunknown{ps4} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{proto\_of} \;\tsunknown{s}.\tsvar{pr} = \tsunknown{icmp}.\tsunknown{proto} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{bound\_after} \;\tsunknown{sid'} \;\tsunknown{sid} \;\tsvar{bound}){}\\{}
\quad\quad\quad\quad\quad\quad\quad )) \}}
}
{\rulesubsection{Description}

  This function returns the set of sockets matching a received ICMP
  datagram $\tsunknown{icmp}$.

  An ICMP datagram contains the initial portion of the header of the
  original message to which it is a response.  For a socket to match,
  it must at least be bound to the same port and protocol as the
  source of the original message.  Beyond this, architectures differ.
  Usually, the socket must be connected, and connected to the same
  port as the original destination; and the source and destination IP
  addresses must agree.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
  For Windows, the socket need not be connected, and the source and
  destination IP addresses need not agree; an ICMP is delivered to
  one socket bound to the same port and protocol as the original
  source.

\\\hline
Linux
&
  For Linux, UDP ICMPs may also be delivered to unconnected sockets,
  as long as no matching connected socket was bound more recently than
  that socket.

\\\hline
FreeBSD
&
  For FreeBSD, the behaviour is as described above.



\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommmiscTaux}{\clustersection{(TCP only)}{TCP Options}
\seccomm{
TCP option handling.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{do\_tcp\_options}$
&
&  Constrain the TCP timestamp option values that appear in an outgoing segment \\
$\tsrule{calculate\_tcp\_options\_len}$
&
&  Calculate the length consumed by the TCP options in a real TCP segment \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defndoTtcpToptions}{\ddefnn{doTtcpToptions}{\iA{do\_tcp\_options}}{\subddefnA[{ Constrain the TCP timestamp option values that appear in an outgoing segment }]{do\_tcp\_options}{\tsaux{do\_tcp\_options} \;\tsunknown{cb\_tf\_doing\_tstmp} \;\tsunknown{cb\_ts\_recent} \;\tsunknown{cb\_ts\_val}  ={}\\{}
 \Mif  \;\tsunknown{cb\_tf\_doing\_tstmp} \;\Mthen {}\\{}
\quad \Mlet  \;\tsunknown{ts\_ecr'} = \tsholop{option\_case}\Mspiii{(\tsunknown{ts\_seq} \;0w)}{\MI }{(\tsunknown{timewindow\_val\_of} \;\tsunknown{cb\_ts\_recent})} \Min {}\\{}
\quad\quad\quad \Msome (\tsunknown{cb\_ts\_val},\tsunknown{ts\_ecr'}){}\\{}
 \Melse {}\\{}
\quad\quad *}
}
{}
}

\newcommand{\defncalculateTtcpToptionsTlen}{\ddefnc{calculateTtcpToptionsTlen}{\iA{calculate\_tcp\_options\_len}}{\subddefnA[{ Calculate the length consumed by the TCP options in a real TCP segment }]{calculate\_tcp\_options\_len}{\tsaux{calculate\_tcp\_options\_len} \;\tsunknown{cb\_tf\_doing\_tstmp} ={}\\{}
 \Mif  \;\tsunknown{cb\_tf\_doing\_tstmp} \;\Mthen  \;12 \;\Melse  \;0 : \tstype{num}}
}
{\rulesubsection{Description}
This calculation omits
   window-scaling and mss options as these only appear in SYN segments during connection setup.
%
   The total length consumed by all options will always be a multiple of 4 bytes due to padding.
   If more TCP options were added to the model, the space consumed by options would be
   architecture/options/alignment/padding dependent.

\rrulepad }
}

\newcommand{\seccommauxTbuffers}{\clustersection{(TCP and UDP)}{Buffers, windows, and queues}
\seccomm{
Various functions that compute buffer sizes, window sizes, and
remaining send queue space.  Some of these computations are
architecture-specific.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{calculate\_buf\_sizes}$
&
&  Calculate buffer sizes for $\tsunknown{rcvbufsize}$, $\tsunknown{sndbufsize}$, $\tsunknown{t\_maxseg}$, and $\tsunknown{snd\_cwnd}$
\\
$\tsrule{send\_queue\_space}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defncalculateTbufTsizes}{\ddefnc{calculateTbufTsizes}{\iA{calculate\_buf\_sizes}}{\subddefnA[{ Calculate buffer sizes for $\tsunknown{rcvbufsize}$, $\tsunknown{sndbufsize}$, $\tsunknown{t\_maxseg}$, and $\tsunknown{snd\_cwnd}$
}]{calculate\_buf\_sizes}{\tsaux{calculate\_buf\_sizes} \;\tsunknown{cb\_t\_maxseg} \;\tsunknown{seg\_mss} \;\tsunknown{bw\_delay\_product\_for\_rt} \;\tsunknown{is\_local\_conn}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{rcvbufsize} \;\tsunknown{sndbufsize} \;\tsunknown{cb\_tf\_doing\_tstmp} \;\tsvar{arch} ={}\\{}
 {}\\{}
 \Mlet  \;\tsunknown{t\_maxseg'} ={}\\{}
 \tsholcomm{ TCPv2p901 claims min 32 for "sanity"; FreeBSD4.6 has 64 in \wasverb{tcp\textunderscore{}mss()}.
         BSD has the route MTU if avail, or $\tsholop{MIN} \;\tsunknown{MSSDFLT} (\tsunknown{link} \;\tsunknown{MTU})$ otherwise, as the first argument
         of the MIN below.  That is the same calculation as we did in $\tsunknown{connect\_1}$. We don't repeat it,
         but use the cached value in $\tsvar{cb}.\tsunknown{t\_maxseg}$. }{}\\{}
 \Mlet  \;\tsunknown{maxseg} = (\tsholop{MIN} \;\tsunknown{cb\_t\_maxseg} (\tsholop{MAX} \;64 (\tsholop{option\_case}\Mspiii{\tsunknown{MSSDFLT}}{\MI }{\tsunknown{seg\_mss}}))) \Min {}\\{}
\quad\quad \Mif  \;\tsunknown{linux\_arch} \;\tsvar{arch} \;\Mthen {}\\{}
\quad\quad\quad \tsunknown{maxseg}{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad \tsholcomm{ BSD subtracts the size consumed by options in the TCP
            header post connection establishment. The WinXP and Linux
            behaviour has not been fully tested but it appears Linux
            does not do this and WinXP does. }{}\\{}
\quad\quad\quad \tsunknown{maxseg} - (\tsaux{calculate\_tcp\_options\_len} \;\tsunknown{cb\_tf\_doing\_tstmp}){}\\{}
 \Min {}\\{}
 \tsholcomm{ round down to multiple of cluster size if larger (as BSD).
    From BSD code; assuming true for WinXP for now }{}\\{}
 \Mlet  \;\tsunknown{t\_maxseg''} = \Mif  \;\tsunknown{linux\_arch} \;\tsvar{arch} \;\Mthen  \;\tsunknown{t\_maxseg'}  \tscomm{ from tests }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsunknown{rounddown} \;\tsunknown{MCLBYTES} \;\tsunknown{t\_maxseg'} \;\Min {}\\{}
 {}\\{}
 \tscomm{ buffootle: rcv }{}\\{}
 \Mlet  \;\tsunknown{rcvbufsize'} = \tsholop{option\_case}\Mspiii{\tsunknown{rcvbufsize}}{\MI }{\tsunknown{bw\_delay\_product\_for\_rt}} \Min {}\\{}
 \Mlet  (\tsunknown{rcvbufsize''},\tsunknown{t\_maxseg'''}) = (\Mif  \;\tsunknown{rcvbufsize'} < \tsunknown{t\_maxseg''}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mthen  (\tsunknown{rcvbufsize'},\tsunknown{rcvbufsize'}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  (\tsholop{MIN} \;\tsunknown{SB\_MAX} (\tsunknown{roundup} \;\tsunknown{t\_maxseg''} \;\tsunknown{rcvbufsize'}),{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{t\_maxseg''})) \Min {}\\{}
 {}\\{}
 \tscomm{ buffootle: snd }{}\\{}
 \Mlet  \;\tsunknown{sndbufsize'} = \tsholop{option\_case}\Mspiii{\tsunknown{sndbufsize}}{\MI }{\tsunknown{bw\_delay\_product\_for\_rt}} \Min {}\\{}
 \Mlet  \;\tsunknown{sndbufsize''} = (\Mif  \;\tsunknown{sndbufsize'} < \tsunknown{t\_maxseg'''}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mthen  \;\tsunknown{sndbufsize'}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsholop{MIN} \;\tsunknown{SB\_MAX} (\tsunknown{roundup} \;\tsunknown{t\_maxseg''} \;\tsunknown{sndbufsize'})) \Min {}\\{}
 {}\\{}
 \Mlet  \;\tsunknown{do\_rfc3390} = \Mtrue  \;\Min  \tscomm{ FIXME }{}\\{}
 {}\\{}
 \tscomm{ compute initial cwnd }{}\\{}
 \Mlet  \;\tsunknown{snd\_cwnd} ={}\\{}
 \Mif  \;\tsunknown{do\_rfc3390} \;\Mthen  \;\tsholop{MIN} (4 * \tsunknown{t\_maxseg'''}) (\tsholop{MAX} (2 * \tsunknown{t\_maxseg'''}) 4380){}\\{}
 \Melse {}\\{}
\quad (\tsunknown{t\_maxseg'''} * (\Mif  \;\tsunknown{is\_local\_conn} \;\Mthen  \;\tsunknown{SS\_FLTSZ\_LOCAL} \;\Melse  \;\tsunknown{SS\_FLTSZ})) \Min {}\\{}
 (\tsunknown{rcvbufsize''},\tsunknown{sndbufsize''},\tsunknown{t\_maxseg'''},\tsunknown{snd\_cwnd})}
}
{\rulesubsection{Description}
Used in $\tsunknown{deliver\_in\_1}$ and $\tsunknown{deliver\_in\_2}$.
\rrulepad }
}

\newcommand{\defnsendTqueueTspace}{\ddefnc{sendTqueueTspace}{\iA{send\_queue\_space}}{\subddefnA{send\_queue\_space}{\tsaux{send\_queue\_space} (\tsunknown{sndq\_max} : \tstype{num}) \tsunknown{sndq\_size} \;\tsunknown{oob} \;\tsvar{arch} \;\tsunknown{maxseg} \;\tsvar{i}_{2} ={}\\{}
\quad \{ \tsunknown{n} \mid  \Mif  \;\tsunknown{bsd\_arch} \;\tsvar{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \tsunknown{n} \leq  (\tsunknown{sndq\_max} - \tsunknown{sndq\_size}) + (\Mif  \;\tsunknown{oob} \;\Mthen  \;\tsunknown{oob\_extra\_sndbuf} \;\Melse  \;0){}\\{}
\quad\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{linux\_arch} \;\tsvar{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad (\Mif  \;\tsunknown{in\_loopback} \;\tsvar{i}_{2} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{n} = \tsunknown{maxseg} + ((\tsunknown{sndq\_max} - \tsunknown{sndq\_size}) \tsholop{DIV} \;16816) * \tsunknown{maxseg}{}\\{}
\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{n} = (2 * \tsunknown{maxseg}) + ((\tsunknown{sndq\_max} - \tsunknown{sndq\_size} - 1890) \tsholop{DIV} \;1888) * \tsunknown{maxseg}){}\\{}
\quad\quad\quad\quad \Melse  \;\tsunknown{n} \geq  0 \}}
}
{\rulesubsection{Description}
   Calculation of the usable send queue space.

   FreeBSD calculates send buffer space based on the byte-count size and
   max, and the number and max of mbufs. As we do not model mbuf usage precisely we are somewhat nondeterministic
   here.

   Linux calculates it based on the MSS: the space is some multiple of
   the MSS; the number of bytes for each MSS-sized segment is the
   MSS+overhead where overhead is 420+(20 if using IP), which is why
   the i2 argument is needed.

   Windows is very strange.  Leaving it completely unconstrained is not
   what actually happens, but more investigation is needed in future to determine the actual behaviour.


\rrulepad }
}

\newcommand{\seccommauxTbandlim}{\clustersection{(TCP and UDP)}{Band limiting}
\seccomm{
The rate of emission of certain TCP and ICMP responses from a host is
often controlled by a bandwidth limiter.  This limits resource usage
in the event of some error conditions, and also defends against
certain denial-of-service attacks.

Responses that may be bandlimited are grouped into categories
($\tsunknown{bandlim\_reason}$), and bandlimiting is applied to each category
separately.  Bandlimiting is applied across the entire host, not per
socket or process.  There are a range of different schemes that may be
used, from none at all, through limiting the number of packets in any
given second, to a decaying average tuned to limit bursts and
sustained throughput differently.  We provide specifications for the
first two.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{bandlim\_state\_init}$
&
&  initial state of bandlimiter \\
$\tsrule{bandlim\_rst\_ok\_always}$
&
&  the trivial 'always OK' bandlimiter \\
$\tsrule{simple\_limit}$
&
&  simple-bandlimiter rate settings \\
$\tsrule{bandlim\_rst\_ok\_simple}$
&
&  a simple rate-limiting bandlimiter \\
$\tsrule{bandlim\_rst\_ok}$
&
&  the bandlimiter actually used \\
$\tsrule{enqueue\_oq\_bndlim\_rst}$
&
&  enqueue onto out-queue if allowed by bandlimiter \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnbandlimTstateTinit}{\ddefnc{bandlimTstateTinit}{\iA{bandlim\_state\_init}}{\subddefnA[{ initial state of bandlimiter }]{bandlim\_state\_init}{\tsaux{bandlim\_state\_init} = [\,] : \tsunknown{bandlim\_state}}
}
{}
}

\newcommand{\defnbandlimTrstTokTalways}{\ddefnc{bandlimTrstTokTalways}{\iA{bandlim\_rst\_ok\_always}}{\subddefnA[{ the trivial 'always OK' bandlimiter }]{bandlim\_rst\_ok\_always}{(\tsaux{bandlim\_rst\_ok\_always} : \tsunknown{tcpSegment} \# \tsunknown{ts\_seq} \# \tsunknown{bandlim\_reason} \# \tsunknown{bandlim\_state} \Mtotype  \tstype{bool} \# \tsunknown{bandlim\_state}){}\\{}
\quad (\tsunknown{seg},\tsvar{ticks},\tsunknown{reason},\tsvar{bndlm}){}\\{}
\quad = \Mlet  \;\tsvar{bndlm}' = (\tsunknown{seg},\tsvar{ticks},\tsunknown{reason})\Mcons \tsvar{bndlm}{}\\{}
\quad\quad \Min {}\\{}
\quad\quad (\Mtrue ,\tsvar{bndlm}')}
}
{}
}

\newcommand{\defnsimpleTlimit}{\ddefnc{simpleTlimit}{\iA{simple\_limit}}{\subddefnA[{ simple-bandlimiter rate settings }]{simple\_limit}{(\tsaux{simple\_limit} : \tsunknown{bandlim\_reason} \Mtotype  \tstype{num} \;\;\tstype{option}){}\\{}
\quad\quad\quad\quad\quad \tscon{BANDLIM\_UNLIMITED}      = * \Mwedge {}\\{}
 \tsaux{simple\_limit} \;\tscon{BANDLIM\_RST\_CLOSEDPORT} = \Msome  \;200 \Mwedge {}\\{}
 \tsaux{simple\_limit} \;\tscon{BANDLIM\_RST\_OPENPORT}   = \Msome  \;200}
}
{}
}

\newcommand{\defnbandlimTrstTokTsimple}{\ddefnc{bandlimTrstTokTsimple}{\iA{bandlim\_rst\_ok\_simple}}{\subddefnA[{ a simple rate-limiting bandlimiter }]{bandlim\_rst\_ok\_simple}{(\tsaux{bandlim\_rst\_ok\_simple} : \tsunknown{tcpSegment} \# \tsunknown{ts\_seq} \# \tsunknown{bandlim\_reason} \# \tsunknown{bandlim\_state} \Mtotype  \tstype{bool} \# \tsunknown{bandlim\_state}){}\\{}
\quad\quad\quad\quad\quad\quad (\tsunknown{seg},\tsvar{ticks},\tsunknown{reason},\tsvar{bndlm}){}\\{}
 = \Mlet  \;\tsunknown{reasoneq} = (\lambda  \tsvar{r}_{0}. \lambda  (\tsunknown{s},\tsunknown{t},\tsunknown{r}). \tsunknown{r} = \tsvar{r}_{0}){}\\{}
\quad \Mand  \;\tsunknown{ticksgt}  = (\lambda  \tsvar{t}_{0}. \lambda  (\tsunknown{s},\tsunknown{t},\tsunknown{r}). \tsunknown{t} > \tsvar{t}_{0}){}\\{}
\quad \Min {}\\{}
\quad \Mlet  \;\tsunknown{count} = \tsholop{LENGTH} (\tsholop{FILTER} (\tsunknown{reasoneq} \;\tsunknown{reason}) (\tsunknown{TAKEWHILE} (\tsunknown{ticksgt} (\tsvar{ticks} - \tsunknown{num\_floor} (1 * \tsunknown{HZ}))) \tsvar{bndlm})){}\\{}
\quad \Min {}\\{}
\quad ((\Mcase  \;\tsaux{simple\_limit} \;\tsunknown{reason} \;\Mof {}\\{}
\quad\quad\quad *   \Mtotype  \Mtrue {}\\{}
\quad\quad \Mdpipe  \Msome  \;\tsunknown{n} \Mtotype  \tsunknown{count} < \tsunknown{n}),{}\\{}
\quad (\tsunknown{seg},\tsvar{ticks},\tsunknown{reason})\Mcons \tsvar{bndlm})}
}
{\rulesubsection{Description}
 Simple bandlimiter: limit number of ICMPs in the last second to the listed value.  This is based roughly on the BSD behaviour, save that for BSD it is "since the
   last second" not "in the last second".

\rrulepad }
}

\newcommand{\defnbandlimTrstTok}{\ddefnc{bandlimTrstTok}{\iA{bandlim\_rst\_ok}}{\subddefnA[{ the bandlimiter actually used }]{bandlim\_rst\_ok}{\tsaux{bandlim\_rst\_ok} = \tsaux{bandlim\_rst\_ok\_simple}}
}
{\rulesubsection{Description}
 Which band limiter to use?

\rrulepad }
}

\newcommand{\defnenqueueToqTbndlimTrst}{\ddefnc{enqueueToqTbndlimTrst}{\iA{enqueue\_oq\_bndlim\_rst}}{\subddefnA[{ enqueue onto out-queue if allowed by bandlimiter }]{enqueue\_oq\_bndlim\_rst}{\tsaux{enqueue\_oq\_bndlim\_rst}(\tsvar{oq},\tsunknown{seg},\tsvar{ticks},\tsunknown{reason},\tsvar{bndlm},\tsvar{oq}',\tsvar{bndlm}',\tsunknown{queued\_or\_dropped}){}\\{}
 = \Mlet  (\tsunknown{emit},\tsvar{bndlm}_{0}) = \tsaux{bandlim\_rst\_ok}(\tsunknown{seg},\tsvar{ticks},\tsunknown{reason},\tsvar{bndlm}){}\\{}
 \Min {}\\{}
 \tsvar{bndlm}' = \tsvar{bndlm}_{0} \Mwedge {}\\{}
 \Mif  \;\tsunknown{emit} \;\Mthen {}\\{}
\quad \tsunknown{enqueue\_oq}(\tsvar{oq},\tsunknown{TCP} \;\tsunknown{seg},\tsvar{oq}',\tsunknown{queued\_or\_dropped}){}\\{}
 \Melse {}\\{}
\quad (\tsvar{oq}' = \tsvar{oq} \Mwedge  \tsunknown{queued\_or\_dropped} = \Mtrue )}
}
{\rulesubsection{Description}
For convenience, combine enqueueing and bandlimiting into a single function.


\rrulepad }
}

\newcommand{\seccommauxTudp}{\clustersection{(UDP only)}{UDP support}
\seccomm{
Performing a UDP send, filling in required details as necessary.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{dosend}$
&
&  do a UDP send, filling in source address and port as necessary \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defndosend}{\ddefnc{dosend}{\iA{dosend}}{\subddefnA[{ do a UDP send, filling in source address and port as necessary }]{dosend}{(\tsaux{dosend} (\tsvar{ifds}, \tsvar{rttab}, (*, \tsvar{data}), (\Msome  \;\tsvar{i}_{1}, \Msome  \;\tsvar{p}_{1}, \Msome  \;\tsvar{i}_{2}, \tsvar{ps}_{2}), \tsvar{oq}, \tsvar{oq}', \tsunknown{ok}) ={}\\{}
 \tsunknown{enqueue\_oq}(\tsvar{oq},\tsunknown{UDP}(\Mmagiclrec  \tsvar{is}_{1} \Mass  \Msome  \;\tsvar{i}_{1}; \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}_{1}; \tsvar{ps}_{2} \Mass  \tsvar{ps}_{2};{}\\{}
 \tsvar{data} \Mass  \tsvar{data} \Mmagicrrec ),{}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{oq}',\tsunknown{ok})) \Mwedge {}\\{}
 (\tsaux{dosend} (\tsvar{ifds}, \tsvar{rttab}, (\Msome (\tsvar{i},\tsvar{p}), \tsvar{data}), (*, \Msome  \;\tsvar{p}_{1}, *, *), \tsvar{oq}, \tsvar{oq}', \tsunknown{ok}) ={}\\{}
 (\exists \tsvar{i}'_{1}.\tsunknown{enqueue\_oq}(\tsvar{oq},\tsunknown{UDP}(\Mmagiclrec  \tsvar{is}_{1} \Mass  \Msome  \;\tsvar{i}'_{1}; \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i};{}\\{}
 \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}_{1};  \tsvar{ps}_{2} \Mass  \Msome  \;\tsvar{p};{}\\{}
 \tsvar{data} \Mass  \tsvar{data} \Mmagicrrec ),{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{oq}',\tsunknown{ok}) \Mwedge  \tsvar{i}'_{1} \;\in  \;\tsunknown{auto\_outroute}(\tsvar{i},*,\tsvar{rttab},\tsvar{ifds}))) \Mwedge {}\\{}
 (\tsaux{dosend} (\tsvar{ifds}, \tsvar{rttab}, (\Msome (\tsvar{i},\tsvar{p}), \tsvar{data}),(\Msome  \;\tsvar{i}_{1}, \Msome  \;\tsvar{p}_{1}, \tsvar{is}_{2}, \tsvar{ps}_{2}), \tsvar{oq}, \tsvar{oq}', \tsunknown{ok}) ={}\\{}
 \tsunknown{enqueue\_oq}(\tsvar{oq},\tsunknown{UDP}(\Mmagiclrec  \tsvar{is}_{1} \Mass  \Msome  \;\tsvar{i}_{1}; \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i};{}\\{}
 \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}_{1}; \tsvar{ps}_{2} \Mass  \Msome  \;\tsvar{p};{}\\{}
 \tsvar{data} \Mass  \tsvar{data} \Mmagicrrec ),{}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{oq}',\tsunknown{ok}))}
}
{\rulesubsection{Description}
 For use in UDP $\tsunknown{sendto}()$.

\rrulepad }
}

\newcommand{\seccommauxTtcptime}{\clustersection{(TCP only)}{TCP timing and RTT}
\seccomm{
TCP performs repeated transmissions in three situations:
retransmission of unacknowledged data, retransmission of an
unacknowledged SYN, and probing a closed window (`persisting').  In
each case the interval between transmissions is a function of the
estimated round-trip time for the connection, and is exponentially
backed off if no response is received.  The RTT estimate indicates
when TCP should expect a reply, and the exponential backoff controls
TCP's resource usage.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{tcp\_backoffs}$
&
&  select this architecture's retransmit backoff list \\
$\tsrule{tcp\_syn\_backoffs}$
&
&  select this architecture's $\tsvar{SYN}$-retransmit backoff list \\
$\tsrule{shift\_of}$
&
&  obtain the shift of a backoff timer \\
$\tsrule{expand\_cwnd}$
&
&  expand congestion window \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntcpTbackoffs}{\ddefnc{tcpTbackoffs}{\iA{tcp\_backoffs}}{\subddefnA[{ select this architecture's retransmit backoff list }]{tcp\_backoffs}{\tsaux{tcp\_backoffs} (\tsvar{arch}: \tsvar{arch}) ={}\\{}
 \Mif  \;\tsunknown{bsd\_arch} \;\tsvar{arch} \;\Mthen  \;\tsunknown{TCP\_BSD\_BACKOFFS}{}\\{}
 \Melse  \;\Mif  \;\tsunknown{linux\_arch} \;\tsvar{arch} \;\Mthen  \;\tsunknown{TCP\_LINUX\_BACKOFFS}{}\\{}
 \Melse  \;\Mif  \;\tsunknown{windows\_arch} \;\tsvar{arch} \;\Mthen  \;\tsunknown{TCP\_WINXP\_BACKOFFS}{}\\{}
 \Melse  \;\tsunknown{TCP\_BSD\_BACKOFFS} \tscomm{ default to BSD }}
}
{}
}

\newcommand{\defntcpTsynTbackoffs}{\ddefnn{tcpTsynTbackoffs}{\iA{tcp\_syn\_backoffs}}{\subddefnA[{ select this architecture's $\tsvar{SYN}$-retransmit backoff list }]{tcp\_syn\_backoffs}{\tsaux{tcp\_syn\_backoffs} (\tsvar{arch}: \tsvar{arch}) ={}\\{}
 \Mif  \;\tsunknown{bsd\_arch} \;\tsvar{arch} \;\Mthen  \;\tsunknown{TCP\_SYN\_BSD\_BACKOFFS}{}\\{}
 \Melse  \;\Mif  \;\tsunknown{linux\_arch} \;\tsvar{arch} \;\Mthen  \;\tsunknown{TCP\_SYN\_LINUX\_BACKOFFS}{}\\{}
 \Melse  \;\Mif  \;\tsunknown{windows\_arch} \;\tsvar{arch} \;\Mthen  \;\tsunknown{TCP\_SYN\_WINXP\_BACKOFFS}{}\\{}
 \Melse  \;\tsunknown{TCP\_SYN\_BSD\_BACKOFFS} \tscomm{ default to BSD }}
}
{}
}

\newcommand{\defnshiftTof}{\ddefnc{shiftTof}{\iA{shift\_of}}{\subddefnA[{ obtain the shift of a backoff timer }]{shift\_of}{\tsaux{shift\_of} (\Msome  (\Mtimed{(\tsunknown{\_},\tsunknown{shift})}{\tsunknown{\_}})) = \tsunknown{shift}}
}
{\rulesubsection{Description}
 TCP exponential-backoff timers are represented as $(\tsunknown{rexmtmode} \# \tstype{num}) \tsunknown{timed} \;\;\tstype{option}$,
   where $\tsunknown{mode} : \tsunknown{rexmtmode}$ is the current TCP output mode (see \ltslink{rexmtmode}{$\tsunknown{rexmtmode}$}), and
   $\tsunknown{shift} : \tstype{num}$ is the 0-origin index into the backoff list of the
   interval \emph{currently underway}.

\rrulepad }
}

\newcommand{\defnexpandTcwnd}{\ddefnc{expandTcwnd}{\iA{expand\_cwnd}}{\subddefnA[{ expand congestion window }]{expand\_cwnd}{\tsaux{expand\_cwnd} \;\tsunknown{ssthresh} \;\tsunknown{maxseg} \;\tsunknown{maxwin} \;\tsunknown{cwnd}{}\\{}
 = \tsholop{MIN} \;\tsunknown{maxwin} (\tsunknown{cwnd} + (\Mif  \;\tsunknown{cwnd} > \tsunknown{ssthresh} \;\Mthen  (\tsunknown{maxseg} * \tsunknown{maxseg}) \tsholop{DIV} \;\tsunknown{cwnd} \;\Melse  \;\tsunknown{maxseg}))}
}
{\rulesubsection{Description}

 Congestion window expansion is linear or exponential depending on the
 current threshold $\tsunknown{ssthresh}$.


\rrulepad }
}

\newcommand{\seccommauxTpmtu}{\clustersection{(TCP only)}{Path MTU Discovery}
\seccomm{
For efficiency and reliability, it is best to send datagrams that do
not need to be fragmented in the network.  However, TCP has direct
access only to the maximum packet size (MTU) for the interfaces at
either end of the connection -- it has no information about routers
and links in between.

To determine the MTU for the entire path, TCP marks all datagrams `do
not fragment'.  It begins by sending a large datagram; if it receives
a `fragmentation needed' ICMP in return it reduces the size of the
datagram and repeats the process.  Most modern routers include the
link MTU in the ICMP message; if the message does not contain an MTU,
however, TCP uses the next lower MTU in the table below.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{next\_smaller}$
&
&  find next-smaller element of a set \\
$\tsrule{mtu\_tab}$
&
&  path MTU plateaus to try \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnnextTsmaller}{\ddefnc{nextTsmaller}{\iA{next\_smaller}}{\subddefnA[{ find next-smaller element of a set }]{next\_smaller}{(\tsaux{next\_smaller}:(\tstype{num}\Mtotype \tstype{bool}) \Mtotype  \tstype{num} \Mtotype  \tstype{num}) \tsvar{xs} \;\tsunknown{y} = @\tsvar{x}\Mcons \tsvar{xs}. \tsvar{x} < \tsunknown{y} \Mwedge  \forall \tsvar{x}'\Mcons \tsvar{xs}. \tsvar{x}' > \tsvar{x} \implies  \tsvar{x}' \geq  \tsunknown{y}}
}
{}
}

\newcommand{\defnmtuTtab}{\ddefnc{mtuTtab}{\iA{mtu\_tab}}{\subddefnA[{ path MTU plateaus to try }]{mtu\_tab}{\tsaux{mtu\_tab} \;\tsvar{arch} = \Mif  \;\tsunknown{linux\_arch} \;\tsvar{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \{32000; 17914; 8166; 4352; 2002; 1492; 576; 296; 216; 128; 68\} : \tstype{num} \;\tstype{set}{}\\{}
\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \{65535; 32000; 17914; 8166; 4352; 2002; 1492; 1006; 508; 296; 68\}}
}
{\rulesubsection{Description}
 MTUs to guess for path MTU discovery.  This table is from RFC1191,
   and is the one that appears in BSD.

   On \wasverb{comp.protocols.tcp-ip, Sun, 15 Feb 2004 01:38:26 -0000,
   \textless{}102tjcifv6vgm02@corp.supernews.com\textgreater{}, kml@bayarea.net (Kevin Lahey)}
   suggests that this is out-of-date, and 2312 (WiFi 802.11), 9180
   (common ATM), and 9000 (jumbo Ethernet) should be added.  For some
   polemic discussion, see \wasverb{http://www.psc.edu/\textasciitilde{}mathis/MTU/}.

   RFC1191 says explicitly "We do not expect that the values in the
   table [...] are going to be valid forever.  The values given here
   are an implementation suggestion, NOT a specification or
   requirement.  Implementors should use up-to-date references to pick
   a set of plateaus [...]".  BSD is therefore not compliant here.

   Linux adds 576, 216, 128 and drops 1006.  576 is used in X.25
   networks, and the source says 216 and 128 are needed for AMPRnet
   AX.25 paths.  1006 is used for SLIP, and was used on the ARPANET.
   Linux does not include the modern MTUs listed above.


\rrulepad }
}

\newcommand{\seccommauxTreass}{\clustersection{(TCP only)}{Reassembly}
\seccomm{
TCP segments may arrive out-of-order, leaving holes in the data
stream.  They may also overlap, due to retransmission, confusion, or
deliberate effort by an unusual TCP implementation.  The TCP
reassembly algorithm is responsible for retrieving the data stream
from the segments that arrive (note this is not to be confused with IP
fragmentation reassembly, which is beneath the scope of this
specification).

There are various ways of resolving overlaps; in this specification we
are completely nondeterministic, and allow any legal reassembly.


}\clustersubsection{Rules}
~}

\newcommand{\seccomminitialTcb}{\clustersection{(TCP only)}{The initial TCP control block}
\seccomm{
The initial state of the TCP control block.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{initial\_cb}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defninitialTcb}{\ddefnn{initialTcb}{\iA{initial\_cb}}{\subddefnA{initial\_cb}{\tsaux{initial\_cb} ={}\\{}
 \Mmagiclrec  \tslongcomm{ X t\textunderscore{}segq            := [];
       tt\textunderscore{}rexmt          := NONE; X }{}\\{}
 \tsfield{tt\_keep}           \Mass  *;{}\\{}
 \tslongcomm{ X tt\textunderscore{}2msl           := NONE;
       tt\textunderscore{}delack         := NONE;
       tt\textunderscore{}conn\textunderscore{}est       := NONE;
       tt\textunderscore{}fin\textunderscore{}wait\textunderscore{}2     := NONE;
       tf\textunderscore{}needfin        := F;
       tf\textunderscore{}shouldacknow   := F;
       snd\textunderscore{}una           := tcp\textunderscore{}seq\textunderscore{}local 0w;
       snd\textunderscore{}max           := tcp\textunderscore{}seq\textunderscore{}local 0w;
       snd\textunderscore{}nxt           := tcp\textunderscore{}seq\textunderscore{}local 0w;
       snd\textunderscore{}wl1           := tcp\textunderscore{}seq\textunderscore{}foreign 0w;
       snd\textunderscore{}wl2           := tcp\textunderscore{}seq\textunderscore{}local 0w;
       iss               := tcp\textunderscore{}seq\textunderscore{}local 0w;
       snd\textunderscore{}wnd           := 0;
       snd\textunderscore{}cwnd          := TCP\textunderscore{}MAXWIN \textless{}\textless{} TCP\textunderscore{}MAXWINSCALE;
       snd\textunderscore{}ssthresh      := TCP\textunderscore{}MAXWIN \textless{}\textless{} TCP\textunderscore{}MAXWINSCALE;
       rcv\textunderscore{}wnd           := 0;
       tf\textunderscore{}rxwin0sent     := F;
       rcv\textunderscore{}nxt           := tcp\textunderscore{}seq\textunderscore{}foreign 0w;
       rcv\textunderscore{}up            := tcp\textunderscore{}seq\textunderscore{}foreign 0w;
       irs               := tcp\textunderscore{}seq\textunderscore{}foreign 0w;
       rcv\textunderscore{}adv           := tcp\textunderscore{}seq\textunderscore{}foreign 0w;
       snd\textunderscore{}recover       := tcp\textunderscore{}seq\textunderscore{}local 0w;
       t\textunderscore{}maxseg          := MSSDFLT;
       t\textunderscore{}advmss          := NONE;
       t\textunderscore{}rttseg          := NONE;
       t\textunderscore{}rttinf :=
       \textless{}|
         t\textunderscore{}rttupdated      := 0;
         tf\textunderscore{}srtt\textunderscore{}valid     := F;
         t\textunderscore{}srtt            := TCPTV\textunderscore{}RTOBASE;
         t\textunderscore{}rttvar          := TCPTV\textunderscore{}RTTVARBASE;
         t\textunderscore{}rttmin          := TCPTV\textunderscore{}MIN;
         t\textunderscore{}lastrtt         := 0;
         t\textunderscore{}lastshift       := 0;
         t\textunderscore{}wassyn          := F  (* if t\textunderscore{}lastshift=0, this doesn't make a difference *)
       |\textgreater{};
       t\textunderscore{}dupacks         := 0;
       t\textunderscore{}idletime        := stopwatch\textunderscore{}zero; X }{}\\{}
 \tsfield{t\_softerror}       \Mass  *{}\\{}
 \tslongcomm{ X snd\textunderscore{}scale         := 0;
       rcv\textunderscore{}scale         := 0;
       request\textunderscore{}r\textunderscore{}scale   := NONE; (* this like many other things is overwritten with
                                     the chosen value later - cf tcp\textunderscore{}newtcpcb() *)
       tf\textunderscore{}doing\textunderscore{}ws       := F;
       ts\textunderscore{}recent         := TimeWindowClosed;
       tf\textunderscore{}req\textunderscore{}tstmp      := F;    (* cf tcp\textunderscore{}newtcpcb() *)
       tf\textunderscore{}doing\textunderscore{}tstmp    := F;
       last\textunderscore{}ack\textunderscore{}sent     := tcp\textunderscore{}seq\textunderscore{}foreign 0w;
       bsd\textunderscore{}cantconnect   := F;
       snd\textunderscore{}cwnd\textunderscore{}prev     := 0;
       snd\textunderscore{}ssthresh\textunderscore{}prev := 0;
       t\textunderscore{}badrxtwin       := TimeWindowClosed
       (* Note: everything should be listed here, leaving nothing as ARB. *)
       (* Many are always overwritten, however. *) X }{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\chapcommTCPITauxFnsTrelmonad}{\chaptersection{ Relational monad}
\label{TCP1_auxFns_relmonad}%
\chapcomm{
The relational `monad' is used to describe stateful computation in a
convenient and compositional way.


}
}

\newcommand{\seccommauxTrelmonad}{\clustersection{(TCP only)}{Relational monad}
\seccomm{
   The implementation TCP input and output routines are imperative C
   code, with mutations of state variables and calls to various other
   routines, some of which send messages or have other observable
   effects.  These are intertwined in a complex control flow.
%
   In the specification we have attempted, as much as possible, to
   adopt purely functional or relational styles.  To deal with the
   observable side effects in the middle of (e.g.) \wasverb{tcp\textunderscore{}output},
   however, we have had to identify some intermediate states.
%
   We introduce a relational monadic style to do so, using
   higher-order functions to hide the plumbing of state variables.
   The nondeterminism of our model adds another layer of complexity;
   instead of the usual functional monads, we use relational monads.

   An operation on the current state is modelled by a relation on the
   current and resulting states.  A number of primitive operations
   are defined; these operations are then chained together by a
   binding combinator, which takes two relations and yields their
   composition.  In this way arbitrarily complex operations on state
   may be defined in a modular manner, and the referential
   transparency of the logic is maintained.

   In the present application, the current state is a pair
   $(\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state})$ of the current socket and the
   state of the host's band limiter.  The resulting state is a
   quadruple $((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg}
\tstype{list}),\tsunknown{continue'}:\tstype{bool})$ of the final socket, band-limiter state, a
   list of segments to be output, and a flag.  This flag models
   aborting: if it is set, operations should be chained together
   normally; if it is cleared, subsequent operations should \emph{not}
   be performed, and instead the resulting state should be the final
   state of the entire composite operation of which this is a part.

   The binding combinator is $\tsaux{andThen}$.  Primitive operators include
   $\tsaux{cont}$, which does nothing and continues, and $\tsaux{stop}$, which
   does nothing and stops.  Several other operations are defined to
   manipulate the state -- the monadic glue is intended to abstract
   away from the implementation of that state as a pair of tuples.

   It should be a theorem that $\tsaux{andThen}$ is assoc, that $\tsaux{cont}$ is
   unit and $\tsaux{stop}$ is zero, and so on.

   Note that $\tsunknown{outsegs}$, the list of messages, is actually a list of
   arbitrary type; this enables us to lift the glue to the type $\tsunknown{msg}
\# \tstype{bool}$ in $\tsunknown{deliver\_in\_3}$, where we need the flag to deal with
   queueing failure.

   As throughout this specification, beware that the nondeterminism
   of, e.g., $\tsaux{chooseM}$ is modelled by an existential, and is thus
   "angelic" in some sense.  This may or may not be what you expect.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{andThen}$
&
&  normal sequencing \\
$\tsrule{cont}$
&
&  do nothing, and continue (unit for $\tsaux{andThen}$) \\
$\tsrule{stop}$
&
&  do nothing, and stop (zero for $\tsaux{andThen}$) \\
$\tsrule{assert}$
&
&  assert truth of condition, and continue \\
$\tsrule{assert\_failure}$
&
&  assertion violated; fail noisily \\
$\tsrule{chooseM}$
&
&  choose a value from a set, nondeterministically \\
$\tsrule{get\_sock}$
&
&  get current socket \\
$\tsrule{get\_tcp\_sock}$
&
&  assert current socket is TCP, and get its protocol data \\
$\tsrule{get\_cb}$
&
&  assert current socket is TCP, and get its control block \\
$\tsrule{modify\_sock}$
&
&  apply function to current socket \\
$\tsrule{modify\_tcp\_sock}$
&
&  apply function to current socket \\
$\tsrule{modify\_cb}$
&
&  assert current socket is TCP, and apply function to its control block \\
$\tsrule{emit\_segs}$
&
&  append segments to current output list \\
$\tsrule{emit\_segs\_pred}$
&
&  append segments specified by a predicate (nondeterministic) \\
$\tsrule{mliftc}$
&
&  lift a monadic operation not involving $\tsunknown{continue}$ or $\tsvar{bndlm}$ \\
$\tsrule{mliftc\_bndlm}$
&
&  lift a monadic operation not involving $\tsunknown{continue}$ \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnandThen}{\ddefnc{andThen}{\iA{andThen}}{\subddefnA[{ normal sequencing }]{andThen}{(\tsunknown{op1} \;\tsaux{andThen} \;\tsunknown{op2}) ={}\\{}
 \lambda  (\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad \exists \tsvar{sock}_{1} \;\tsvar{bndlm}_{1} \;\tsvar{outsegs}_{1} \;\tsvar{continue}_{1} \;\tsvar{sock}_{2} \;\tsvar{bndlm}_{2} \;\tsvar{outsegs}_{2} \;\tsvar{continue}_{2}.{}\\{}
\quad \tsunknown{op1} (\tsunknown{sock},\tsvar{bndlm}) ((\tsvar{sock}_{1},\tsvar{bndlm}_{1},\tsvar{outsegs}_{1}),\tsvar{continue}_{1}) \Mwedge {}\\{}
\quad \Mif  \;\tsvar{continue}_{1} \;\Mthen {}\\{}
\quad\quad\quad \tsunknown{op2} (\tsvar{sock}_{1},\tsvar{bndlm}_{1}) ((\tsvar{sock}_{2},\tsvar{bndlm}_{2},\tsvar{outsegs}_{2}),\tsvar{continue}_{2}) \Mwedge {}\\{}
\quad\quad\quad (\tsunknown{sock'} = \tsvar{sock}_{2} \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm}_{2} \Mwedge  \tsunknown{outsegs'} = \Mappend{\tsvar{outsegs}_{1}}{\tsvar{outsegs}_{2}} \Mwedge  \tsunknown{continue'} = \tsvar{continue}_{2}){}\\{}
\quad \Melse {}\\{}
\quad\quad\quad (\tsunknown{sock'} = \tsvar{sock}_{1} \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm}_{1} \Mwedge  \tsunknown{outsegs'} = \tsvar{outsegs}_{1} \Mwedge  \tsunknown{continue'} = \Mfalse )}
}
{}
}

\newcommand{\defncont}{\ddefnc{cont}{\iA{cont}}{\subddefnA[{ do nothing, and continue (unit for $\tsaux{andThen}$) }]{cont}{\tsaux{cont} ={}\\{}
 \lambda  (\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\tsunknown{sock'} = \tsunknown{sock} \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\defnstop}{\ddefnc{stop}{\iA{stop}}{\subddefnA[{ do nothing, and stop (zero for $\tsaux{andThen}$) }]{stop}{\tsaux{stop} ={}\\{}
 \lambda  (\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\tsunknown{sock'} = \tsunknown{sock} \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsunknown{continue'} = \Mfalse )}
}
{}
}

\newcommand{\defnassert}{\ddefnc{assert}{\iA{assert}}{\subddefnA[{ assert truth of condition, and continue }]{assert}{\tsaux{assert} \;\tsvar{p} ={}\\{}
 \lambda  (\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\tsvar{p} \Mwedge  \tsunknown{sock'} = \tsunknown{sock} \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\defnassertTfailure}{\ddefnc{assertTfailure}{\iA{assert\_failure}}{\subddefnA[{ assertion violated; fail noisily }]{assert\_failure}{\tsaux{assert\_failure} \;\tsunknown{s} ={}\\{}
 \lambda  (\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad \tsunknown{ASSERTION\_FAILURE} \;\tsunknown{s}}
}
{}
}

\newcommand{\defnchooseM}{\ddefnn{chooseM}{\iA{chooseM}}{\subddefnA[{ choose a value from a set, nondeterministically }]{chooseM}{\tsaux{chooseM} \;\tsunknown{s} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad \tsholop{choose} \;\tsunknown{x} \Mcons  \tsunknown{s}. \tsunknown{f} \;\tsunknown{x} (\tsunknown{sock},\tsvar{bndlm}) ((\tsunknown{sock'},\tsvar{bndlm}',\tsunknown{outsegs'}),\tsunknown{continue'})}
}
{}
}

\newcommand{\defngetTsock}{\ddefnc{getTsock}{\iA{get\_sock}}{\subddefnA[{ get current socket }]{get\_sock}{\tsaux{get\_sock} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad \tsunknown{f} \;\tsunknown{sock} (\tsunknown{sock},\tsvar{bndlm}) ((\tsunknown{sock'},\tsvar{bndlm}',\tsunknown{outsegs'}),\tsunknown{continue'})}
}
{}
}

\newcommand{\defngetTtcpTsock}{\ddefnc{getTtcpTsock}{\iA{get\_tcp\_sock}}{\subddefnA[{ assert current socket is TCP, and get its protocol data }]{get\_tcp\_sock}{\tsaux{get\_tcp\_sock} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad \exists \tsunknown{tcp\_sock}.{}\\{}
\quad \tsunknown{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad \tsunknown{f} \;\tsunknown{tcp\_sock} (\tsunknown{sock},\tsvar{bndlm}) ((\tsunknown{sock'},\tsvar{bndlm}',\tsunknown{outsegs'}),\tsunknown{continue'})}
}
{}
}

\newcommand{\defngetTcb}{\ddefnc{getTcb}{\iA{get\_cb}}{\subddefnA[{ assert current socket is TCP, and get its control block }]{get\_cb}{\tsaux{get\_cb} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad \exists \tsunknown{tcp\_sock}.{}\\{}
\quad \tsunknown{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad \tsunknown{f} \;\tsunknown{tcp\_sock}.\tsvar{cb} (\tsunknown{sock},\tsvar{bndlm}) ((\tsunknown{sock'},\tsvar{bndlm}',\tsunknown{outsegs'}),\tsunknown{continue'})}
}
{}
}

\newcommand{\defnmodifyTsock}{\ddefnc{modifyTsock}{\iA{modify\_sock}}{\subddefnA[{ apply function to current socket }]{modify\_sock}{\tsaux{modify\_sock} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\tsunknown{sock'} = \tsunknown{f} \;\tsunknown{sock} \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\defnmodifyTtcpTsock}{\ddefnc{modifyTtcpTsock}{\iA{modify\_tcp\_sock}}{\subddefnA[{ apply function to current socket }]{modify\_tcp\_sock}{\tsaux{modify\_tcp\_sock} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\exists \tsunknown{tcp\_sock}.{}\\{}
\quad \tsunknown{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad \tsunknown{sock'} = \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO} (\tsunknown{f} \;\tsunknown{tcp\_sock}) \Mmagicrrec  \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\defnmodifyTcb}{\ddefnn{modifyTcb}{\iA{modify\_cb}}{\subddefnA[{ assert current socket is TCP, and apply function to its control block }]{modify\_cb}{\tsaux{modify\_cb} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad \exists \tsunknown{tcp\_sock}.{}\\{}
\quad \tsunknown{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad (\tsunknown{sock'} = \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{cb} \Mass  (\tsunknown{f} \;\tsunknown{tcp\_sock}.\tsvar{cb}) \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad \tsvar{bndlm}' = \tsvar{bndlm} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\defnemitTsegs}{\ddefnc{emitTsegs}{\iA{emit\_segs}}{\subddefnA[{ append segments to current output list }]{emit\_segs}{\tsaux{emit\_segs} \;\tsunknown{segs} ={}\\{}
 \lambda  (\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\tsunknown{sock'} = \tsunknown{sock} \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm} \Mwedge  \tsunknown{outsegs'} = \tsunknown{segs} \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\defnemitTsegsTpred}{\ddefnn{emitTsegsTpred}{\iA{emit\_segs\_pred}}{\subddefnA[{ append segments specified by a predicate (nondeterministic) }]{emit\_segs\_pred}{\tsaux{emit\_segs\_pred} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\tsunknown{sock'} = \tsunknown{sock} \Mwedge  \tsunknown{f} \;\tsvar{bndlm} \;\tsvar{bndlm}' \;\tsunknown{outsegs'} \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\defnmliftc}{\ddefnc{mliftc}{\iA{mliftc}}{\subddefnA[{ lift a monadic operation not involving $\tsunknown{continue}$ or $\tsvar{bndlm}$ }]{mliftc}{\tsaux{mliftc} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\tsunknown{f} \;\tsunknown{sock} (\tsunknown{sock'},\tsunknown{outsegs'}) \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm} \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\defnmliftcTbndlm}{\ddefnn{mliftcTbndlm}{\iA{mliftc\_bndlm}}{\subddefnA[{ lift a monadic operation not involving $\tsunknown{continue}$ }]{mliftc\_bndlm}{\tsaux{mliftc\_bndlm} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tstype{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tstype{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\tsunknown{f} (\tsunknown{sock},\tsvar{bndlm}) (\tsunknown{sock'},\tsvar{bndlm}',\tsunknown{outsegs'}) \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\chapcommTCPmajorAuxFns}{\chaptersection{ Auxiliary functions for TCP segment creation and drop}
\label{TCPmajorAuxFns}%
\chapcomm{
We gather here all the general TCP segment generation and processing
functions that are used in the host LTS.


}
}

\newcommand{\seccommtcpTsynTrstTsegmentTcreation}{\clustersection{(TCP only)}{SYN and RST Segment Creation}
\seccomm{
Generating various simple segments (none of which contain any user data).


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{make\_syn\_segment}$
&
&  Make a SYN segment for emission by $\tsunknown{connect\_1}$ etc \\
$\tsrule{make\_syn\_ack\_segment}$
&
&  Make a SYN,ACK segment for emission by $\tsunknown{deliver\_in\_1}$, $\tsunknown{deliver\_in\_2}$, etc.\\
$\tsrule{make\_ack\_segment}$
&
&  Make a plain boring ACK segment in response to a SYN,ACK segment \\
$\tsrule{bsd\_make\_phantom\_segment}$
&
&  Make phantom (no flags) segment for BSD $\tscon{LISTEN}$ bug \\
$\tsrule{make\_rst\_segment\_from\_cb}$
&
&  Make a RST segment asynchronously, from socket information only \\
$\tsrule{make\_rst\_segment\_from\_seg}$
&
&  Make a RST segment synchronously, in response to an incoming segment \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnmakeTsynTsegment}{\ddefnn{makeTsynTsegment}{\iA{make\_syn\_segment}}{\subddefnA[{ Make a SYN segment for emission by $\tsunknown{connect\_1}$ etc }]{make\_syn\_segment}{\tsaux{make\_syn\_segment} \tscomm{ X cb X } (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) \tscomm{ X ts\textunderscore{}val X } \tsunknown{seg'} ={}\\{}
 {}\\{}
 \tslongcomm{ X
     choose urp\textunderscore{}any :: UNIV.
     choose ack\textunderscore{}any :: UNIV.

    (* Determine window size; fail if out of range *)
    choose win :: UNIV. (* X FIXME may need to constrain further? X *)
    (* X let win = n2w cb.rcv\textunderscore{}wnd in
    w2n win = cb.rcv\textunderscore{}wnd /\textbackslash{} X *)

    (* Choose a window scaling; fail if out of range *)
    (* Note there may be a better place for this assertion. *)
    choose request\textunderscore{}r\textunderscore{}scale :: UNIV.
    let ws = OPTION\textunderscore{}MAP CHR (* X cb. X *)request\textunderscore{}r\textunderscore{}scale in
    (IS\textunderscore{}SOME (* X cb. X *)request\textunderscore{}r\textunderscore{}scale ==\textgreater{} ORD (THE ws) = THE (* X cb. X *)request\textunderscore{}r\textunderscore{}scale) /\textbackslash{}
    (case ws of NONE -\textgreater{} T || SOME n -\textgreater{} ORD n \textless{}= TCP\textunderscore{}MAXWINSCALE) /\textbackslash{}

    (* Determine maximum segment size; fail if out of range *)
    (*: Put the MSS we initially advertise into [[t\textunderscore{}advmss]] :*)
    choose t\textunderscore{}advmss :: UNIV.
    let mss = (case (* X cb. X *)t\textunderscore{}advmss of
                  NONE   -\textgreater{} NONE
               || SOME v -\textgreater{} SOME (n2w v)) in
    (case (*  X cb. X *)t\textunderscore{}advmss of
        NONE   -\textgreater{} T
     || SOME v -\textgreater{} v = w2n (THE mss)) /\textbackslash{}

    (* Do timestamping? *)
    choose tf\textunderscore{}req\textunderscore{}tstmp :: UNIV.
    choose ts\textunderscore{}recent :: UNIV.
    let ts = do\textunderscore{}tcp\textunderscore{}options (* X cb. X *)tf\textunderscore{}req\textunderscore{}tstmp (* X cb. X *)ts\textunderscore{}recent ts\textunderscore{}val in

    choose iss :: UNIV.

X }{}\\{}
 \tsunknown{seg'} = \tsunknown{seg'} \; \Mmagiclrec  \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tslongcomm{ X              seq  := (* X cb. X *)iss;
              ack  := ack\textunderscore{}any; X }{}\\{}
 \tsunknown{URG}  \Mass  \Mfalse ;{}\\{}
 \tsunknown{ACK}  \Mass  \Mfalse ;{}\\{}
 \tsunknown{PSH}  \Mass  \Mfalse ;{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mtrue ;{}\\{}
 \tsvar{FIN}  \Mass  \Mfalse ;{}\\{}
 \tslongcomm{ X              win  := win;
              ws   := ws;
              urp  := urp\textunderscore{}any;
              mss  := mss;
              ts   := ts; X }{}\\{}
 \tsvar{data} \Mass  [\,]{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defnmakeTsynTackTsegment}{\ddefnn{makeTsynTackTsegment}{\iA{make\_syn\_ack\_segment}}{\subddefnA[{ Make a SYN,ACK segment for emission by $\tsunknown{deliver\_in\_1}$, $\tsunknown{deliver\_in\_2}$, etc.}]{make\_syn\_ack\_segment}{\tscomm{ X Decided to be much more aggressive with these auxiliary functions X }{}\\{}
 {}\\{}
 \tsaux{make\_syn\_ack\_segment} \tscomm{ X cb X } (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) \tscomm{ X ts\textunderscore{}val' X } \tsunknown{seg'} ={}\\{}
 {}\\{}
 \tslongcomm{ X    choose urp\textunderscore{}any :: UNIV.

    (* Determine window size; fail if out of range *)
    (*: We don't scale yet ([[\textgreater{}\textgreater{} rcv\textunderscore{}scale']]). RFC1323 says: segments with SYN are not scaled, and BSD
       agrees.  Even though we know what scaling the other end wants to use, and we know whether we
       are doing scaling, we can't use it until we reach the ESTABLISHED state. :*)
    let win = n2w cb.rcv\textunderscore{}wnd in (*: [[rcv\textunderscore{}window - LENGTH data']] :*)
    w2n win = cb.rcv\textunderscore{}wnd /\textbackslash{}

    (* If doing window scaling, set it; fail if out of range *)
    let ws = if cb.tf\textunderscore{}doing\textunderscore{}ws then SOME (CHR cb.rcv\textunderscore{}scale) else NONE in
    (cb.tf\textunderscore{}doing\textunderscore{}ws ==\textgreater{} ORD (THE ws) = cb.rcv\textunderscore{}scale) /\textbackslash{}

    (* Determine maximum segment size; fail if out of range *)
    (*: Put the MSS we initially advertise into [[t\textunderscore{}advmss]] :*)
    let mss = (case cb.t\textunderscore{}advmss of
                  NONE   -\textgreater{} NONE
               || SOME v -\textgreater{} SOME (n2w v)) in
    (case cb.t\textunderscore{}advmss of
        NONE   -\textgreater{} T
     || SOME v -\textgreater{} v = w2n (THE mss)) /\textbackslash{}

    (* Set timestamping option? *)
    let ts =  do\textunderscore{}tcp\textunderscore{}options cb.tf\textunderscore{}doing\textunderscore{}tstmp cb.ts\textunderscore{}recent ts\textunderscore{}val' in
X }{}\\{}
 \tsunknown{seg'} = \tsunknown{seg'} \; \Mmagiclrec  \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tslongcomm{ X seq  := cb.iss;
              ack  := cb.rcv\textunderscore{}nxt; X }{}\\{}
 \tsunknown{URG}  \Mass  \Mfalse ;{}\\{}
 \tsunknown{ACK}  \Mass  \Mtrue ;{}\\{}
 \tsunknown{PSH}  \Mass  \Mfalse ;  \tsholcomm{ see below }{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mtrue ;{}\\{}
 \tsvar{FIN}  \Mass  \Mfalse ;  \tscomm{ Note: we are not modelling T/TCP }{}\\{}
 \tslongcomm{ X win  := win;
              ws   := ws;
              urp  := urp\textunderscore{}any;
              mss  := mss;
              ts   := ts; X }{}\\{}
 \tsvar{data} \Mass  [\,]  \tsholcomm{ see below }{}\\{}
 \Mmagicbolrrec {}\\{}
 \tsholcomm{ No $\tsvar{data}$ can be send here using the BSD sockets API, although
TCP notionally allows it.  Accordingly, the $\tsunknown{PSH}$ flag is never set
(under BSD, PSH is only set if we're sending a non-zero amount of data
(and emptying the send buffer); see \wasverb{tcp\textunderscore{}output.c:626}). }}
}
{}
}

\newcommand{\defnmakeTackTsegment}{\ddefnn{makeTackTsegment}{\iA{make\_ack\_segment}}{\subddefnA[{ Make a plain boring ACK segment in response to a SYN,ACK segment }]{make\_ack\_segment}{\tsaux{make\_ack\_segment} \tscomm{ X cb X } \tsvar{FIN} (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) \tscomm{ X ts\textunderscore{}val' X } \tsunknown{seg'} ={}\\{}
 \tslongcomm{ X    (* SB thinks these should be unconstrained. *)
    choose urp\textunderscore{}garbage :: UNIV.

    (* Determine window size; fail if out of range *)
    (* Connection is now established so any scaling should be taken into account *)
    (* Note it might be appropriate to clip the value to be in range rather than failing if out of range. *)
    let win = n2w (cb.rcv\textunderscore{}wnd \textgreater{}\textgreater{} cb.rcv\textunderscore{}scale) in
    w2n win = cb.rcv\textunderscore{}wnd \textgreater{}\textgreater{} cb.rcv\textunderscore{}scale /\textbackslash{}

    (* Set timestamping option? *)
    let ts = do\textunderscore{}tcp\textunderscore{}options cb.tf\textunderscore{}doing\textunderscore{}tstmp cb.ts\textunderscore{}recent ts\textunderscore{}val' in
X }{}\\{}
 \tsunknown{seg'} = \tsunknown{seg'} \; \Mmagiclrec  \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tslongcomm{ X seq  := if FIN then cb.snd\textunderscore{}una else cb.snd\textunderscore{}nxt;
              ack  := cb.rcv\textunderscore{}nxt; X }{}\\{}
 \tsunknown{URG}  \Mass  \Mfalse ;{}\\{}
 \tsunknown{ACK}  \Mass  \Mtrue ;{}\\{}
 \tsunknown{PSH}  \Mass  \Mfalse ;  \tsholcomm{ see comment for $\tsaux{make\_syn\_ack\_segment}$ }{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mfalse ;{}\\{}
 \tsvar{FIN}  \Mass  \tsvar{FIN};{}\\{}
 \tslongcomm{ X win  := win;
              ws   := NONE;
              urp  := urp\textunderscore{}garbage;
              mss  := NONE;
              ts   := ts; X }{}\\{}
 \tsvar{data} \Mass  [\,] \tsholcomm{ Note that if there is data in $\tsvar{sndq}$ then it
                            should always appear in a seperate segment after the connnection
                            establishment handshake, but this needs to be verified. }{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defnbsdTmakeTphantomTsegment}{\ddefnn{bsdTmakeTphantomTsegment}{\iA{bsd\_make\_phantom\_segment}}{\subddefnA[{ Make phantom (no flags) segment for BSD $\tscon{LISTEN}$ bug }]{bsd\_make\_phantom\_segment}{\tslongcomm{ If a socket is changed to the LISTEN state, the rexmt timer may still be running.
   If it fires, phantom segments are emitted. }{}\\{}
 \tsaux{bsd\_make\_phantom\_segment} \tscomm{ X cb X } (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) \tscomm{ X ts\textunderscore{}val' X } \tsvar{cantsndmore} \;\tsunknown{seg'} ={}\\{}
 \tslongcomm{ X    choose urp\textunderscore{}garbage :: UNIV.

    (* Determine window size; fail if out of range *)
    (* Connection is now established so any scaling should be taken into account *)
    (* Note it might be appropriate to clip the value to be in range rather than failing if out of range. *)
    let win = n2w (cb.rcv\textunderscore{}wnd \textgreater{}\textgreater{} cb.rcv\textunderscore{}scale) in
    w2n win = cb.rcv\textunderscore{}wnd \textgreater{}\textgreater{} cb.rcv\textunderscore{}scale /\textbackslash{}
X }{}\\{}
 \tsholop{choose} \;\tsunknown{snd\_una\_lt\_pred\_snd\_max} \Mcons  \tsunknown{UNIV}.{}\\{}
 \Mlet  \;\tsvar{FIN} = (\tsvar{cantsndmore} \Mwedge  \tsunknown{snd\_una\_lt\_pred\_snd\_max} \tscomm{cb.snd\textunderscore{}una \textless{} (cb.snd\textunderscore{}max - 1)} ) \Min {}\\{}
 \tslongcomm{ X
    (* Set timestamping option? *)
    let ts = do\textunderscore{}tcp\textunderscore{}options cb.tf\textunderscore{}doing\textunderscore{}tstmp cb.ts\textunderscore{}recent ts\textunderscore{}val' in X }{}\\{}
 {}\\{}
 \tsunknown{seg'} = \tsunknown{seg'} \; \Mmagiclrec  \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tslongcomm{ X seq  := if FIN then cb.snd\textunderscore{}una else cb.snd\textunderscore{}max; (* no flags, no data, and no persist timer so use snd\textunderscore{}max *)
              ack  := cb.rcv\textunderscore{}nxt;  (*: yes, really, even though [[\textasciitilde{}ACK]] :*) X }{}\\{}
 \tsunknown{URG}  \Mass  \Mfalse ;{}\\{}
 \tsunknown{ACK}  \Mass  \Mfalse ;{}\\{}
 \tsunknown{PSH}  \Mass  \Mfalse ;{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mfalse ;{}\\{}
 \tsvar{FIN}  \Mass  \tsvar{FIN};{}\\{}
 \tscomm{ X win  := win; X }{}\\{}
 \tsunknown{ws}   \Mass  *;{}\\{}
 \tscomm{ X urp  := urp\textunderscore{}garbage; X }{}\\{}
 \tsunknown{mss}  \Mass  *;{}\\{}
 \tscomm{ X ts   := ts; X }{}\\{}
 \tsvar{data} \Mass  [\,] \tsholcomm{ sndq always empty in this situation }{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defnmakeTrstTsegmentTfromTcb}{\ddefnn{makeTrstTsegmentTfromTcb}{\iA{make\_rst\_segment\_from\_cb}}{\subddefnA[{ Make a RST segment asynchronously, from socket information only }]{make\_rst\_segment\_from\_cb}{\tsaux{make\_rst\_segment\_from\_cb} \tscomm{ X cb X } (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) \tsunknown{seg'} ={}\\{}
 \tscomm{ Deliberately unconstrained }{}\\{}
 \tsholop{choose} \;\tsunknown{urp\_garbage}  \Mcons  \tsunknown{UNIV} .{}\\{}
 \tsholop{choose} \;\tsunknown{URG\_garbage}  \Mcons  \tsunknown{UNIV} .{}\\{}
 \tsholop{choose} \;\tsunknown{PSH\_garbage}  \Mcons  \tsunknown{UNIV} .{}\\{}
 \tsholop{choose} \;\tsunknown{win\_garbage}  \Mcons  \tsunknown{UNIV} .{}\\{}
 \tsholop{choose} \;\tsunknown{data\_garbage} \Mcons  \tsunknown{UNIV}.{}\\{}
 \tsholop{choose} \;\tsunknown{FIN\_garbage}  \Mcons  \tsunknown{UNIV} .{}\\{}
 \tsholop{choose} \;\tsunknown{snd\_nxt} \Mcons  \tsunknown{UNIV}.{}\\{}
 \tsholop{choose} \;\tsunknown{rcv\_nxt} \Mcons  \tsunknown{UNIV}.{}\\{}
 {}\\{}
 \tsholcomm{ Note that BSD is perfectly capable of putting data in a RST segment; try filling the buffer
       and then doing a force close: the result is a segment with RST+PSH+data+win advertisement.
       Presumably URG is also possible.  This is *not* the same as the RFC-suggested data carried by
       a RST; that would be an error message, this is just data from the buffer!  }{}\\{}
 \tsunknown{seg'} = \Mmagiclrec  \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsunknown{seq}  \Mass  \tsunknown{snd\_nxt};   \tsholcomm{ from RFC793p62 }{}\\{}
 \tsunknown{ack}  \Mass  \tsunknown{rcv\_nxt};   \tsholcomm{ seems the right thing to do }{}\\{}
 \tsunknown{URG}  \Mass  \tsunknown{URG\_garbage};  \tsholcomm{ expect: $\Mfalse $ }{}\\{}
 \tsunknown{ACK}  \Mass  \Mtrue ;            \tsholcomm{ from TCPv1p248 }{}\\{}
 \tsunknown{PSH}  \Mass  \tsunknown{PSH\_garbage};  \tsholcomm{ expect: $\Mfalse $ }{}\\{}
 \tsvar{RST}  \Mass  \Mtrue ;{}\\{}
 \tsvar{SYN}  \Mass  \Mfalse ;{}\\{}
 \tsvar{FIN}  \Mass  \tsunknown{FIN\_garbage};  \tsholcomm{ expect: $\Mfalse $ }{}\\{}
 \tsunknown{win}  \Mass  \tsunknown{win\_garbage};  \tsholcomm{ expect: $0w$ }{}\\{}
 \tsunknown{ws}   \Mass  *;{}\\{}
 \tsunknown{urp}  \Mass  \tsunknown{urp\_garbage};  \tsholcomm{ expect: $0w$ }{}\\{}
 \tsunknown{mss}  \Mass  *;{}\\{}
 \tsvar{ts}   \Mass  *;  \tsholcomm{ RFC1323 S4.2 recommends no TS on RST, and BSD follows this }{}\\{}
 \tsvar{data} \Mass  \tsunknown{data\_garbage}  \tsholcomm{ expect: $ [\,] $ }{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defnmakeTrstTsegmentTfromTseg}{\ddefnn{makeTrstTsegmentTfromTseg}{\iA{make\_rst\_segment\_from\_seg}}{\subddefnA[{ Make a RST segment synchronously, in response to an incoming segment }]{make\_rst\_segment\_from\_seg}{\tsaux{make\_rst\_segment\_from\_seg} \;\tsunknown{seg} \;\tsunknown{seg'} ={}\\{}
 (\tsunknown{seg}.\tsvar{RST} = \Mfalse  \Mwedge   \tscomm{ Sanity check: never RST a RST }{}\\{}
 {}\\{}
 (\exists \tsvar{ack}'.{}\\{}
 \tscomm{ Deliberately unconstrained }{}\\{}
 \tsholop{choose} \;\tsunknown{urp\_garbage}\Mcons \tsunknown{UNIV}.{}\\{}
 \tsholop{choose} \;\tsunknown{URG\_garbage}\Mcons \tsunknown{UNIV}.{}\\{}
 \tsholop{choose} \;\tsunknown{PSH\_garbage}\Mcons \tsunknown{UNIV}.{}\\{}
 \tsholop{choose} \;\tsunknown{win\_garbage}\Mcons \tsunknown{UNIV}.{}\\{}
 \tsholop{choose} \;\tsunknown{data\_garbage}\Mcons \tsunknown{UNIV}.{}\\{}
 \tsholop{choose} \;\tsunknown{FIN\_garbage}\Mcons \tsunknown{UNIV}.{}\\{}
 {}\\{}
 \tslongcomm{ RFC795 S3.4: only ack segments that don't contain an ACK.
       SB believes this is equivalent to: only send a RST+ACK segment in response to a bad SYN
       segment }{}\\{}
 \Mlet  \;\tsunknown{ACK'} = \neg{}\tsunknown{seg}.\tsunknown{ACK} \;\Min {}\\{}
 {}\\{}
 \tslongcomm{ Sequence number is zero for RST+ACK segments, otherwise it is the next sequence number
       expected }{}\\{}
 \Mlet  \;\tsunknown{seq'} = \Mif  \;\tsunknown{seg}.\tsunknown{ACK} \;\Mthen  \;\tsunknown{tcp\_seq\_flip\_sense} \;\tsunknown{seg}.\tsunknown{ack}{}\\{}
\quad\quad\quad\quad\quad \Melse  \;\tsunknown{tcp\_seq\_local} \;0w \;\Min {}\\{}
 {}\\{}
 (\Mif  \;\tsunknown{ACK'} \;\Mthen {}\\{}
\quad \tscomm{ RFC794 S3.4: for RST+ACK segments the ack value must be valid }{}\\{}
\quad \tsvar{ack}' = \tsunknown{tcp\_seq\_flip\_sense} \;\tsunknown{seg}.\tsunknown{seq} + \tsholop{LENGTH} \;\tsunknown{seg}.\tsvar{data} + (\Mif  \;\tsunknown{seg}.\tsvar{SYN} \;\Mthen  \;1 \;\Melse  \;0){}\\{}
 \Melse {}\\{}
\quad \tscomm{ otherwise it can be arbitrary, although it possibly should be zero }{}\\{}
\quad \tsvar{ack}' \;\in  \{ \tsunknown{n} \mid  \Mtrue  \}{}\\{}
 ) \Mwedge {}\\{}
 \tsunknown{seg'} = \Mmagiclrec  \tsvar{is}_{1}  \Mass  \tsunknown{seg}.\tsvar{is}_{2};{}\\{}
 \tsvar{ps}_{1}  \Mass  \tsunknown{seg}.\tsvar{ps}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \tsunknown{seg}.\tsvar{is}_{1};{}\\{}
 \tsvar{ps}_{2}  \Mass  \tsunknown{seg}.\tsvar{ps}_{1};{}\\{}
 \tsunknown{seq}  \Mass  \tsunknown{seq'};{}\\{}
 \tsunknown{ack}  \Mass  \tsvar{ack}';{}\\{}
 \tsunknown{URG}  \Mass  \tsunknown{URG\_garbage};  \tsholcomm{ expect: $\Mfalse $ }{}\\{}
 \tsunknown{ACK}  \Mass  \tsunknown{ACK'};{}\\{}
 \tsunknown{PSH}  \Mass  \tsunknown{PSH\_garbage};  \tsholcomm{ expect: $\Mfalse $ }{}\\{}
 \tsvar{RST}  \Mass  \Mtrue ;{}\\{}
 \tsvar{SYN}  \Mass  \Mfalse ;{}\\{}
 \tsvar{FIN}  \Mass  \tsunknown{FIN\_garbage};  \tsholcomm{ expect: $\Mfalse $ }{}\\{}
 \tsunknown{win}  \Mass  \tsunknown{win\_garbage};  \tsholcomm{ expect: $0w$ }{}\\{}
 \tsunknown{ws}   \Mass  *;{}\\{}
 \tsunknown{urp}  \Mass  \tsunknown{urp\_garbage};  \tsholcomm{ expect: $0w$ }{}\\{}
 \tsunknown{mss}  \Mass  *;{}\\{}
 \tsvar{ts}   \Mass  *;  \tsholcomm{ RFC1323 S4.2 recommends no TS on RST, and BSD follows this }{}\\{}
 \tsvar{data} \Mass  \tsunknown{data\_garbage}  \tsholcomm{ expect: $ [\,] $ }{}\\{}
 \Mmagicbolrrec {}\\{}
 ))}
}
{}
}

\newcommand{\seccommtcpTsegmentTcreation}{\clustersection{(TCP only)}{General Segment Creation}
\seccomm{
The TCP output routines.  These, together with the input routines in
$\tsunknown{deliver\_in\_3}$, form the heart of TCP.



}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{tcp\_output\_required}$
&
&  determine whether TCP output is required \\
$\tsrule{tcp\_output\_really}$
&
&  do TCP output \\
$\tsrule{FIXMEstream\_tcp\_output\_really}$
&
&  do TCP output \\
$\tsrule{tcp\_output\_perhaps}$
&
&  combination of $\tsaux{tcp\_output\_required}$ and $\tsaux{tcp\_output\_really}$ \\
$\tsrule{FIXMEstream\_tcp\_output\_perhaps}$
&
&  combination of $\tsaux{tcp\_output\_required}$ and $\tsaux{tcp\_output\_really}$ \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntcpToutputTrequired}{\ddefnc{tcpToutputTrequired}{\iA{tcp\_output\_required}}{\subddefnA[{ determine whether TCP output is required }]{tcp\_output\_required}{\tsaux{tcp\_output\_required} (\tsunknown{do\_output}, \tsunknown{persist\_fun}) ={}\\{}
 (\tsunknown{do\_output} \;\in  \{\Mtrue ;\Mfalse \} \Mwedge {}\\{}
 \tsunknown{persist\_fun} \;\in  \{*; \Msome  (\lambda \tsvar{cb}:\tsvar{tcpcb}.\tsvar{cb})\})}
}
{\rulesubsection{Description}

  This function determines if it is currently necessary to emit a
  segment.  It is not quite a predicate, because in certain
  circumstances the operation of testing may start or reset the
  persist timer, and alter $\tsunknown{snd\_nxt}$.  Thus it returns a pair of a
  flag $\tsunknown{do\_output}$ (with the obvious meaning), and an optional
  mutator function $\tsunknown{persist\_fun}$ which, if present, performs the
  required updates on the TCP control block.

\rrulepad }
}

\newcommand{\defntcpToutputTreally}{\ddefnc{tcpToutputTreally}{\iA{tcp\_output\_really}}{\subddefnA[{ do TCP output }]{tcp\_output\_really}{\tsaux{tcp\_output\_really} \;\tsunknown{sock} (\tsunknown{sock'},\tsunknown{outsegs'}) ={}\\{}
 \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsunknown{sock} \;\Min {}\\{}
 \Mlet  \;\tsvar{cb} = \tsunknown{tcp\_sock}.\tsvar{cb} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Assert that the socket is fully bound and connected }{}\\{}
 \tsunknown{sock}.\tsvar{is}_{1} \neq  * \Mwedge {}\\{}
 \tsunknown{sock}.\tsvar{is}_{2} \neq  * \Mwedge {}\\{}
 \tsunknown{sock}.\tsvar{ps}_{1} \neq  * \Mwedge {}\\{}
 \tsunknown{sock}.\tsvar{ps}_{2} \neq  * \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Is it possible that a $\tsvar{FIN}$ may need to be transmitted? }{}\\{}
 \Mlet  \;\tsunknown{fin\_required} = (\tsunknown{sock}.\tsvar{cantsndmore} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} \;\notin  \{\tscon{FIN\_WAIT\_2};\tscon{TIME\_WAIT}\}) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Should $\tsvar{FIN}$ be set in this segment? }{}\\{}
 \tsholop{choose} \;\tsunknown{snd\_nxt\_plus\_length\_data\_to\_send\_ge\_last\_sndq\_data\_seq} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
 \Mlet  \;\tsvar{FIN} = (\tsunknown{fin\_required} \Mwedge  \tsunknown{snd\_nxt\_plus\_length\_data\_to\_send\_ge\_last\_sndq\_data\_seq}) \Min {}\\{}
 {}\\{}
 \exists  \tsunknown{snd\_nxt'} \;\tsunknown{rcv\_nxt} \;\tsvar{URG} \;\tsvar{ACK} \;\tsvar{PSH} \;\tsvar{win} \;\tsunknown{urp\_} \;\tsvar{ts} \;\tsunknown{data\_to\_send}.{}\\{}
 \Mlet  \;\tsunknown{seg} = \Mmagiclrec  \tsvar{is}_{1}  \Mass  \tsunknown{sock}.\tsvar{is}_{1};{}\\{}
 \tsvar{is}_{2}  \Mass  \tsunknown{sock}.\tsvar{is}_{2};{}\\{}
 \tsvar{ps}_{1}  \Mass  \tsunknown{sock}.\tsvar{ps}_{1};{}\\{}
 \tsvar{ps}_{2}  \Mass  \tsunknown{sock}.\tsvar{ps}_{2};{}\\{}
 \tsunknown{seq}  \Mass  \tsunknown{snd\_nxt'};{}\\{}
 \tsunknown{ack}  \Mass  \tsunknown{rcv\_nxt};{}\\{}
 \tsvar{URG}  \Mass  \tsvar{URG};{}\\{}
 \tsvar{ACK}  \Mass  \tsvar{ACK};{}\\{}
 \tsvar{PSH}  \Mass  \tsvar{PSH};{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mfalse ;{}\\{}
 \tsvar{FIN}  \Mass  \tsvar{FIN};{}\\{}
 \tsvar{win}  \Mass  \tsvar{win};{}\\{}
 \tsunknown{ws}   \Mass  *;{}\\{}
 \tsunknown{urp}  \Mass  \tsunknown{urp\_};{}\\{}
 \tsunknown{mss}  \Mass  *;{}\\{}
 \tsvar{ts}   \Mass  \tsvar{ts};{}\\{}
 \tsvar{data} \Mass  \tsunknown{data\_to\_send}{}\\{}
 \Mmagicbolrrec  \Min {}\\{}
 {}\\{}
 \tsholcomm{ If emitting a $\tsvar{FIN}$ for the first time then change TCP state }{}\\{}
 \Mlet  \;\tsvar{st}' = \Mif  \;\tsvar{FIN} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \Mcase  \;\tsunknown{tcp\_sock}.\tsvar{st} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad \tscon{SYN\_SENT}     \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ can't move yet -- wait until connection established (see $\tsunknown{deliver\_in\_2}$/$\tsunknown{deliver\_in\_3}$) }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{SYN\_RECEIVED} \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ can't move yet -- wait until connection established (see $\tsunknown{deliver\_in\_2}$/$\tsunknown{deliver\_in\_3}$) }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{ESTABLISHED}  \Mtotype  \tscon{FIN\_WAIT\_1} \Mdpipe {}\\{}
\quad\quad\quad\quad\quad\quad \tscon{CLOSE\_WAIT}   \Mtotype  \tscon{LAST\_ACK} \Mdpipe {}\\{}
\quad\quad\quad\quad\quad\quad \tscon{FIN\_WAIT\_1}   \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ FIN retransmission }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{FIN\_WAIT\_2}   \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ can't happen       }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{CLOSING}      \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ FIN retransmission }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{LAST\_ACK}     \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ FIN retransmission }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{TIME\_WAIT}    \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st}       \tsholcomm{ can't happen       }{}\\{}
\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{st} \;\Min {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Update the socket }{}\\{}
 \tsunknown{sock'} = \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{st} \Mass  \tsvar{st}' \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Constrain the list of output segments to contain just the segment being emitted }{}\\{}
 \tsunknown{outsegs'} = [\tsunknown{TCP} \;\tsunknown{seg}]}
}
{\rulesubsection{Description}

  This function constructs the next segment to be output.  It is
  usually called once $\tsaux{tcp\_output\_required}$ has returned true, but
  sometimes is called directly when we wish always to emit a segment.
  A large number of TCP state variables are modified also.

  Note that while constructing the segment a variety of errors such as
  $\tsunknown{ENOBUFS}$ are possible, but this is not modelled here. Also,
  window shrinking is not dealt with properly here.

\rrulepad }
}

\newcommand{\defnFIXMEstreamTtcpToutputTreally}{\ddefnc{FIXMEstreamTtcpToutputTreally}{\iA{FIXMEstream\_tcp\_output\_really}}{\subddefnA[{ do TCP output }]{FIXMEstream\_tcp\_output\_really}{\tsaux{FIXMEstream\_tcp\_output\_really} \;\tsunknown{sock} (\tsunknown{sock'},\tsvar{FIN}) ={}\\{}
 \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsunknown{sock} \;\Min {}\\{}
 \Mlet  \;\tsvar{cb} = \tsunknown{tcp\_sock}.\tsvar{cb} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Assert that the socket is fully bound and connected }{}\\{}
 \tsunknown{sock}.\tsvar{is}_{1} \neq  * \Mwedge {}\\{}
 \tsunknown{sock}.\tsvar{is}_{2} \neq  * \Mwedge {}\\{}
 \tsunknown{sock}.\tsvar{ps}_{1} \neq  * \Mwedge {}\\{}
 \tsunknown{sock}.\tsvar{ps}_{2} \neq  * \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Is it possible that a $\tsvar{FIN}$ may need to be transmitted? }{}\\{}
 \Mlet  \;\tsunknown{fin\_required} = (\tsunknown{sock}.\tsvar{cantsndmore} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} \;\notin  \{\tscon{FIN\_WAIT\_2};\tscon{TIME\_WAIT}\}) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Should $\tsvar{FIN}$ be set in this segment? }{}\\{}
 \tsholop{choose} \;\tsunknown{snd\_nxt\_plus\_length\_data\_to\_send\_ge\_last\_sndq\_data\_seq} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
 \tsvar{FIN} = (\tsunknown{fin\_required} \Mwedge  \tsunknown{snd\_nxt\_plus\_length\_data\_to\_send\_ge\_last\_sndq\_data\_seq}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ If emitting a $\tsvar{FIN}$ for the first time then change TCP state }{}\\{}
 \Mlet  \;\tsvar{st}' = \Mif  \;\tsvar{FIN} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \Mcase  \;\tsunknown{tcp\_sock}.\tsvar{st} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad \tscon{SYN\_SENT}     \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ can't move yet -- wait until connection established (see $\tsunknown{deliver\_in\_2}$/$\tsunknown{deliver\_in\_3}$) }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{SYN\_RECEIVED} \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ can't move yet -- wait until connection established (see $\tsunknown{deliver\_in\_2}$/$\tsunknown{deliver\_in\_3}$) }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{ESTABLISHED}  \Mtotype  \tscon{FIN\_WAIT\_1} \Mdpipe {}\\{}
\quad\quad\quad\quad\quad\quad \tscon{CLOSE\_WAIT}   \Mtotype  \tscon{LAST\_ACK} \Mdpipe {}\\{}
\quad\quad\quad\quad\quad\quad \tscon{FIN\_WAIT\_1}   \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ FIN retransmission }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{FIN\_WAIT\_2}   \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ can't happen       }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{CLOSING}      \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ FIN retransmission }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{LAST\_ACK}     \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ FIN retransmission }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{TIME\_WAIT}    \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st}       \tsholcomm{ can't happen       }{}\\{}
\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{st} \;\Min {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Update the socket }{}\\{}
 \tsunknown{sock'} = \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{st} \Mass  \tsvar{st}' \Mmagicrrec ) \Mmagicrrec }
}
{\rulesubsection{Description}

  This function constructs the next segment to be output.  It is
  usually called once $\tsaux{tcp\_output\_required}$ has returned true, but
  sometimes is called directly when we wish always to emit a segment.
  A large number of TCP state variables are modified also.

  Note that while constructing the segment a variety of errors such as
  $\tsunknown{ENOBUFS}$ are possible, but this is not modelled here. Also,
  window shrinking is not dealt with properly here.

\rrulepad }
}

\newcommand{\defntcpToutputTperhaps}{\ddefnn{tcpToutputTperhaps}{\iA{tcp\_output\_perhaps}}{\subddefnA[{ combination of $\tsaux{tcp\_output\_required}$ and $\tsaux{tcp\_output\_really}$ }]{tcp\_output\_perhaps}{\tsaux{tcp\_output\_perhaps} \;\tsunknown{sock} (\tsunknown{sock'},\tsunknown{outsegs}) ={}\\{}
 \exists  \tsunknown{do\_output} \;\tsunknown{persist\_fun}.{}\\{}
 (\tsaux{tcp\_output\_required} (\tsunknown{do\_output},\tsunknown{persist\_fun}) \Mwedge {}\\{}
 \Mlet  \;\tsunknown{sock''} = \tsunknown{sock} \;\Min {}\\{}
 \Mif  \;\tsunknown{do\_output} \;\Mthen {}\\{}
 \tsaux{tcp\_output\_really} \;\tsunknown{sock''} (\tsunknown{sock'},\tsunknown{outsegs}){}\\{}
 \Melse {}\\{}
 (\tsunknown{sock'} = \tsunknown{sock''} \Mwedge  \tsunknown{outsegs} = [\,]))}
}
{}
}

\newcommand{\defnFIXMEstreamTtcpToutputTperhaps}{\ddefnn{FIXMEstreamTtcpToutputTperhaps}{\iA{FIXMEstream\_tcp\_output\_perhaps}}{\subddefnA[{ combination of $\tsaux{tcp\_output\_required}$ and $\tsaux{tcp\_output\_really}$ }]{FIXMEstream\_tcp\_output\_perhaps}{\tsholcomm{ $\tsunknown{FINs}$ argument records whether any messages were sent, and if so, whether they were a $\tsvar{FIN}$ }{}\\{}
 \tsaux{FIXMEstream\_tcp\_output\_perhaps} \;\tsunknown{sock} (\tsunknown{sock'},\tsunknown{FINs}) ={}\\{}
 \exists  \tsunknown{do\_output} \;\tsunknown{persist\_fun}.{}\\{}
 (\tsaux{tcp\_output\_required} (\tsunknown{do\_output},\tsunknown{persist\_fun}) \Mwedge {}\\{}
 \Mlet  \;\tsunknown{sock''} = \tsunknown{sock} \;\Min {}\\{}
 \Mif  \;\tsunknown{do\_output} \;\Mthen {}\\{}
 \exists  \tsvar{FIN}.{}\\{}
 \tsaux{FIXMEstream\_tcp\_output\_really} \;\tsunknown{sock''} (\tsunknown{sock'},\tsvar{FIN}) \tscomm{ definitely does send a seg } \Mwedge {}\\{}
 \tsunknown{FINs} = \Msome  \;\tsvar{FIN}{}\\{}
 \Melse {}\\{}
 (\tsunknown{sock'} = \tsunknown{sock''} \Mwedge  \tsunknown{FINs} = *))}
}
{}
}

\newcommand{\seccommtcpTsegmentTqueueing}{\clustersection{(TCP only)}{Segment Queueing}
\seccomm{
Once a segment is generated for output, it must be enqueued for
transmission.  This enqueuing may fail.  These functions model what
happens in this case, and encapsulate the
enqueuing-and-possibly-rolling-back process.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{rollback\_tcp\_output}$
&
&  Attempt to enqueue segments, reverting appropriate socket fields if the enqueue fails \\
$\tsrule{FIXMEstream\_rollback\_tcp\_output}$
&
&  Attempt to enqueue segments, reverting appropriate socket fields if the enqueue fails \\
$\tsrule{enqueue\_or\_fail}$
&
&  wrap $\tsaux{rollback\_tcp\_output}$ together with enqueue \\
$\tsrule{FIXMEstream\_enqueue\_or\_fail}$
&
&  wrap $\tsaux{rollback\_tcp\_output}$ together with enqueue \\
$\tsrule{FIXMEstream\_enqueue\_or\_fail\_sock}$
&
&  version of $\tsaux{enqueue\_or\_fail}$ that works with sockets rather than cbs \\
$\tsrule{enqueue\_and\_ignore\_fail}$
&
&  version of $\tsaux{enqueue\_or\_fail}$ that ignores errors and doesn't touch the tcpcb \\
$\tsrule{enqueue\_each\_and\_ignore\_fail}$
&
&  version of above that ignores errors and doesn't touch the tcpcb \\
$\tsrule{mlift\_tcp\_output\_perhaps\_or\_fail}$
&
&  do mliftc for function returning at most one segment and not dealing with queueing flag \\
$\tsrule{FIXMEstream\_mlift\_tcp\_output\_perhaps\_or\_fail}$
&
&  do mliftc for function returning at most one segment and not dealing with queueing flag \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnrollbackTtcpToutput}{\ddefnn{rollbackTtcpToutput}{\iA{rollback\_tcp\_output}}{\subddefnA[{ Attempt to enqueue segments, reverting appropriate socket fields if the enqueue fails }]{rollback\_tcp\_output}{\tsaux{rollback\_tcp\_output} \;\tsunknown{rcvdsyn} \;\tsunknown{seg} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{is\_connect} \tscomm{ X cb0 X } \tsunknown{cb\_in} (\tsvar{cb}',\tsvar{es}',\tsunknown{outsegs'}) ={}\\{}
 {}\\{}
 \tsholcomm{ NB: from $\tsvar{cb}_{0}$, only $\tsunknown{snd\_nxt}$, $\tsunknown{tt\_delack}$, $\tsunknown{last\_ack\_sent}$, $\tsunknown{rcv\_adv}$,
        $\tsunknown{tf\_rxwin0sent}$, $\tsunknown{t\_rttseg}$, $\tsunknown{snd\_max}$, $\tsunknown{tt\_rexmt}$ are
        used. }{}\\{}
 {}\\{}
 (\tsholop{choose} \;\tsunknown{allocated} \Mcons  (\Mif  \;\tsunknown{INFINITE\_RESOURCES} \;\Mthen  \{\Mtrue \} \Melse  \{\Mtrue ;\Mfalse \}).{}\\{}
 \Mlet  \;\tsunknown{route} = \tsunknown{test\_outroute} (\tsunknown{seg},\tsvar{rttab},\tsvar{ifds},\tsvar{arch}) \Min {}\\{}
 \Mlet  \;\tsunknown{f1} = \lambda \tsvar{cb}. \Mif  \neg{}\tsunknown{rcvdsyn} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb} \; \Mmagiclrec  \tscomm{ set soft error flag; on ip\textunderscore{}output routing failure }{}\\{}
 \tsfield{t\_softerror} \Mass  \tsholop{THE} \;\tsunknown{route}  \tscomm{ assumes route = SOME (SOME e) }{}\\{}
 \Mmagicbolrrec  \Min {}\\{}
 \Mif  \neg{}\tsunknown{allocated} \;\Mthen   \tscomm{ allocation failure }{}\\{}
\quad\quad \tsvar{cb}' = \tsunknown{cb\_in} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsvar{es}' = \Msome  \;\tsunknown{ENOBUFS}{}\\{}
 \Melse  \;\Mif  \;\tsunknown{route} = * \;\Mthen   \tscomm{ ill-formed segment }{}\\{}
\quad\quad \tsunknown{ASSERTION\_FAILURE} \text{``rollback\textunderscore{}tcp\textunderscore{}output:1''}  \tscomm{ should never happen }{}\\{}
 \Melse  \;\Mif  \exists \tsvar{e}. \tsunknown{route} = \Msome  (\Msome  \;\tsvar{e}) \Mthen   \tscomm{ routing failure }{}\\{}
\quad\quad \tsvar{cb}' = \tsunknown{f1} \;\tsunknown{cb\_in} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsvar{es}' = \tsholop{THE} \;\tsunknown{route}{}\\{}
 \Melse  \;\Mif  \;\tsunknown{loopback\_on\_wire} \;\tsunknown{seg} \;\tsvar{ifds} \;\Mthen  \tscomm{ loopback not allowed on wire - RFC1122 }{}\\{}
\quad\quad (\Mif  \;\tsunknown{windows\_arch} \;\tsvar{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}' = \tsunknown{cb\_in} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsvar{es}' = *  \tscomm{ Windows silently drops segment! }{}\\{}
\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{bsd\_arch} \;\tsvar{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}' = \tsunknown{cb\_in} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsvar{es}' = \Msome  \;\tsunknown{EADDRNOTAVAIL}{}\\{}
\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{linux\_arch} \;\tsvar{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}' = \tsunknown{cb\_in} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsvar{es}' = \Msome  \;\tsunknown{EINVAL}{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsunknown{ASSERTION\_FAILURE} \text{``rollback\textunderscore{}tcp\textunderscore{}output:2''} \tscomm{ never happen }{}\\{}
\quad\quad ){}\\{}
 \Melse {}\\{}
\quad\quad (\exists \tsvar{queued}.{}\\{}
\quad\quad\quad \tsunknown{outsegs'} = [(\tsunknown{seg},\tsvar{queued})] \Mwedge {}\\{}
\quad\quad\quad \Mif  \neg{}\tsvar{queued} \;\Mthen   \tscomm{ queueing failure }{}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}' = \tsunknown{cb\_in} \Mwedge  \tsvar{es}' = \Msome  \;\tsunknown{ENOBUFS}{}\\{}
\quad\quad\quad \Melse   \tscomm{ success }{}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}' = \tsunknown{cb\_in} \Mwedge  \tsvar{es}' = *){}\\{}
 )}
}
{}
}

\newcommand{\defnFIXMEstreamTrollbackTtcpToutput}{\ddefnn{FIXMEstreamTrollbackTtcpToutput}{\iA{FIXMEstream\_rollback\_tcp\_output}}{\subddefnA[{ Attempt to enqueue segments, reverting appropriate socket fields if the enqueue fails }]{FIXMEstream\_rollback\_tcp\_output}{\tsaux{FIXMEstream\_rollback\_tcp\_output} \;\tsunknown{rcvdsyn} (\tsvar{is}_{1},\tsvar{is}_{2}) \tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{cb\_in} (\tsvar{cb}',\tsvar{es}',\tsunknown{outsegs'}) ={}\\{}
 {}\\{}
 \tsholcomm{ NB: from $\tsvar{cb}_{0}$, only $\tsunknown{snd\_nxt}$, $\tsunknown{tt\_delack}$, $\tsunknown{last\_ack\_sent}$, $\tsunknown{rcv\_adv}$,
        $\tsunknown{tf\_rxwin0sent}$, $\tsunknown{t\_rttseg}$, $\tsunknown{snd\_max}$, $\tsunknown{tt\_rexmt}$ are
        used. }{}\\{}
 {}\\{}
 (\tsholop{choose} \;\tsunknown{allocated} \Mcons  (\Mif  \;\tsunknown{INFINITE\_RESOURCES} \;\Mthen  \{\Mtrue \} \Melse  \{\Mtrue ;\Mfalse \}).{}\\{}
 \Mlet  \;\tsunknown{route} = \tsaux{FIXMEstream\_test\_outroute} (\tsvar{is}_{2},\tsvar{rttab},\tsvar{ifds},\tsvar{arch}) \Min {}\\{}
 \Mlet  \;\tsunknown{f1} = \lambda \tsvar{cb}. \Mif  \neg{}\tsunknown{rcvdsyn} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb} \; \Mmagiclrec  \tscomm{ set soft error flag; on ip\textunderscore{}output routing failure }{}\\{}
 \tsfield{t\_softerror} \Mass  \tsholop{THE} \;\tsunknown{route}  \tscomm{ assumes route = SOME (SOME e) }{}\\{}
 \Mmagicbolrrec  \Min {}\\{}
 \Mif  \neg{}\tsunknown{allocated} \;\Mthen   \tscomm{ allocation failure }{}\\{}
\quad\quad \tsvar{cb}' = \tsunknown{cb\_in} \Mwedge  \tsunknown{outsegs'} = \Mfalse  \Mwedge  \tsvar{es}' = \Msome  \;\tsunknown{ENOBUFS}{}\\{}
 \Melse  \;\Mif  \;\tsunknown{route} = * \;\Mthen   \tscomm{ ill-formed segment }{}\\{}
\quad\quad \tsunknown{ASSERTION\_FAILURE} \text{``FIXMEstream\textunderscore{}rollback\textunderscore{}tcp\textunderscore{}output:1''}  \tscomm{ should never happen }{}\\{}
 \Melse  \;\Mif  \exists \tsvar{e}. \tsunknown{route} = \Msome  (\Msome  \;\tsvar{e}) \Mthen   \tscomm{ routing failure }{}\\{}
\quad\quad \tsvar{cb}' = \tsunknown{f1} \;\tsunknown{cb\_in} \Mwedge  \tsunknown{outsegs'} = \Mfalse  \Mwedge  \tsvar{es}' = \tsholop{THE} \;\tsunknown{route}{}\\{}
 \Melse  \;\Mif  \;\tsaux{FIXMEstream\_loopback\_on\_wire} (\tsvar{is}_{1},\tsvar{is}_{2}) \tsvar{ifds} \;\Mthen  \tscomm{ loopback not allowed on wire - RFC1122 }{}\\{}
\quad\quad (\Mif  \;\tsunknown{windows\_arch} \;\tsvar{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}' = \tsunknown{cb\_in} \Mwedge  \tsunknown{outsegs'} = \Mfalse  \Mwedge  \tsvar{es}' = *  \tscomm{ Windows silently drops segment! }{}\\{}
\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{bsd\_arch} \;\tsvar{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}' = \tsunknown{cb\_in} \Mwedge  \tsunknown{outsegs'} = \Mfalse  \Mwedge  \tsvar{es}' = \Msome  \;\tsunknown{EADDRNOTAVAIL}{}\\{}
\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{linux\_arch} \;\tsvar{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}' = \tsunknown{cb\_in} \Mwedge  \tsunknown{outsegs'} = \Mfalse  \Mwedge  \tsvar{es}' = \Msome  \;\tsunknown{EINVAL}{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsunknown{ASSERTION\_FAILURE} \text{``FIXMEstream\textunderscore{}rollback\textunderscore{}tcp\textunderscore{}output:2''} \tscomm{ never happen }{}\\{}
\quad\quad ){}\\{}
 \Melse {}\\{}
\quad\quad (\exists \tsvar{queued}.{}\\{}
\quad\quad\quad \tsunknown{outsegs'} = \Mtrue  \Mwedge {}\\{}
\quad\quad\quad \Mif  \neg{}\tsvar{queued} \;\Mthen   \tscomm{ queueing failure }{}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}' = \tsunknown{cb\_in} \Mwedge  \tsvar{es}' = \Msome  \;\tsunknown{ENOBUFS}{}\\{}
\quad\quad\quad \Melse   \tscomm{ success }{}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}' = \tsunknown{cb\_in} \Mwedge  \tsvar{es}' = *){}\\{}
 )}
}
{}
}

\newcommand{\defnenqueueTorTfail}{\ddefnn{enqueueTorTfail}{\iA{enqueue\_or\_fail}}{\subddefnA[{ wrap $\tsaux{rollback\_tcp\_output}$ together with enqueue }]{enqueue\_or\_fail}{\tsaux{enqueue\_or\_fail} \;\tsunknown{rcvdsyn} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{outsegs} \;\tsvar{oq} \;\tsvar{cb}_{0} \;\tsunknown{cb\_in} (\tsvar{cb}',\tsvar{oq}') ={}\\{}
 (\Mcase  \;\tsunknown{outsegs} \;\Mof {}\\{}
\quad [\,]    \Mtotype  \tsvar{cb}' = \tsvar{cb}_{0} \Mwedge  \tsvar{oq}' = \tsvar{oq}{}\\{}
 \Mdpipe  [\tsunknown{seg}] \Mtotype  (\exists \tsvar{outsegs}' \;\tsvar{es}'.{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{rollback\_tcp\_output} \;\tsunknown{rcvdsyn} \;\tsunknown{seg} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\Mfalse  \tscomm{ X cb0 X } \tsunknown{cb\_in} (\tsvar{cb}',\tsvar{es}',\tsvar{outsegs}') \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsunknown{enqueue\_oq\_list\_qinfo} (\tsvar{oq},\tsvar{outsegs}',\tsvar{oq}')){}\\{}
 \Mdpipe  \tsunknown{\_other84} \Mtotype  \tsunknown{ASSERTION\_FAILURE} \text{``enqueue\textunderscore{}or\textunderscore{}fail''} \tscomm{ only 0 or 1 segments at a time }{}\\{}
 )}
}
{}
}

\newcommand{\defnFIXMEstreamTenqueueTorTfail}{\ddefnn{FIXMEstreamTenqueueTorTfail}{\iA{FIXMEstream\_enqueue\_or\_fail}}{\subddefnA[{ wrap $\tsaux{rollback\_tcp\_output}$ together with enqueue }]{FIXMEstream\_enqueue\_or\_fail}{\tsaux{FIXMEstream\_enqueue\_or\_fail} \;\tsunknown{rcvdsyn} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} (\tsvar{is}_{1},\tsvar{is}_{2}) \tsunknown{cb\_in} \;\tsvar{cb}' ={}\\{}
 (\exists  \tsvar{es}' \;\tsvar{outsegs}'.\tsaux{FIXMEstream\_rollback\_tcp\_output} \;\tsunknown{rcvdsyn} (\tsvar{is}_{1},\tsvar{is}_{2}) \tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{cb\_in} (\tsvar{cb}',\tsvar{es}',\tsvar{outsegs}'))}
}
{}
}

\newcommand{\defnFIXMEstreamTenqueueTorTfailTsock}{\ddefnn{FIXMEstreamTenqueueTorTfailTsock}{\iA{FIXMEstream\_enqueue\_or\_fail\_sock}}{\subddefnA[{ version of $\tsaux{enqueue\_or\_fail}$ that works with sockets rather than cbs }]{FIXMEstream\_enqueue\_or\_fail\_sock}{\tsaux{FIXMEstream\_enqueue\_or\_fail\_sock} \;\tsunknown{rcvdsyn} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} (\tsvar{is}_{1},\tsvar{is}_{2}) \tsunknown{sock0} \;\tsunknown{sock} \;\tsunknown{sock'} ={}\\{}
 \tsholcomm{ NB: could calculate $\tsunknown{rcvdsyn}$, but clearer to pass it in }{}\\{}
 \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsunknown{sock} \;\Min {}\\{}
 \Mlet  \;\tsunknown{tcp\_sock0} = \tsaux{tcp\_sock\_of} \;\tsunknown{sock0} \;\Min {}\\{}
 (\exists \tsvar{cb}'.{}\\{}
 \tsaux{FIXMEstream\_enqueue\_or\_fail} \;\tsunknown{rcvdsyn} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} (\tsvar{is}_{1},\tsvar{is}_{2}) (\tsaux{tcp\_sock\_of} \;\tsunknown{sock}).\tsvar{cb} \;\tsvar{cb}' \Mwedge {}\\{}
 \tsunknown{sock'} = \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsaux{tcp\_sock\_of} \;\tsunknown{sock} \; \Mmagiclrec {}\\{}
 \tsvar{cb} \Mass  \tsvar{cb}'{}\\{}
 \Mmagicbolrrec ) \Mmagicrrec )}
}
{}
}

\newcommand{\defnenqueueTandTignoreTfail}{\ddefnn{enqueueTandTignoreTfail}{\iA{enqueue\_and\_ignore\_fail}}{\subddefnA[{ version of $\tsaux{enqueue\_or\_fail}$ that ignores errors and doesn't touch the tcpcb }]{enqueue\_and\_ignore\_fail}{\tsaux{enqueue\_and\_ignore\_fail} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{outsegs} \;\tsvar{oq} \;\tsvar{oq}' ={}\\{}
 \exists \tsvar{rcvdsyn} \;\tsvar{cb}_{0} \;\tsunknown{cb\_in} \;\tsvar{cb}'.{}\\{}
 \tsaux{enqueue\_or\_fail} \;\tsvar{rcvdsyn} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{outsegs} \;\tsvar{oq} \;\tsvar{cb}_{0} \;\tsunknown{cb\_in} (\tsvar{cb}',\tsvar{oq}')}
}
{}
}

\newcommand{\defnenqueueTeachTandTignoreTfail}{\ddefnn{enqueueTeachTandTignoreTfail}{\iA{enqueue\_each\_and\_ignore\_fail}}{\subddefnA[{ version of above that ignores errors and doesn't touch the tcpcb }]{enqueue\_each\_and\_ignore\_fail}{(\tsaux{enqueue\_each\_and\_ignore\_fail} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} [\,] \tsvar{oq} \;\tsvar{oq}' = (\tsvar{oq} = \tsvar{oq}')) \Mwedge {}\\{}
 (\tsaux{enqueue\_each\_and\_ignore\_fail} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} (\tsunknown{seg}\Mcons \tsunknown{segs}) \tsvar{oq} \;\tsvar{oq}''{}\\{}
 = \exists \tsvar{oq}'. \tsaux{enqueue\_and\_ignore\_fail} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} [\tsunknown{seg}] \tsvar{oq} \;\tsvar{oq}' \Mwedge {}\\{}
\quad\quad\quad\quad \tsaux{enqueue\_each\_and\_ignore\_fail} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{segs} \;\tsvar{oq}' \;\tsvar{oq}'')}
}
{}
}

\newcommand{\defnmliftTtcpToutputTperhapsTorTfail}{\ddefnn{mliftTtcpToutputTperhapsTorTfail}{\iA{mlift\_tcp\_output\_perhaps\_or\_fail}}{\subddefnA[{ do mliftc for function returning at most one segment and not dealing with queueing flag }]{mlift\_tcp\_output\_perhaps\_or\_fail}{\tsaux{mlift\_tcp\_output\_perhaps\_or\_fail} \;\tsunknown{ts\_val} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds}_{0} ={}\\{}
 \tsaux{mliftc} (\lambda  \tsvar{s} (\tsvar{s}',\tsunknown{outsegs'}).{}\\{}
\quad\quad\quad\quad \exists \tsvar{s}_{1} \;\tsvar{segs}.{}\\{}
\quad\quad\quad\quad \tsaux{tcp\_output\_perhaps} \;\tsvar{s} (\tsvar{s}_{1},\tsvar{segs}) \Mwedge {}\\{}
\quad\quad\quad\quad \Mcase  \;\tsvar{segs} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad [\,]       \Mtotype  \tsvar{s}' = \tsvar{s}_{1} \Mwedge  \tsunknown{outsegs'} = [\,]{}\\{}
\quad\quad\quad\quad \Mdpipe  [\tsunknown{seg}]    \Mtotype  (\exists \tsvar{cb}' \;\tsvar{es}'.  \tscomm{ ignore error return }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{rollback\_tcp\_output} \;\Mtrue  \;\tsunknown{seg} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds}_{0} \;\Mfalse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscomm{ X (tcp\textunderscore{}sock\textunderscore{}of s).cb X } (\tsaux{tcp\_sock\_of} \;\tsvar{s}_{1}).\tsvar{cb} (\tsvar{cb}',\tsvar{es}',\tsunknown{outsegs'}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{s}' = \tsvar{s}_{1} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsaux{tcp\_sock\_of} \;\tsvar{s}_{1} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}' \Mmagicrrec ) \Mmagicrrec ){}\\{}
\quad\quad\quad\quad \Mdpipe  \tsunknown{\_other58} \Mtotype  \tsunknown{ASSERTION\_FAILURE} \text{``mlift\textunderscore{}tcp\textunderscore{}output\textunderscore{}perhaps\textunderscore{}or\textunderscore{}fail''}  \tscomm{ never happen }{}\\{}
\quad\quad\quad )}
}
{}
}

\newcommand{\defnFIXMEstreamTmliftTtcpToutputTperhapsTorTfail}{\ddefnn{FIXMEstreamTmliftTtcpToutputTperhapsTorTfail}{\iA{FIXMEstream\_mlift\_tcp\_output\_perhaps\_or\_fail}}{\subddefnA[{ do mliftc for function returning at most one segment and not dealing with queueing flag }]{FIXMEstream\_mlift\_tcp\_output\_perhaps\_or\_fail}{\tsaux{FIXMEstream\_mlift\_tcp\_output\_perhaps\_or\_fail} \tscomm{ X ts\textunderscore{}val X } \tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds}_{0} \;\tsunknown{s} (\tsunknown{s'},\tsvar{FIN}) ={}\\{}
\quad\quad\quad\quad \exists \tsvar{s}_{1} \;\tsvar{FINs}.{}\\{}
\quad\quad\quad\quad \tsaux{FIXMEstream\_tcp\_output\_perhaps} \;\tsunknown{s} (\tsvar{s}_{1},\tsvar{FINs}) \Mwedge {}\\{}
\quad\quad\quad\quad \Mcase  \;\tsvar{FINs} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad *       \Mtotype  \tsunknown{s'} = \tsvar{s}_{1} \Mwedge  \tsvar{FIN} = \Mfalse {}\\{}
\quad\quad\quad\quad \Mdpipe  \Msome  \;\tsvar{FIN}'  \Mtotype  (\exists \tsvar{cb}' \;\tsvar{es}' \;\tsvar{outsegs}'.  \tscomm{ ignore error return }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{FIXMEstream\_rollback\_tcp\_output} \;\Mtrue  (\tsvar{s}_{1}.\tsvar{is}_{1},\tsvar{s}_{1}.\tsvar{is}_{2}) \tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds}_{0}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscomm{ X (tcp\textunderscore{}sock\textunderscore{}of s).cb X } (\tsaux{tcp\_sock\_of} \;\tsvar{s}_{1}).\tsvar{cb} (\tsvar{cb}',\tsvar{es}',\tsvar{outsegs}') \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{s'} = \tsvar{s}_{1} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsaux{tcp\_sock\_of} \;\tsvar{s}_{1} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}' \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{FIN} = (\tsvar{outsegs}' \Mwedge  \tsvar{FIN}') \tsholcomm{ possibly too deterministic FIXME could just assume FIN = FIN' })}
}
{}
}

\newcommand{\seccommtcpTincomingTsegment}{\clustersection{(TCP only)}{Incoming Segment Functions}
\seccomm{
Updates performed to the idle, keepalive, and \wasverb{FIN\textunderscore{}WAIT\textunderscore{}2} timers for
every incoming segment.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{update\_idle}$
&
&  Do updates appropriate to receiving a new segment on a connection \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnupdateTidle}{\ddefnn{updateTidle}{\iA{update\_idle}}{\subddefnA[{ Do updates appropriate to receiving a new segment on a connection }]{update\_idle}{\tsaux{update\_idle} \;\tsunknown{tcp\_sock} \;\tsunknown{tt\_keep'} ={}\\{}
 \tsholop{choose} \;\tsunknown{tf\_needfin} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
 \tsunknown{tt\_keep'} = (\Mif  \neg{}(\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge  \tsunknown{tf\_needfin}) \Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ reset keepalive timer to 2 hours. }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Msome  (\Mtimed{()}{\tsunknown{slow\_timer} \;\tsunknown{TCPTV\_KEEP\_IDLE}}){}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_keep})}
}
{}
}

\newcommand{\seccommtcpTdropTsegment}{\clustersection{(TCP only)}{Drop Segment Functions}
\seccomm{
When an erroneous or unexpected segment arrives, it is usually dropped
(i.e, ignored).  However, the peer is usually informed immediately by
means of a RST or ACK segment.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{dropwithreset}$
&
&  emit a RST segment corresponding to the passed segment, unless that would be stupid. \\
$\tsrule{FIXMEstream\_mlift\_dropafterack\_or\_fail}$
&
&  send immediate ACK to segment, but otherwise process it no further \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defndropwithreset}{\ddefnn{dropwithreset}{\iA{dropwithreset}}{\subddefnA[{ emit a RST segment corresponding to the passed segment, unless that would be stupid. }]{dropwithreset}{\tsaux{dropwithreset} \;\tsunknown{segRST} (\tsvar{is}_{1},\tsvar{is}_{2}) \tsvar{ifds}_{0} \;\tsvar{RST} ={}\\{}
 \tsholcomm{ Needs list of the host's interfaces, to verify that the incoming segment wasn't broadcast.
   Returns a list of segments. }{}\\{}
 {}\\{}
 \Mif   \tscomm{ never RST a RST }{}\\{}
\quad \tsunknown{segRST} \Mvee {}\\{}
\quad \tscomm{ is segment a (link-layer?) broadcast or multicast? }{}\\{}
\quad \Mfalse  \Mvee {}\\{}
\quad \tscomm{ is source or destination broadcast or multicast? }{}\\{}
\quad (\exists \tsvar{i}_{1}. \tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsunknown{is\_broadormulticast} \;\emptyset  \;\tsvar{i}_{1}) \Mvee {}\\{}
\quad (\exists \tsvar{i}_{2}. \tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsunknown{is\_broadormulticast} \;\tsvar{ifds}_{0} \;\tsvar{i}_{2}){}\\{}
\quad\quad \tscomm{ BSD only checks incoming interface, but should have same effect as long as interfaces don't overlap }{}\\{}
 \Mthen {}\\{}
\quad \tsvar{RST} = \Mfalse {}\\{}
 \Melse {}\\{}
\quad \tsvar{RST} \;\in  \{\Mtrue ;\Mfalse \}}
}
{}
}

\newcommand{\defnFIXMEstreamTmliftTdropafterackTorTfail}{\ddefnn{FIXMEstreamTmliftTdropafterackTorTfail}{\iA{FIXMEstream\_mlift\_dropafterack\_or\_fail}}{\subddefnA[{ send immediate ACK to segment, but otherwise process it no further }]{FIXMEstream\_mlift\_dropafterack\_or\_fail}{\tsaux{FIXMEstream\_mlift\_dropafterack\_or\_fail} \;\tsunknown{segRST} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{sock} (\tsunknown{sock'},\tsvar{FIN},\tsvar{RST},\tsunknown{stop'}) ={}\\{}
 \tsholcomm{    $\tsvar{ifds}$ is just in case we need to send a RST, to make sure we don't
   send it to a broadcast address. }{}\\{}
 \Mlet  \;\tsunknown{continue} = \neg{} \tsunknown{stop'} \;\Min {}\\{}
 \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsunknown{sock} \;\Min {}\\{}
 (\tsunknown{continue} = \Mtrue  \Mwedge {}\\{}
 \Mlet  \;\tsvar{cb} = \tsunknown{tcp\_sock}.\tsvar{cb} \;\Min {}\\{}
 \tsholop{choose} \;\tsunknown{ACK} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
 \tsholop{choose} \;\tsunknown{ack\_lt\_snd\_una\_or\_snd\_max\_lt\_ack} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
 \Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge {}\\{}
\quad \tsunknown{ACK} \Mwedge {}\\{}
\quad \tsunknown{ack\_lt\_snd\_una\_or\_snd\_max\_lt\_ack}{}\\{}
 \Mthen {}\\{}
\quad\quad \tsholcomm{ break loop in "LAND" DoS attack, and also prevent ACK
            storm between two listening ports that have been sent
            forged SYN segments, each with the source address of
            the other. (\wasverb{tcp\textunderscore{}input.c:2141}) }{}\\{}
\quad\quad \tsunknown{sock'} = \tsunknown{sock} \Mwedge {}\\{}
\quad\quad \tsvar{FIN} = \Mfalse  \Mwedge {}\\{}
\quad\quad \tsaux{dropwithreset} \;\tsunknown{segRST} (\tsunknown{sock}.\tsvar{is}_{1},\tsunknown{sock}.\tsvar{is}_{2}) \tsvar{ifds} \;\tsvar{RST}{}\\{}
\quad\quad\quad\quad \tscomm{ ignore queue full error }{}\\{}
 \Melse {}\\{}
\quad\quad (\exists  \tsvar{sock}_{1} \;\tsvar{msgFIN}.  \tscomm{ ignore errors }{}\\{}
\quad\quad \Mlet  \;\tsunknown{tcp\_sock1} = \tsaux{tcp\_sock\_of} \;\tsvar{sock}_{1} \;\Min {}\\{}
\quad\quad \tsaux{FIXMEstream\_tcp\_output\_really} \;\tsunknown{sock} (\tsvar{sock}_{1},\tsvar{msgFIN}) \Mwedge   \tsholcomm{ did set $\tsunknown{tf\_acknow}$ and call $\tsaux{tcp\_output\_perhaps}$, which seemed a bit silly }{}\\{}
\quad\quad \tsholcomm{ notice we here bake in the assumption that the timestamps use the same counter as the band limiter; perhaps this is unwise }{}\\{}
\quad\quad \exists  \tsvar{outsegs}' \;\tsvar{cb}' \;\tsvar{es}'.{}\\{}
\quad\quad \tsaux{FIXMEstream\_rollback\_tcp\_output} \;\Mtrue  (\tsunknown{sock}.\tsvar{is}_{1},\tsunknown{sock}.\tsvar{is}_{2}) \tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{tcp\_sock1}.\tsvar{cb} (\tsvar{cb}',\tsvar{es}',\tsvar{outsegs}') \Mwedge {}\\{}
\quad\quad \tsunknown{sock'} = \tsvar{sock}_{1} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock1} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}' \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad \tsvar{FIN} = (\Mif  \;\tsvar{outsegs}' \;\Mthen  \;\tsvar{msgFIN} \;\Melse  \;\Mfalse ) \Mwedge {}\\{}
\quad\quad \tsvar{RST} = \Mfalse ))}
}
{}
}

\newcommand{\seccommtcpTclose}{\clustersection{(TCP only)}{Close Functions}
\seccomm{
Closing a connection, updating the socket and TCP control block
appropriately.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{tcp\_close}$
&
&  close the socket and remove the TCPCB \\
$\tsrule{tcp\_drop\_and\_close}$
&
&  drop TCP connection, reporting the specified error.  If synchronised, send RST to peer \\
$\tsrule{exists\_quad\_of}$
&
& \\
$\tsrule{quad\_of}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntcpTclose}{\ddefnc{tcpTclose}{\iA{tcp\_close}}{\subddefnA[{ close the socket and remove the TCPCB }]{tcp\_close}{\tsaux{tcp\_close} \;\tsvar{arch} \;\tsunknown{sock} = \tsunknown{sock} \;{}\\{}
 \Mmagiclrec  \tsvar{cantrcvmore} \Mass  \Mtrue ; \tscomm{ MF doesn't believe this is correct for Linux or WinXP }{}\\{}
 \tsvar{cantsndmore} \Mass  \Mtrue ;{}\\{}
 \tsvar{is}_{1} \Mass  \Mif  \;\tsunknown{bsd\_arch} \;\tsvar{arch} \;\Mthen  \;* \;\Melse  \;\tsunknown{sock}.\tsvar{is}_{1};{}\\{}
 \tsvar{ps}_{1} \Mass  \Mif  \;\tsunknown{bsd\_arch} \;\tsvar{arch} \;\Mthen  \;* \;\Melse  \;\tsunknown{sock}.\tsvar{ps}_{1};{}\\{}
 \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsaux{tcp\_sock\_of} \;\tsunknown{sock} \;{}\\{}
 \Mmagiclrec  \tsvar{st} \Mass  \tscon{CLOSED};{}\\{}
 \tsvar{cb} \Mass  \tsaux{initial\_cb} \tslongcomm{ X with (* in reality, it's dropped entirely, but we don't do that *)
                  \textless{}| bsd\textunderscore{}cantconnect := if bsd\textunderscore{}arch arch then T else F |\textgreater{} X } ;{}\\{}
 \tsvar{sndq} \Mass  [\,] \Mmagicrrec ){}\\{}
 \Mmagicbolrrec }
}
{\rulesubsection{Description}
   This is similar to BSD's \wasverb{tcp\textunderscore{}close()}, except
   that we do not actually remove the protocol/control blocks. The quad of the socket is
   cleared, to enable another socket to bind to the port we were previously using --- this
   isn't actually done by BSD, but the effect is the same. The $\tsunknown{bsd\_cantconnect}$ flag is
   set to indicate that the socket is in such a detached state.
\rrulepad }
}

\newcommand{\defntcpTdropTandTclose}{\ddefnc{tcpTdropTandTclose}{\iA{tcp\_drop\_and\_close}}{\subddefnA[{ drop TCP connection, reporting the specified error.  If synchronised, send RST to peer }]{tcp\_drop\_and\_close}{\tsaux{tcp\_drop\_and\_close} \;\tsvar{arch} \;\tsunknown{err} \;\tsunknown{sock} (\tsunknown{sock'},(\tsunknown{oflgs},\tsunknown{odata}:\tsunknown{char} \;\tstype{list})) ={}\\{}
 \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsunknown{sock} \;\Min  ({}\\{}
 (\Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} \;\notin  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT}\} \Mthen {}\\{}
\quad\quad (\tsunknown{oflgs} = \tsunknown{oflgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{FIN} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mtrue  \Mmagicrrec  \Mwedge {}\\{}
\quad\quad \tsunknown{odata} \;\in  \;\tsunknown{UNIV}){}\\{}
\quad \Melse {}\\{}
\quad\quad (\tsunknown{oflgs} = \tsunknown{oflgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{FIN} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Mwedge {}\\{}
\quad\quad \tsunknown{odata} = [\,])) \Mwedge {}\\{}
 \Mlet  \;\tsvar{es}' ={}\\{}
 \Mif  \;\tsunknown{err} = \Msome  \;\tsunknown{ETIMEDOUT} \;\Mthen {}\\{}
\quad (\Mif  \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{t\_softerror} \neq  * \;\Mthen {}\\{}
\quad\quad \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{t\_softerror}{}\\{}
\quad \Melse {}\\{}
\quad\quad \Msome  \;\tsunknown{ETIMEDOUT}){}\\{}
 \Melse  \;\Mif  \;\tsunknown{err} \neq  * \;\Mthen  \;\tsunknown{err}{}\\{}
 \Melse  \;\tsunknown{sock}.\tsvar{es}{}\\{}
 \Min {}\\{}
 \tsunknown{sock'} = \tsaux{tcp\_close} \;\tsvar{arch} (\tsunknown{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}' \Mmagicrrec ))}
}
{\rulesubsection{Description}
 BSD calls this \wasverb{tcp\textunderscore{}drop}
\rrulepad }
}

\newcommand{\defnexistsTquadTof}{\ddefnn{existsTquadTof}{\iA{exists\_quad\_of}}{\subddefnA{exists\_quad\_of}{\tsaux{exists\_quad\_of} (\tsunknown{sock}:\tsunknown{TCP3\_hostTypes}\;\tsunknown{\$socket}) = \exists  \tsvar{i}_{1} \;\tsvar{p}_{1} \;\tsvar{i}_{2} \;\tsvar{p}_{2}. (\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2}) = (\tsunknown{sock}.\tsvar{is}_{1},\tsunknown{sock}.\tsvar{ps}_{1},\tsunknown{sock}.\tsvar{is}_{2},\tsunknown{sock}.\tsvar{ps}_{2})}
}
{}
}

\newcommand{\defnquadTof}{\ddefnn{quadTof}{\iA{quad\_of}}{\subddefnA{quad\_of}{\tsaux{quad\_of} (\tsunknown{sock}:\tsunknown{TCP3\_hostTypes}\;\tsunknown{\$socket}) = (\tsholop{THE} \;\tsunknown{sock}.\tsvar{is}_{1},\tsholop{THE} \;\tsunknown{sock}.\tsvar{ps}_{1},\tsholop{THE} \;\tsunknown{sock}.\tsvar{is}_{2},\tsholop{THE} \;\tsunknown{sock}.\tsvar{ps}_{2})}
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPITauxFns}
\showrule{\defnFIXMEstreamTtestToutroute}
\showrule{\defnFIXMEstreamTloopbackTonTwire}
\showrule{\seccommauxTfiles}
\showrule{\defnsaneTsocket}
\showrule{\seccommauxTbinding}
\showrule{\defnboundTportsTprotocolTautobind}
\showrule{\defnboundTportTallowed}
\showrule{\defnautobind}
\showrule{\defnboundTafter}
\showrule{\defnmatchTscore}
\showrule{\defnlookupTudp}
\showrule{\defntcpTsocketTbestTmatch}
\showrule{\defnlookupTicmp}
\showrule{\seccommmiscTaux}
\showrule{\defndoTtcpToptions}
\showrule{\defncalculateTtcpToptionsTlen}
\showrule{\seccommauxTbuffers}
\showrule{\defncalculateTbufTsizes}
\showrule{\defnsendTqueueTspace}
\showrule{\seccommauxTbandlim}
\showrule{\defnbandlimTstateTinit}
\showrule{\defnbandlimTrstTokTalways}
\showrule{\defnsimpleTlimit}
\showrule{\defnbandlimTrstTokTsimple}
\showrule{\defnbandlimTrstTok}
\showrule{\defnenqueueToqTbndlimTrst}
\showrule{\seccommauxTudp}
\showrule{\defndosend}
\showrule{\seccommauxTtcptime}
\showrule{\defntcpTbackoffs}
\showrule{\defntcpTsynTbackoffs}
\showrule{\defnshiftTof}
\showrule{\defnexpandTcwnd}
\showrule{\seccommauxTpmtu}
\showrule{\defnnextTsmaller}
\showrule{\defnmtuTtab}
\showrule{\seccommauxTreass}
\showrule{\seccomminitialTcb}
\showrule{\defninitialTcb}
\showrule{\chapcommTCPITauxFnsTrelmonad}
\showrule{\seccommauxTrelmonad}
\showrule{\defnandThen}
\showrule{\defncont}
\showrule{\defnstop}
\showrule{\defnassert}
\showrule{\defnassertTfailure}
\showrule{\defnchooseM}
\showrule{\defngetTsock}
\showrule{\defngetTtcpTsock}
\showrule{\defngetTcb}
\showrule{\defnmodifyTsock}
\showrule{\defnmodifyTtcpTsock}
\showrule{\defnmodifyTcb}
\showrule{\defnemitTsegs}
\showrule{\defnemitTsegsTpred}
\showrule{\defnmliftc}
\showrule{\defnmliftcTbndlm}
\showrule{\chapcommTCPmajorAuxFns}
\showrule{\seccommtcpTsynTrstTsegmentTcreation}
\showrule{\defnmakeTsynTsegment}
\showrule{\defnmakeTsynTackTsegment}
\showrule{\defnmakeTackTsegment}
\showrule{\defnbsdTmakeTphantomTsegment}
\showrule{\defnmakeTrstTsegmentTfromTcb}
\showrule{\defnmakeTrstTsegmentTfromTseg}
\showrule{\seccommtcpTsegmentTcreation}
\showrule{\defntcpToutputTrequired}
\showrule{\defntcpToutputTreally}
\showrule{\defnFIXMEstreamTtcpToutputTreally}
\showrule{\defntcpToutputTperhaps}
\showrule{\defnFIXMEstreamTtcpToutputTperhaps}
\showrule{\seccommtcpTsegmentTqueueing}
\showrule{\defnrollbackTtcpToutput}
\showrule{\defnFIXMEstreamTrollbackTtcpToutput}
\showrule{\defnenqueueTorTfail}
\showrule{\defnFIXMEstreamTenqueueTorTfail}
\showrule{\defnFIXMEstreamTenqueueTorTfailTsock}
\showrule{\defnenqueueTandTignoreTfail}
\showrule{\defnenqueueTeachTandTignoreTfail}
\showrule{\defnmliftTtcpToutputTperhapsTorTfail}
\showrule{\defnFIXMEstreamTmliftTtcpToutputTperhapsTorTfail}
\showrule{\seccommtcpTincomingTsegment}
\showrule{\defnupdateTidle}
\showrule{\seccommtcpTdropTsegment}
\showrule{\defndropwithreset}
\showrule{\defnFIXMEstreamTmliftTdropafterackTorTfail}
\showrule{\seccommtcpTclose}
\showrule{\defntcpTclose}
\showrule{\defntcpTdropTandTclose}
\showrule{\defnexistsTquadTof}
\showrule{\defnquadTof}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP3\protect\textunderscore hostLTS

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
% TCP3_hostLTSScript.sml:15476:-1-15480:6:    WARNING: Old-style rule comment
\def\rulesrcsid{\$Id: Spec3_alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommprelimChapFIXME}{\chaptersection{ Prelim hostLTS stuff}
\label{prelimChapFIXME}%
\chapcomm{}
}

\newcommand{\seccommpreliminaryFIXME}{\clustersection{(TCP only)}{}
\seccomm{    This text is ignored.

}\clustersubsection{Rules}
~}

\newcommand{\defnsoreadable}{\ddefnc{soreadable}{\iA{soreadable}}{\subddefnA[{ check whether a socket is readable }]{soreadable}{\tsaux{soreadable} \;\tsvar{arch} \;\tsunknown{sock} ={}\\{}
 \Mcase  \;\tsunknown{sock}.\tsvar{pr} \;\Mof {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp}) \Mtotype {}\\{}
\quad (\tsholop{LENGTH} \;\tsunknown{tcp}.\tsvar{rcvq} \geq  \tsunknown{sock}.\tsvar{sf}.\tsunknown{n}(\tscon{SO\_RCVLOWAT}) \Mvee {}\\{}
\quad \tsunknown{sock}.\tsvar{cantrcvmore} \Mvee {}\\{}
\quad (\tsunknown{linux\_arch} \;\tsvar{arch} \Mwedge  \tsunknown{tcp}.\tsvar{st} = \tscon{CLOSED}) \Mvee {}\\{}
\quad (\tsunknown{tcp}.\tsvar{st} = \tscon{LISTEN} \Mwedge {}\\{}
\quad\quad \exists \tsvar{lis}. \tsunknown{tcp}.\tsvar{lis} = \Msome  \;\tsvar{lis} \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{lis}.\tsunknown{q} \neq  [\,]) \Mvee {}\\{}
\quad \tsunknown{sock}.\tsvar{es} \neq  *) \Mdpipe {}\\{}
 \tscon{UDP\_PROTO}(\tsunknown{udp}) \Mtotype {}\\{}
\quad (\tsunknown{udp}.\tsvar{rcvq} \neq  [\,] \Mvee  \tsunknown{sock}.\tsvar{es} \neq  * \Mvee  (\tsunknown{sock}.\tsvar{cantrcvmore} \Mwedge  \neg{}\tsunknown{windows\_arch} \;\tsvar{arch}))}
}
{\rulesubsection{Description}

A TCP socket $\tsunknown{sock}$ is readable if: (1) the length of its receive queue is greater than or equal
to the minimum number of bytes for socket input operations, $\tsvar{sf}.\tsunknown{n}(\tscon{SO\_RCVLOWAT})$; (2) it has been
shut down for reading; (3) on Linux, it is in the $\tscon{CLOSED}$ state; it is in the $\tscon{LISTEN}$ state
and has at least one connection on its completed connection queue; or (4) it has a pending error.

A UDP socket $\tsunknown{sock}$ is readable if its receive queue is not empty, it has a pending error, or it
has been shutdown for reading.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
On all OSes, attempting to read from a closed socket yields an immediate error.  Only on Linux,
however, does $\tsaux{soreadable}$ return $\Mtrue $ in this case.

\\\hline
WinXP
&
The socket will not be readable if it has been shutdown for reading.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\defnsowriteable}{\ddefnc{sowriteable}{\iA{sowriteable}}{\subddefnA[{ check whether a socket is writable }]{sowriteable}{\tsaux{sowriteable} \;\tsvar{arch} \;\tsunknown{sock} ={}\\{}
 \Mcase  \;\tsunknown{sock}.\tsvar{pr} \;\Mof {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp}) \Mtotype {}\\{}
\quad ((\tsunknown{tcp}.\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{CLOSE\_WAIT}\} \Mwedge {}\\{}
\quad\quad \tsunknown{sock}.\tsvar{sf}.\tsunknown{n}(\tscon{SO\_SNDBUF}) - \tsholop{LENGTH} \;\tsunknown{tcp}.\tsvar{sndq}  \geq  \tsunknown{sock}.\tsvar{sf}.\tsunknown{n}(\tscon{SO\_SNDLOWAT})) \Mvee  \tscomm{ change to send\textunderscore{}buffer\textunderscore{}space }{}\\{}
\quad (\Mif  \;\tsunknown{linux\_arch} \;\tsvar{arch} \;\Mthen  \neg{}\tsunknown{sock}.\tsvar{cantsndmore} \;\Melse  \;\tsunknown{sock}.\tsvar{cantsndmore}) \Mvee {}\\{}
\quad (\tsunknown{linux\_arch} \;\tsvar{arch} \Mwedge  \tsunknown{tcp}.\tsvar{st} = \tscon{CLOSED}) \Mvee {}\\{}
\quad \tsunknown{sock}.\tsvar{es} \neq  *) \Mdpipe {}\\{}
 \tscon{UDP\_PROTO}(\tsunknown{udp}) \Mtotype  \Mtrue }
}
{\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
On all OSes, attempting to write to a closed socket yields an immediate error.  Only on Linux,
however, does $\tsaux{sowriteable}$ return $\Mtrue $ in this case.

On Linux, if the outgoing half of the connection has been closed by the application, the socket
becomes non-writeable, whereas on other OSes it becomes writeable (because an immediate error would
result from writing).

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\chapcommsocketTcalls}{\chaptersection{ Host LTS: Socket Calls}
\label{socket_calls}%
\chapcomm{}
}

\newcommand{\seccommaccept}{\clustersection{(TCP only)}{$\tsunknown{accept}()$}
\seccomm{ \[ \tsunknown{accept}: \tsunknown{fd} \Mtotype  \tsunknown{fd} * (\tsunknown{ip} * \tsunknown{port}) \]

  $\tsunknown{accept}(\tsunknown{fd})$ returns the next connection available on the completed connections queue for the
  listening TCP socket referenced by file descriptor $\tsunknown{fd}$.  The returned file descriptor $\tsunknown{fd}$
  refers to the newly-connected socket; the returned $\tsunknown{ip}$ and $\tsunknown{port}$ are its remote address.
  $\tsunknown{accept}()$ blocks if the completed connections queue is empty and the socket does not have the
  $\tscon{O\_NONBLOCK}$ flag set.

  Any pending errors on the new connection are ignored, except for $\tsunknown{ECONNABORTED}$ which causes
  $\tsunknown{accept}()$ to fail with $\tsunknown{ECONNABORTED}$.

  Calling $\tsunknown{accept}()$ on a UDP socket fails: UDP is not a connection-oriented protocol.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{accept}()$ can fail with the errors below, in which case the corresponding exception
  is raised:

\par\begin{ltstabular}
$\tsunknown{EAGAIN}$
&  The socket has the $\tscon{O\_NONBLOCK}$ flag set and no connections are available on
  the completed connections queue.

\\\hline
$\tsunknown{ECONNABORTED}$
&  The connection at the head of the completed connections queue has been
  aborted; the socket has been shutdown for reading; or the socket has been closed.

\\\hline
$\tsunknown{EINVAL}$
&  Ths socket is not accepting connections, \ie,  it is not in the $\tscon{LISTEN}$ state,
  or is a UDP socket.

\\\hline
$\tsunknown{EMFILE}$
&  The maximum number of file descriptors allowed per process are already open for
  this process.

\\\hline
$\tsunknown{EOPNOTSUPP}$
&  The socket type of the specified socket does not support accepting
  connections. This error is raised if $\tsunknown{accept}()$ is called on a UDP socket.

\\\hline
$\tsunknown{ENFILE}$
&  Out of resources.


\\\hline
$\tsunknown{ENOBUFS}$
&  Out of resources.

\\\hline
$\tsunknown{ENOMEM}$
&  Out of resources.

\\\hline
$\tsunknown{EINTR}$
&  The system was interrupted by a caught signal.

\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsunknown{accept}()$ is called and immediately returns a connection: $\tsunknown{accept\_1}$; $\tsunknown{return\_1}$

  $\tsunknown{accept}()$ is called and blocks; a connection is completed and the call returns: $\tsunknown{accept\_2}$;
  $\tsunknown{deliver\_in\_99}$; $\tsunknown{deliver\_in\_1}$; $\tsunknown{accept\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:  &  \wasverb{int accept(int socket, struct sockaddr *restrict address,} \\
            &  \wasverb{           socklen\textunderscore{}t *restrict address\textunderscore{}len);} \\
    FreeBSD:&  \wasverb{int accept(int s, struct sockaddr *addr, socklen\textunderscore{}t *addrlen);} \\
    Linux:  &  \wasverb{int accept(int s, struct sockaddr *addr, socklen\textunderscore{}t *addrlen);} \\
    WinXP:  &  \wasverb{SOCKET accept(SOCKET s, struct sockaddr* addr, int* addrlen);} \\
  \end{tabular}\\

  In the Posix interface:
  \begin{itemize}

    \item \wasverb{socket} is the listening socket's file descriptor, corresponding to the $\tsunknown{fd}$
     argument of the model;

    \item the returned \wasverb{int} is either non-negative, \ie,  a file descriptor referring to the
     newly-connected socket, or \wasverb{-1} to indicate an error, in which case the error code is
     in \wasverb{errno}.  On WinXP an error is indicated by a return value of
     \wasverb{INVALID\textunderscore{}SOCKET}, not \wasverb{-1}, with the actual error code available through a
     call to \wasverb{WSAGetLastError()}.

    \item \wasverb{address} is a pointer to a \wasverb{sockaddr} structure of length
    \wasverb{address\textunderscore{}len} corresponding to the $\tsunknown{ip}*\tsunknown{port}$ returned by the model $\tsunknown{accept}()$. If
    \wasverb{address} is not a null pointer then it stores the address of the peer for the accepted
    connection. For the model $\tsunknown{accept}()$ it will actually be a \wasverb{sockaddr\textunderscore{}in} structure;
    the peer IP address will be stored in the \wasverb{sin\textunderscore{}addr.s\textunderscore{}addr} field, and the peer port
    will be stored in the \wasverb{sin\textunderscore{}port} field. If \wasverb{address} is a null pointer then the
    peer address is ignored, but the model $\tsunknown{accept}()$ always returns the peer address. On input
    the \wasverb{address\textunderscore{}len} is the length of the \wasverb{address} structure, and on output it is
    the length of the stored address.

  \end{itemize}


}\clustersubsection{Model details}
\seccomm{
  If the $\tsunknown{accept}()$ call blocks then state $\tscon{Accept2}(\tsunknown{sid})$ is entered, where $\tsunknown{sid}$ is the index
  of the socket that $\tsunknown{accept}()$ was called upon.

  The following errors are not included in the model:
  \begin{itemize}

    \item \wasverb{EFAULT} signifies that the pointers passed as either the \wasverb{address} or
     \wasverb{address\textunderscore{}len} arguments were inaccessible.  This is an artefact of the C interface to
     $\tsunknown{accept}()$ that is excluded by the clean interface used in the model.

    \item \wasverb{EPERM} is a Linux-specific error code described by the Linux man page as
     "Firewall rules forbid connection". This is outside the scope of what is modelled.

    \item \wasverb{EPROTO} is a Linux-specific error code described by the man page as "Protocol
     error". Only TCP and UDP are modelled here; the only sockets that can exist in the model are
     bound to a known protocol.

    \item \wasverb{WSAECONNRESET} is a WinXP-specific error code described in the MSDN page as "An
    incoming connection was indicated, but was subsequently terminated by the remote peer prior to
    accepting the call." This error has not been encountered in exhaustive testing.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


  From the Linux man page:
       Linux $\tsunknown{accept}()$ passes already-pending network errors on the new socket as
       an error code from accept.  This behaviour differs from other BSD socket implementations.
       For reliable operation the application should detect the network errors defined for the
       protocol after accept and treat them like EAGAIN by retrying. In case of TCP/IP these are
       ENETDOWN, EPROTO, ENOPROTOOPT, EHOSTDOWN, ENONET, EHOSTUNREACH, EOPNOTSUPP, and
       ENETUNREACH.

       This is currently not modelled, but will be looked at when the Linux semantics are
       investigated.



}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{accept\_1}$
& \textbf{tcp: rc}
&  Return new connection; either immediately or from a blocked state. \\
$\tsrule{accept\_2}$
& \textbf{tcp: block}
&  Block waiting for connection \\
$\tsrule{accept\_3}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{EAGAIN}$: no pending connections and non-blocking
     semantics set \\
$\tsrule{accept\_4}$
& \textbf{tcp: rc}
&  Fail with $\tsunknown{ECONNABORTED}$: the listening socket has $\tsvar{cantsndmore}$ set
     or has become $\tscon{CLOSED}$. Returns either immediately or from a blocked state. \\
$\tsrule{accept\_5}$
& \textbf{tcp: rc}
&  Fail with $\tsunknown{EINVAL}$: socket not in LISTEN state \\
$\tsrule{accept\_6}$
& \textbf{tcp: rc}
&  Fail with $\tsunknown{EMFILE}$: out of file descriptors \\
$\tsrule{accept\_7}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{EOPNOTSUPP}$ or $\tsunknown{EINVAL}$: $\tsunknown{accept}()$ called on
     a UDP socket \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\acceptTI}{\rrulecc{acceptTI}{accept\_1}{tcp: rc}{\tsholcomm{ Return new connection; either immediately or from a blocked state. }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{t}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds};{}\\{}
 \tsvar{files} \Mass  \tsvar{files};{}\\{}
 \tsvar{socks} \Mass {}\\{}
 \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid} ,\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis},[\,],[\,])));{}\\{}
 (\tsvar{sid}',\tscon{Sock}(*,\tsvar{sf}',\Msome  \;\tsvar{i}'_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es}',\tsvar{cantsndmore}',\tsvar{cantrcvmore}',{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{ESTABLISHED},\tsvar{cb}',*,\tsvar{sndq},\tsvar{rcvq})))] \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \tsvar{lbl} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsvar{fd}',(\tsvar{i}_{2},\tsvar{p}_{2})))}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}';{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus  [(\tsvar{fid}',\tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}'),\tsunknown{ff\_default}))];{}\\{}
 \tsvar{socks} \Mass {}\\{}
 \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid} ,\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis}',[\,],[\,])));{}\\{}
 (\tsvar{sid}',\tscon{Sock}(\Msome  \;\tsvar{fid}',\tsvar{sf}',\Msome  \;\tsvar{i}'_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es}',{}\\{}
\quad\quad\quad\quad\quad \tsvar{cantsndmore}',\tsvar{cantrcvmore}', \tsaux{TCP\_Sock}(\tscon{ESTABLISHED},\tsvar{cb}',*,\tsvar{sndq},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{rcvq})))] \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mboxedor{\tsvar{t} = \tscon{Run} \Mwedge {}\\{}
 \tsvar{lbl} = \MLhcall{\tsvar{tid}}{(\tsunknown{accept} \;\tsvar{fd})} \Mwedge {}\\{}
 \tsvar{rc} = \tscon{fast} \;\tscon{succeed} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}}  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \Mfapply{\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}){}\\{}
 {}\\{}
 }{\tsvar{t} = \tscon{Accept2}(\tsvar{sid}) \Mwedge {}\\{}
\quad \tsvar{lbl} = \MLhtau  \Mwedge {}\\{}
\quad \tsvar{rc} = \tscon{slow} \;\tsunknown{urgent} \;\tscon{succeed}{}\\{}
 } \Mwedge {}\\{}
 {}\\{}
 \tsvar{lis}.\tsvar{q} = \Mappend{\tsvar{q}}{[\tsvar{sid}']} \Mwedge {}\\{}
 \tsvar{lis}'.\tsvar{q} = \tsvar{q} \Mwedge {}\\{}
 \tsvar{lis}'.\tsvar{q}_{0} = \tsvar{lis}.\tsvar{q}_{0} \Mwedge  \tsvar{lis}'.\tsunknown{qlimit} = \tsvar{lis}.\tsunknown{qlimit} \Mwedge  {}\\{}
 (\tsvar{sid} \neq  \tsvar{sid}') \Mwedge  {}\\{}
 \tsvar{es}' \neq  \Msome  \;\tsunknown{ECONNABORTED} \Mwedge  {}\\{}
 \tsvar{fid}' \;\notin  ((\Mfdom{\tsvar{files}}) \cup  \{\tsvar{fid}\}) \Mwedge {}\\{}
 \tsunknown{nextfd} \;\tsvar{h}.\tsvar{arch} \;\tsvar{fds} \;\tsvar{fd}' \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \oplus  (\tsvar{fd}', \tsvar{fid}') \Mwedge {}\\{}
 (\forall \tsvar{i}_{1}. \Msome  \;\tsvar{i}_{1} = \tsvar{is}_{1} \implies  \tsvar{i}_{1} = \tsvar{i}'_{1}) }
{\rulesubsection{Description}

   This rule covers two cases: (1) the completed connection queue is non-empty when $\tsunknown{accept}(\tsvar{fd})$ is
   called from a thread $\tsvar{tid}$ in the $\tscon{Run}$ state, where $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$,
   and (2) a previous call to $\tsunknown{accept}(\tsvar{fd})$ on socket $\tsvar{sid}$ blocked, leaving its calling thread
   $\tsvar{tid}$ in state $\tscon{Accept2}(\tsvar{sid})$, and a new connection has become available.

   In either case the listening TCP socket $\tsvar{sid}$ has a connection $\tsvar{sid}'$ at the head of its
   completed connections queue $\tsvar{sid}'\Mcons \tsvar{q}$. A socket entry for $\tsvar{sid}'$ already exists in the host's
   finite map of sockets, $\tsvar{socks}$$\oplus\dots$. The socket is $\tscon{ESTABLISHED}$, is not shutdown for
   reading, and is only missing a file description association that would make it accessible via the
   sockets interface.

   A new file description record is created for connection $\tsvar{sid}'$, indexed by a new $\tsvar{fid}'$, and
   this is added to the host's finite map of file descriptions $\tsvar{files}$.  It is assigned a default
   set of file flags, $\tsunknown{ff\_default}$. The socket entry $\tsvar{sid}'$ is completed with its file
   association $\Msome  \;\tsvar{fid}'$ and $\tsvar{sid}'$ is removed from the head of the completed connections
   queue.

   When the listening socket $\tsvar{sid}$ is bound to a local IP address $\tsvar{i}_{1}$, the accepted socket
   $\tsvar{sid}'$ is also bound to it.

   Finally, the new file descriptor $\tsvar{fd}'$ is created in an architecture-specific way using the
   auxiliary \ltslink{nextfd}{$\tsunknown{nextfd}$}, and an entry mapping $\tsvar{fd}'$ to $\tsvar{fid}'$ is added to the host's finite map
   of file descriptors.  If the calling thread was previously blocked in state $\tscon{Accept2}(\tsvar{sid})$ it
   proceeds via a $\MLhtau $ transition, otherwise by a $\MLhcall{\tsvar{tid}}{ (\tsunknown{accept} \;\tsvar{fd})}$ transition.
   The thread is left in state $\tscon{Ret} (\tscon{OK} (\tsvar{fd}',(\tsvar{i}_{2},\tsvar{p}_{2})))$ to return the file descriptor and remote
   address of the accepted connection in response to the original $\tsunknown{accept}()$ call.

   If the new socket $\tsvar{sid}'$ has error $\tsunknown{ECONNABORTED}$ pending in its error field $\tsvar{es}'$, this is
   handled by rule $\tsunknown{accept\_5}$. All other pending errors on $\tsvar{sid}'$ are ignored, but left as the
   socket's pending error.

\rrulepad }
}

\newcommand{\acceptTII}{\rrulecc{acceptTII}{accept\_2}{tcp: block}{\tsholcomm{ Block waiting for connection }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{(\tsunknown{accept} \;\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Accept2}(\tsvar{sid})}{\tsunknown{never\_timer}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) = \Mfalse  \Mwedge {}\\{}
 \tsvar{sid} \;\in  \Mfdom{\tsvar{h}.\tsvar{socks}} \Mwedge {}\\{}
 (\exists \tsvar{sf} \;\tsvar{is}_{1} \;\tsvar{p}_{1} \;\tsvar{cb} \;\tsvar{lis} \;\tsvar{es}.{}\\{}
\quad \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis},[\,],[\,])) \Mwedge {}\\{}
\quad \tsvar{lis}.\tsunknown{q} = [\,])}
{\rulesubsection{Description}

   A blocking $\tsunknown{accept}()$ call is performed on socket $\tsvar{sid}$ when no completed incoming
   connections are available. The calling thread blocks until a new connection attempt completes
   successfully, the call is interrupted, or the process runs out of file descriptors.

   From thread $\tsvar{tid}$, which is initially in the $\tscon{Run}$ state, $\tsunknown{accept}(\tsvar{fd})$ is called where
   $\tsvar{fd}$ refers to listening TCP socket $\tsvar{sid}$ which is bound to local port $\tsvar{p}_{1}$, is not
   shutdown for reading and is in blocking mode: $\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK})=\Mfalse $. The socket's queue of
   completed connections is empty, $\tsunknown{q} \Mass  [\,]$, hence the $\tsunknown{accept}()$ call blocks waiting for a
   successful new connection attempt, leaving the calling thread state $\tscon{Accept2}(\tsvar{sid})$.

   Socket $\tsvar{sid}$ might not be bound to a local IP address, i.e. $\tsvar{is}_{1}$ could be $*$. In this
   case the socket is listening for connection attempts on port $\tsvar{p}_{1}$ for all local IP addresses.

\rrulepad }
}

\newcommand{\acceptTIII}{\rrulecc{acceptTIII}{accept\_3}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EAGAIN}$: no pending connections and non-blocking
     semantics set }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{(\tsunknown{accept} \;\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EAGAIN}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} = \tsvar{fid} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) = \Mtrue  \Mwedge {}\\{}
 \tsvar{sid} \;\in  \Mfdom{\tsvar{h}.\tsvar{socks}} \Mwedge {}\\{}
 (\exists \tsvar{sf} \;\tsvar{is}_{1} \;\tsvar{p}_{1} \;\tsvar{cb} \;\tsvar{lis} \;\tsvar{es}.{}\\{}
 \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis},[\,],[\,])) \Mwedge {}\\{}
 \tsvar{lis}.\tsunknown{q} = [\,])}
{\rulesubsection{Description}

   A non-blocking $\tsunknown{accept}()$ call is performed on socket $\tsvar{sid}$ when no completed incoming
   connections are available. Error $\tsunknown{EAGAIN}$ is returned to the calling thread.

   From thread $\tsvar{tid}$, which is initially in the $\tscon{Run}$ state, $\tsunknown{accept}(\tsvar{fd})$ is called where
   $\tsvar{fd}$ refers to a listening TCP socket $\tsvar{sid}$ which is bound to local port $\tsvar{p}_{1}$, not shutdown
   for writing, and in non-blocking mode: $\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) = \Mtrue $. The socket's queue of completed
   connections is empty, $\tsunknown{q} \Mass  [\,]$, hence the $\tsunknown{accept}()$ call returns error $\tsunknown{EAGAIN}$,
   leaving the calling thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EAGAIN}})$ after a $\MLhcall{\tsvar{tid}}{\tsunknown{accept}(\tsvar{fd})}$
   transition.

   Socket $\tsvar{sid}$ might not be bound to a local IP address, i.e. $\tsvar{is}_{1}$ could be $*$. In this
   case the socket is listening for connection attempts on port $\tsvar{p}_{1}$ for all local IP addresses.

\rrulepad }
}

\newcommand{\acceptTIV}{\rrulecc{acceptTIV}{accept\_4}{tcp: rc}{\tsholcomm{ Fail with $\tsunknown{ECONNABORTED}$: the listening socket has $\tsvar{cantsndmore}$ set
     or has become $\tscon{CLOSED}$. Returns either immediately or from a blocked state. }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{t}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass {}\\{}
 \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid} ,\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},\Msome  \;\tsvar{lis},[\,],[\,])))] \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \tsvar{lbl} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ECONNABORTED}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass {}\\{}
 \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid} ,\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},\Msome  \;\tsvar{lis},[\,],[\,])))] \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mboxedor{\tsvar{t} = \tscon{Run} \Mwedge {}\\{}
 \tsvar{st} = \tscon{LISTEN} \Mwedge {}\\{}
 \tsvar{cantsndmore} = \Mtrue  \Mwedge {}\\{}
 \tsvar{lbl} = \MLhcall{\tsvar{tid}}{\tsunknown{accept}(\tsvar{fd})} \Mwedge {}\\{}
 \tsvar{rc} = \tscon{fast} \;\tscon{fail} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}){}\\{}
 }{\tsvar{t} = \tscon{Accept2}(\tsvar{sid}) \Mwedge {}\\{}
 ((\tsvar{cantrcvmore} = \Mtrue  \Mwedge  \tsvar{st} = \tscon{LISTEN}) \Mvee {}\\{}
 (\tsvar{st} = \tscon{CLOSED})) \Mwedge {}\\{}
 \tsvar{lbl} = \MLhtau  \Mwedge {}\\{}
 \tsvar{rc} = \tscon{slow} \;\tsunknown{urgent} \;\tscon{fail}{}\\{}
 }}
{\rulesubsection{Description}

   This rule covers two cases: (1) an $\tsunknown{accept}(\tsvar{fd})$ call is made on a listening TCP socket $\tsvar{sid}$,
   referenced by $\tsvar{fd}$, with $\tsvar{cantsndmore}$ set, and (2) a previous call to $\tsunknown{accept}()$ on socket
   $\tsvar{sid}$ blocked, leaving a thread $\tsvar{tid}$ in state $\tscon{Accept2}(\tsvar{sid})$, but the socket has since
   either entered the $\tscon{CLOSED}$ state, or had $\tsvar{cantrcvmore}$ set. In both cases, $\tsunknown{ECONNABORTED}$
   is returned.

   This situation will arise only when a thread calls $\tsunknown{close}()$ on the listening socket while
   another thread is blocking on an $\tsunknown{accept}()$ call, or if $\tsvar{listen}()$ was originally called on a
   socket which already had $\tsvar{cantrcvmore}$ set. The latter can occur in BSD, which allows
   $\tsvar{listen}()$ to be called in any (non $\tscon{CLOSED}$ or $\tscon{LISTEN}$) state, though should never happen
   under typical use.

   If the calling thread was previously blocked in state $\tscon{Accept2}(\tsvar{sid})$, it proceeds via an
   $\MLhtau $ transition, otherwise by a $\MLhcall{\tsvar{tid}}{\tsunknown{accept}(\tsvar{fd})}$ transition. The thread is
   left in state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ECONNABORTED}})$ to return the error $\tsunknown{ECONNABORTED}$ in response to
   the initial $\tsunknown{accept}()$ call.

   Note that this rule is not correct when dealing with the FreeBSD behaviour which allows any
   socket to be placed in the $\tscon{LISTEN}$ state.

\rrulepad }
}

\newcommand{\acceptTV}{\rrulecc{acceptTV}{accept\_5}{tcp: rc}{\tsholcomm{ Fail with $\tsunknown{EINVAL}$: socket not in LISTEN state }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{t}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\Mtransition{ \tsvar{lbl} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINVAL}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\Mboxedor{\tsvar{t} = \tscon{Run} \Mwedge {}\\{}
 \tsvar{lbl} = \MLhcall{\tsvar{tid}}{\tsunknown{accept}(\tsvar{fd})} \Mwedge {}\\{}
 \tsvar{rc} = \tscon{fast} \;\tscon{fail} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}){}\\{}
 }{\tsvar{t} = \tscon{Accept2}(\tsvar{sid}) \Mwedge {}\\{}
 \tsvar{lbl} = \MLhtau  \Mwedge {}\\{}
 \tsvar{rc} = \tscon{slow} \;\tsunknown{urgent} \;\tscon{fail}{}\\{}
 } \Mwedge {}\\{}
 \tsvar{sid} \;\in  \Mfdom{\tsvar{h}.\tsvar{socks}} \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \neq  \tscon{LISTEN}}
{\rulesubsection{Description}


   It is not valid to call $\tsunknown{accept}()$ on a socket that is not in the
   $\tscon{LISTEN}$ state.

   This rule covers two cases: (1) on the non-listening TCP socket $\tsvar{sid}$, $\tsunknown{accept}()$ is called
   from a thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, and (2) a previous call to $\tsunknown{accept}()$ on
   TCP socket $\tsvar{sid}$ blocked because no completed connections were available, leaving thread
   $\tsvar{tid}$ in state $\tscon{Accept2}(\tsvar{sid})$ and after the $\tsunknown{accept}()$ call blocked the socket changed to a
   state other than $\tscon{LISTEN}$.

   In the first case the $\tsunknown{accept}(\tsvar{fd})$ call on socket $\tsvar{sid}$, referenced by file descriptor
   $\tsvar{fd}$, proceeds by a $\MLhcall{\tsvar{tid}}{\tsunknown{accept}(\tsvar{fd})}$ transition and in the latter by a $\MLhtau $
   transition. In either case, the thread is left in state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINVAL}})$ to return error
   $\tsunknown{EINVAL}$ to the caller.

   The second case is subtle: a previous call to $\tsunknown{accept}()$ may have blocked waiting for a new
   completed connection to arrive and an operation, such as a $\tsunknown{close}()$ call, in another thread
   caused the socket to change from the $\tscon{LISTEN}$ state.

\rrulepad }
}

\newcommand{\acceptTVI}{\rrulecc{acceptTVI}{accept\_6}{tcp: rc}{\tsholcomm{ Fail with $\tsunknown{EMFILE}$: out of file descriptors }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{t}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\Mtransition{ \tsvar{lbl} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EMFILE}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\Mboxedor{\tsvar{t} = \tscon{Run} \Mwedge {}\\{}
 \tsvar{lbl} = \MLhcall{\tsvar{tid}}{\tsunknown{accept}(\tsvar{fd})} \Mwedge {}\\{}
 \tsvar{rc} = \tscon{fast} \;\tscon{fail} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sid} \;\in  \Mfdom{\tsvar{h}.\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{sock} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}) \Mwedge {}\\{}
 \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tsunknown{PROTO\_TCP}{}\\{}
 }{\tsvar{t} = \tscon{Accept2}(\tsvar{sid}) \Mwedge {}\\{}
 \tsvar{lbl} = \MLhtau  \Mwedge {}\\{}
 \tsvar{rc} = \tscon{slow} \;\tsunknown{nonurgent} \;\tscon{fail}{}\\{}
 } \Mwedge {}\\{}
 \tsholop{CARD} (\Mfdom{\tsvar{h}.\tsvar{fds}}) \geq  \tsunknown{OPEN\_MAX}}
{\rulesubsection{Description}

   This rule covers two cases: (1) from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, an
   $\tsunknown{accept}(\tsvar{fd})$ call is made where $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$, and (2) a previous call
   to $\tsunknown{accept}()$ blocked leaving thread $\tsvar{tid}$ in the $\tscon{Accept2}(\tsvar{sid})$ state. In either case the
   $\tsunknown{accept}()$ call fails with $\tsunknown{EMFILE}$ as the process (see Model Details) already has open its
   maximum number of open file descriptors $\tsunknown{OPEN\_MAX}$.

   In the first case the error is returned immediately ($\tscon{fast} \;\tscon{fail}$) by performing an
   $\MLhcall{\tsvar{tid}}{\tsunknown{accept}(\tsvar{fd})}$ transition, leaving the thread state $\tscon{Ret}(\tscon{FAIL}\;{\tsunknown{EMFILE}})$. In the
   second, the thread is unblocked, also leaving the thread state $\tscon{Ret}(\tscon{FAIL}\;{\tsunknown{EMFILE}})$, by
   performing a $\MLhtau $ transition.

\rulesubsection{Model details}

   In real systems, error $\tsunknown{EMFILE}$ indicates that the calling process already has $\tsunknown{OPEN\_MAX}$ file
   descriptors open and is not permitted to open any more. This specification only models one
   single-process host with multiple threads, thus $\tsunknown{EMFILE}$ is generated when the host exceeds the
   $\tsunknown{OPEN\_MAX}$ limit in this model.

\rrulepad }
}

\newcommand{\acceptTVII}{\rrulecc{acceptTVII}{accept\_7}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EOPNOTSUPP}$ or $\tsunknown{EINVAL}$: $\tsunknown{accept}()$ called on
     a UDP socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{accept}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sid} \;\in  \Mfdom{\tsvar{h}.\tsvar{socks}} \Mwedge {}\\{}
 \tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tsunknown{PROTO\_UDP} \Mwedge {}\\{}
 (\Mif  \;\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{err} = \tsunknown{EINVAL}{}\\{}
 \Melse  \;\tsvar{err} = \tsunknown{EOPNOTSUPP})}
{\rulesubsection{Description}

   Calling $\tsunknown{accept}()$ on a socket for a connectionless protocol (such as UDP) has no defined
   behaviour and is thus an invalid ($\tsunknown{EINVAL}$) or unsupported ($\tsunknown{EOPNOTSUPP}$) operation.

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, an $\tsunknown{accept}(\tsvar{fd})$ call is made where $\tsvar{fd}$
   refers to a UDP socket identified by $\tsvar{sid}$. The call proceeds by a $\MLhcall{\tsvar{tid}}{\tsunknown{accept}(\tsvar{fd})}$
   transition leaving the thread state $\tscon{Ret}(\tscon{FAIL}\;{\tsvar{err}})$ to return error $\tsvar{err}$. On FreeBSD
   $\tsvar{err}$ is $\tsunknown{EINVAL}$; on all other systems the error is $\tsunknown{EOPNOTSUPP}$.


\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   FreeBSD returns error $\tsunknown{EINVAL}$ if $\tsunknown{accept}()$ is called on a UDP socket.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommbind}{\clustersection{(TCP and UDP)}{$\tsunknown{bind}()$}
\seccomm{ \[ \tsunknown{bind}: (\tsunknown{fd} * \tsunknown{ip} \;\;\tstype{option} * \tsunknown{port} \;\;\tstype{option}) \Mtotype  \tstype{unit} \]

  $\tsunknown{bind}(\tsunknown{fd},\tsunknown{is},\tsunknown{ps})$ assigns a local address to the socket referenced by file descriptor $\tsunknown{fd}$. The
  local address, $(\tsunknown{is},\tsunknown{ps})$, may consist of an IP address, a port or both an IP address and port.

  If $\tsunknown{bind}()$ is called without specifying a port, $\tsunknown{bind}(\tsunknown{\_},\tsunknown{\_},*)$, the socket's local port
  assignment is autobound, i.e. an unused port for the socket's protocol in the host's ephemeral
  port range is selected and assigned to the socket. Otherwise the port $\tsvar{p}$ specified in the bind
  call, $\tsunknown{bind}(\tsunknown{\_},\tsunknown{\_},\Msome  \;\tsvar{p})$ forms part of the socket's local address.

  On some architectures a range of port values are designated to be privileged, e.g. 0-1023
  inclusive. If a call to $\tsunknown{bind}()$ requests a port in this range and the caller does not have
  sufficient privileges the call will fail.

  A $\tsunknown{bind}()$ call may or may not specify the IP address. If an IP address is not specified,
  $\tsunknown{bind}(\tsunknown{\_},*,\tsunknown{\_})$, the socket's local IP address is set to $*$ and it will receive segments
  or datagrams addressed to any of the host's local IP addresses and port $\tsvar{p}$. Otherwise, the
  caller specifies a local IP address, $\tsunknown{bind}(\tsunknown{\_},\Msome  \;\tsvar{i},\tsunknown{\_})$, the socket's local IP address is set
  to $\Msome  \;\tsvar{i}$, and it only receives segments or datagrams addressed to IP address $\tsvar{i}$ and port
  $\tsvar{p}$.

  A call to $\tsunknown{bind}()$ may be unsuccessful if the requested IP address or port is unavailable to
  bind to, although in certain situations this can be overrriden by setting the socket option
  $\tscon{SO\_REUSEADDR}$ appropriately: see \ltslink{boundTportTallowed}{$\tsaux{bound\_port\_allowed}$}.

  A socket can only be bound once: it is not possible to rebind it to a different port later. A
  $\tsunknown{bind}()$ call is not necessary for every socket: sockets may be autobound to an ephemeral port when a
  call requiring a port binding is made, e.g. $\tsunknown{connect}()$.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{bind}()$ can fail with the errors below, in which case the corresponding exception
  is raised:

\par\begin{ltstabular}
$\tsunknown{EACCES}$
&  The specified port is in the privileged port range of the host architecture and
  the current thread does not have the required privileges to bind to it.

\\\hline
$\tsunknown{EADDRINUSE}$
&  The specified address is in use by or conflicts with the address of another
  socket using the same protocol. The error may occur in the following situations only:
    \begin{itemize}

      \item $\tsunknown{bind}(\tsunknown{\_},\tsunknown{\_},\Msome  \;\tsvar{p})$ will fail with $\tsunknown{EADDRINUSE}$ if another socket is bound to port
       $\tsvar{p}$. This error may be preventable by setting the $\tscon{SO\_REUSEADDR}$ socket option.

      \item $\tsunknown{bind}(\tsunknown{\_},\Msome  \;\tsvar{i},\Msome  \;\tsvar{p})$ will fail with $\tsunknown{EADDRINUSE}$ if another socket is bound to
       port $\tsvar{p}$ and IP address $\tsvar{i}$, or is bound to port $\tsvar{p}$ and wildcard IP. This error will
       not occur if the $\tscon{SO\_REUSEADDR}$ option is correctly used to allow multiple sockets to be
       bound to the same local port.

    \end{itemize}
  This error is never returned from a call $\tsunknown{bind}(\tsunknown{\_},\tsunknown{\_},*)$ that requests an autobound port.

\\\hline
$\tsunknown{EADDRNOTAVAIL}$
&  The specified IP address cannot be bound as it is not local to the host.

\\\hline
$\tsunknown{EINVAL}$
&  The socket is already bound to an address and the socket's protocol does not
  support rebinding to a new address. Multiple calls to $\tsunknown{bind}()$ are not permitted.

\\\hline
$\tsunknown{EISCONN}$
&  The socket is connected and rebinding to a new local address is not
  permitted (TCP ONLY).

\\\hline
$\tsunknown{ENOBUFS}$
&  A port was not specified in the $\tsunknown{bind}()$ call and autobinding failed because
  no ephemeral ports for the socket's protocol are currently available. In addition, on WinXP the
  error can signal that the host has insufficient available buffers to complete the operation.

\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  A server application creates a TCP socket and binds it to its local address. It is then put in the
  $\tscon{LISTEN}$ state to accept incoming connections to this address: $\tsunknown{socket\_1}$; $\tsunknown{return\_1}$;
  $\tsunknown{bind\_1}$; $\tsunknown{return\_1}$; ${\tsvar{listen}}_{1}$

  A UDP socket is created and bound to its local address. $\tsunknown{recv}()$ is called and the socket
  blocks, waiting to receive datagrams sent to the local address: $\tsunknown{socket\_1}$; $\tsunknown{return\_1}$;
  $\tsunknown{bind\_1}$; $\tsunknown{return\_1}$; $\tsunknown{recv\_12}$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:  &  \wasverb{int bind(int socket, const struct sockaddr *address,} \\
            &  \wasverb{           socklen\textunderscore{}t address\textunderscore{}len);} \\
    FreeBSD:&  \wasverb{int bind(int s, struct sockaddr *addr, socklen\textunderscore{}t addrlen);} \\
    Linux:  &  \wasverb{int bind(int sockfd, struct sockaddr *addr, socklen\textunderscore{}t addrlen);} \\
    WinXP:  &  \wasverb{SOCKET bind(SOCKET s, const struct sockaddr* name, int namelen);} \\
  \end{tabular}\\

  In the Posix interface:
  \begin{itemize}

    \item \wasverb{socket} is the socket's file descriptor, corresponding to the $\tsunknown{fd}$ argument of
     the model.

    \item \wasverb{address} is a pointer to a \wasverb{sockaddr} structure of size
    \wasverb{socklen\textunderscore{}t} containing the local IP address and port to be assigned to the socket,
    corresponding to the $\tsunknown{is}$ and $\tsunknown{ps}$ arguments of the model. For the \wasverb{AF\textunderscore{}INET}
    sockets used in the model, a \wasverb{sockaddr\textunderscore{}in} structure stores the address. The
    \wasverb{sin\textunderscore{}addr.s\textunderscore{}addr} field holds the IP address; if it is set to \wasverb{0} then the IP
    address is wildcarded: $\tsunknown{is}=*$. The \wasverb{sin\textunderscore{}port} field stores the port to bind to; if
    it is set to \wasverb{0} then the port is wildcarded: $\tsunknown{ps}=*$. On WinXP a wildcard IP is
    specified by the constant \wasverb{INADDR\textunderscore{}ANY}, not \wasverb{0}

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual
     error code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  The FreeBSD, Linux and WinXP interfaces are similar modulo some argument renaming, except where
  noted above.

  On Windows Socket 2 the \wasverb{name} parameter is not necessarily interpreted as a pointer to a
  \wasverb{sockaddr} structure but is cast this way for compatilibity with Windows Socket 1.1 and
  the BSD sockets interface. The service provider implementing the functionality can choose to
  interpret the pointer as a pointer to any block of memory provided that the first two bytes of the
  block start with the address family used to create the socket. The default WinXP internet family
  provider expects a \wasverb{sockaddr} structure here. This change is purely an interface design
  choice that ultimately achieves the same functionality of providing a name for the socket and is
  not modelled.

}\clustersubsection{Model details}
\seccomm{
  The specification only models the {AF,PF}\_INET address families thus the address family field of
  the \wasverb{struct sockaddr} argument to $\tsunknown{bind}()$ and those errors specific to other address
  familes, e.g. UNIX domain sockets, are not modelled here.

  In the Posix specification, $\tsunknown{ENOBUFS}$ may have the additional meaning of "Insufficient resources
  were available to complete the call". This is more general than the use of $\tsunknown{ENOBUFS}$ in the
  model.

  The following errors are not modelled:
  \begin{itemize}

    \item \wasverb{EAGAIN} is BSD-specific and described in the man page as: "Kernel resources to
     complete the request are temporarily unavailable". This is not modelled here.


    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

    \item \wasverb{EFAULT} signifies that the pointers passed as either the \wasverb{address} or
     \wasverb{address\textunderscore{}len} arguments were inaccessible.  This is an artefact of the C interface to
     $\tsunknown{bind}()$ that is excluded by the clean interface used in the model. On WinXP, the equivalent
     error \wasverb{WSAEFAULT} in addition signifies that the name address format used in
     \wasverb{name} may be incorrect or the address family in \wasverb{name} does not match that of
     the socket.

    \item \wasverb{ENOTDIR}, \wasverb{ENAMETOOLONG}, \wasverb{ENOENT}, \wasverb{ELOOP},
     \wasverb{EIO} (BSD-only), \wasverb{EROFS}, \wasverb{EISDIR} (BSD-only), \wasverb{ENOMEM},
     \wasverb{EAFNOTSUPPORT} (Posix-only) and \wasverb{EOPNOTSUPP} (Posix-only) are errors specific
     to other address families and are not modelled here. None apply to WinXP as other address
     families are not available by default.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{bind\_1}$
& \textbf{all: fast succeed}
&  Successfully assign a local address to a socket (possibly by
     autobinding the port) \\
$\tsrule{bind\_2}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{EADDRINUSE}$: the specified address is already in use \\
$\tsrule{bind\_3}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{EADDRNOTAVAIL}$: the specified IP address is not available on the host \\
$\tsrule{bind\_5}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{EINVAL}$: the socket is already bound to an address and does not support rebinding; or socket has been shutdown for writing on FreeBSD \\
$\tsrule{bind\_7}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{EACCES}$: the specified port is priveleged and the current process does not have permission to bind to it \\
$\tsrule{bind\_9}$
& \textbf{all: fast badfail}
&  Fail with $\tsunknown{ENOBUFS}$: no ephemeral ports free for autobinding or, on WinXP only, insufficient buffers available. \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\bindTI}{\rrulecc{bindTI}{bind\_1}{all: fast succeed}{\tsholcomm{ Successfully assign a local address to a socket (possibly by
     autobinding the port) }}
{(\tsvar{h}_{0},\tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})} }{1}}
{(\tsvar{h},\tsvar{SS},\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h}' \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid} ,\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,*,*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tsvar{pr}))]{}\\{}
 \Mmagicbolrrec  \Mwedge {}\\{}
 \tsvar{h}  = \tsvar{h}' \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid} ,\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tsvar{pr}))];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sid} \;\notin  (\Mfdom{\tsvar{socks}}) \Mwedge {}\\{}
 (\forall \tsvar{i}_{1}. \tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \implies  \tsvar{i}_{1} \;\in  \;\tsunknown{local\_ips}(\tsvar{h}_{0}.\tsvar{ifds})) \Mwedge {}\\{}
 \tsvar{p}_{1} \;\in  \;\tsaux{autobind}(\tsvar{ps}_{1},(\tsaux{proto\_of} \;\tsvar{pr}),\tsvar{h}_{0},\tsvar{socks}) \Mwedge {}\\{}
 \tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \Mwedge {}\\{}
 (\tsvar{h}_{0}.\tsvar{privs} \Mvee  \tsvar{p}_{1} \;\notin  \;\tsaux{privileged\_ports} \;\tsvar{h}_{0}) \Mwedge {}\\{}
 \tsaux{bound\_port\_allowed} \;\tsvar{pr} (\tsvar{h}_{0}.\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}) \tsvar{sf} \;\tsvar{h}_{0}.\tsvar{arch} \;\tsvar{is}_{1} \;\tsvar{p}_{1} \Mwedge {}\\{}
 (\Mcase  \;\tsvar{pr} \;\Mof {}\\{}
\quad \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mtotype  \tsunknown{tcp\_sock} = \tsaux{TCP\_Sock0}(\tscon{CLOSED},\tsvar{cb},*,[\,],[\,]) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsunknown{bsd\_arch} \;\tsvar{h}_{0}.\tsvar{arch} \implies  \tsvar{cantsndmore}=\Mfalse  ) \Mdpipe {}\\{}
\quad \tscon{UDP\_PROTO}(\tsunknown{udp\_sock}) \Mtotype  \tsunknown{udp\_sock} = \tsaux{UDP\_Sock0}([\,]))}
{\rulesubsection{Description}

   The call $\tsunknown{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})$ is perfomed on the TCP or UDP socket $\tsvar{sid}$ referenced by file
   descriptor $\tsvar{fd}$ from a thread $\tsvar{tid}$ in the $\tscon{Run}$ state. The socket $\tsvar{sid}$ is currently
   uninitialised, i.e. it has no local or remote address defined $(*,*,*,*)$, and it
   contains an uninitialised TCP or UDP protocol block, $\tsunknown{tcp\_sock}$ and $\tsunknown{udp\_sock}$ as appropriate for the socket's protocol.

   If an IP address is specified in the $\tsunknown{bind}()$ call, i.e. $\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1}$, the call can only succeed
   if the IP address $\tsvar{i}_{1}$ is one of those belonging to an interface of host $\tsvar{h}$, $\tsvar{i}_{1} \;\in
\tsunknown{local\_ips}(\tsvar{h}_{0}.\tsvar{ifds})$.

   The port $\tsvar{p}_{1}$ that the socket will be bound to is determined by the auxiliary function
   $\tsaux{autobind}$ that takes as argument the port option $\tsvar{ps}_{1}$ from the $\tsunknown{bind}()$ call. If $\tsvar{ps}_{1} =
\Msome  \;\tsvar{p}$ $\tsaux{autobind}$ simply returns the singleton set $\{\tsvar{p}\}$, constraining the local port
   binding $\tsvar{p}_{1}$ by $\tsvar{p}_{1} = \tsvar{p}$. Otherwise, $\tsaux{autobind}$ returns a set of available ephemeral ports
   and $\tsvar{p}_{1}$ is constrained to be a port within the set.

   If a port is specified in the $\tsunknown{bind}()$ call, i.e. $\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1}$, either the port is not a
   privileged port $\tsvar{p}_{1} \;\notin  \;\tsaux{privileged\_ports}$ or the host (actually, process) must have
   sufficient privileges $\tsvar{h}_{0}.\tsunknown{priv} = \Mtrue $.

   Not all requested bindings are permissible because other sockets in the system may be bound to
   the chosen address or to a conflicting address. To check the binding $\tsvar{is}_{1}, \Msome  \;\tsvar{p}_{1}$ is
   permitted the auxiliary function $\tsaux{bound\_port\_allowed}$ is used. $\tsaux{bound\_port\_allowed}$ is
   architecture dependent and checks not only the other sockets bound locally to port $\tsvar{p}_{1}$ on the
   host, but also the status of the socket flag $\tscon{SO\_REUSEADDR}$ for socket $\tsvar{sid}$ and the
   conflicting sockets. The use of the socket flag $\tscon{SO\_REUSEADDR}$ can permit sockets to share
   bindings under some circumstances, resolving the binding conflict. See \ltslink{boundTportTallowed}{$\tsaux{bound\_port\_allowed}$} for further information.

   The call proceeds by performing a $\MLhcall{\tsvar{tid}}{\tsunknown{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})}$ transition returning $\tscon{OK}()$
   to the calling thread. Socket $\tsvar{sid}$ is bound to local address $(\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1})$and the host has
   an updated list of bound sockets $\tsvar{bound}$ with socket $\tsvar{sid}$ at its head.

\rulesubsection{Model details}

   The list of bound sockets $\tsvar{bound}$ is used by the model to determine the order in which sockets
   are bound. This is required to model ICMP message and UDP datagram delivery on Linux.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   If $\tsvar{sid}$ is a TCP socket then it cannot be shutdown for writing: $\tsvar{cantsndmore}=\Mfalse $, and its
   $\tsunknown{bsd\_cantconnect}$ flag cannot be set.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\bindTII}{\rrulecc{bindTII}{bind\_2}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{EADDRINUSE}$: the specified address is already in use }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{bind}(\tsvar{fd},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EADDRINUSE}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}) \Mwedge {}\\{}
 \neg{}(\tsaux{bound\_port\_allowed} \;\tsvar{sock}.\tsvar{pr} (\tsvar{h}.\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}) \tsvar{sock}.\tsvar{sf} \;\tsvar{h}.\tsvar{arch} \;\tsvar{is}_{1} \;\tsvar{p}_{1}) \Mwedge {}\\{}
 (\tsholop{option\_case}\Mspiii{\Mtrue }{(\lambda \tsvar{i}_{1}. \tsvar{i}_{1} \;\in  \;\tsunknown{local\_ips}(\tsvar{h}.\tsvar{ifds}))}{\tsvar{is}_{1}}  \Mvee  \tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{bind}(\tsvar{fd},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1})$ call is performed
   on the socket $\tsvar{sock}$, which is identified by $\tsvar{sid}$ and referenced by $\tsvar{fd}$.

   If an IP address is specified in the call, $\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1}$, then $\tsvar{i}_{1}$ must be an IP address
   for one of the host's interfaces. The requested local address binding, $(\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1})$, is not
   available as it is already in use: see \ltslink{boundTportTallowed}{$\tsaux{bound\_port\_allowed}$} for details.

   The call proceeds by a $\MLhcall{\tsvar{tid}}{\tsunknown{bind}(\tsvar{fd},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1})}$ transition leaving the thread in
   state $\tscon{Ret}(\tscon{FAIL}\;{\tsunknown{EADDRINUSE}})$ to return error $\tsunknown{EADDRINUSE}$ to the caller.

\rrulepad }
}

\newcommand{\bindTIII}{\rrulecc{bindTIII}{bind\_3}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{EADDRNOTAVAIL}$: the specified IP address is not available on the host }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{bind}(\tsvar{fd},\Msome  \;\tsvar{i}_{1},\tsvar{ps}_{1})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EADDRNOTAVAIL}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{i}_{1} \;\notin  \;\tsunknown{local\_ips}(\tsvar{h}.\tsvar{ifds})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{bind}(\tsvar{fd},\Msome  \;\tsvar{i}_{1},\tsvar{ps}_{1})$ call is made where
   $\tsvar{fd}$ refers to a socket $\tsvar{sid}$.

   The IP address, $\tsvar{i}_{1}$, to be assigned as part of the socket's local address does not belong to
   any of the interfaces on the host, $\tsvar{i}_{1} \;\notin  \;\tsunknown{local\_ips}(\tsvar{h}.\tsvar{ifds})$, and therefore can not be
   assigned to the socket.

   The call proceeds by a $\MLhcall{\tsvar{tid}}{\tsunknown{bind}(\tsvar{fd},\Msome  \;\tsvar{i}_{1},\tsvar{ps}_{1})}$ transition leaving the thread in
   state $\tscon{Ret}(\tscon{FAIL}\;{\tsunknown{EADDRNOTAVAIL}})$ to return error $\tsunknown{EADDRNOTAVAIL}$ to the caller.

\rrulepad }
}

\newcommand{\bindTV}{\rrulecc{bindTV}{bind\_5}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{EINVAL}$: the socket is already bound to an address and does not support rebinding; or socket has been shutdown for writing on FreeBSD }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINVAL}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} = \tsvar{sock} \Mwedge {}\\{}
 (\tsvar{sock}.\tsvar{ps}_{1} \neq  * \Mvee {}\\{}
 (\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad (\tsvar{sock}.\tsvar{cantsndmore} \Mvee {}\\{}
\quad \Mtrue  ) ))}
{\rulesubsection{Description}
   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})$ call is made where
   $\tsvar{fd}$ refers to a socket $\tsvar{sock}$. The socket already has a local port binding: $\tsvar{sock}.\tsvar{ps}_{1} \neq
*$, and rebinding is not supported.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule also applies if $\tsvar{fd}$ refers to a TCP socket which is either shut down for writing or
    has its $\tsunknown{bsd\_cantconnect}$ flag set.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\bindTVII}{\rrulecc{bindTVII}{bind\_7}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{EACCES}$: the specified port is priveleged and the current process does not have permission to bind to it }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{bind}(\tsvar{fd},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EACCES}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\neg{}\tsvar{h}.\tsvar{privs} \Mwedge  \tsvar{p}_{1} \;\in  \;\tsaux{privileged\_ports} \;\tsvar{h})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{bind}(\tsvar{fd},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1})$ call is made where
   $\tsvar{fd}$ refers to a socket $\tsvar{sid}$.  The port specified in the $\tsunknown{bind}$ call, $\tsvar{p}_{1}$, lies in the
   host's range of privileged ports, $\tsvar{p}_{1} \;\in  \;\tsaux{privileged\_ports}$, and the current host (actually,
   process) does not have sufficient permissions to bind to it: $\neg{}\tsvar{h}.\tsvar{privs}$.

   The call proceeds by a $\MLhcall{\tsvar{tid}}{\tsunknown{bind}(\tsvar{fd},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1})}$ transition leaving the thread in
   state $\tscon{Ret}(\tscon{FAIL}\;{\tsunknown{EACCES}})$ to return the access violation error $\tsunknown{EACCES}$ to the caller.

\rrulepad }
}

\newcommand{\bindTIX}{\rrulecc{bindTIX}{bind\_9}{all: fast badfail}{\tsholcomm{ Fail with $\tsunknown{ENOBUFS}$: no ephemeral ports free for autobinding or, on WinXP only, insufficient buffers available. }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOBUFS}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{SS},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{ps}_{1} = * \Mwedge {}\\{}
 ((\tsaux{autobind}(\tsvar{ps}_{1},(\tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr}),\tsvar{h},\tsvar{h}.\tsvar{socks}) = \emptyset ) \Mvee {}\\{}
 \tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})$ call is made where
   $\tsvar{fd}$ refers to a socket $\tsvar{sid}$.

   A port is not specifed in the $\tsunknown{bind}$ call, i.e. $\tsvar{ps}_{1} = *$, and calling $\tsaux{autobind}$ returns
   the $\emptyset $ set rather than a set of free ephemeral ports that the socket could choose
   from. This occurs only when there are no remaining ephemeral ports available for autobinding.

   The call proceeds by a $\MLhcall{\tsvar{tid}}{\tsunknown{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})}$ transition leaving the thread state
   $\tscon{Ret}(\tscon{FAIL}\;{\tsunknown{ENOBUFS}})$ to return the out of resources error $\tsunknown{ENOBUFS}$ to the caller.

\rulesubsection{Model details}

   Posix reports $\tsunknown{ENOBUFS}$ to signify that "Insufficient resources were available to complete the
   call". This is not modelled here.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
   On WinXP this error can occur non-deterministically when insufficient buffers are available.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommclose}{\clustersection{(TCP and UDP)}{$\tsunknown{close}()$}
\seccomm{ \[ \tsunknown{close}: \tsunknown{fd} \Mtotype  \tstype{unit} \]

  A call $\tsunknown{close}(\tsunknown{fd})$ closes file descriptor $\tsunknown{fd}$ so that it no longer refers to a file
  description and associated socket. The closed file descriptor is made available for reuse by the
  process. If the file descriptor is the last file descriptor referencing a file description the
  file description itself is deleted and the underlying socket is closed. If the socket is a UDP
  socket it is removed.

  It is important to note the distinction drawn above: only closing the last file descriptor of a
  socket has an effect on the state of the file description and socket.

  The following behaviour may occur when closing the last file descriptor of a TCP socket:

  \begin{itemize}

   \item A TCP socket may have the $\tscon{SO\_LINGER}$ option set which specifies a maximum duration in
    seconds that a $\tsunknown{close}(\tsunknown{fd})$ call is permitted to block.
    \begin{itemize}

      \item In the normal case the $\tscon{SO\_LINGER}$ option is not set, the close call returns
       immediately and asynchronously sends any remaining data and gracefully closes the connection.

      \item If $\tscon{SO\_LINGER}$ is set to a non-zero duration, the $\tsunknown{close}(\tsunknown{fd})$ call will block while
       the TCP implementation attempts to successfully send any remaining data in the socket's send
       buffer and gracefully close the connection. If the sending of remaining data and the graceful
       close are successful within the set duration, $\tsunknown{close}(\tsunknown{fd})$ returns successfully, otherwise
       the linger timer expires, $\tsunknown{close}(\tsunknown{fd})$ returns an error $\tsunknown{EAGAIN}$, and the close operation
       continues asychronously, attempting to send the remaining data.

      \item The $\tscon{SO\_LINGER}$ option may be set to zero to indicate that $\tsunknown{close}(\tsunknown{fd})$ should be
       abortive. A call to $\tsunknown{close}(\tsunknown{fd})$ tears down the connection by emitting a reset segment to
       the remote end (abandoning any data remaining in the socket's send queue) and returns
       successfully without blocking.


    \end{itemize}

   \item If $\tsunknown{close}(\tsunknown{fd})$ is called on a TCP socket in a pre-established state the file description
    and socket are simply closed and removed, regardless of how $\tscon{SO\_LINGER}$ is set, except on
    Linux platforms where $\tscon{SYN\_RECEIVED}$ is dealt with as an established state for the purposes of
    $\tsunknown{close}(\tsunknown{fd})$.

   \item Calling $\tsunknown{close}(\tsunknown{fd})$ on a listening TCP socket closes and removes the socket and aborts
    each of the connections on the socket's pending and completed connection queues.

  \end{itemize}

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{close}()$ can fail with the errors below, in which case the corresponding exception is
  raised:

\par\begin{ltstabular}
$\tsunknown{EAGAIN}$
&  The linger timer expired for a lingering $\tsunknown{close}()$ call and the socket has not
  yet been successfully closed.

\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\\\hline
$\tsunknown{EINTR}$
&  The system was interrupted by a caught signal.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  A TCP socket is created and connected to a peer; other socket calls are made, most likely $\tsunknown{send}()$ and
  $\tsunknown{recv}()$, but the $\tscon{SO\_LINGER}$ option is not set. $\tsunknown{close}()$ is then called and the connection
  is gracefully closed: $\tsunknown{socket\_1}$; $\dots $; $\tsunknown{close\_2}$

  A UDP socket is created and socket calls are made on it, mostly $\tsunknown{send}()$ and $\tsunknown{recv}()$ calls;
  the socket is then closed: $\tsunknown{socket\_1}$; $\dots $; $\tsunknown{close\_10}$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:  &  \wasverb{int close(int fildes);} \\
    FreeBSD:&  \wasverb{int close(int d);} \\
    Linux:  &  \wasverb{int close(int fd);} \\
    WinXP:  &  \wasverb{int closesocket(SOCKET s);} \\
  \end{tabular}\\

  In the Posix interface:
  \begin{itemize}

    \item \wasverb{fildes} is the file descriptor to close, corresponding to the $\tsunknown{fd}$ argument of
    the model $\tsunknown{close}()$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
    indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
    indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual
    error code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  The FreeBSD, Linux and WinXP interfaces are similar modulo argument renaming, except where
  noted above.

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item In Posix and on FreeBSD and Linux, \wasverb{EIO} means an I/O error occurred while reading from or
    writing to the file system.  Since we model only sockets, not file systems, we do not model this
    error.

    \item On FreeBSD, \wasverb{ENOSPC} means the underlying object did not fit, cached data was
    lost.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{close\_1}$
& \textbf{all: fast succeed}
&  Successfully close a file descriptor that is not the last file descriptor for a socket \\
$\tsrule{close\_2}$
& \textbf{tcp: fast succeed}
&  Successfully perform a graceful close on the last file descriptor of a synchronised socket \\
$\tsrule{close\_3}$
& \textbf{tcp: fast succeed}
&  Successful abortive close of a synchronised socket \\
$\tsrule{close\_4}$
& \textbf{tcp: block}
&  Block on a lingering close on the last file descriptor of a synchronised socket \\
$\tsrule{close\_5}$
& \textbf{tcp: slow urgent succeed}
&  Successful completion of a lingering close on a synchronised socket \\
$\tsrule{close\_6}$
& \textbf{tcp: slow nonurgent fail}
&  Fail with $\tsunknown{EAGAIN}$: unsuccessful completion of a lingering close on a synchronised socket \\
$\tsrule{close\_7}$
& \textbf{tcp: fast succeed}
&  Successfully close the last file descriptor for a socket in the $\tscon{CLOSED}$, $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$ states. \\
$\tsrule{close\_8}$
& \textbf{tcp: fast succeed}
&  Successfully close the last file descriptor for a listening TCP socket \\
$\tsrule{close\_10}$
& \textbf{udp: fast succeed}
&  Successfully close the last file descriptor of a UDP socket \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\closeTI}{\rrulecc{closeTI}{close\_1}{all: fast succeed}{\tsholcomm{ Successfully close a file descriptor that is not the last file descriptor for a socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds} \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{close}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}' \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsunknown{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) > 1 \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd}}
{\rulesubsection{Description}

    A $\tsunknown{close}(\tsvar{fd})$ call is performed where $\tsvar{fd}$ refers to either a TCP or UDP socket. At least
    two file descriptors refer to file description $\tsvar{fid}$, $\tsunknown{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) > 1$, of which
    one is $\tsvar{fd}$, $\tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}}$.

    The $\tsunknown{close}(\tsvar{fd})$ call proceeds by a $\MLhcall{\tsvar{tid}}{\tsunknown{close}(\tsvar{fd})}$ transition leaving the host in
    the successful return state $\tscon{Ret} (\tscon{OK}())$. In the final host state, the mapping of file
    descriptor $\tsvar{fd}$ to file descriptor index $\tsvar{fid}$ is removed from the file descriptors finite
    map $\tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd}$ , effectively reducing the reference count of the file description by
    one. The $\tsunknown{close}()$ call does not alter the socket's state as other file descriptors still
    refer to the socket through file description $\tsvar{fid}$.

\rrulepad }
}

\newcommand{\closeTII}{\rrulecc{closeTII}{close\_2}{tcp: fast succeed}{\tsholcomm{ Successfully perform a graceful close on the last file descriptor of a synchronised socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds};{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus {}\\{}
\quad [(\tsvar{fid},\tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}))];{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq})))] \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{close}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}';{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \backslash{}\backslash{} \tsvar{fid};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(*,\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\Mtrue ,\Mtrue ,{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},[\,])))] \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s}')],\tsvar{M})}
{(\tsvar{st} \;\in  \{\tscon{ESTABLISHED};\tscon{FIN\_WAIT\_1};\tscon{CLOSING};\tscon{FIN\_WAIT\_2};{}\\{}
\quad\quad\quad\quad \tscon{TIME\_WAIT};\tscon{CLOSE\_WAIT};\tscon{LAST\_ACK}\} \Mvee {}\\{}
 \tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge  \tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge  {}\\{}
 (\tsvar{sf}.\tsunknown{t}(\tscon{SO\_LINGER}) = \infty \Mvee {}\\{}
 \tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) = \Mtrue  \Mwedge  \tsvar{sf}.\tsunknown{t}(\tscon{SO\_LINGER}) \neq  0 \Mwedge  \neg{}\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsunknown{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1 \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd} \Mwedge {}\\{}
 \tsvar{fid} \;\notin  (\Mfdom{\tsvar{files}}) \Mwedge {}\\{}
 (\tsvar{peek},\tsvar{inline}) = (\Mfalse ,\Mtrue ) \Mwedge {}\\{}
 \tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsvar{peek} \;\tsvar{inline} (\tsvar{flgs},\tsvar{data}) \tsvar{s} \;\tsvar{s}'}
{\rulesubsection{Description}

    A $\tsunknown{close}(\tsvar{fd})$ call is performed on the TCP socket $\tsvar{sid}$ referenced by file descriptor $\tsvar{fd}$
    which is the only file descriptor referencing the socket's file description:
    $\tsunknown{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1$. The TCP socket $\tsvar{sid}$ is in a synchronised state, i.e. a state
    $\geq  \tscon{ESTABLISHED}$, or on Linux it may be in the $\tscon{SYN\_RECEIVED}$ state.

    In the common case the socket's linger option is not set, $\tsvar{sf}.\tsunknown{t}(\tscon{SO\_LINGER}) = \infty$, and
    regardless of whether the socket is in non-blocking mode or not, i.e. $\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK})$ is
    unconstrained, the call to $\tsunknown{close}()$ proceeds successfully without blocking.

    On all platforms except for Linux, if the socket is in non-blocking mode $\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) =
\Mtrue $ the linger option may be set with a positive duration: $\tsvar{sf}.\tsunknown{t}(\tscon{SO\_LINGER}) \neq  0)$. In
    this case the option is ignored giving precedence to the socket's non-blocking semantics. The
    $\tsunknown{close}()$ call succeeds without blocking.

    The $\tsunknown{close}(\tsvar{fd})$ call proceeds by a $\MLhcall{\tsvar{tid}}{\tsunknown{close}(\tsvar{fd})}$ transition leaving the host in
    the successful return state $\tscon{Ret} (\tscon{OK}())$. The final socket is marked as unable to send and
    receive further data, $\tsvar{cantsndmore} = \Mtrue  \Mwedge  \tsvar{cantrcvmore} = \Mtrue $, eventually causing TCP to transmit
    all remaining data in the socket's send queue and perform a graceful close.

    In the final host state, the mapping of file descriptor $\tsvar{fd}$ to file descriptor index $\tsvar{fid}$
    is removed from the file descriptors finite map $\tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd}$ and the file description
    entry $\tsvar{fid}$ is removed from the finite map of file descriptors $\tsvar{files} \backslash{}\backslash{} \tsvar{fid}$. The socket
    entry itself, $(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},$$\dots $,$))$ is not destroyed at this point; it remains
    until the TCP connection has been successfully closed.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    The socket can be in the $\tscon{SYN\_RECEIVED}$ state or in one of the synchronised states $\geq
\tscon{ESTABLISHED}$.

    On Linux, non-blocking semantics do not take precedence over the $\tscon{SO\_LINGER}$ option, i.e. if
    the socket is non-blocking, $\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) = \Mtrue $ and a linger option is set to a non-zero
    value, $\tsvar{sf}.\tsunknown{t}(\tscon{SO\_LINGER}) \neq  0$, the socket may block on a call to $\tsunknown{close}()$. See also
    \ltslink{closeTIV}{$\tsunknown{close\_4}$}.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\closeTIII}{\rrulecc{closeTIII}{close\_3}{tcp: fast succeed}{\tsholcomm{ Successful abortive close of a synchronised socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds};{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus {}\\{}
\quad [(\tsvar{fid},\tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}))];{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{close}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}';{}\\{}
 \tsvar{files} \Mass  \tsvar{files};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}'',\tsvar{M})}
{(\tsvar{st} \;\in  \{\tscon{ESTABLISHED};\tscon{FIN\_WAIT\_1};\tscon{CLOSING};\tscon{FIN\_WAIT\_2};{}\\{}
\quad\quad\quad \tscon{TIME\_WAIT};\tscon{CLOSE\_WAIT};\tscon{LAST\_ACK}\} \Mvee {}\\{}
 \tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge  \tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge  {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq})) \Mwedge {}\\{}
 \tsvar{sf}.\tsunknown{t}(\tscon{SO\_LINGER}) = 0 \Mwedge   {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsunknown{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1 \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd} \Mwedge {}\\{}
 \tsvar{fid} \;\notin  (\Mfdom{\tsvar{files}}) \Mwedge {}\\{}
 \tsvar{sid} \;\notin  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{sock}' = (\tsaux{tcp\_close} \;\tsvar{h}.\tsvar{arch} \;\tsvar{sock})  \Mmagiclrec  \tsvar{fid} \Mass  * \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{oflgs} = \tsvar{oflgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mtrue  \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{odata} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 \tsvar{SS} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})] \Mwedge {}\\{}
 \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
 \tsvar{S}' = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')] \Mwedge {}\\{}
 \tsaux{destroy} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsvar{S}' \;\tsvar{S}''}
{\rulesubsection{Description}

    A $\tsunknown{close}(\tsvar{fd})$ call is performed on the TCP socket $\tsvar{sid}$ referenced by file descriptor $\tsvar{fd}$
    which is the only file descriptor referencing the socket's file description:
    $\tsunknown{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1$. The TCP socket $\tsvar{sid}$ is in a synchronised state, i.e. a state >=
    $\tscon{ESTABLISHED}$, except on Linux platforms where it may be in the $\tscon{SYN\_RECEIVED}$ state.

    The socket's linger option is set to a duration of zero, $\tsvar{sf}.\tsunknown{t}(\tscon{SO\_LINGER}) = 0$, to signify
    that an abortive closure of socket $\tsvar{sid}$ is required.

    The $\tsunknown{close}(\tsvar{fd})$ call proceeds by a $\MLhcall{\tsvar{tid}}{\tsunknown{close}(\tsvar{fd})}$ transition leaving the host in
    the successful return state $\tscon{Ret} (\tscon{OK}())$. A reset segment $\tsunknown{seg}$ is constructed from the
    socket's control block $\tsvar{cb}$ and address quad $(\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2})$ and is appended to the host's
    output queue, $\tsvar{oq}$, by the function \ltslink{enqueueTandTignoreTfail}{$\tsaux{enqueue\_and\_ignore\_fail}$}, to create new output queue
    $\tsvar{oq}'$. The $\tsaux{enqueue\_and\_ignore\_fail}$ function always succeeds; if it is not possible to add
    the reset segment $\tsunknown{seq}$ to the output queue the corresponding error code is ignored and the
    reset segment is not queued for transmission.

    The mapping of file descriptor $\tsvar{fd}$ to index $\tsvar{fid}$ is removed from the file descriptors
    finite map $\tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd}$ and the file description entry indexed by $\tsvar{fid}$ is removed
    from the finite map of file descriptions. The socket is put in the $\tscon{CLOSED}$ state, shutdown
    for reading and writing, has its control block reset, and its send and receive queues emptied;
    this is done by the auxiliary function \ltslink{tcpTclose}{$\tsaux{tcp\_close}$}. Additionally, its file description
    field is cleared.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    The socket can be in the $\tscon{SYN\_RECEIVED}$ state or in one of the synchronised states $\geq
\tscon{ESTABLISHED}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\closeTIV}{\rrulecc{closeTIV}{close\_4}{tcp: block}{\tsholcomm{ Block on a lingering close on the last file descriptor of a synchronised socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds};{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus {}\\{}
\quad [(\tsvar{fid},\tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}))];{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq})))] \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{close}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Close2}(\tsvar{sid})}{\tsunknown{slow\_timer} (\tsvar{sf}.\tsunknown{t}(\tscon{SO\_LINGER}))}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}';{}\\{}
 \tsvar{files} \Mass  \tsvar{files};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(*,\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\Mtrue ,\Mtrue ,{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},[\,])))] \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{(\tsvar{st} \;\in  \{\tscon{ESTABLISHED};\tscon{FIN\_WAIT\_1};\tscon{CLOSING};\tscon{FIN\_WAIT\_2};{}\\{}
\quad\quad\quad \tscon{TIME\_WAIT};\tscon{CLOSE\_WAIT};\tscon{LAST\_ACK}\} \Mvee {}\\{}
 \tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge  \tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge  {}\\{}
 \tsvar{sf}.\tsunknown{t}(\tscon{SO\_LINGER}) \notin  \{0; \infty\} \Mwedge {}\\{}
 (\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) = \Mfalse  \Mvee  (\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) = \Mtrue  \Mwedge  \tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch})) \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsunknown{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1 \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd} \Mwedge {}\\{}
 \tsvar{fid} \;\notin  (\Mfdom{\tsvar{files}})}
{\rulesubsection{Description}

    A $\tsunknown{close}(\tsvar{fd})$ call is performed on the TCP socket $\tsvar{sid}$ referenced by file descriptor $\tsvar{fd}$
    which is the only file descriptor referencing the socket's file description:
    $\tsunknown{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1$. The TCP socket $\tsvar{sid}$ has a blocking mode of operation,
    $\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) = \Mfalse $, and is in a synchronised state, i.e. a state $\geq  \tscon{ESTABLISHED}$.

    On Linux, the socket is also permitted to be in the $\tscon{SYN\_RECEIVED}$ state and it may have
    non-blocking semantics $\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) = \Mtrue $, because the linger option takes precedence over
    non-blocking semantics.

    The socket's linger option is set to a positive duration and is neither zero (which signifies an
    immediate abortive close of the socket) nor infinity (which signifies that the linger option has
    not been set), $\tsvar{sf}.\tsunknown{t}(\tscon{SO\_LINGER}) \notin  \{0; \infty\}$. The close call blocks for a
    maximum duration that is the linger option duration in seconds, during which time TCP attempts
    to send all remaining data in the socket's send buffer and gracefully close the connection.

    The $\tsunknown{close}(\tsvar{fd})$ call proceeds by a $\MLhcall{\tsvar{tid}}{\tsunknown{close}(\tsvar{fd})}$ transition leaving the host in
    the blocked state $\tscon{Close2}(\tsvar{sid})$.  The socket is marked as unable to send and receive
    further data, $\tsvar{cantsndmore} = \Mtrue  \Mwedge  \tsvar{cantrcvmore} = \Mtrue $; this eventually causes TCP to send all
    remaining data in the socket's send queue and perform a graceful close.

    In the final host state, the mapping of file descriptor $\tsvar{fd}$ to file descriptor index $\tsvar{fid}$
    is removed from the file descriptors finite map $\tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd}$ and file description entry
    $\tsvar{fid}$ is removed from the finite map of file descriptors. The socket entry itself,
    $(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},$$\dots$$))$, is not destroyed at this point; it remains until the TCP
    socket has been successfully closed by future asychronous events.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    The socket can be in the $\tscon{SYN\_RECEIVED}$ state or in one of the synchronised states $\geq
\tscon{ESTABLISHED}$.

    On Linux, non-blocking semantics do not take precedence over the $\tscon{SO\_LINGER}$ option, i.e. if
    the socket is non-blocking, $\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) = \Mtrue $ and a linger option is set to a non-zero
    value, $\tsvar{sf}.\tsunknown{t}(\tscon{SO\_LINGER}) \neq  0$ the socket may block on a call to $\tsunknown{close}()$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\closeTV}{\rrulecc{closeTV}{close\_5}{tcp: slow urgent succeed}{\tsholcomm{ Successful completion of a lingering close on a synchronised socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Close2}(\tsvar{sid})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(*,\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\Mtrue ,\Mtrue ,{}\\{}
\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,[\,],[\,])))] \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(*,\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\Mtrue ,\Mtrue ,{}\\{}
\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,[\,],[\,])))] \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\tsvar{st} \;\in  \{\tscon{TIME\_WAIT};\tscon{CLOSED};\tscon{FIN\_WAIT\_2}\}{}\\{}
 }
{\rulesubsection{Description}

    A previous call to $\tsunknown{close}()$ with the linger option set on the socket blocked leaving thread
    $\tsvar{tid}$ in the $\tscon{Close2}(\tsvar{sid})$ state. The socket $\tsvar{sid}$ has successfully transmitted all the
    data in its send queue, $\tsvar{sndq} = [\,]$, and has completed a graceful close of the connection: $\tsvar{st}
\in  \{\tscon{TIME\_WAIT}; \tscon{CLOSED}; \tscon{FIN\_WAIT\_2}\}$.

    The rule proceeds via a $\MLhtau $ transition leaving thread $\tsvar{tid}$ in the $\tscon{Ret}(\tscon{OK} ())$
    state to return successfully from the blocked $\tsunknown{close}()$ call. The socket remains in a closed state.

    Note that the asychronous sending of any remaining data in the send queue and graceful closing of
    the connection is handled by other rules. This rule applies once these events have reached a
    successful conclusion.

\rrulepad }
}

\newcommand{\closeTVI}{\rrulecc{closeTVI}{close\_6}{tcp: slow nonurgent fail}{\tsholcomm{ Fail with $\tsunknown{EAGAIN}$: unsuccessful completion of a lingering close on a synchronised socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Close2}(\tsvar{sid})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})]{}\\{}
 \Mmagicbolrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EAGAIN}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})]{}\\{}
 \Mmagicbolrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\tsvar{sock} = \tscon{Sock}(*,\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\Mtrue ,\Mtrue ,{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},[\,])) \Mwedge {}\\{}
 \tsunknown{timer\_expires} \;\tsvar{d} \Mwedge {}\\{}
 \tsvar{st} \;\notin  \{\tscon{TIME\_WAIT}; \tscon{CLOSED}\}}
{\rulesubsection{Description}

    A previous call to $\tsunknown{close}()$ with the linger option set on the socket blocked, leaving thread
    $\tsvar{tid}$ in the $\tscon{Close2}(\tsvar{sid})$ state. The linger timer has expired, $\tsunknown{timer\_expires} \;\tsvar{d}$, before
    the socket has been successfully closed: $\tsvar{st} \;\notin  \{\tscon{TIME\_WAIT}; \tscon{CLOSED}\}$.

    The rule proceeds via a $\MLhtau $ transition leaving thread $\tsvar{tid}$ in the $\tscon{Ret}(\tscon{FAIL}\;{\tsunknown{EAGAIN}})$
    state to return error $\tsunknown{EAGAIN}$ from the blocked $\tsunknown{close}()$ call. The socket remains in a
    synchronised state and is not destroyed until the socket has been successfully closed by future
    asychronous events.


    The asychronous transmission of any remaining data in the send queue and the graceful closing of
    the connection is handled by other rules. This rule is only predicated on the unsuccessfulness
    of these operations, i.e. $\tsvar{st} \;\notin  \{\tscon{TIME\_WAIT}; \tscon{CLOSED}\}$. When the linger timer expires the
    socket could be (a) still attempting to successfully transmit the data in the send queue, or (b)
    be someway through the graceful close operation. The exact state of the socket is not important
    here, explaining the relatively unconstrained socket state in the rule.

\rrulepad }
}

\newcommand{\closeTVII}{\rrulecc{closeTVII}{close\_7}{tcp: fast succeed}{\tsholcomm{ Successfully close the last file descriptor for a socket in the $\tscon{CLOSED}$, $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$ states. }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds};{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus  [(\tsvar{fid},\tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}))];{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{close}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{ \tsunknown{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}';{}\\{}
 \tsvar{files} \Mass  \tsvar{files};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks}\Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{(\tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{CLOSED}; \tscon{SYN\_SENT}\} \Mvee {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge  \neg{}\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = \tsvar{sock}.\tsvar{pr} \Mwedge {}\\{}
 \tsvar{fid} \;\notin  (\Mfdom{\tsvar{files}}) \Mwedge {}\\{}
 \tsvar{sid} \;\notin  (\Mfdom{\tsvar{socks}}) \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsunknown{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1 \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd} \Mwedge {}\\{}
 {}\\{}
 \Mcase  \;\tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{CLOSED};\tscon{LISTEN}\} \Mof {}\\{}
\quad\quad \Mtrue  \Mtotype  \tsvar{S}' = \tsvar{SS}{}\\{}
\quad\quad \Mdpipe  \Mfalse  \Mtotype  \Mif  \;\tsaux{exists\_quad\_of} \;\tsvar{sock} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{destroy} (\tsaux{quad\_of} \;\tsvar{sock}) \tsvar{SS} \;\tsvar{S}'{}\\{}
\quad\quad\quad\quad \Melse  \;\tsvar{S}' = \tsvar{SS} \tsholcomm{ FIXME presumably sockets should also die if the quad is altered }}
{\rulesubsection{Description}

    A $\tsunknown{close}(\tsvar{fd})$ call is performed on the TCP socket $\tsvar{sock}$, identified by $\tsvar{sid}$ and
    referenced by file descriptor $\tsvar{fd}$ which is the only file descriptor referencing the socket's
    file description: $\tsunknown{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1$. The TCP socket $\tsvar{sock}$ is not in a
    synchronised state: $\tsvar{st} \;\in  \{\tscon{CLOSED}; \tscon{SYN\_SENT}\}$.

    The $\tsunknown{close}(\tsvar{fd})$ call proceeds by a $\MLhcall{\tsvar{tid}}{\tsunknown{close}(\tsvar{fd})}$ transition leaving the host in
    the successful return state $\tscon{Ret} (\tscon{OK} ())$.

    The mapping of file descriptor $\tsvar{fd}$ to file descriptor index $\tsvar{fid}$ is removed from the
    host's finite map of file descriptors; the file description entry for $\tsvar{fid}$ is removed from
    the host's finite map of file descriptors; and the socket entry $(\tsvar{sid},\tsvar{sock})$ is removed from
    the host's finite map of sockets.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    The rule does not apply if the socket is in state $\tscon{SYN\_RECEIVED}$: for the purposes of
    $\tsunknown{close}()$ this is treated as a synchronised state on Linux.


    Note that the socket $\tsvar{sock}$ is not in a synchronised state and thus has no data in its send queue ready
    for transmission. Closing an unsynchronised socket simply involves deleting the socket entry and
    removing all references to it. These operations are performed immediately by the rule, hence the
    socket's $\tscon{SO\_LINGER}$ option is not constrained because it has no effect regardless of how it
    may be set.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\closeTVIII}{\rrulecc{closeTVIII}{close\_8}{tcp: fast succeed}{\tsholcomm{ Successfully close the last file descriptor for a listening TCP socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds};{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus  [(\tsvar{fid},\tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}))];{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{listen} \Mass  \tsvar{listen};{}\\{}
 \tsvar{oq}    \Mass  \tsvar{oq} \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{close}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{ \tsunknown{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}';{}\\{}
 \tsvar{files} \Mass  \tsvar{files};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks}';{}\\{}
 \tsvar{listen} \Mass  \tsvar{listen}';{}\\{}
 \tsvar{oq}    \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}'',\tsvar{M})}
{\tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis},\tsvar{sndq},\tsvar{rcvq})) \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsunknown{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1 \Mwedge {}\\{}
 \tsvar{fid} \;\notin  (\Mfdom{\tsvar{files}}) \Mwedge {}\\{}
 \tsvar{sid} \;\notin  (\Mfdom{\tsvar{socks}}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ cantrcvmore/cantsndmore unconstrained under BSD, as may have previously called shutdown }{}\\{}
 \tsholcomm{ MS: this is more of an assertion than a condition, so we could get away without it }{}\\{}
 (\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mvee  (\tsvar{cantsndmore} = \Mfalse  \Mwedge  \tsvar{cantrcvmore} = \Mfalse )) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ BSD and Linux do not send RSTs to sockets on $\tsvar{lis}.\tsunknown{q0}$. }{}\\{}
 \tsunknown{socks\_to\_rst} = \{ \tsvar{sock}' \mid  \exists \tsvar{sid}' \;\tsunknown{tcp\_sock'}. \tsvar{sid}' \;\in  \;\tsvar{lis}.\tsunknown{q} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{socks} \Mfapply{}{\tsvar{sid}'} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) = \tsvar{sock}'.\tsvar{pr} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock'}.\tsvar{st} \;\notin  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT}\} \} \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \Mfdom{\tsvar{S}'} = \Mfdom{\tsvar{SS}} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ FIXME not sure about the following }{}\\{}
 (\forall  \tsvar{sock}'. \tsvar{sock}' \;\in  \;\tsunknown{socks\_to\_rst} \implies {}\\{}
\quad\quad \Mlet  (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) = \tsaux{quad\_of} \;\tsvar{sock}' \;\Min {}\\{}
\quad\quad \Mlet  \;\tsvar{streamid} = \tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \Min {}\\{}
\quad\quad \exists  \tsvar{oflgs} \;\tsvar{odata}.{}\\{}
\quad\quad \tsholcomm{ FIXME info about what a RST is should be localised in one place }{}\\{}
\quad\quad \tsvar{oflgs} = \tsvar{oflgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mtrue  \Mmagicrrec  \Mwedge {}\\{}
\quad\quad \tsvar{odata} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
\quad\quad \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) (\tsvar{SS} \Mfapply{}{\tsvar{streamid}}) (\tsvar{S}' \Mfapply{}{\tsvar{streamid}})) \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{streamid} \Mcons  \Mfdom{\tsvar{SS}}.{}\\{}
\quad\quad \neg{} (\tsvar{streamid} \;\in  (\tsholop{IMAGE} (\tsaux{streamid\_of\_quad} \;\tsunknown{o} \;\tsaux{quad\_of}) \tsunknown{socks\_to\_rst})) \implies {}\\{}
\quad\quad \tsvar{S}' \Mfapply{}{\tsvar{streamid}} = \tsvar{SS} \Mfapply{}{\tsvar{streamid}}) \Mwedge {}\\{}
 {}\\{}
 \tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd} \Mwedge {}\\{}
 \tsvar{listen}' = \tsholop{FILTER} (\lambda \tsvar{sid}'. \tsvar{sid}' \neq  \tsvar{sid}) \tsvar{listen} \Mwedge {}\\{}
 \tsvar{socks}' = \Mdrestrict{\tsvar{socks}}{\{ \tsvar{sid}' \mid   \tsvar{sid}' \;\notin  \Mappend{\tsvar{lis}.\tsunknown{q0}}{\tsvar{lis}.\tsunknown{q}}\}} \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ $\tsunknown{removed\_sids}$ does not include sid }{}\\{}
 \Mlet  \;\tsunknown{removed\_sids} = \{ \tsvar{sid}' \mid   \tsvar{sid}' \;\in  \Mappend{\tsvar{lis}.\tsunknown{q0}}{\tsvar{lis}.\tsunknown{q}}\} \Min {}\\{}
 \Mlet  \;\tsunknown{removed\_socks} = \{\tsvar{sock}\} \cup  \{\tsvar{sock}'\mid  \exists  \tsvar{sid}'. \tsvar{sid}' \;\in  \;\tsunknown{removed\_sids} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{socks} \Mfapply{}{\tsvar{sid}'} = \tsvar{sock}'\} \Min {}\\{}
 \Mlet  \;\tsvar{destroyed} = \{ (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \mid  \exists  \tsvar{sock}. \tsvar{sock} \;\in  \;\tsunknown{removed\_socks} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{ps}_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}) = (\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2}) \} \Min {}\\{}
 {}\\{}
 \tsholcomm{ Some streams are destroyed }{}\\{}
 \tsaux{destroy\_quads} \;\tsvar{destroyed} \;\tsvar{S}' \;\tsvar{S}''{}\\{}
 }
{\rulesubsection{Description}

    A $\tsunknown{close}(\tsvar{fd})$ call is performed on the TCP socket $\tsvar{sock}$ referenced by file descriptor
    $\tsvar{fd}$ which is the only file descriptor referencing the socket's file description $\tsvar{fid}$,
    $\tsunknown{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1$. Socket $\tsvar{sock}$ is locally bound to port $\tsvar{p}_{1}$ and one or more
    local IP addresses $\tsvar{is}_{1}$, and is in the $\tscon{LISTEN}$ state.

    The listening socket $\tsvar{sock}$ may have $\tscon{ESTABLISHED}$ incoming connections on its connection
    queue $\tsvar{lis}.\tsunknown{q}$ and incomplete incoming connection attempts on queue $\tsvar{lis}.\tsunknown{q0}$. Each
    connection, regardless of whether it is complete or not, is represented by a $\tstype{socket}$
    entry in $\tsvar{h}.\tsvar{socks}$ and its corresponding index $\tsvar{sid}$ is on the respective queue. These
    connections have not been accepted by any thread through a call to $\tsunknown{accept}()$ and are dropped
    on the closure of socket $\tsvar{sock}$.

    A set of reset seqments $\tsunknown{rsts\_to\_go}$ is created using the auxiliary function
    \ltslink{makeTrstTsegmentTfromTcb}{$\tsaux{make\_rst\_segment\_from\_cb}$} for each of the sockets referenced by both queues. This is
    performed by looking up each socket $\tsvar{sock}'$ for every $\tsvar{sid}'$ in the concatentation of both
    queues, $\Mappend{\tsvar{lis}.\tsunknown{q0}}{\tsvar{lis}.\tsunknown{q}}$, and extracting their address quads
    $(\tsvar{sock}'.\tsvar{is}_{1},\tsvar{sock}'.\tsvar{is}_{2},\tsvar{sock}'.\tsvar{ps}_{1},\tsvar{sock}'.\tsvar{ps}_{2})$ and control blocks $\tsvar{cb}$ for use by
    $\tsaux{make\_rst\_segment\_from\_cb}$.

    The set of reset segments $\tsunknown{rsts\_to\_go}$ is constrained to a list, $\tsunknown{segs}$, and  queued by
    the auxiliary function $\tsaux{enqueue\_each\_and\_ignore\_fail}$ on the hosts output queue $\tsvar{h}.\tsvar{oq}$.  The
    $\tsaux{enqueue\_each\_and\_ignore\_fail}$ function always succeeds; if it is not possible to add any of
    the reset segments $\tsunknown{segs}$ to the output queue $\tsvar{h}.\tsvar{oq}$, the corresponding error codes are
    ignored and the reset segments in error are ultimately not queued for transmission. This is
    sensible behaviour as the sockets for these connections are about to be deleted: if a reset
    segment does not successfully abort the remote end of the connection, perhaps because it could
    not be transmitted in the first place, any future incoming segments should not match any other
    socket in the system and will be dropped.

    The $\tsunknown{close}(\tsvar{fd})$ call proceeds by a $\MLhcall{\tsvar{tid}}{\tsunknown{close}(\tsvar{fd})}$ transition leaving the host in
    the successful return state $\tscon{Ret} (\tscon{OK} ())$.

    In the final host state, the mapping of file descriptor $\tsvar{fd}$ to file descriptor index $\tsvar{fid}$
    is removed from the file descriptors finite map $\tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd}$ and file description entry
    $\tsvar{fid}$ is removed from the finite map of file descriptors $\tsvar{h}.\tsvar{files}$. The socket entry
    $\tsvar{sock}$ is removed from the hosts finite map of sockets $\tsvar{h}.\tsvar{socks}$ and the socket's $\tsvar{sid}$
    value is removed from the host's list of listening sockets $\tsvar{h}.\tsvar{listen}$ by $\tsvar{listen}' = \tsholop{FILTER}
(\lambda \tsvar{sid}'. \tsvar{sid}' \neq  \tsvar{sid}) \tsvar{listen}$. Finally, all the sockets in $\tsvar{h}.\tsvar{socks}$ that were referenced on
    one of the queues $\tsvar{lis}.\tsunknown{q0}$ and $\tsvar{lis}.\tsunknown{q}$, are removed by $\tsvar{socks}' = \Mdrestrict{\tsvar{socks}}{\{ \tsvar{sid}' \mid  \tsvar{sid}' \;\notin  \Mappend{\tsvar{lis}.\tsunknown{q0}}{\tsvar{lis}.\tsunknown{q}}\}}$ as they were not accepted by any thread before socket $\tsvar{sock}$
    was closed.

\rulesubsection{Model details}

    The local IP address option $\tsvar{is}_{1}$ of the socket $\tsvar{sock}$ is not constrained in this
    rule. Instead it is constrained by other rules for $\tsunknown{bind}()$ and $\tsvar{listen}()$ prior to the
    socket entering the $\tscon{LISTEN}$ state.

\rrulepad }
}

\newcommand{\closeTX}{\rrulecc{closeTX}{close\_10}{udp: fast succeed}{\tsholcomm{ Successfully close the last file descriptor of a UDP socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds};{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus  [(\tsvar{fid},\tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}))];{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{close}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}';{}\\{}
 \tsvar{files} \Mass  \tsvar{files};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsunknown{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1 \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd} \Mwedge {}\\{}
 \tsvar{fid} \;\notin  (\Mfdom{\tsvar{files}}) \Mwedge {}\\{}
 \tsvar{sid} \;\notin  (\Mfdom{\tsvar{socks}})}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, with a file description record indexed by
    $\tsvar{fid}$. $\tsvar{fd}$ is the only open file descriptor referring to the file description record
    indexed by $\tsvar{fid}$, $\tsunknown{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1$. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$
    state, a $\tsunknown{close}(\tsvar{fd})$ call is made and succeeds.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{close}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}())$. The
    socket $\tsvar{sid}$ is removed from the host's finite map of sockets $\tsvar{socks}$$\oplus\dots$, the
    file description record indexed by $\tsvar{fid}$ is removed from the host's finite map of file
    descriptions $\tsvar{files}$$\oplus\dots$, and $\tsvar{fd}$ is removed from the host's finite map of file
    descriptors $\tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd}$.

\rrulepad }
}

\newcommand{\seccommconnect}{\clustersection{(TCP and UDP)}{$\tsunknown{connect}()$}
\seccomm{ \[ \tsunknown{connect}: \tsunknown{fd} * \tsunknown{ip} * \tsunknown{port} \;\;\tstype{option} \Mtotype  \tstype{unit} \]

  A call to $\tsunknown{connect}(\tsunknown{fd},\tsunknown{ip},\tsunknown{port})$ attempts to connect a TCP socket to a peer, or to set the peer
  address of a UDP socket.
  Here $\tsunknown{fd}$ is a file descriptor referring to a socket,
  $\tsunknown{ip}$ is the peer IP address to connect to, and $\tsunknown{port}$ is the peer port.

  If $\tsunknown{fd}$ refers to a TCP socket then TCP's connection establishment protocol, often called the
  \textit{three-way handshake}, will be used to connect the socket to the peer specified by
  $(\tsunknown{ip},\tsunknown{port})$. A peer port must be specified: $\tsunknown{port}$ cannot be set to $*$. There must be a
  listening TCP socket at the peer address, otherwise the connection attempt will fail with an
  $\tsunknown{ECONNRESET}$ or $\tsunknown{ECONNREFUSED}$ error. The local socket must be in the $\tscon{CLOSED}$ state: attempts to
  $\tsunknown{connect}()$ to a peer when already synchronised with another peer will fail. To start
  the connection establishment attempt, a $\tsvar{SYN}$ segment will be constructed, specifying the
  initial sequeunce number and window size for the connection, and possibly the maximum segment
  size, window scaling, and timestamping.  The segment is then
  enqueued on the host's out-queue; if this fails then the $\tsunknown{connect}()$ call fails, otherwise
  connection establishment proceeds.

  If the socket is a blocking one (the $\tscon{O\_NONBLOCK}$ flag for $\tsunknown{fd}$ is not set), then the call
  will block until the connection is established, or a timeout expires in which case the error
  $\tsunknown{ETIMEDOUT}$ is returned.

  If the socket is non-blocking (the $\tscon{O\_NONBLOCK}$ flag is set for $\tsunknown{fd}$), then the $\tsunknown{connect}()$
  call will fail with an $\tsunknown{EINPROGRESS}$ error (or $\tsunknown{EALREADY}$ on WinXP), and connection
  establishment will proceed asynchronously.

  Calling $\tsunknown{connect}()$ again will indicate the current status of the connection establishment in
  the returned error: it will fail with $\tsunknown{EALREADY}$ if the connection has not been established,
  $\tsunknown{EISCONN}$ once the connection has been established, or if the connection establishment failed,
  an error describing why. Alternatively, $\tsunknown{pselect}([\,],[\tsunknown{fd}],[\,],*,\tsunknown{\_})$ can be used; it will return
  when $\tsunknown{fd}$ is ready for writing which will be when connection establishment is complete, either
  successfully or not. On Linux, unsetting the $\tscon{O\_NONBLOCK}$ flag for $\tsunknown{fd}$ and then calling
  $\tsunknown{connect}()$ will block until the connection is established or fails; for WinXP the call will
  fail with $\tsunknown{EALREADY}$ and the connection establishment will be performed asynchronously still;
  for FreeBSD the call will fail with $\tsunknown{EISCONN}$ even if the connection has not been established.

  Upon completion of connection establishment the socket will be in state $\tscon{ESTABLISHED}$, ready to
  send and receive data, or $\tscon{CLOSE\_WAIT}$ if it received a FIN segment during connection
  establishment.

  On FreeBSD, if connection establishment fails having sent a $\tsvar{SYN}$ then further connection
  establishment attempts are not allowed; on Linux and WinXP further attempts are possible.

  If $\tsunknown{fd}$ refers to a UDP socket then the peer address of the socket is set, but no connection is
  made. The peer address is then the default destination address for subsequent $\tsunknown{send}()$ calls
  (and the only possible destination address on FreeBSD), and only datagrams with this source
  address will be delivered to the socket. On FreeBSD the peer port must be specified: a call to
  $\tsunknown{connect}(\tsunknown{fd},\tsunknown{ip},*)$ will fail with an $\tsunknown{EADDRNOTAVAIL}$ error; on Linux and WinXP such a call
  succeeds: datagrams from any port on the host with IP address $\tsunknown{ip}$ will be delivered to the
  socket. Calling $\tsunknown{connect}()$ on a UDP socket that already has a peer address set is allowed: the
  peer address will be replaced with the one specified in the call. On FreeBSD if the socket has a
  pending error, that may be returned when the call is made, and the peer address will also be set.

  In order for a socket to connect to a peer or have its peer address set, it must be bound to a
  local IP and port. If it is not bound to a local port when the $\tsunknown{connect}()$ call is made, then it
  will be autobound: an unused port for the socket's protocol in the host's ephemeral port range is
  selected and assigned to the socket. If the socket does not have its local IP address set then it
  will be bound to the primary IP address of an interface which has a route to the peer. If the
  socket does have a local IP address set then the interface that this IP address will be the
  one used to connect to the peer; if this interface does not have a route to the peer then for a
  TCP socket the $\tsunknown{connect}()$ call will fail when the SYN is enqueued on the host's outqueue; for a
  UDP socket the call will  fail on FreeBSD, whereas on Linux and WinXP the $\tsunknown{connect}()$ call will
  succeed but later $\tsunknown{send}()$ calls to the peer will fail.

  For a TCP socket, its binding quad must be unique: there can be no other socket in the host's
  finite map of sockets with the same binding quad. If the $\tsunknown{connect}()$ call would result in two
  sockets having the same binding quad then it will fail with an $\tsunknown{EADDRINUSE}$ error. For UDP
  sockets the same is true on FreeBSD, but on Linux and WinXP multiple sockets may have the same
  address quad. The socket that matching datagrams are delivered to is architecture-dependent: see
  \ltslink{lookup}{$\tsunknown{lookup}$}.


}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{connect}()$ can fail with the errors below, in which case the corresponding exception
  is raised:

\par\begin{ltstabular}
$\tsunknown{EADDRNOTAVAIL}$
&  There is no route to the peer; a port must be specified ($\tsunknown{port} \neq  *$); or
  there are no ephemeral ports left.

\\\hline
$\tsunknown{EADDRINUSE}$
&  The address quad that would result if the connection was successful is in
  use by another socket of the same protocol.

\\\hline
$\tsunknown{EAGAIN}$
&  On WinXP, the socket is non-blocking and the connection cannot be established
  immediately: it will be established asynchronously. [TCP ONLY]

\\\hline
$\tsunknown{EALREADY}$
&  A connection attempt is already in progress on the socket but not
  yet complete: it is in state $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$. [TCP ONLY]

\\\hline
$\tsunknown{ECONNREFUSED}$
&  Connection rejected by peer. [TCP ONLY]

\\\hline
$\tsunknown{ECONNRESET}$
&  Connection rejected by peer. [TCP ONLY]

\\\hline
$\tsunknown{EHOSTUNREACH}$
&  No route to the peer.

\\\hline
$\tsunknown{EINPROGRESS}$
&  The socket is non-blocking and the connection cannot be established
  immediately: it will be established asynchronously. [TCP ONLY]

\\\hline
$\tsunknown{EINVAL}$
&  On WinXP, socket is listening. [TCP ONLY]

\\\hline
$\tsunknown{EISCONN}$
&  Socket already connected. [TCP ONLY]

\\\hline
$\tsunknown{ENETDOWN}$
&  The interface used to reach the peer is down.

\\\hline
$\tsunknown{ENETUNREACH}$
&  No route to the peer.

\\\hline
$\tsunknown{EOPNOTSUPP}$
&  On FreeBSD, socket is listening. [TCP ONLY]

\\\hline
$\tsunknown{ETIMEDOUT}$
&   The connection attempt timed out before a connection was established for a socket. [TCP ONLY]

\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\\\hline
$\tsunknown{EINTR}$
&  The system was interrupted by a caught signal.

\\\hline
$\tsunknown{ENOBUFS}$
&  Out of resources.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  TCP: $\tsunknown{socket\_1}$; $\tsunknown{connect\_1}$; $\dots$

  UDP: $\tsunknown{socket\_1}$; $\tsunknown{bind\_1}$; $\tsunknown{connect\_8}$; $\dots$


}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:  &  \wasverb{int connect(int socket, const struct sockaddr *address, socklen\textunderscore{}t address\textunderscore{}len);} \\
    FreeBSD:&  \wasverb{int connect(int s, const struct sockaddr *name, socklen\textunderscore{}t namelen);} \\
    Linux:  &  \wasverb{int connect(int sockfd, constr struct sockaddr *serv\textunderscore{}addr, socklen\textunderscore{}t addrlen);} \\
    WinXP:  &  \wasverb{int connect(SOCKET s, const struct sockaddr* name, int namelen);} \\
  \end{tabular}\\

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is a file descriptor referring to the socket to make a connection on,
    corresponding to the $\tsunknown{fd}$ argument of the model $\tsunknown{connect}()$.

    \item \wasverb{address} is a pointer to a \wasverb{sockaddr} structure of length
    \wasverb{address\textunderscore{}len} specifying the peer to connect to. \wasverb{sockaddr} is a generic socket
    address structure: what is used for the model $\tsunknown{connect}()$ is an internet socket
    address structure \wasverb{sockaddr\textunderscore{}in}. The \wasverb{sin\textunderscore{}family} member is set to
    \wasverb{AF\textunderscore{}INET}; the \wasverb{sin\textunderscore{}port} is the port to connect to, corresponding to the
    $\tsunknown{port}$ argument of the model $\tsunknown{connect}()$: \wasverb{sin\textunderscore{}port = 0} corresponds to
    $\tsunknown{port}=*$ and \wasverb{sin\textunderscore{}port=p} corresponds to $\tsunknown{port} = \Msome  \;\tsvar{p}$; the
    \wasverb{sin\textunderscore{}addr.s\textunderscore{}addr} member of the structure corresponds to the $\tsunknown{ip}$ argument of the
    model $\tsunknown{connect}()$.

   \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual
     error code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  The FreeBSD, Linux and WinXP interfaces are similar modulo argument renaming, except where
  noted above.

  Note: For UDP sockets, the Winsock Reference says "The default destination can be changed by
  simply calling connect again, even if the socket is already connected. Any datagrams queued for
  receipt are discarded if name is different from the previous connect." This is not the
  case.

}\clustersubsection{Model details}
\seccomm{
  If the call blocks then the thread enters state $\tscon{Connect2}(\tsunknown{sid})$ where $\tsunknown{sid}$ is the identifier
  of the socket attempting to establish a connection.

  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EAFNOSUPPORT} means that the specified address is not a valid address for the
    address family of the specified socket. The model $\tsunknown{connect}()$ only models the
    \wasverb{AF\textunderscore{}INET} family of addresses so this error cannot occur.

    \item \wasverb{EFAULT} signifies that the pointers passed as either the \wasverb{address} or
     \wasverb{address\textunderscore{}len} arguments were inaccessible.  This is an artefact of the C interface to
     $\tsunknown{connect}()$ that is excluded by the clean interface used in the model.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

    \item \wasverb{EINVAL} is a Posix-specific error signifying that the \wasverb{address\textunderscore{}len}
    argument is not a valid length for the socket's address family or invalid address family in the
    \wasverb{sockaddr} structure. The length of the address to connect to is implicit in the model
    $\tsunknown{connect}()$, and only the \wasverb{AF\textunderscore{}INET} family of addresses is modelled so this error
    cannot occur.

   \item \wasverb{EPROTOTYPE} is a Posix-specific error meaning that the specified address has a
   different type than the socket bound to the specified peer address. This error does not occur in
   any of the implementations as TCP and UDP sockets are dealt with seperately.

   \item \wasverb{EACCES}, \wasverb{ELOOP}, and \wasverb{ENAMETOOLONG} are errors dealing with Unix
   domain sockets which are not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{connect\_1}$
& \textbf{tcp: rc}
&  Begin connection establishment by creating a SYN and trying to enqueue it on host's outqueue \\
$\tsrule{connect\_1a}$
& \textbf{tcp: rc}
&  Begin connection establishment by creating a SYN and trying to enqueue it on host's outqueue \\
$\tsrule{connect\_2}$
& \textbf{tcp: slow urgent succeed}
&  Successfully return from blocking state after connection is successfully established \\
$\tsrule{connect\_3}$
& \textbf{tcp: slow urgent fail}
&  Fail with the pending error on a socket in the $\tscon{CLOSED}$ state \\
$\tsrule{connect\_4}$
& \textbf{tcp: slow urgent fail}
&  Fail: socket has pending error \\
$\tsrule{connect\_4a}$
& \textbf{tcp: fast fail}
&  Fail with pending error \\
$\tsrule{connect\_5}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{EALREADY}$, $\tsunknown{EINVAL}$, $\tsunknown{EISCONN}$, $\tsunknown{EOPNOTSUPP}$: socket already in use \\
$\tsrule{connect\_5a}$
& \textbf{all: fast fail}
&  Fail: no route to host \\
$\tsrule{connect\_5b}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{EADDRINUSE}$: address already in use \\
$\tsrule{connect\_5c}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{EADDRNOTAVAIL}$: no ephemeral ports left \\
$\tsrule{connect\_5d}$
& \textbf{tcp: block}
&  Block, entering state $\tscon{Connect2}$: connection attempt already in progress and connect called with blocking semantics \\
$\tsrule{connect\_6}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{EINVAL}$: socket has been shutdown for writing \\
$\tsrule{connect\_7}$
& \textbf{udp: fast succeed}
&  Set peer address on socket with binding quad $*,\tsvar{ps}_{1},*,*$ \\
$\tsrule{connect\_8}$
& \textbf{udp: fast succeed}
&  Set peer address on socket with local address set \\
$\tsrule{connect\_9}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{EADDRNOTAVAIL}$: port must be specified in $\tsunknown{connect}()$ call on FreeBSD \\
$\tsrule{connect\_10}$
& \textbf{udp: fast fail}
&  Fail with pending error on FreeBSD, but still set peer address \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\connectTI}{\rrulecc{connectTI}{connect\_1}{tcp: rc}{\tsholcomm{ Begin connection establishment by creating a SYN and trying to enqueue it on host's outqueue }}
{(\tsvar{h},\tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} }{1}}
{(\tsvar{h}',\tsvar{S}',\tsvar{M})}
{{}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ FIXME N.B. this rule has been split into two to cope with BSD specific behaviour }{}\\{}
 {}\\{}
 \tsholcomm{ Thread $\tsvar{tid}$ is in state $\tscon{Run}$ and TCP socket $\tsvar{sid}$ has binding quad $(\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2})$.  }{}\\{}
 \tsvar{h}  = \tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsunknown{ts\_}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,[\,],[\,])))] ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Thread $\tsvar{tid}$ ends in state $\tsvar{t}'$ with updated host sockets and output queue }{}\\{}
 \tsvar{h}' = \tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsunknown{ts\_}}{\tsvar{tid}}{\tsvar{t}'};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}'_{1},\Msome  \;\tsvar{p}'_{1},\tsvar{is}'_{2},\tsvar{ps}'_{2},\tsvar{es}'',\Mfalse ,\Mfalse ,{}\\{}
\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st}',\tsvar{cb}''',*,[\,],[\,])))] ;{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ File descriptor $\tsvar{fd}$ refers to TCP socket $\tsvar{sid}$ }{}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{h}_{0}.\tsvar{files} \Mfapply{}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Either $\tsvar{sid}$ is bound to a local IP address or one of the host's interface has a route to
     $\tsvar{i}_{2}$ and $\tsvar{i}'_{1}$ is one of its IP addresses.  If it is not routable, then we will fail below,
     when we try to enqueue the segment. }{}\\{}
 {}\\{}
 \tsvar{i}'_{1} \;\in  \;\tsunknown{auto\_outroute}(\tsvar{i}_{2},\tsvar{is}_{1},\tsvar{h}.\tsvar{rttab},\tsvar{h}.\tsvar{ifds}) \Mwedge {}\\{}
\quad \tsholcomm{ Notice that $\tsunknown{auto\_outroute}$ never fails if $\tsvar{is}_{1}\neq *$ (i.e., is specified in the socket). }{}\\{}
 {}\\{}
 \tsholcomm{ The socket is either bound to a local port $\tsvar{p}'_{1}$ or can be autobound to an ephemeral port $\tsvar{p}'_{1}$ }{}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{ps}_{1},\tsunknown{PROTO\_TCP},\tsvar{h},\tsvar{h}.\tsvar{socks}) \Mwedge {}\\{}
 \tsholcomm{ If autobinding occurs then $\tsvar{sid}$ is added to the head of the host's list of bound sockets. }{}\\{}
 (\Mif  \;\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}.\tsvar{bound}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ The socket can be in one of two states: (1) it is in state $\tscon{CLOSED}$ in which case its
         peer address is not set; it has no pending error; it is not shutdown for writing; and it is
         not shutdown for reading on non-FreeBSD architectures. Otherwise, (2) on FreeBSD the socket
         is in state $\tscon{TIME\_WAIT}$, and either $\tsvar{is}_{2}$ and $\tsvar{ps}_{2}$ are both set or both are not set.
       The fact that BSD allows a $\tscon{TIME\_WAIT}$ socket to be reconnected means that some
       fields may contain old data, so we leave them unconstrained here. This is particularly
       important in the $\tsvar{cb}$.
     }{}\\{}
 {}\\{}
 (\tsvar{st} = \tscon{CLOSED} \Mwedge  \tsvar{is}_{2} = * \Mwedge  \tsvar{ps}_{2} = * \Mwedge {}\\{}
\quad \tsvar{es} = * \Mwedge  \tsvar{cantsndmore} = \Mfalse  \Mwedge  (\tsvar{cantrcvmore} = \Mfalse  \Mvee  \tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ No other TCP sockets on the host have the address quad $(\Msome  \;\tsvar{i}'_{1},\Msome  \;\tsvar{p}'_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$. }{}\\{}
 \neg{}(\exists  (\tsvar{sid}', \tsvar{s}) \Mcons  (\tsvar{h}.\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}).{}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{s}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}'_{1} \Mwedge  \tsvar{s}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}'_{1} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{s}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2}  \Mwedge  \tsvar{s}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}  \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{proto\_of} \;\tsvar{s}.\tsvar{pr} = \tsunknown{PROTO\_TCP}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Update the socket's control block to $\tsvar{cb}'$, which is $\tsvar{cb}$ except we: (1) start the
     retransmit and connection establishment timers; (2) set the $\tsunknown{snd\_una}$, $\tsunknown{snd\_nxt}$,
     $\tsunknown{snd\_max}$, $\tsunknown{iss}$ fields based on the initial sequence number chosen; (3) set the
     $\tsunknown{rcv\_wnd}$, $\tsunknown{rcv\_adv}$, and $\tsunknown{tf\_rxwin0sent}$ fields based on the receive window chosen; (4)
     record whether or not to do windows scaling, time-stamping, and what the advertised maximum
     segment size is; and (5) store the segment to time. }{}\\{}
 \tsvar{cb}' = \tsvar{cb} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ now build the segment (using an auxiliary, since we might have to retransmit it) }{}\\{}
 {}\\{}
 \tsholcomm{ Make a $\tsvar{SYN}$ segment based on the updated control block and the socket's address quad;
     see \ltslink{makeTsynTsegment}{$\tsaux{make\_syn\_segment}$} for details. }{}\\{}
 (\tsvar{oflgs},\tsvar{odata}) \in  \;\tsaux{make\_syn\_flgs\_data} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ and send it out... }{}\\{}
 {}\\{}
 \tsholcomm{ If possible, enqueue the segment $\tsunknown{seg}$ on the host's outqueue. The auxiliary function
     \ltslink{rollbackTtcpToutput}{$\tsaux{rollback\_tcp\_output}$} is used for this; if the segment is a well-formed segment,
     there is a route to the peer from $\tsvar{i}'_{1}$, and there are no buffer allocation failures,
     $\tsvar{outsegs}' \neq  [\,]$, then the segment is enqueued on the host's outqueue, $\tsvar{oq}$, resulting in a
     new outqueue, $\tsvar{oq}'$. The socket's control block is left as $\tsvar{cb}'$ which is described
     above. Otherwise an error may have occurred; possible errors are: (1) $\tsunknown{ENOBUFS}$ indicating a
     buffer allocation failure; (2) a routing error; or (3) $\tsunknown{EADDRNOTAVAIL}$ on FreeBSD or
     $\tsunknown{EINVAL}$ on Linux indicating that the segment would cause a loopback packet to appear on the
     wire (on WINXP the segment is silently dropped with no error in this case). If an error does
     occur then the socket's control block reverts to $\tsvar{cb}$, the control block when the call was
     made. }{}\\{}
 \exists \tsvar{outsegs}'.  {}\\{}
 \tsaux{FIXMEstream\_rollback\_tcp\_output} \;\Mfalse  (\Msome  \;\tsvar{i}'_{1}, \Msome  \;\tsvar{i}_{2}) \tsvar{h}.\tsvar{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{cb}' (\tsvar{cb}'',\tsvar{es}',\tsvar{outsegs}') \Mwedge {}\\{}
 \tsvar{cb}''' = (\Mif  (\tsvar{outsegs}' \Mvee  \tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch}) \Mthen  \;\tsvar{cb}'' \;\Melse  \;\tsvar{cb}) \Mwedge {}\\{}
 (\tsunknown{INFINITE\_RESOURCES} \implies  \tsvar{queued}) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ If the socket is a blocking one, its $\tscon{O\_NONBLOCK}$ flag is not set, then the call will
         block, entering state $\tscon{Connect2}(\tsvar{sid})$ and leaving the socket in state $\tscon{SYN\_SENT}$ with
         peer address $(\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ and, if the segment could not be enqueued, its pending
         error set to the error resulting from the attempt to enqueue the segment.

	 If the socket is non-blocking, its $\tscon{O\_NONBLOCK}$ flag is set, and the segment was enqueued
	 on the host's outqueue, then the call will fail with an $\tsunknown{EINPROGRESS}$ error (or $\tsunknown{EAGAIN}$
	 on WinXP). The socket will be left in state $\tscon{SYN\_SENT}$ with peer address $(\Msome  \;\tsvar{i}_{2},\Msome
\tsvar{p}_{2})$. Otherwise, if the segment was not enqueued, then the call will fail with the error
	 resulting from attempting to enqueue it, $\Msome  \;\tsvar{err}$; the socket will be left in state
	 $\tscon{CLOSED}$ with no peer address set.
     }{}\\{}
 {}\\{}
 \tsholcomm{ In the case of BSD, if we connect via the loopback interface, then the segment exchange
         occurs so fast that the socket has connected before the connect-calling thread regains control.
         When it does, it sees that the socket has been connected, and therefore returns with success
         rather than $\tsunknown{EINPROGRESS}$. Since this behaviour is due to timing, however, it may be possible
         for the connect call to return before all the segments have been sent, for example if there
         was an artificially imposed delay on the loopback interface. This behaviour is therefore
         made nondeterministic, for a BSD non-blocking socket connecting via loopback, in that it may
         either fail immediately, or be blocked for a short time.
         Linux does not exhibit this behaviour.}{}\\{}
 {}\\{}
 (\tsholcomm{ blocking socket, or BSD and using loopback interface }{}\\{}
 ((\neg{}\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) \Mvee  (\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsvar{i}_{2} \;\in  \;\tsunknown{local\_ips} \;\tsvar{h}.\tsvar{ifds})) \Mwedge {}\\{}
\quad\quad \tsvar{t}' = \Mtimed{\tscon{Connect2}(\tsvar{sid})}{\tsunknown{never\_timer}} \Mwedge  \tsvar{rc} = \tscon{block} \Mwedge {}\\{}
\quad\quad \tsvar{es}''=\tsvar{es}' \Mwedge  \tsvar{st}' = \tscon{SYN\_SENT} \Mwedge  \tsvar{is}'_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}'_{2} = \Msome  \;\tsvar{p}_{2} \Mwedge {}\\{}
\quad\quad\quad \tsvar{s} = \tsaux{initial\_streams} (\tsvar{i}'_{1},\tsvar{p}'_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \Mwedge {}\\{}
\quad\quad\quad \tsaux{write} (\tsvar{i}'_{1},\tsvar{p}'_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
\quad\quad\quad \tsvar{S}' = \tsvar{SS} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}'_{1},\tsvar{p}'_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')]) \Mvee {}\\{}
 \tsholcomm{ non-blocking socket }{}\\{}
 (\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) \Mwedge {}\\{}
\quad\quad \tsvar{es} = * \Mwedge {}\\{}
\quad\quad (\tsvar{err} = (\Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsunknown{EAGAIN} \;\Melse  \;\tsunknown{EINPROGRESS}) \Mvee  \Msome  \;\tsvar{err} = \tsvar{es}') \Mwedge {}\\{}
\quad\quad \tsvar{t}' = \Mtimed{\tscon{Ret}(\tscon{FAIL}\;{\tsvar{err}})}{\tsunknown{sched\_timer}} \Mwedge  \tsvar{rc} = \tscon{fast} \;\tscon{fail} \Mwedge  \tsvar{es}''=* \Mwedge {}\\{}
\quad\quad \Mif  \neg{}\tsvar{queued} \;\Mthen {}\\{}
\quad\quad\quad\quad \tsvar{st}' = \tscon{CLOSED} \Mwedge  \tsvar{is}'_{2} = * \Mwedge  \tsvar{ps}'_{2} = * \Mwedge {}\\{}
\quad\quad\quad\quad \tsholcomm{ under BSD $\tsvar{st}$ could be $\tscon{TIME\_WAIT}$ }{}\\{}
\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad \tsvar{S}' = \tsvar{SS}{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad\quad \tsvar{st}' = \tscon{SYN\_SENT} \Mwedge  \tsvar{is}'_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}'_{2} = \Msome  \;\tsvar{p}_{2} \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{s} = \tsaux{initial\_streams} (\tsvar{i}'_{1},\tsvar{p}'_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsaux{write} (\tsvar{i}'_{1},\tsvar{p}'_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{S}' = \tsvar{SS} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}'_{1},\tsvar{p}'_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')]){}\\{}
 )}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, a $\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ call is made where $\tsvar{fd}$ refers to a TCP
   socket. The socket is in state $\tscon{CLOSED}$ with no peer address set, no pending error, and not
   shutdown for reading or writing. A $\tsvar{SYN}$ segment is created to being connection establishment,
   and is enqueued on the host's out-queue.

   If the socket is a blocking one (its $\tscon{O\_NONBLOCK}$ flag is not set) then the call will block: a
   $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread state
   $\tscon{Connect2}(\tsvar{sid})$. If the socket is non-blocking (its $\tscon{O\_NONBLOCK}$ flag is set) and the segment
   enqueuing was successful then the call will fail: a $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$
   transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINPROGRESS}})$ (or $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EAGAIN}})$ on WinXP); connection establishment will proceed asynchronously. Otherwise, if the enqueueing did not succeed, the call will fail with an
   error $\tsvar{err}$: a $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread
   in state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$.

   For further details see the in-line comments above.


\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   The socket may also be in state $\tscon{TIME\_WAIT}$ when the $\tsunknown{connect}()$ call is made, with either
   both its peer IP and port set, or neither set.

   The socket may be shutdown for reading when the $\tsunknown{connect}()$ call is made.

\\\hline
WinXP
&
   If there is an early buffer allocation failure when enqueuing the segment, then it will not be
   placed on the host's out-queue and $\tsvar{es}' = \tsunknown{ENOBUFS}$; the socket's control block will be $\tsvar{cb}'$
   with its $\tsunknown{snd\_nxt}$ and $\tsunknown{snd\_max}$ fields set to the intial sequence number, its
   $\tsunknown{last\_ack\_seen}$ and $\tsunknown{rcv\_adv}$ fields set to $0$, its $\tsunknown{tt\_delack}$ option set to $*$,
   its $\tsunknown{tt\_rexmt}$ timer stopped, and its $\tsunknown{tf\_rxwin0sent}$ and $\tsunknown{t\_rttseg}$ fields reset.

   If there is no route from an interface specified by the local IP address $\tsvar{i}_{1}$ to the foreign IP
   address $\tsvar{i}_{2}$ then the socket's control block will be $\tsvar{cb}'$ with its $\tsunknown{snd\_next}$ field set to the
   initial sequence number, its $\tsunknown{last\_ack\_sent}$ and $\tsunknown{rcv\_adv}$ fields set to $0$, and its
   $\tsunknown{tt\_delack}$ option set to $*$.

   If the segment would case a loopback packet to be sent on the wire then the socket's control
   block will be $\tsvar{cb}'$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTIa}{\rrulecc{connectTIa}{connect\_1a}{tcp: rc}{\tsholcomm{ Begin connection establishment by creating a SYN and trying to enqueue it on host's outqueue }}
{(\tsvar{h},\tsvar{S},\tsvar{M})}
{\Mtransition{ \tsvar{lbl} }{1}}
{(\tsvar{h}',\tsvar{S}',\tsvar{M})}
{{}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Thread $\tsvar{tid}$ is in state $\tscon{Run}$ and TCP socket $\tsvar{sid}$ has binding quad $(\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2})$.  }{}\\{}
 \tsvar{h}  = \tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsunknown{ts\_}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,[\,],[\,])))] ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Thread $\tsvar{tid}$ ends in state $\tsvar{t}'$ with updated host sockets and output queue }{}\\{}
 \tsvar{h}' = \tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsunknown{ts\_}}{\tsvar{tid}}{\tsvar{t}'};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}'_{1},\Msome  \;\tsvar{p}'_{1},\tsvar{is}'_{2},\tsvar{ps}'_{2},\tsvar{es}'',\Mfalse ,\Mfalse ,{}\\{}
\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st}',\tsvar{cb}''',*,[\,],[\,])))] ;{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ File descriptor $\tsvar{fd}$ refers to TCP socket $\tsvar{sid}$ }{}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{h}_{0}.\tsvar{files} \Mfapply{}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Either $\tsvar{sid}$ is bound to a local IP address or one of the host's interface has a route to
     $\tsvar{i}_{2}$ and $\tsvar{i}'_{1}$ is one of its IP addresses.  If it is not routable, then we will fail below,
     when we try to enqueue the segment. }{}\\{}
 {}\\{}
 \tsvar{i}'_{1} \;\in  \;\tsunknown{auto\_outroute}(\tsvar{i}_{2},\tsvar{is}_{1},\tsvar{h}.\tsvar{rttab},\tsvar{h}.\tsvar{ifds}) \Mwedge {}\\{}
\quad \tsholcomm{ Notice that $\tsunknown{auto\_outroute}$ never fails if $\tsvar{is}_{1}\neq *$ (i.e., is specified in the socket). }{}\\{}
 {}\\{}
 \tsholcomm{ The socket is either bound to a local port $\tsvar{p}'_{1}$ or can be autobound to an ephemeral port $\tsvar{p}'_{1}$ }{}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{ps}_{1},\tsunknown{PROTO\_TCP},\tsvar{h},\tsvar{h}.\tsvar{socks}) \Mwedge {}\\{}
 \tsholcomm{ If autobinding occurs then $\tsvar{sid}$ is added to the head of the host's list of bound sockets. }{}\\{}
 (\Mif  \;\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}.\tsvar{bound}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ The socket can be in one of two states: (1) it is in state $\tscon{CLOSED}$ in which case its
         peer address is not set; it has no pending error; it is not shutdown for writing; and it is
         not shutdown for reading on non-FreeBSD architectures. Otherwise, (2) on FreeBSD the socket
         is in state $\tscon{TIME\_WAIT}$, and either $\tsvar{is}_{2}$ and $\tsvar{ps}_{2}$ are both set or both are not set.
       The fact that BSD allows a $\tscon{TIME\_WAIT}$ socket to be reconnected means that some
       fields may contain old data, so we leave them unconstrained here. This is particularly
       important in the $\tsvar{cb}$.
     }{}\\{}
 {}\\{}
 (\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsvar{st} = \tscon{TIME\_WAIT} \Mwedge {}\\{}
\quad (\tsvar{is}_{2} \neq  * \implies  \tsvar{ps}_{2} \neq  *) \Mwedge {}\\{}
\quad\quad (\tsvar{ps}_{2} \neq  * \implies  \tsvar{is}_{2} \neq  *)) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ No other TCP sockets on the host have the address quad $(\Msome  \;\tsvar{i}'_{1},\Msome  \;\tsvar{p}'_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$. }{}\\{}
 \neg{}(\exists  (\tsvar{sid}', \tsvar{s}) \Mcons  (\tsvar{h}.\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}).{}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{s}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}'_{1} \Mwedge  \tsvar{s}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}'_{1} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{s}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2}  \Mwedge  \tsvar{s}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}  \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{proto\_of} \;\tsvar{s}.\tsvar{pr} = \tsunknown{PROTO\_TCP}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Update the socket's control block to $\tsvar{cb}'$, which is $\tsvar{cb}$ except we: (1) start the
     retransmit and connection establishment timers; (2) set the $\tsunknown{snd\_una}$, $\tsunknown{snd\_nxt}$,
     $\tsunknown{snd\_max}$, $\tsunknown{iss}$ fields based on the initial sequence number chosen; (3) set the
     $\tsunknown{rcv\_wnd}$, $\tsunknown{rcv\_adv}$, and $\tsunknown{tf\_rxwin0sent}$ fields based on the receive window chosen; (4)
     record whether or not to do windows scaling, time-stamping, and what the advertised maximum
     segment size is; and (5) store the segment to time. }{}\\{}
 \tsvar{cb}' = \tsvar{cb} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ now build the segment (using an auxiliary, since we might have to retransmit it) }{}\\{}
 {}\\{}
 \tsholcomm{ Make a $\tsvar{SYN}$ segment based on the updated control block and the socket's address quad;
     see \ltslink{makeTsynTsegment}{$\tsaux{make\_syn\_segment}$} for details. }{}\\{}
 (\tsvar{oflgs},\tsvar{odata}) \in  \;\tsaux{make\_syn\_flgs\_data} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ and send it out... }{}\\{}
 {}\\{}
 \tsholcomm{ If possible, enqueue the segment $\tsunknown{seg}$ on the host's outqueue. The auxiliary function
     \ltslink{rollbackTtcpToutput}{$\tsaux{rollback\_tcp\_output}$} is used for this; if the segment is a well-formed segment,
     there is a route to the peer from $\tsvar{i}'_{1}$, and there are no buffer allocation failures,
     $\tsvar{outsegs}' \neq  [\,]$, then the segment is enqueued on the host's outqueue, $\tsvar{oq}$, resulting in a
     new outqueue, $\tsvar{oq}'$. The socket's control block is left as $\tsvar{cb}'$ which is described
     above. Otherwise an error may have occurred; possible errors are: (1) $\tsunknown{ENOBUFS}$ indicating a
     buffer allocation failure; (2) a routing error; or (3) $\tsunknown{EADDRNOTAVAIL}$ on FreeBSD or
     $\tsunknown{EINVAL}$ on Linux indicating that the segment would cause a loopback packet to appear on the
     wire (on WINXP the segment is silently dropped with no error in this case). If an error does
     occur then the socket's control block reverts to $\tsvar{cb}$, the control block when the call was
     made. }{}\\{}
 \exists \tsvar{outsegs}'.  {}\\{}
 \tsaux{FIXMEstream\_rollback\_tcp\_output} \;\Mfalse  (\Msome  \;\tsvar{i}'_{1}, \Msome  \;\tsvar{i}_{2}) \tsvar{h}.\tsvar{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{cb}' (\tsvar{cb}'',\tsvar{es}',\tsvar{outsegs}') \Mwedge {}\\{}
 \tsvar{cb}''' = (\Mif  (\tsvar{outsegs}' \Mvee  \tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch}) \Mthen  \;\tsvar{cb}'' \;\Melse  \;\tsvar{cb}) \Mwedge {}\\{}
 (\tsunknown{INFINITE\_RESOURCES} \implies  \tsvar{queued}) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ If the socket is a blocking one, its $\tscon{O\_NONBLOCK}$ flag is not set, then the call will
         block, entering state $\tscon{Connect2}(\tsvar{sid})$ and leaving the socket in state $\tscon{SYN\_SENT}$ with
         peer address $(\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ and, if the segment could not be enqueued, its pending
         error set to the error resulting from the attempt to enqueue the segment.

	 If the socket is non-blocking, its $\tscon{O\_NONBLOCK}$ flag is set, and the segment was enqueued
	 on the host's outqueue, then the call will fail with an $\tsunknown{EINPROGRESS}$ error (or $\tsunknown{EAGAIN}$
	 on WinXP). The socket will be left in state $\tscon{SYN\_SENT}$ with peer address $(\Msome  \;\tsvar{i}_{2},\Msome
\tsvar{p}_{2})$. Otherwise, if the segment was not enqueued, then the call will fail with the error
	 resulting from attempting to enqueue it, $\Msome  \;\tsvar{err}$; the socket will be left in state
	 $\tscon{CLOSED}$ with no peer address set.
     }{}\\{}
 {}\\{}
 \tsholcomm{ In the case of BSD, if we connect via the loopback interface, then the segment exchange
         occurs so fast that the socket has connected before the connect-calling thread regains control.
         When it does, it sees that the socket has been connected, and therefore returns with success
         rather than $\tsunknown{EINPROGRESS}$. Since this behaviour is due to timing, however, it may be possible
         for the connect call to return before all the segments have been sent, for example if there
         was an artificially imposed delay on the loopback interface. This behaviour is therefore
         made nondeterministic, for a BSD non-blocking socket connecting via loopback, in that it may
         either fail immediately, or be blocked for a short time.
         Linux does not exhibit this behaviour.}{}\\{}
 {}\\{}
 (\tsholcomm{ blocking socket, or BSD and using loopback interface }{}\\{}
 ((\neg{}\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) \Mvee  (\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsvar{i}_{2} \;\in  \;\tsunknown{local\_ips} \;\tsvar{h}.\tsvar{ifds})) \Mwedge {}\\{}
\quad\quad \tsvar{t}' = \Mtimed{\tscon{Connect2}(\tsvar{sid})}{\tsunknown{never\_timer}} \Mwedge  \tsvar{rc} = \tscon{block} \Mwedge {}\\{}
\quad\quad \tsvar{es}''=\tsvar{es}' \Mwedge  \tsvar{st}' = \tscon{SYN\_SENT} \Mwedge  \tsvar{is}'_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}'_{2} = \Msome  \;\tsvar{p}_{2} \Mwedge {}\\{}
\quad\quad\quad \tsholcomm{ BSD and $\tsvar{st}=\tscon{TIME\_WAIT}$, so new new stream created }{}\\{}
\quad\quad\quad \tsvar{lbl} = \MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} \Mwedge {}\\{}
\quad\quad\quad \tsvar{S} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}'_{1},\tsvar{p}'_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s})]  \Mwedge {}\\{}
\quad\quad\quad \tsaux{write} (\tsvar{i}'_{1},\tsvar{p}'_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
\quad\quad\quad \tsvar{S}' = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}'_{1},\tsvar{p}'_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s})]) \Mvee {}\\{}
 \tsholcomm{ non-blocking socket }{}\\{}
 (\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) \Mwedge {}\\{}
\quad\quad \tsvar{es} = * \Mwedge {}\\{}
\quad\quad (\tsvar{err} = (\Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsunknown{EAGAIN} \;\Melse  \;\tsunknown{EINPROGRESS}) \Mvee  \Msome  \;\tsvar{err} = \tsvar{es}') \Mwedge {}\\{}
\quad\quad \tsvar{t}' = \Mtimed{\tscon{Ret}(\tscon{FAIL}\;{\tsvar{err}})}{\tsunknown{sched\_timer}} \Mwedge  \tsvar{rc} = \tscon{fast} \;\tscon{fail} \Mwedge  \tsvar{es}''=* \Mwedge {}\\{}
\quad\quad \Mif  \neg{}\tsvar{queued} \;\Mthen {}\\{}
\quad\quad\quad\quad \tsvar{st}' = \tscon{CLOSED} \Mwedge  \tsvar{is}'_{2} = * \Mwedge  \tsvar{ps}'_{2} = * \Mwedge {}\\{}
\quad\quad\quad\quad \tsholcomm{ under BSD $\tsvar{st}=\tscon{TIME\_WAIT}$, and we destroy a stream }{}\\{}
\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad \exists  \tsvar{i}_{1} \;\tsvar{p}_{1}. (\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1}) = (\tsvar{is}_{1},\tsvar{ps}_{1}) \Mwedge {}\\{}
\quad\quad\quad\quad \tsaux{destroy} (\tsvar{i}'_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsvar{S} \;\tsvar{S}' \Mwedge {}\\{}
\quad\quad\quad\quad \tsvar{lbl} = \MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad\quad \tsvar{st}' = \tscon{SYN\_SENT} \Mwedge  \tsvar{is}'_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}'_{2} = \Msome  \;\tsvar{p}_{2} \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{lbl} = \MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{S} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}'_{1},\tsvar{p}'_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s})]  \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsaux{write} (\tsvar{i}'_{1},\tsvar{p}'_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{S}' = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}'_{1},\tsvar{p}'_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s}')]){}\\{}
 {}\\{}
 )}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, a $\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ call is made where $\tsvar{fd}$ refers to a TCP
   socket. The socket is in state $\tscon{CLOSED}$ with no peer address set, no pending error, and not
   shutdown for reading or writing. A $\tsvar{SYN}$ segment is created to being connection establishment,
   and is enqueued on the host's out-queue.

   If the socket is a blocking one (its $\tscon{O\_NONBLOCK}$ flag is not set) then the call will block: a
   $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread state
   $\tscon{Connect2}(\tsvar{sid})$. If the socket is non-blocking (its $\tscon{O\_NONBLOCK}$ flag is set) and the segment
   enqueuing was successful then the call will fail: a $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$
   transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINPROGRESS}})$ (or $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EAGAIN}})$ on WinXP); connection establishment will proceed asynchronously. Otherwise, if the enqueueing did not succeed, the call will fail with an
   error $\tsvar{err}$: a $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread
   in state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$.

   For further details see the in-line comments above.


\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   The socket may also be in state $\tscon{TIME\_WAIT}$ when the $\tsunknown{connect}()$ call is made, with either
   both its peer IP and port set, or neither set.

   The socket may be shutdown for reading when the $\tsunknown{connect}()$ call is made.

\\\hline
WinXP
&
   If there is an early buffer allocation failure when enqueuing the segment, then it will not be
   placed on the host's out-queue and $\tsvar{es}' = \tsunknown{ENOBUFS}$; the socket's control block will be $\tsvar{cb}'$
   with its $\tsunknown{snd\_nxt}$ and $\tsunknown{snd\_max}$ fields set to the intial sequence number, its
   $\tsunknown{last\_ack\_seen}$ and $\tsunknown{rcv\_adv}$ fields set to $0$, its $\tsunknown{tt\_delack}$ option set to $*$,
   its $\tsunknown{tt\_rexmt}$ timer stopped, and its $\tsunknown{tf\_rxwin0sent}$ and $\tsunknown{t\_rttseg}$ fields reset.

   If there is no route from an interface specified by the local IP address $\tsvar{i}_{1}$ to the foreign IP
   address $\tsvar{i}_{2}$ then the socket's control block will be $\tsvar{cb}'$ with its $\tsunknown{snd\_next}$ field set to the
   initial sequence number, its $\tsunknown{last\_ack\_sent}$ and $\tsunknown{rcv\_adv}$ fields set to $0$, and its
   $\tsunknown{tt\_delack}$ option set to $*$.

   If the segment would case a loopback packet to be sent on the wire then the socket's control
   block will be $\tsvar{cb}'$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTII}{\rrulecc{connectTII}{connect\_2}{tcp: slow urgent succeed}{\tsholcomm{ Successfully return from blocking state after connection is successfully established }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Connect2} \;\tsvar{sid}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{ESTABLISHED};\tscon{CLOSE\_WAIT}\} \Mwedge {}\\{}
 (\neg{}\exists \tsvar{tid}' \;\tsvar{d}'. (\tsvar{tid}' \;\in  \Mfdom{\tsvar{ts}}) \Mwedge  (\tsvar{tid}' \neq  \tsvar{tid}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{ts} \Mfapply{}{\tsvar{tid}'} = \Mtimed{\tscon{Connect2} \;\tsvar{sid}}{\tsvar{d}'})}
{\rulesubsection{Description}

   Thread $\tsvar{tid}$ is blocked in state $\tscon{Connect2}(\tsvar{sid})$ where $\tsvar{sid}$ identifies a TCP socket which
   is in state $\tscon{ESTABLISHED}$: the connection establishment has been successfully completed; or
   $\tscon{CLOSE\_WAIT}$: connection establishment successfully completed but a $\tsvar{FIN}$ was received during
   establishment. $\tsvar{tid}$ is the only thread which is blocked waiting for the socket $\tsvar{sid}$ to
   establish a connection. As connection establishment has now completed, the thread can
   successfully return from the blocked state.

   A $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK} ())$.

\rrulepad }
}

\newcommand{\connectTIII}{\rrulecc{connectTIII}{connect\_3}{tcp: slow urgent fail}{\tsholcomm{ Fail with the pending error on a socket in the $\tscon{CLOSED}$ state }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Connect2} \;\tsvar{sid}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsvar{e} \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  * \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = \tsvar{sock}.\tsvar{pr} \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSED}}
{\rulesubsection{Description}

   Thread $\tsvar{tid}$ is blocked in the $\tscon{Connect2}(\tsvar{sid})$ state where $\tsvar{sid}$ identifies a TCP socket
   $\tsvar{sock}$ that is in the $\tscon{CLOSED}$ state: connection establishment has failed, leaving the socket
   in a pending error state $\Msome  \;\tsvar{e}$. Usually this occurs when there is no listening TCP socket at
   the peer address, giving an error of $\tsunknown{ECONNREFUSED}$ or $\tsunknown{ECONNRESET}$; or when the connection
   establishment timer expired, giving an error of $\tsunknown{ETIMEDOUT}$. The call now returns, failing with
   the error $\tsvar{e}$, and clearing the pending error field of the socket.

   A $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   When connection establishment failed, the $\tsunknown{bsd\_cantconnect}$ flag in the control block would
   have been set, the socket's $\tsvar{cantsndmore}$ and $\tsvar{cantrcvmore}$ flags would have been set and its
   local address binding would have been removed. This renders the sockets useless: call to
   $\tsunknown{bind}()$, $\tsunknown{connect}()$, and $\tsvar{listen}()$ will all fail.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTIV}{\rrulecc{connectTIV}{connect\_4}{tcp: slow urgent fail}{\tsholcomm{ Fail: socket has pending error }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Connect2} \;\tsvar{sid}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock}')] \Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{\tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\tsvar{ps}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\Msome  \;\tsvar{err},\Mfalse ,\Mfalse ,{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{SYN\_SENT},\tsvar{cb},*,[\,],[\,])) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ On WinXP if the error is from routing to an unavailable address,
       the error is not returned and the socket is left alone. The
       rexmtsyn timer will retry the SYN transmission and eventually fail. }{}\\{}
 \neg{}(\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsvar{err} = \tsunknown{EINVAL}) \Mwedge {}\\{}
 \Mif  \;\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen {}\\{}
\quad \Mif  (\tsvar{err} = \tsunknown{EADDRNOTAVAIL}) \Mthen {}\\{}
\quad\quad\quad {}\\{}
\quad\quad\quad \tsvar{sock}' = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\tsvar{ps}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\Mfalse ,{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{SYN\_SENT},\tsvar{cb},*,[\,],[\,])) \Mwedge {}\\{}
\quad\quad\quad \tsvar{S}' = \tsvar{SS}{}\\{}
\quad \Melse {}\\{}
\quad\quad\quad \tsvar{sock}' = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\tsvar{ps}_{1},*,*,*,\Mfalse ,\Mfalse ,{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{CLOSED},\tsaux{initial\_cb},*,[\,],[\,])) \Mwedge {}\\{}
\quad\quad\quad \Mcase  \;\tsvar{ps}_{1} \;\Mof  \;\Msome  \;\tsvar{p}_{1} \Mtotype  \tsaux{destroy} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsvar{SS} \;\tsvar{S}'{}\\{}
\quad\quad\quad\quad\quad \Mdpipe  * \Mtotype  \tsvar{S}' = \tsvar{SS} {}\\{}
 \Melse {}\\{}
\quad \tsholcomm{ close the socket, but do not shutdown for reading/writing }{}\\{}
\quad \tsvar{sock}' = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\tsvar{ps}_{1},*,*,*,\Mfalse ,\Mfalse ,{}\\{}
\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{CLOSED},\tsvar{cb}',*,[\,],[\,])) \Mwedge {}\\{}
\quad \tsvar{cb}' = \tsaux{initial\_cb} \Mwedge {}\\{}
\quad \Mcase  \;\tsvar{ps}_{1} \;\Mof  \;\Msome  \;\tsvar{p}_{1} \Mtotype  \tsaux{destroy} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsvar{SS} \;\tsvar{S}'{}\\{}
\quad\quad\quad \Mdpipe  * \Mtotype  \tsvar{S}' = \tsvar{SS} }
{\rulesubsection{Description}

   Thread $\tsvar{tid}$ is blocked in the $\tscon{Connect2}(\tsvar{sid})$ state waiting for a connection to be
   established. $\tsvar{sid}$ identifies a TCP socket $\tsvar{sock}$ that has not been shutdown for reading or
   writing, and has binding quad $(\Msome  \;\tsvar{i}_{1},\tsvar{ps}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ and pending error $\tsvar{err}$. The
   socket is in state $\tscon{SYN\_SENT}$, is not listening, has empty send and receive queues, and no
   urgent marks set. The call fails, returning the pending error.

   A $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$. The socket is
   left in state $\tscon{CLOSED}$ with its peer address not set, its pending error cleared, and its control
   block reset to the initial control block, $\tsaux{initial\_cb}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   If the pending error is $\tsunknown{EADDRNOTAVAIL}$ then the error is cleared and returned but the rest of
   the socket stays the same: it is in state $\tscon{SYN\_SENT}$ so the $\tsvar{SYN}$ will be retransmitted until
   it times out.

   If the pending error is not $\tsunknown{EADDRNOTAVAIL}$ then the socket is reset as above except that the
   the socket's local ip and port are cleared

\\\hline
WinXP
&
   If the error is $\tsunknown{EINVAL}$ then this rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTIVa}{\rrulecc{connectTIVa}{connect\_4a}{tcp: fast fail}{\tsholcomm{ Fail with pending error }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsvar{err} \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsunknown{sched\_timer}}} ;{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  * \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = \tsvar{sock}.\tsvar{pr} \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{CLOSED}  \}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ call is
    made. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sock}$, identified by $\tsvar{sid}$, with pending error $\tsvar{err}$
    and in state $\tscon{CLOSED}$. The call fails with the pending error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsunknown{ip},\tsunknown{port})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsvar{err}})$ and the socket's pending error clear.

    The most likely cause of this behaviour is for a non-blocking $\tsunknown{connect}(\tsvar{fd},\tsunknown{\_},\tsunknown{\_})$ call to have
    previously been made. The call fails, setting the pending error on the socket, and when
    $\tsunknown{connect}()$ is called to check the status of connection establishment the error is
    returned. In such a case $\tsvar{err}$ is most likely to be $\tsunknown{ECONNREFUSED}$, $\tsunknown{ECONNRESET}$, or
    $\tsunknown{ETIMEDOUT}$.


\rrulepad }
}

\newcommand{\connectTV}{\rrulecc{connectTV}{connect\_5}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EALREADY}$, $\tsunknown{EINVAL}$, $\tsunknown{EISCONN}$, $\tsunknown{EOPNOTSUPP}$: socket already in use }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} \Mwedge {}\\{}
 \Mcase  \;\tsunknown{tcp\_sock}.\tsvar{st} \;\Mof {}\\{}
\quad\quad \tscon{SYN\_SENT}     \Mtotype  \Mif      \;\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) = \Mtrue  \;\Mthen  \;\tsvar{err} = \tsunknown{EALREADY} \tsholcomm{ connection already in progress }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{err} = \tsunknown{EALREADY} \tsholcomm{ connection already in progress }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{bsd\_arch}     \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{err} = \tsunknown{EISCONN}  \tsholcomm{ connection being established }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsunknown{ASSERTION\_FAILURE} \text{``connect\textunderscore{}5:1''} \Mdpipe  \tsholcomm{ never happen }{}\\{}
\quad\quad \tscon{SYN\_RECEIVED} \Mtotype  \Mif      \;\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) = \Mtrue  \;\Mthen  \;\tsvar{err} = \tsunknown{EALREADY} \tsholcomm{ connection already in progress }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{err} = \tsunknown{EALREADY}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{bsd\_arch}     \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{err} = \tsunknown{EISCONN}  \tsholcomm{ connection being established }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsunknown{ASSERTION\_FAILURE} \text{``connect\textunderscore{}5:2''} \Mdpipe  \tsholcomm{ never happen }{}\\{}
\quad\quad \tscon{LISTEN}      \Mtotype  \Mif       \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{err} = \tsunknown{EINVAL}  \tsholcomm{ socket is listening }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{bsd\_arch}     \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{err} = \tsunknown{EOPNOTSUPP}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{linux\_arch}   \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{err} = \tsunknown{EISCONN}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsunknown{ASSERTION\_FAILURE} \text{``connect\textunderscore{}5:3''} \Mdpipe  \tsholcomm{ never happen }{}\\{}
\quad\quad \tscon{ESTABLISHED} \Mtotype  \tsvar{err} = \tsunknown{EISCONN} \Mdpipe   \tsholcomm{ socket already connected }{}\\{}
\quad\quad \tscon{FIN\_WAIT\_1} \Mtotype  \tsvar{err} = \tsunknown{EISCONN} \Mdpipe    \tsholcomm{ socket already connected }{}\\{}
\quad\quad \tscon{FIN\_WAIT\_2} \Mtotype  \tsvar{err} = \tsunknown{EISCONN} \Mdpipe    \tsholcomm{ socket already connected }{}\\{}
\quad\quad \tscon{CLOSING} \Mtotype  \tsvar{err} = \tsunknown{EISCONN} \Mdpipe       \tsholcomm{ socket already connected }{}\\{}
\quad\quad \tscon{CLOSE\_WAIT} \Mtotype  \tsvar{err} = \tsunknown{EISCONN} \Mdpipe    \tsholcomm{ socket already connected }{}\\{}
\quad\quad \tscon{LAST\_ACK} \Mtotype  \tsvar{err} = \tsunknown{EISCONN} \Mdpipe      \tsholcomm{ socket already connected; seems that fd is valid in this state }{}\\{}
\quad\quad \tscon{TIME\_WAIT} \Mtotype  (\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mvee  \tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge  \tsvar{err} = \tsunknown{EISCONN} \Mdpipe {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ BSD allows a $\tscon{TIME\_WAIT}$ socket to be reconnected }{}\\{}
\quad\quad \tscon{CLOSED} \Mtotype  \tsvar{err} = \tsunknown{EINVAL} \Mwedge  \tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} }
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ call is made
   where $\tsvar{fd}$ refers to a TCP socket identified by $\tsvar{sid}$. The call fails with an error $\tsvar{err}$:
   if the socket is in state $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$ and the socket is non-blocking or the
   host is a WinXP architecture then $\tsvar{err}=\tsunknown{EALREADY}$ ($\tsunknown{EISCONN}$ on FreeBSD); if it is in state $\tscon{LISTEN}$ then on WinXP
   $\tsvar{err}=\tsunknown{EINVAL}$, on FreeBSD $\tsvar{err}=\tsunknown{EOPNOTSUPP}$, and on Linux $\tsvar{err}=\tsunknown{EISCONN}$; if it is in state
   $\tscon{ESTABLISHED}$, $\tscon{FIN\_WAIT\_1}$, $\tscon{FIN\_WAIT\_2}$, $\tscon{CLOSING}$, $\tscon{CLOSE\_WAIT}$, or $\tscon{TIME\_WAIT}$ on
   Linux and WinXP, $\tsvar{err}=\tsunknown{EISCONN}$; if it is in state $\tscon{CLOSED}$ on FreeBSD and has its
   $\tsunknown{bsd\_cantconnect}$ flag set then $\tsvar{err}=\tsunknown{EINVAL}$.

   A $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsvar{err}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   If the socket is in state $\tscon{TIME\_WAIT}$ then the call does not fail: the socket may be
   reconnected by \ltslink{connectTI}{$\tsunknown{connect\_1}$}.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTVa}{\rrulecc{connectTVa}{connect\_5a}{all: fast fail}{\tsholcomm{ Fail: no route to host }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{1} \Mass  *; \tsvar{ps}_{1} \Mass  \tsvar{ps}_{1} \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{1} \Mass  \tsvar{is}'_{1}; \tsvar{ps}_{1} \Mass  \tsvar{ps}'_{1} \Mmagicrrec )];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsholcomm{ FIXME although this rule may result in a quad becoming bound, we assume $(\tsvar{i}_{2},\tsvar{p}_{2})$ not bound }{}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{h}.\tsvar{files} \Mfapply{}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\Mif  \;\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tsunknown{PROTO\_TCP} \;\Mthen {}\\{}
\quad\quad \tsvar{is}'_{1} = \Msome  \;\tsvar{i}'_{1} \Mwedge  \tsvar{i}'_{1} \;\in  \;\tsunknown{local\_primary\_ips} \;\tsvar{h}.\tsvar{ifds} \Mwedge {}\\{}
\quad\quad \tsvar{ps}'_{1} = \Msome  \;\tsvar{p}'_{1} \Mwedge  \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{ps}_{1},\tsunknown{PROTO\_TCP},\tsvar{h},\tsvar{h}.\tsvar{socks}) \Mwedge {}\\{}
\quad\quad (\Mif  \;\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}.\tsvar{bound}){}\\{}
 \Melse  \;\tsvar{is}'_{1} = * \Mwedge  \tsvar{ps}'_{1} = \tsvar{ps}_{1} \Mwedge  \tsvar{bound} = \tsvar{h}.\tsvar{bound}) \Mwedge {}\\{}
 \Mcase  \;\tsunknown{test\_outroute\_ip}(\tsvar{i}_{2},\tsvar{h}.\tsvar{rttab},\tsvar{h}.\tsvar{ifds},\tsvar{h}.\tsvar{arch}) \Mof {}\\{}
\quad\quad \Msome  \;\tsunknown{e}   \Mtotype  \tsvar{err} = \tsunknown{e}{}\\{}
 \Mdpipe   \tsunknown{\_other29} \Mtotype  \Mfalse    \Mwedge {}\\{}
 (\tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tsunknown{PROTO\_UDP} \implies  \neg{}\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ call is
   made. $\tsvar{fd}$ refers to a socket identified by $\tsvar{sid}$ which does not have a local IP address
   set. The \ltslink{testToutrouteTip}{$\tsunknown{test\_outroute\_ip}$} function is used to check if there is a route from the host
   to $\tsvar{i}_{2}$. There is no route so the call will fail with a routing error $\tsvar{err}$. If there is no
   interface with a route to the host then on Linux the call fails with $\tsunknown{ENETUNREACH}$ and on
   FreeBSD and WinXP it fails with $\tsunknown{EHOSTUNREACH}$. If there are interfaces with a route to the
   host but none of these are up then the call fails with $\tsunknown{ENETDOWN}$.

   A $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsvar{err}})$, where $\tsvar{err}$ is one of the above errors.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   This rule does not apply to UDP sockets on FreeBSD. Additionally, if the socket is not bound to a
   local port then it will be autobound to one and $\tsvar{sid}$ will be appended to the head of the
   host's list of bound sockets, $\tsvar{bound}$. The socket's local IP address may be set to $\Msome  \;\tsvar{i}_{1}$
   even though there is no route from $\tsvar{i}_{1}$ to $\tsvar{i}_{2}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTVb}{\rrulecc{connectTVb}{connect\_5b}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{EADDRINUSE}$: address already in use }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EADDRINUSE}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{1} \Mass  \tsvar{is}'_{1}; \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}'_{1}; \tsvar{is}_{2} \Mass  \tsvar{is}'_{2}; \tsvar{ps}_{2} \Mass  \tsvar{ps}'_{2} \Mmagicrrec  )];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound}' \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{i}'_{1} \;\in  \;\tsunknown{auto\_outroute}(\tsvar{i}_{2},\tsvar{sock}.\tsvar{is}_{1},\tsvar{h}.\tsvar{rttab},\tsvar{h}.\tsvar{ifds}) \Mwedge {}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{sock}.\tsvar{ps}_{1},(\tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr}),\tsvar{h},\tsvar{h}.\tsvar{socks}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{sock}.\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound}' = \tsvar{sid}\Mcons \tsvar{bound} \;\Melse  \;\tsvar{bound}' = \tsvar{bound}) \Mwedge {}\\{}
 (\tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tsunknown{PROTO\_UDP} \implies  \neg{}(\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \Mvee  \tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch})) \Mwedge {}\\{}
 (\exists (\tsvar{sid}',\tsunknown{s}) \Mcons  \tsvar{socks} \backslash{}\backslash{} \tsvar{sid}.{}\\{}
\quad \tsunknown{s}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}'_{1} \Mwedge  \tsunknown{s}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}'_{1} \Mwedge {}\\{}
\quad \tsunknown{s}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2}  \Mwedge  \tsunknown{s}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}  \Mwedge {}\\{}
\quad \tsaux{proto\_eq} \;\tsvar{sock}.\tsvar{pr} \;\tsunknown{s}.\tsvar{pr}) \Mwedge {}\\{}
 (\Mif  \;\tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tsunknown{PROTO\_UDP} \;\Mthen {}\\{}
\quad\quad \Mif  \;\tsvar{sock}.\tsvar{is}_{2} = * \;\Mthen  \;\tsvar{is}'_{1} = \tsvar{sock}.\tsvar{is}_{1} \Mwedge  \tsvar{is}'_{2} = * \Mwedge  \tsvar{ps}'_{2} = *{}\\{}
\quad\quad \Melse                     \;\tsvar{is}'_{1} = *  \Mwedge  \tsvar{is}'_{2} = * \Mwedge  \tsvar{ps}'_{2} = *{}\\{}
 \Melse  \;\tsvar{is}'_{1} = \tsvar{sock}.\tsvar{is}_{1} \Mwedge  \tsvar{is}'_{2} = \tsvar{sock}.\tsvar{is}_{2} \Mwedge  \tsvar{ps}'_{2} = \tsvar{sock}.\tsvar{ps}_{2}) }
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ call is made
   where $\tsvar{fd}$ refers to a socket $\tsvar{sock}$ identified by $\tsvar{sid}$. The socket is either bound to
   local port $\Msome  \;\tsvar{p}'_{1}$, or can be autobound to port $\Msome  \;\tsvar{p}'_{1}$. The socket either has its
   local IP address set to $\Msome  \;\tsvar{i}'_{1}$ or else its local IP address is unset but there exists an IP
   address $\tsvar{i}'_{1}$ for one of the host's interfaces which has a route to $\tsvar{i}_{2}$. There exists
   another socket $\tsunknown{s}$ in the host's finite map of sockets, identified by $\tsvar{sid}'$, that has as its
   binding quad $(\Msome  \;\tsvar{i}'_{1},\Msome  \;\tsvar{p}'_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$.

   A $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsunknown{EADDRINUSE}})$: there is already another socket with the same local address connected to the
   peer address $(\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$. The socket's local port is set to $\Msome  \;\tsvar{p}'_{1}$; if this was
   accomplished by autobinding then $\tsvar{sid}$ is appended to the head of $\tsvar{bound}$, the host's list of
   bound sockets, to create a new list $\tsvar{bound}'$. If $\tsvar{sock}$ is a TCP socket then its $\tsvar{is}_{1}$,
   $\tsvar{is}_{2}$, and $\tsvar{ps}_{2}$ fields are unchanged. If $\tsvar{sock}$ is a UDP socket on FreeBSD then if its
   peer IP address was set, its local IP address will be unset: $\tsvar{is}'_{1}=*$, otherwise its local
   IP address will stay as it was: $\tsvar{is}'_{1}=\tsvar{sock}.\tsvar{is}_{1}$; its peer IP address and port will both be
   unset: $\tsvar{is}'_{2}=* \Mwedge  \tsvar{ps}'_{2}=*$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
   This rule does not apply to UDP sockets: Linux allows two UDP sockets to have the same binding quad.

\\\hline
WinXP
&
   This rule does not apply to UDP sockets: WinXP allows two UDP sockets to have the same binding quad.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTVc}{\rrulecc{connectTVc}{connect\_5c}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{EADDRNOTAVAIL}$: no ephemeral ports left }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EADDRNOTAVAIL}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{ps}_{1} = * \Mwedge {}\\{}
 \tsaux{autobind}(*,(\tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr}),\tsvar{h},\tsvar{h}.\tsvar{socks}) = \emptyset }
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ is made. $\tsvar{fd}$
   refers to a socket identified by $\tsvar{sid}$ which is not bound to a local port. There are no
   ephemeral ports available to autobind to so the call fails with an $\tsunknown{EADDRNOTAVAIL}$ error.

   A $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsunknown{EADDRNOTAVAIL}})$.

\rrulepad }
}

\newcommand{\connectTVd}{\rrulecc{connectTVd}{connect\_5d}{tcp: block}{\tsholcomm{ Block, entering state $\tscon{Connect2}$: connection attempt already in progress and connect called with blocking semantics }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Connect2}(\tsvar{sid})}{\tsunknown{never\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} \Mwedge {}\\{}
 \tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) = \Mfalse  \Mwedge {}\\{}
 \tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}\}}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ call is
   made. $\tsvar{fd}$ refers to a TCP socket identified by $\tsvar{sid}$ which is in state $\tscon{SYN\_SENT}$ or
   $\tscon{SYN\_RECEIVED}$: in other words, a connection attempt is already in progress for the socket
   (this could be an asynchronous connection attempt or one in another thread). The open file
   description referred to by $\tsvar{fd}$ does not have its $\tscon{O\_NONBLOCK}$ flag set so the call blocks,
   awaiting completion of the original connection attempt.

   A $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread state
   $\tscon{Connect2}(\tsvar{sid})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   This rule does not apply.

\\\hline
WinXP
&
   This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTVI}{\rrulecc{connectTVI}{connect\_6}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EINVAL}$: socket has been shutdown for writing }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantsndmore} \Mass  \Mtrue ; \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsvar{tcp} \; \Mmagiclrec  \tsvar{st} \Mass  \tscon{CLOSED} \Mmagicrrec ) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINVAL}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantsndmore} \Mass  \Mtrue ; \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsvar{tcp} \; \Mmagiclrec  \tsvar{st} \Mass  \tscon{CLOSED} \Mmagicrrec ) \Mmagicrrec  )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{h}.\tsvar{files} \Mfapply{}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}){}\\{}
 \tsholcomm{ FIXME do we want to sync with stream at this point? }}
{\rulesubsection{Description}

     On FreeBSD, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$
     call is made. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sock}$ identified by $\tsvar{sid}$ which is in state
     $\tscon{CLOSED}$ and has been shutdown for writing.

     A $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsunknown{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
     This rule does not apply.

\\\hline
Linux
&
     This rule does not apply.

\\\hline
WinXP
&
     This rule does not apply.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTVII}{\rrulecc{connectTVII}{connect\_7}{udp: fast succeed}{\tsholcomm{ Set peer address on socket with binding quad $*,\tsvar{ps}_{1},*,*$ }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\tsvar{ps}_{2})} }{1}}
{(\tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}'_{1},\Msome  \;\tsvar{p}'_{1},\Msome  \;\tsvar{i}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore}',\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound}{}\\{}
 \Mmagicbolrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,\tsvar{ps}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))]{}\\{}
 \Mmagicbolrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{h}_{0}.\tsvar{files} \Mfapply{}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{ps}_{1},\tsunknown{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound}) \Mwedge {}\\{}
 \tsvar{i}'_{1} \;\in  \;\tsunknown{auto\_outroute}(\tsvar{i}_{2},*,\tsvar{h}_{0}.\tsvar{rttab},\tsvar{h}_{0}.\tsvar{ifds}) \Mwedge {}\\{}
 \neg{}(\exists  (\tsvar{sid}', \tsunknown{s}) \Mcons  (\tsvar{h}_{0}.\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}).{}\\{}
\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}'_{1} \Mwedge  \tsunknown{s}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}'_{1} \Mwedge {}\\{}
\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2}  \Mwedge  \tsunknown{s}.\tsvar{ps}_{2} = \tsvar{ps}_{2} \Mwedge {}\\{}
\quad\quad\quad\quad \tsaux{proto\_of} \;\tsunknown{s}.\tsvar{pr} = \tsunknown{PROTO\_UDP} \Mwedge {}\\{}
\quad\quad\quad\quad \tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge {}\\{}
 (\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \implies  \tsvar{ps}_{2} \neq  * \Mwedge  \tsvar{es} = *) \Mwedge {}\\{}
 (\Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{cantsndmore}' = \Mfalse {}\\{}
 \Melse                         \;\tsvar{cantsndmore}' = \tsvar{cantsndmore})}
{\rulesubsection{Description}

      Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, with no local IP or peer address
      set. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\tsvar{ps}_{2})$ call is
      made. The socket's local port is either set to $\tsvar{p}'_{1}$, or it is unset and can be autobound to
      a local ephemeral port $\tsvar{p}'_{1}$. The local IP address can be set to $\tsvar{i}'_{1}$ which is the
      primary IP address for an interface with a route to $\tsvar{i}_{2}$.

      A $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\tsvar{ps}_{2})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$. The socket's local address is set to $(\Msome  \;\tsvar{i}'_{1},\Msome  \;\tsvar{p}'_{1})$, and its peer address
      is set to $(\Msome  \;\tsvar{i}_{2},\tsvar{ps}_{2})$. If the socket's local port was autobound then $\tsvar{sid}$ is placed
      at the head of the host's list of bound sockets: $\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
      As above, with the additional conditions that a foreign port is specified in the $\tsunknown{connect}()$
      call: $\tsvar{ps}_{2} \neq  *$, and there are no pending errors on the socket. Furthermore, there may
      be no other sockets in the host's finite map of sockets with the binding quad $(\Msome  \;\tsvar{i}'_{1},\Msome
\tsvar{p}'_{1},\Msome  \;\tsvar{i}_{2},\tsvar{ps}_{2})$.

\\\hline
WinXP
&
      As above, except that the socket will not be shutdown for writing after the $\tsunknown{connect}()$ call
      has been made.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTVIII}{\rrulecc{connectTVIII}{connect\_8}{udp: fast succeed}{\tsholcomm{ Set peer address on socket with local address set }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i},\tsvar{ps})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i},\tsvar{ps},\tsvar{es},\tsvar{cantsndmore}',\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{h}_{0} =  \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \implies  \tsvar{ps} \neq  * \Mwedge  \tsvar{es} = *) \Mwedge {}\\{}
 (\Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{cantsndmore}' = \Mfalse {}\\{}
 \Melse                         \;\tsvar{cantsndmore}' = \tsvar{cantsndmore}) \Mwedge {}\\{}
 \neg{}(\exists  (\tsvar{sid}',\tsunknown{s}) \Mcons  (\tsvar{h}_{0}.\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}).{}\\{}
\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsunknown{s}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge {}\\{}
\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}  \Mwedge  \tsunknown{s}.\tsvar{ps}_{2} = \tsvar{ps} \Mwedge {}\\{}
\quad\quad\quad\quad \tsaux{proto\_of} \;\tsunknown{s}.\tsvar{pr} = \tsunknown{PROTO\_UDP} \Mwedge {}\\{}
\quad\quad\quad\quad \tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch})}
{\rulesubsection{Description}

     Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, with local address set to $(\Msome  \;\tsvar{i}_{1},\Msome
\tsvar{p}_{1})$. Its peer address may or may not be set. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$
     state, a $\tsunknown{connect}(\tsvar{fd},\tsvar{i},\tsvar{ps})$ call is made.

     The call succeeds: a $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i},\tsvar{ps})}$ transition is made, leaving the thread
     in state $\tscon{Ret} (\tscon{OK}())$. The socket has its peer address set to $(\Msome  \;\tsvar{i},\tsvar{ps})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
     As above, with the additional conditions that a foreign port is specified in the $\tsunknown{connect}()$
     call, $\tsvar{ps} \neq  *$, and there are no pending errors on the socket. Furthermore, there may be
     no other sockets in the host's finite map of sockets with the binding quad $(\Msome  \;\tsvar{i}'_{1},\Msome
\tsvar{p}'_{1},\Msome  \;\tsvar{i},\tsvar{ps})$.

\\\hline
WinXP
&
     As above, with the additional effect that if the socket was shutdown for writing when the
     $\tsunknown{connect}()$ call was made, it will no longer be shutdown for writing.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTIX}{\rrulecc{connectTIX}{connect\_9}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EADDRNOTAVAIL}$: port must be specified in $\tsunknown{connect}()$ call on FreeBSD }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i},*)} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EADDRNOTAVAIL}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{1} \Mass  \tsvar{is}_{1}; \tsvar{is}_{2} \Mass  *; \tsvar{ps}_{2} \Mass  *; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec  )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{sock}.\tsvar{is}_{2} \neq  * \;\Mthen  \;\tsvar{is}_{1} = * \;\Melse  \;\tsvar{is}_{1} = \tsvar{sock}.\tsvar{is}_{1})}
{\rulesubsection{Description}

    On FreeBSD, consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in
    the $\tscon{Run}$ state, a $\tsunknown{connect}(\tsvar{fd},\tsvar{i},*)$ call is made. Because no port is specified, the call
    fails with an $\tsunknown{EADDRNOTAVAIL}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i},*)}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsunknown{EADDRNOTAVAIL}})$. The socket's peer address is cleared: $\tsvar{is}_{2} \Mass  *$ and $\tsvar{ps}_{2} \Mass
*$. Additionally, if the socket had its peer IP address set, $\tsvar{sock}.\tsvar{is}_{2} \neq  *$, then its
    local IP address will be cleared: $\tsvar{is}_{1} = *$; otherwise it remains the same: $\tsvar{is}_{1} =
\tsvar{sock}.\tsvar{is}_{1}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.

\\\hline
WinXP
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTX}{\rrulecc{connectTX}{connect\_10}{udp: fast fail}{\tsholcomm{ Fail with pending error on FreeBSD, but still set peer address }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i},\tsvar{ps})} }{1}}
{(\tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i}; \tsvar{ps}_{2} \Mass  \tsvar{ps}; \tsvar{es} \Mass  *; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{h}_{0} =  \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsvar{err}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{ps} \neq  * \Mwedge {}\\{}
 \neg{}(\exists (\tsvar{sid}',\tsunknown{s}) \Mcons  (\tsvar{h}_{0}.\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}).{}\\{}
\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{1} = \tsvar{sock}.\tsvar{is}_{1} \Mwedge  \tsunknown{s}.\tsvar{ps}_{1} = \tsvar{sock}.\tsvar{ps}_{1} \Mwedge {}\\{}
\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}  \Mwedge  \tsunknown{s}.\tsvar{ps}_{2} = \tsvar{ps} \Mwedge {}\\{}
\quad\quad\quad\quad \tsaux{proto\_of} \;\tsunknown{s}.\tsvar{pr} = \tsunknown{PROTO\_UDP})}
{\rulesubsection{Description}

     On FreeBSD, consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, with pending error
     $\tsvar{err}$. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{connect}(\tsvar{fd},\tsvar{i},\tsvar{ps})$ call is
     made with $\tsvar{ps} \neq  *$. There is no other UDP socket on the host which has the same local
     address $\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{ps}_{1}$ as $\tsvar{sid}$, and its peer address set to $\Msome  \;\tsvar{i}, \tsvar{ps}$. The call
     fails, returning the pending error $\tsvar{err}$.

     A $\MLhcall{\tsvar{tid}}{\tsunknown{connect}(\tsvar{fd},\tsvar{i},\tsvar{ps})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$. The socket's peer address is set to $(\Msome  \;\tsvar{i},\tsvar{ps})$, and the error is cleared from the
     socket.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
     This rule does not apply.

\\\hline
WinXP
&
     This rule does not apply.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommdisconnect}{\clustersection{(TCP and UDP)}{$\tsunknown{disconnect}()$}
\seccomm{  \[ \tsunknown{disconnect}: \tsunknown{fd} \Mtotype  \tstype{unit} \]

   A call to $\tsunknown{disconnect}(\tsunknown{fd})$, where $\tsunknown{fd}$ is a file descriptor referring to a socket, removes
   the peer address for a UDP socket. If a UDP socket has peer address set to $(\Msome  \;\tsvar{i}_{2}, \Msome  \;\tsvar{p}_{2})$
   then it can only receive datagrams with source address $(\tsvar{i}_{2},\tsvar{p}_{2})$. Calling $\tsunknown{disconnect}()$ on
   the socket resets its peer address to $(*,*)$, and so it will be able to receive
   datagrams with any source address.

   It does not make sense to disconnect a TCP socket in this way.  Most supported architectures
   simply disallow $\tsunknown{disconnect}$ on such a socket; however, Linux implements it as an abortive
   close (see \ltslink{closeTIII}{$\tsunknown{close\_3}$}).

}\clustersubsection{Errors}
\seccomm{
   A call to $\tsunknown{disconnect}()$ can fail with the errors below, in which case the corresponding
   exception is raised:

\par\begin{ltstabular}
$\tsunknown{EADDRNOTAVAIL}$
&  There are no ephemeral ports left for autobinding to.

\\\hline
$\tsunknown{EAFNOSUPPORT}$
&  The address family \wasverb{AF\textunderscore{}UNSPEC} is not supported. This can be the
   result for a successful $\tsunknown{disconnect}()$ for a UDP socket.

\\\hline
$\tsunknown{EAGAIN}$
&  There are no ephemeral ports left for autobinding to.

\\\hline
$\tsunknown{EALREADY}$
&  A connection is already in progress.

\\\hline
$\tsunknown{EBADF}$
&  The file descriptor $\tsunknown{fd}$ is an invalid file descriptor.

\\\hline
$\tsunknown{EISCONN}$
&  The socket is already connected.

\\\hline
$\tsunknown{ENOBUFS}$
&  No buffer space is available.

\\\hline
$\tsunknown{EOPNOTSUPP}$
&  The socket is listening and cannot be connected.

\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
   $\tsunknown{disconnect\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tsunknown{disconnect}()$ is a Posix $\tsunknown{connect}()$ call with the address family set to
  \wasverb{AF\textunderscore{}UNSPEC}.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int connect(int socket, const struct sockaddr *address,}\\
             & \wasverb{            socklen\textunderscore{}t address\textunderscore{}len);} \\
    FreeBSD: & \wasverb{int connect(int s, const struct sockaddr *name, }\\
             & \wasverb{            socklen\textunderscore{}t namelen);} \\
    Linux:   & \wasverb{int connect(int  sockfd,  const  struct sockaddr *serv\textunderscore{}addr,}\\
               \wasverb{            socklen\textunderscore{}t addrlen);} \\
    WinXP:   & \wasverb{int connect(SOCKET s, const struct sockaddr* name,} \\
             & \wasverb{            int namelen);}\\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

  \item \wasverb{socket} is a file descriptor referring to a socket. This corresponds to the $\tsunknown{fd}$
   argument of the model $\tsunknown{disconnect}()$.

  \item \wasverb{address} is a pointer to a location of size \wasverb{address\textunderscore{}len} containing a
   \wasverb{sockaddr} structure which specifies the address to connect to. For a $\tsunknown{disconnect}()$
   call, the \wasverb{sin\textunderscore{}family} field of the \wasverb{sockaddr} family must be set to
   \wasverb{AF\textunderscore{}UNSPEC}; other fields can be set to anything.

  \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
   indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
   indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
   code available through a call to \wasverb{WSAGetLastError()}.

   \end{itemize}

  The Linux man-page states: "Unconnecting a socket by calling connect with a AF\_UNSPEC address is
  not yet implemented." As a result, a $\tsunknown{disconnect}()$ call always returns successfully on Linux.

  The WinXP documentation states: "The default destination can be changed by simply calling
  \wasverb{connect} again, even if the socket is already connected. Any datagrams queued for receipt
  are discarded if \wasverb{name} is different from the previous \wasverb{connect}." This implies
  that calling $\tsunknown{disconnect}()$ will result in all datagrams on the socket's receive queue; however,
  this is not the case: no datagrams are discarded.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{disconnect\_4}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{EAFNOSUPPORT}$: address family not supported; $\tsunknown{EOPNOTSUPP}$: operation not supported; $\tsunknown{EALREADY}$: connection already in progress; or $\tsunknown{EISCONN}$: socket already connected \\
$\tsrule{disconnect\_5}$
& \textbf{tcp: fast fail}
&  Succeed on Linux, possibly dropping the connection \\
$\tsrule{disconnect\_1}$
& \textbf{udp: fast succeed}
&  Unset socket's peer address \\
$\tsrule{disconnect\_2}$
& \textbf{udp: fast succeed}
&  Unset socket's peer address and autobind local port \\
$\tsrule{disconnect\_3}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{EAGAIN}$, $\tsunknown{EADDRNOTAVAIL}$, or $\tsunknown{ENOBUFS}$: there are no ephemeral ports left \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\disconnectTIV}{\rrulecc{disconnectTIV}{disconnect\_4}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EAFNOSUPPORT}$: address family not supported; $\tsunknown{EOPNOTSUPP}$: operation not supported; $\tsunknown{EALREADY}$: connection already in progress; or $\tsunknown{EISCONN}$: socket already connected }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{disconnect}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} \Mwedge {}\\{}
 \neg{}(\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge {}\\{}
 \Mcase  \;\tsunknown{tcp\_sock}.\tsvar{st} \;\Mof {}\\{}
\quad\quad \tscon{CLOSED}      \Mtotype  \Mif  \;\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{err} = \tsunknown{EINVAL} \Mvee  \tsvar{err} = \tsunknown{EAFNOSUPPORT}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsvar{err} = \tsunknown{EAFNOSUPPORT} \Mdpipe {}\\{}
\quad\quad \tscon{LISTEN}      \Mtotype  \Mif       \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{err} = \tsunknown{EAFNOSUPPORT}  \tsholcomm{ socket is listening }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{bsd\_arch}     \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{err} = \tsunknown{EOPNOTSUPP}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsunknown{ASSERTION\_FAILURE} \text{``disconnect\textunderscore{}4:1''} \Mdpipe  \tsholcomm{ never happen }{}\\{}
\quad\quad \tscon{SYN\_SENT}    \Mtotype  \tsvar{err} = \tsunknown{EALREADY} \Mdpipe  \tsholcomm{ connection already in progress }{}\\{}
\quad\quad \tscon{SYN\_RECEIVED} \Mtotype  \tsvar{err} = \tsunknown{EALREADY} \Mdpipe  \tsholcomm{ connection already in progress }{}\\{}
\quad\quad \tscon{ESTABLISHED}  \Mtotype  \tsvar{err} = \tsunknown{EISCONN} \Mdpipe   \tsholcomm{ socket already connected }{}\\{}
\quad\quad \tscon{TIME\_WAIT}    \Mtotype  \Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{err} = \tsunknown{EISCONN}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{err} = \tsunknown{EAFNOSUPPORT}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsunknown{ASSERTION\_FAILURE} \text{``disconnect\textunderscore{}4:2''} \Mdpipe  \tsholcomm{ never happen }{}\\{}
\quad\quad \tsunknown{\_1}           \Mtotype  \tsvar{err} = \tsunknown{EISCONN} \tsholcomm{ all other states }}
{\rulesubsection{Description}

    Consider a TCP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ on a non-Linux architecture. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$
    state, a $\tsunknown{disconnect}(\tsvar{fd})$ call is made. The call fails with an error $\tsvar{err}$ which depends on
    the the state of the socket: If the socket is in the $\tscon{CLOSED}$ state then it fails with
    $\tsunknown{EAFNOSUPPORT}$, except if on FreeBSD its $\tsunknown{bsd\_cantconnect}$ flag is set, in which case it
    fails with $\tsunknown{EINVAL}$;if it is in the $\tscon{LISTEN}$ state the error is $\tsunknown{EAFNOSUPPORT}$ on WinXP
    and $\tsunknown{EOPNOTSUPP}$ on FreeBSD; if it is in the $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$ state the error
    is $\tsunknown{EALREADY}$; if it is in the $\tscon{ESTABLISHED}$ state the error is $\tsunknown{EISCONN}$; if it is in the
    $\tscon{TIME\_WAIT}$ state the error is $\tsunknown{EISCONN}$ on WinXP and $\tsunknown{EAFNOSUPPORT}$ on FreeBSD; in all
    other states the error is $\tsunknown{EISCONN}$.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{disconnect}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$ where $\tsvar{err}$ is one of the above errors.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\disconnectTV}{\rrulecc{disconnectTV}{disconnect\_5}{tcp: fast fail}{\tsholcomm{ Succeed on Linux, possibly dropping the connection }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid}, \tsvar{sock})];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}  \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{disconnect}(\tsvar{fd})}  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK}())}{ \tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid}, \tsvar{sock}')];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = \tsvar{sock}.\tsvar{pr} \Mwedge {}\\{}
 (\Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{SYN\_RECEIVED}; \tscon{ESTABLISHED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}; \tscon{CLOSE\_WAIT}\} \Mthen {}\\{}
\quad\quad \tsaux{tcp\_drop\_and\_close} \;\tsvar{h}.\tsvar{arch} \;* \;\tsvar{sock} (\tsvar{sock}',(\tsvar{oflgs},\tsvar{odata})) \Mwedge  \tsholcomm{ FIXME before it either output segs or not, whereas here we always sync }{}\\{}
\quad\quad \Mif  \;\tsaux{exists\_quad\_of} \;\tsvar{sock} \;\Mthen {}\\{}
\quad\quad\quad\quad \exists  \tsvar{S}_{0} \;\tsvar{s} \;\tsvar{s}'. \tsvar{SS} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsaux{quad\_of} \;\tsvar{sock}),\tsvar{s})] \Mwedge {}\\{}
\quad\quad\quad\quad \tsaux{write} (\tsaux{quad\_of} \;\tsvar{sock}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
\quad\quad\quad\quad \tsaux{destroy} (\tsaux{quad\_of} \;\tsvar{sock}) (\tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsaux{quad\_of} \;\tsvar{sock}),\tsvar{s}')]) \tsvar{S}'{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad\quad \tsvar{S}' = \tsvar{SS}{}\\{}
 \Melse {}\\{}
\quad\quad \tsvar{sock} = \tsvar{sock}' \Mwedge {}\\{}
\quad\quad \tsvar{oq} = \tsvar{oq}' \Mwedge {}\\{}
\quad\quad \tsvar{S}' = \tsvar{SS}{}\\{}
 )}
{\rulesubsection{Description}

    On Linux, consider a TCP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in
    the $\tscon{Run}$ state, a $\tsunknown{disconnect}(\tsvar{fd})$ call is made and succeeds.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{disconnect}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$. If the socket is in the $\tscon{SYN\_RECEIVED}$, $\tscon{ESTABLISHED}$, $\tscon{FIN\_WAIT\_1}$,
    $\tscon{FIN\_WAIT\_2}$, or $\tscon{CLOSE\_WAIT}$ state then the connection is dropped, a RST segment is
    constructed, $\tsunknown{outsegs}$, which may be placed on the host's outqueue, $\tsvar{oq}$, resulting in new
    outqueue $\tsvar{oq}'$. If the socket is in any other state then it remains unchanged, as does the
    host's outqueue.

\rulesubsection{Model details}

    Note that $\tsunknown{disconnect}()$ has not been properly implemented on Linux yet so it will always succeed.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    This rule does not apply.

\\\hline
FreeBSD
&
    This rule does not apply.

\\\hline
WinXP
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\disconnectTI}{\rrulecc{disconnectTI}{disconnect\_1}{udp: fast succeed}{\tsholcomm{ Unset socket's peer address }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsunknown{ts\_}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid}, \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))]{}\\{}
 \Mmagicbolrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{disconnect}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsunknown{ts\_}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tsvar{ret})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid}, \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))]{}\\{}
 \Mmagicbolrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\Mif  \;\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{ret} = \tscon{OK}(){}\\{}
 \Melse  \;\Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \exists \tsvar{i}'_{2}.\tsvar{is}_{2}=\Msome  \;\tsvar{i}'_{2} \;\Mthen  \;\tsvar{ret} = \tscon{OK}(){}\\{}
 \Melse                       \;\tsvar{ret} = \tscon{FAIL}\;{\tsunknown{EAFNOSUPPORT}})}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ with $(\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2})$ as its binding
    quad. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{disconnect}(\tsvar{fd})$ call is made. On
    Linux the call succeeds; on WinXP if the socket had its peer IP address set then the call
    succeeds, otherwise it fails with an $\tsunknown{EAFNOSUPPORT}$ error; on FreeBSD the call fails with an
    $\tsunknown{EAFNOSUPPORT}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{disconnect}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}())$
    or $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EAFNOSUPPORT}})$. The socket has its peer address set to $(*,*)$, and its
    local IP address set to $*$. The local port, $\tsvar{p}_{1}$, is left in place.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    As above: the call fails with an $\tsunknown{EAFNOSUPPORT}$ error.

\\\hline
Linux
&
    As above: the call succeeds.

\\\hline
WinXP
&
    As above: the call succeeds if the socket had a peer IP address set, or fails with an
    $\tsunknown{EAFNOSUPPORT}$ error otherwise.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\disconnectTII}{\rrulecc{disconnectTII}{disconnect\_2}{udp: fast succeed}{\tsholcomm{ Unset socket's peer address and autobind local port }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{disconnect} \;\tsvar{fd}} }{1}}
{(\tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsunknown{ts\_}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tsvar{ret})}{ \tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid}, \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))];{}\\{}
 \tsvar{bound} \Mass  \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsunknown{ts\_}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid}, \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,*,*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{p}_{1} \;\in  \;\tsaux{autobind}(*,\tsunknown{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge {}\\{}
 (\Mif  \;\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{ret} = \tscon{OK}(){}\\{}
 \Melse                       \;\tsvar{ret} = (\tscon{FAIL}\;{\tsunknown{EAFNOSUPPORT}}))}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ and with binding quad
    $(*,*,*,*)$. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a
    $\tsunknown{disconnect}(\tsvar{fd})$ call is made. The call succeeds on Linux and fails with an $\tsunknown{EAFNOSUPPORT}$
    error on FreeBSD and WinXP.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{disconnect}(\tsvar{fd})}$ transition is made, leaving the thread either in state $\tscon{Ret}
(\tscon{OK}())$, or in state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EAFNOSUPPORT}})$. The socket is autobound to a local ephemeral
    port $\tsvar{p}'_{1}$, and $\tsvar{sid}$ is placed on the head of the host's list of bound sockets.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    As above: the call fails with an $\tsunknown{EAFNOSUPPORT}$ error.

\\\hline
Linux
&
    As above: the call succeeds.

\\\hline
WinXP
&
    As above: the call fails with an $\tsunknown{EAFNOSUPPORT}$ error.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\disconnectTIII}{\rrulecc{disconnectTIII}{disconnect\_3}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EAGAIN}$, $\tsunknown{EADDRNOTAVAIL}$, or $\tsunknown{ENOBUFS}$: there are no ephemeral ports left }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{disconnect} \;\tsvar{fd}} }{1}}
{(\tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,*,*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsaux{autobind}(*,\tsunknown{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) = \emptyset  \Mwedge {}\\{}
 \tsvar{e} \;\in  \{\tsunknown{EAGAIN}; \tsunknown{EADDRNOTAVAIL}; \tsunknown{ENOBUFS}\}}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ and with binding quad
    $*,*,*,*$. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a
    $\tsunknown{disconnect}(\tsvar{fd})$ call is made. There are no ephemeral ports left, so the socket cannot be
    autobound to a local port. The call fails with an error: $\tsunknown{EAGAIN}$, $\tsunknown{EADDRNOTAVAIL}$, or
    $\tsunknown{ENOBUFS}$.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{disconnect}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$ where $\tsvar{e}$ is one of the above errors.

\rrulepad }
}

\newcommand{\seccommdup}{\clustersection{(TCP and UDP)}{$\tsunknown{dup}()$}
\seccomm{  \[ \tsunknown{dup}: \tsunknown{fd} \Mtotype  \tsunknown{fd} \]

  A call to $\tsunknown{dup}(\tsunknown{fd})$ creates and returns a new file descriptor referring to the open file
  description referred to by the file descriptor $\tsunknown{fd}$.
  A successful $\tsunknown{dup}()$ call will return the least numbered free file descriptor. The call will
  only fail if there are no more free file descriptors, or $\tsunknown{fd}$ is not a valid file descriptor.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{dup}()$ can fail with the errors below, in which case the corresponding exception is
  raised:

\par\begin{ltstabular}
$\tsunknown{EMFILE}$
&  There are no more file descriptors available.
\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsunknown{dup\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:   & \wasverb{int dup(int fildes);} \\
    FreeBSD: & \wasverb{int dup(int oldd);} \\
    Linux:   & \wasverb{int dup(int oldfd);} \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}
    \item \wasverb{fildes} is a file descriptor referring to the open file description for which
     another file descriptor is to be created for. This corresponds to the $\tsunknown{fd}$ argument of the
     model $\tsunknown{dup}()$.

    \item The returned \wasverb{int} is either non-negative to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}. If the call is
     successful then the returned \wasverb{int} is the new file descriptor corresponding to the
     $\tsunknown{fd}$ return type of the model $\tsunknown{dup}()$.

  \end{itemize}

  The FreeBSD and Linux interfaces are similar. This call does not exist on WinXP.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{dup\_1}$
& \textbf{all: fast succeed}
&  Successfully duplicate file descriptor \\
$\tsrule{dup\_2}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{EMFILE}$: no more file descriptors available \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\dupTI}{\rrulecc{dupTI}{dup\_1}{all: fast succeed}{\tsholcomm{ Successfully duplicate file descriptor }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{dup}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} \;\tsvar{fd}')}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}' \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{unix\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsunknown{nextfd} \;\tsvar{h}.\tsvar{arch} \;\tsvar{fds} \;\tsvar{fd}' \Mwedge {}\\{}
 \tsvar{fd}' < \tsunknown{OPEN\_MAX\_FD} \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \oplus  (\tsvar{fd}', \tsvar{fid})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{dup}(\tsvar{fd})$ call is made where $\tsvar{fd}$ is a
   file descriptor referring to an open file description identified by $\tsvar{fid}$. A new file
   descriptor, $\tsvar{fd}'$ can be created in an architecture-specific way according to the \ltslink{nextfd}{$\tsunknown{nextfd}$}
   function. $\tsvar{fd}'$ is less than the maximum open file descriptor, $\tsunknown{OPEN\_MAX\_FD}$. The call
   succeeds returning $\tsvar{fd}'$.

   A $\MLhcall{\tsvar{tid}}{\tsunknown{dup}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK} \;\tsvar{fd}')$. The
   host's finite map of file descriptors, $\tsvar{fds}$, is extended to map the new file descriptor
   $\tsvar{fd}'$ to the file identifier $\tsvar{fid}$, which results in a new finite map of file descriptors
   $\tsvar{fds}'$ for the host.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
   This rule does not apply: there is no $\tsunknown{dup}()$ call on WinXP.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\dupTII}{\rrulecc{dupTII}{dup\_2}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{EMFILE}$: no more file descriptors available }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{dup}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EMFILE}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{unix\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 (\tsholop{CARD} (\Mfdom{\tsvar{h}.\tsvar{fds}}) + 1) \geq  \tsunknown{OPEN\_MAX}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{dup}(\tsvar{fd})$ call is made where $\tsvar{fd}$ is
    a valid file descriptor: it has an entry in the host's finite map of file descriptors,
    $\tsvar{h}.\tsvar{fds}$. Creating another file descriptor would cause the number of open file descriptors to
    be greater than or equal to the maximum number of open file descriptors, $\tsunknown{OPEN\_MAX}$. The call
    fails with an $\tsunknown{EMFILE}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{dup}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EMFILE}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    This rule does not apply: there is no $\tsunknown{dup}()$ call on WinXP.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommdupfd}{\clustersection{(TCP and UDP)}{$\tsunknown{dupfd}()$}
\seccomm{  \[ \tsunknown{dupfd}: \tsunknown{fd} * \tstype{int} \Mtotype  \tsunknown{fd} \]

  A call to $\tsunknown{dupfd}(\tsunknown{fd},\tsunknown{n})$ creates and returns a new file desciptor referring to the open file
  description referred to by the file descriptor $\tsunknown{fd}$.

  A successful $\tsunknown{dupfd}()$ call will return the least free file descriptor greater than or equal to
  $\tsunknown{n}$. The call will fail if $\tsunknown{n}$ is negative or greater than the maximum allowed file
  descriptor, $\tsunknown{OPEN\_MAX}$; if the file descriptor $\tsunknown{fd}$ is not a valid file descriptor; or if
  there are no more file descriptors available.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{dupfd}()$ can fail with the errors below, in which case the corresponding exception is
  raised:

\par\begin{ltstabular}
$\tsunknown{EINVAL}$
&  The requested file descriptor is invalid: it is negative or greater than the maximum allowed.

\\\hline
$\tsunknown{EMFILE}$
&  There are no more file descriptors available.

\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsunknown{dupfd\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tsunknown{dupfd}()$ is Posix $\tsunknown{fcntl}()$ using the \wasverb{F\textunderscore{}DUPFD} command:

  \begin{tabular}{ll}
  Posix:   & \wasverb{int fcntl(int fildes, int cmd, int arg);} \\
  FreeBSD: & \wasverb{int fcntl(int fd, int cmd, int arg);} \\
  Linux:   & \wasverb{int fcntl(int fd, int cmd, long arg);} \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}
    \item \wasverb{fildes} is a file descriptor referring to the open file description for which
     another file descriptor is to be created for. This corresponds to the $\tsunknown{fd}$ argument of the
     model $\tsunknown{dupfd}()$.

    \item \wasverb{cmd} is the command to run on the specified file descriptor. For the model
     $\tsunknown{dupfd}()$ this command is set to \wasverb{F\textunderscore{}DUPFD}.

    \item The returned \wasverb{int} is either non-negative to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}. If the call was
     successful then the returned \wasverb{int} is the new file descriptor.
  \end{itemize}

  The FreeBSD and Linux interfaces are similar. This call does not exist on WinXP.

}\clustersubsection{Model details}
\seccomm{
  Note that $\tsunknown{dupfd}()$ is \wasverb{fcntl()} with \wasverb{F\textunderscore{}DUPFD} rather than the similar but
  different \wasverb{dup2()}.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{dupfd\_1}$
& \textbf{all: fast succeed}
&  Successfully create a duplicate file descriptor greater than or equal to $\tsunknown{n}$ \\
$\tsrule{dupfd\_3}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{EINVAL}$: $\tsunknown{n}$ is negative or greater than the maximum allowed file descriptor \\
$\tsrule{dupfd\_4}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{EMFILE}$: no more file descriptors available \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\dupfdTI}{\rrulecc{dupfdTI}{dupfd\_1}{all: fast succeed}{\tsholcomm{ Successfully create a duplicate file descriptor greater than or equal to $\tsvar{n}$ }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{dupfd}(\tsvar{fd},\tsvar{n})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} \;\tsvar{fd}')}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}' \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{unix\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{n} \geq  0 \Mwedge {}\\{}
 \tscon{FD} (\tsholop{Num} \;\tsvar{n}) < \tsunknown{OPEN\_MAX\_FD} \Mwedge   {}\\{}
 \tsvar{fd}' = \tscon{FD} (\tsholop{LEAST} \;\tsvar{n}'. \tsholop{Num} \;\tsvar{n} \leq  \tsvar{n}' \Mwedge  \tscon{FD} \;\tsvar{n}' < \tsunknown{OPEN\_MAX\_FD} \Mwedge  \tscon{FD} \;\tsvar{n}' \;\notin  \Mfdom{\tsvar{fds}}) \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \oplus  (\tsvar{fd}', \tsvar{fid})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{dupfd}(\tsvar{fd},\tsvar{n})$ call is made. The host's
   finite map of file descriptors is $\tsvar{fds}$, and $\tsvar{fd}$ is a valid file descriptor in $\tsvar{fds}$,
   referring to an open file description identified by $\tsvar{fid}$. $\tsvar{n}$ is non-negative. A file
   descriptor $\tsvar{fd}'$ can be created, where it is the least free file descriptor greater than or
   equal to $\tsvar{n}$, and less than the maximum allowed file descriptor, $\tsunknown{OPEN\_MAX\_FD}$. The call
   succeeds, returning this new file descriptor $\tsvar{fd}'$.

   A $\MLhcall{\tsvar{tid}}{\tsunknown{dupfd}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}
\tsvar{fd}')$. An entry mapping $\tsvar{fd}'$ to the open file description $\tsvar{fid}$ is added to $\tsvar{fds}$,
   resulting in a new finite map of file descriptors for the host, $\tsvar{fds}'$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
   This rule does not apply: there is no $\tsunknown{dupfd}()$ call on WinXP.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\dupfdTIII}{\rrulecc{dupfdTIII}{dupfd\_3}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{EINVAL}$: $\tsvar{n}$ is negative or greater than the maximum allowed file descriptor }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{dupfd}(\tsvar{fd},\tsvar{n})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{unix\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{n} < 0 \Mvee  \tsholop{Num} \;\tsvar{n} \geq  \tsunknown{OPEN\_MAX} \Mwedge {}\\{}
 \tsvar{err} = (\Mif  \;\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsunknown{EBADF} \;\Melse  \;\tsunknown{EINVAL})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{dupfd}(\tsvar{fd},\tsvar{n})$ call is made. $\tsvar{n}$ is
   either negative or greater than the maximum number of open file descriptors, $\tsunknown{OPEN\_MAX}$. The
   call fails with an $\tsunknown{EINVAL}$ error.

   A $\MLhcall{\tsvar{tid}}{\tsunknown{dupfd}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
   This call does not apply: there is no $\tsunknown{dupfd}()$ call on WinXP.

\\\hline
FreeBSD
&
   On BSD the error $\tsunknown{EBADF}$ is returned.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\dupfdTIV}{\rrulecc{dupfdTIV}{dupfd\_4}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{EMFILE}$: no more file descriptors available }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{dupfd}(\tsvar{fd},\tsvar{n})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EMFILE}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{unix\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{n} \geq  0 \Mwedge {}\\{}
 \tsvar{fd}' = \tscon{FD} (\tsholop{LEAST} \;\tsvar{n}'. \tsholop{Num} \;\tsvar{n} \leq  \tsvar{n}' \Mwedge  \tsunknown{OPEN\_MAX\_FD} \leq  \tscon{FD} \;\tsvar{n}' \Mwedge  \tscon{FD} \;\tsvar{n}' \;\notin  \Mfdom{\tsvar{h}.\tsvar{fds}})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{dupfd}(\tsvar{fd},\tsvar{n})$ call is made. $\tsvar{fd}$ is a
   file descriptor referring to open file description $\tsvar{fid}$ and $\tsvar{n}$ is non-negative. The least
   file descriptor $\tsvar{fd}'$ that is greater than or equal to $\tsvar{n}$ is greater than or equal to the
   maximum open file descriptor, $\tsunknown{OPEN\_MAX\_FD}$. The call fails with an $\tsunknown{EMFILE}$ error.

   A $\MLhcall{\tsvar{tid}}{\tsunknown{dupfd}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EMFILE}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
   This rule does not apply: there is no $\tsunknown{dupfd}()$ call on WinXP.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommgetfileflags}{\clustersection{(TCP and UDP)}{$\tsunknown{getfileflags}()$}
\seccomm{ \[ \tsunknown{getfileflags}: \tsunknown{fd} \Mtotype  \tsunknown{filebflag} \;\tstype{list} \]

   A call to $\tsunknown{getfileflags}(\tsunknown{fd})$ returns a list of the file flags currently set for the file which
   $\tsunknown{fd}$ refers to.

   The possible file flags are:
   \begin{itemize}
     \item $\tscon{O\_ASYNC}$ Reports whether signal driven I/O is enabled.
     \item $\tscon{O\_NONBLOCK}$ Reports whether a socket is non-blocking.
   \end{itemize}

}\clustersubsection{Errors}
\seccomm{
   A call to $\tsunknown{getfileflags}()$ can fail with the error below, in which case the corresponding
   exception is raised:

\par\begin{ltstabular}
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  A call to $\tsunknown{getfileflags}()$ is made, returning the flags set: $\tsunknown{getfileflags\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tsunknown{getfileflags}()$ is Posix \wasverb{fcntl(fd,F\textunderscore{}GETFL)}. On WinXP it is \wasverb{ioctlsocket()}
  with the \wasverb{FIONBIO} command.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int fcntl(int fildes, int cmd, ...);}\\
    FreeBSD: & \wasverb{int fcntl(int fd, int cmd, ...);}\\
    Linux:   & \wasverb{int fcntl(int fd, int cmd);}\\
    WinXP:   & \wasverb{int ioctlsocket(SOCKET s, long cmd, u\textunderscore{}long* argp)}
  \end{tabular}

   In the Posix interface:

   \begin{itemize}
     \item \wasverb{fildes} is a file descriptor for the file to retrieve flags from. It corresponds
      to the $\tsunknown{fd}$ argument of the model $\tsunknown{getfileflags}()$. On WinXP the \wasverb{s} is a socket
      descriptor corresponding to the $\tsunknown{fd}$ argument of the model $\tsunknown{getfileflags}()$.

     \item \wasverb{cmd} is a command to perform an operation on the file. This is set to
      \wasverb{F\textunderscore{}GETFL} for the model $\tsunknown{getfileflags}()$. On WinXP, \wasverb{cmd} is set to
      \wasverb{FIONBIO} to get the $\tscon{O\_NONBLOCK}$ flag; there is no $\tscon{O\_ASYNC}$ flag on WinXP.

     \item The call takes a variable number of arguments. For the model $\tsunknown{getfileflags}()$ only the
      two arguments described above are needed.

     \item If the call succeeds the returned \wasverb{int} represents the file flags that are set
      corresponding to the $\tsunknown{filebflag} \;\tstype{list}$ return type of the model $\tsunknown{getfileflags}()$. If the
      returned \wasverb{int} is \wasverb{-1} then an error has occurred in which case the error code
      is in \wasverb{errno}. On WinXP an error is indicated by a return value of
      \wasverb{SOCKET\textunderscore{}ERROR} with the actual error code available through a call to
      \wasverb{WSAGetLastError()}.
   \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}
    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

    \item \wasverb{WSAENOTSOCK} is a possible error on WinXP as the \wasverb{ioctlsocket()} call is
     specific to a socket. In the model the $\tsunknown{getfileflags}()$ call is performed on a file.
  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getfileflags\_1}$
& \textbf{all: fast succeed}
&  Return list of file flags currently set for an open file description \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getfileflagsTI}{\rrulecc{getfileflagsTI}{getfileflags\_1}{all: fast succeed}{\tsholcomm{ Return list of file flags currently set for an open file description }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getfileflags}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} \;\tsvar{flags})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsvar{ft},\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{flags} \;\in  \;\tsunknown{ORDERINGS} \;\tsvar{ff}.\tsunknown{b}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{getfileflags}(\tsvar{fd})$ call is made. $\tsvar{fd}$
    refers to a file description $\tscon{File}(\tsvar{ft},\tsvar{ff})$ where $\tsvar{ff}$ is the file flags that are set. The
    call succeeds, returning $\tsvar{flags}$ which is a list representing some ordering of the boolean
    file flags $\tsvar{ff}.\tsunknown{b}$ in $\tsvar{ff}$.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getfileflags}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}(\tsvar{flags}))$.

\rrulepad }
}

\newcommand{\seccommgetifaddrs}{\clustersection{(TCP and UDP)}{$\tsunknown{getifaddrs}()$}
\seccomm{ \[ \tsunknown{getifaddrs}: \tstype{unit} \Mtotype  (\tsunknown{ifid} * \tsunknown{ip} * \tsunknown{ip} \;\tstype{list} * \tsunknown{netmask}) \tstype{list} \]

  A call to $\tsunknown{getifaddrs}()$ returns the interface information for a host. For each interface a
  tuple is constructed consisting of: the interface name, the primary IP address for the interface,
  the auxiliary IP addresses for the interface, and the subnet mask for the interface. A list is
  constructed with one tuple for each interface, and this is the return value of the call to
  $\tsunknown{getifaddrs}()$.

}\clustersubsection{Errors}
\seccomm{
  FIXME comment here

\par\begin{ltstabular}
$\tsunknown{EINTR}$
&  The system was interrupted by a caught signal.

\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsunknown{getifaddrs\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tsunknown{getifaddrs}()$ is two calls to Posix \wasverb{ioctl()}: one with the \wasverb{SIOCGIFCONF}
  request and one with the \wasverb{SIOCGIFNETMASK} request. On FreeBSD there is a specific
  \wasverb{getifaddrs()} call. On WinXP the $\tsunknown{getifaddrs}()$ call does not exist.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int ioctl(int fildes, int request, ... /* arg */);} \\
    FreeBSD: & \wasverb{int getifaddrs(struct ifaddrs **ifap);} \\
    Linux:   & \wasverb{int ioctl(int d, int request, ...);}
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{fildes} is a file descriptor. There is no corresponding argument in the model
     $\tsunknown{getifaddrs}()$.

    \item \wasverb{request} is the operation to perform on the file. When \wasverb{request} is
     \wasverb{SIOCGIFCONF} the list of all interfaces is returned; when it is \wasverb{SIOCNETMASK}
     the subnet mask is returned for an interface.

    \item The function takes a variable number of arguments. When \wasverb{request} is
     \wasverb{SIOCGIFCONF} there is a third argument: a pointer to a location to store a linked-list
     of the interfaces; when it is \wasverb{SIOCGIFNETMASK} it is a pointer to a structure
     containing the interface and it is filled in with the subnet mask for that interface.

    \item The returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.

  \end{itemize}

  To construct the return value of type $(\tsunknown{ifid} * \tsunknown{ip} * \tsunknown{ip} \;\tstype{list} * \tsunknown{netmask}) \tstype{list}$, the interface name
  and the IP addresses associated with it are obtained from the call to \wasverb{ioctl()} using
  \wasverb{SIOCGIFCONF}, and then the subnet mask for each interface is obtained from a call to
  \wasverb{ioctl()} using \wasverb{SIOCGIFNETMASK}.

  On FreeBSD the \wasverb{ifap} argument to \wasverb{getifaddrs()} is a pointer to a location to store
  a linked list of the interface information in, corresponding to the return type of the model
  $\tsunknown{getifaddrs}()$.

}\clustersubsection{Model details}
\seccomm{
  Any of the errors possible when making an \wasverb{ioctl()} call are possible: $\tsunknown{EIO}$, $\tsunknown{ENOTTY}$,
  $\tsunknown{ENXIO}$, and $\tsunknown{ENODEV}$. None of these are modelled.

  Note that the Posix interface admits the possibility that the interfaces will change between the
  two calls, whereas in the model interface the $\tsunknown{getifaddrs}()$ call is atomic.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getifaddrs\_1}$
& \textbf{all: fast succeed}
&  Successfully return host interface information \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getifaddrsTI}{\rrulecc{getifaddrsTI}{getifaddrs\_1}{all: fast succeed}{\tsholcomm{ Successfully return host interface information }}
{(\tsvar{h} \; \;\tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getifaddrs} ()} }{1}}
{(\tsvar{h} \; \;\tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{OK} \;\tsvar{iflist})}{\tsunknown{sched\_timer}}},\tsvar{S},\tsvar{M})}
{\tsvar{ifidlist} \;\in  \;\tsunknown{ORDERINGS} \;\tsvar{ifidset} \Mwedge {}\\{}
 \tsholop{LENGTH} \;\tsvar{ifidlist} = \tsholop{LENGTH} \;\tsvar{iflist} \Mwedge {}\\{}
 {}\\{}
 \tsvar{ifidset} = \{ (\tsunknown{ifid}, \tsunknown{hifd}) \mid {}\\{}
\quad\quad\quad\quad\quad\quad \tsunknown{ifid} \;\in  \Mfdom{\tsvar{h}.\tsvar{ifds}} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsunknown{hifd} = \tsvar{h}.\tsvar{ifds} \Mfapply{}{\tsunknown{ifid}} \} \Mwedge {}\\{}
 {}\\{}
 \tsholop{EVERY} \;\MI  (\tsholop{MAP2} (\lambda  (\tsunknown{ifid},\tsunknown{hifd}) (\tsunknown{ifid'},\tsunknown{primary},\tsunknown{ipslist},\tsunknown{netmask}). (\tsunknown{ifid'} = \tsunknown{ifid} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{primary} = \tsunknown{hifd}.\tsunknown{primary} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{ipslist} \;\in  \;\tsunknown{ORDERINGS} \;\tsunknown{hifd}.\tsunknown{ipset} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{netmask} = \tsunknown{hifd}.\tsunknown{netmask})){}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{ifidlist} \;\tsvar{iflist})}
{\rulesubsection{Description}

     On a Unix architecture, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{getifaddrs}()$
     call is made. The call succeeds, returning $\tsvar{iflist}$ which is a list of tuples: one for each
     interface on the host. Each tuple consists of: the interface name; the primary IP address for
     the interface; a list of the other IP addresses for the interface; and the netmask for the
     interface.

     A $\MLhcall{\tsvar{tid}}{\tsunknown{getifaddrs}()}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}
\tsvar{iflist})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
     This call does not exist on WinXP.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommgetpeername}{\clustersection{(TCP and UDP)}{$\tsunknown{getpeername}()$}
\seccomm{  \[ \tsunknown{getpeername}: \tsunknown{fd} \Mtotype  (\tsunknown{ip} * \tsunknown{port}) \]

  A call to $\tsunknown{getpeername}(\tsunknown{fd})$ returns the peer address of the socket referred to by file
  descriptor $\tsunknown{fd}$. If the file descriptor refers to a socket $\tsunknown{sock}$ then a successful call will
  return $(\tsvar{i}_{2},\tsvar{p}_{2})$ where $\tsunknown{sock}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2}$, and $\tsunknown{sock}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}$.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{getpeername}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tsunknown{ENOTCONN}$
&  Socket not connected to a peer.
\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsunknown{getpeername\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:    & \wasverb{int getpeername(int socket, struct sockaddr *restrict address,} \\
              & \wasverb{                socklen\textunderscore{}t *restrict address\textunderscore{}len);} \\
    FreeBSD:  & \wasverb{int getpeername(int s, struct sockaddr *name, } \\
              & \wasverb{                socklen\textunderscore{}t *namelen);} \\
    Linux:    & \wasverb{int getpeername(int s, struct sockaddr *name, } \\
              & \wasverb{                socklen\textunderscore{}t *namelen);} \\
    WinXP:    & \wasverb{int getpeername(SOCKET s,struct sockaddr* name,} \\
              & \wasverb{                int* namelen);} \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is a file descriptor referring to the socket to get the peer address of,
     corresponding to the $\tsunknown{fd}$ argument in the model $\tsunknown{getpeername}()$.

    \item \wasverb{address} is a pointer to a \wasverb{sockaddr} structure of length
     \wasverb{address\textunderscore{}len}, which contains the peer address of the socket upon return. These two
     correspond to the $(\tsunknown{ip} * \tsunknown{port})$ return type of the model $\tsunknown{getpeername}()$. The
     \wasverb{sin\textunderscore{}addr.s\textunderscore{}addr} field of the \wasverb{address} structure holds the peer IP address,
     corresponding to the $\tsunknown{ip}$ in the return tuple; the \wasverb{sin\textunderscore{}port} field of the
     \wasverb{address} structure holds the peer port, corresponding to the $\tsunknown{port}$ in the return
     tuple.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item According to the FreeBSD man page for $\tsunknown{getpeername}()$, $\tsunknown{ECONNRESET}$ can be returned if
     the connection has been reset by the peer. This behaviour has not been observed in any tests.

    \item On FreeBSD, Linux, and WinXP, $\tsunknown{EFAULT}$ can be returned if the \wasverb{name} parameter
     points to memory not in a valid part of the process address space. This is an artefact of the C
     interface to \wasverb{getpeername()} that is excluded by the clean interface used in the model
     $\tsunknown{getpeername}()$.

    \item In Posix, $\tsunknown{EINVAL}$ can be returned if the socket has been shutdown; none of the
    implementations in the model return this error from a $\tsunknown{getpeername}()$ call.

    \item In Posix, $\tsunknown{EOPNOTSUPP}$ is returned if the $\tsunknown{getpeername}()$ operation is not supported
     by the protocol. Both TCP and UDP support this operation.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getpeername\_1}$
& \textbf{all: fast succeed}
&  Successfully return socket's peer address \\
$\tsrule{getpeername\_2}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{ENOTCONN}$: socket not connected to a peer \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getpeernameTI}{\rrulecc{getpeernameTI}{getpeername\_1}{all: fast succeed}{\tsholcomm{ Successfully return socket's peer address }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getpeername}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsvar{i}_{2},\tsvar{p}_{2}))}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge {}\\{}
 (\tsvar{sock}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2} \Mvee  (\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsvar{sock}.\tsvar{ps}_{2} = * \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{p}_{2} = \tscon{Port} \;0) \Mwedge  \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tsunknown{PROTO\_UDP}) ) \Mwedge {}\\{}
 ((\forall \tsunknown{tcp\_sock}. \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \implies {}\\{}
\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{CLOSE\_WAIT}; \tscon{LAST\_ACK};{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscon{FIN\_WAIT\_1}; \tscon{CLOSING}\} \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad (\neg{}\tsvar{sock}.\tsvar{cantrcvmore} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{FIN\_WAIT\_2}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad (\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad \tsholcomm{ BSD listen bug }{}\\{}
\quad\quad\quad\quad\quad\quad (\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{LISTEN}) ) \Mvee {}\\{}
 \tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch}){}\\{}
 {}\\{}
 {}\\{}
 }
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{getpeername}(\tsvar{fd})$ call is made. $\tsvar{fd}$
    refers to a socket $\tsvar{sock}$, identified by $\tsvar{sid}$, which has its peer IP address set to $\Msome
\tsvar{i}_{2}$ and its peer port address set to $\Msome  \;\tsvar{p}_{2}$. If $\tsvar{sock}$ is a TCP socket then either it is
    in state $\tscon{ESTABLISHED}$, $\tscon{CLOSE\_WAIT}$, $\tscon{LAST\_ACK}$, $\tscon{FIN\_WAIT\_1}$, or $\tscon{CLOSING}$; or it is
    in state $\tscon{FIN\_WAIT\_2}$ and is not shutdown for reading. The call succeeds, returning
    $(\tsvar{i}_{2},\tsvar{p}_{2})$, the socket's peer address.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getpeername}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret}( \tscon{OK}
(\tsvar{i}_{2},\tsvar{p}_{2}))$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    If $\tsvar{sock}$ is a TCP socket then it may be in state $\tscon{LISTEN}$; this is due to the FreeBSD bug
    that allows $\tsvar{listen}()$ to be called on a synchronised socket.

\\\hline
Linux
&
    If $\tsvar{sock}$ is a TCP socket then it may also be in state $\tscon{SYN\_RECEIVED}$.

\\\hline
WinXP
&
    If $\tsvar{sock}$ is a UDP socket and has no peer port set, $\tsvar{sock}.\tsvar{ps}_{2} = *$ then the call may
    still succeed with $\tsvar{p}_{2} = \tscon{Port} \;0$. Additionally, if $\tsvar{sock}$ is a TCP socket then it may be in
    any state.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\getpeernameTII}{\rrulecc{getpeernameTII}{getpeername\_2}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{ENOTCONN}$: socket not connected to a peer }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getpeername}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOTCONN}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
 \neg{}(\tsvar{sock}.\tsvar{is}_{2} \neq  * \Mwedge {}\\{}
\quad (\tsvar{sock}.\tsvar{ps}_{2} \neq  * \Mvee  (\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tsunknown{PROTO\_UDP})) \Mwedge {}\\{}
\quad (\forall \tsunknown{tcp\_sock}. \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \implies {}\\{}
\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{CLOSE\_WAIT}; \tscon{LAST\_ACK}; \tscon{FIN\_WAIT\_1}; \tscon{CLOSING} \} \Mvee {}\\{}
\quad\quad\quad (\neg{}\tsvar{sock}.\tsvar{cantrcvmore} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{FIN\_WAIT\_2}) \Mvee {}\\{}
\quad\quad\quad (\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED}) \Mvee {}\\{}
\quad\quad\quad {}\\{}
\quad\quad\quad \tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch}))}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{getpeername}(\tsvar{fd})$ call is made where
    $\tsvar{fd}$ refers to a socket $\tsvar{sock}$ identified by $\tsvar{sid}$. The socket does not have both its peer
    IP and port set, If it is a TCP socket then it is not in state $\tscon{ESTABLISHED}$, $\tscon{CLOSE\_WAIT}$,
    $\tscon{LAST\_ACK}$, $\tscon{FIN\_WAIT\_1}$ or $\tscon{CLOSING}$; or in state $\tscon{FIN\_WAIT\_2}$ and not shutdown for
    reading. The call fails with an $\tsunknown{ENOTCONN}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getpeername}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOTCONN}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    As above, with the additional condition that if $\tsvar{sock}$ is a TCP socket then it is not in state
    $\tscon{SYN\_RECEIVED}$.

\\\hline
WinXP
&
    As above, except that if $\tsvar{sock}$ is a TCP socket then it does not matter what state it is in
    and if it is a UDP socket then the state of its peer port, whether it is set or unset, does not
    matter.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommgetsockbopt}{\clustersection{(TCP and UDP)}{$\tsunknown{getsockbopt}()$}
\seccomm{  \[ \tsunknown{getsockbopt}: (\tsunknown{fd} * \tsunknown{sockbflag}) \Mtotype  \tstype{bool} \]

  A call to $\tsunknown{getsockbopt}(\tsunknown{fd},\tsunknown{flag})$ returns the value of one of the socket's boolean-valued flags.

  The $\tsunknown{fd}$ argument is a file descriptor referring to the socket to retrieve a flag's value from,
  and the $\tsunknown{flag}$ argument is the boolean-valued socket flag to get. Possible flags are:

  \begin{itemize}

    \item $\tscon{SO\_BSDCOMPAT}$ Reports whether the BSD semantics for delivery of ICMPs to UDP sockets
     with no peer address set is enabled.

    \item $\tscon{SO\_DONTROUTE}$ Reports whether outgoing messages bypass the standard routing facilities.

    \item $\tscon{SO\_KEEPALIVE}$ Reports whether connections are kept active with periodic transmission of
     messages, if this is supported by the protocol.

    \item $\tscon{SO\_OOBINLINE}$ Reports whether the socket leaves received out-of-band data (data marked
     urgent) inline.

    \item $\tscon{SO\_REUSEADDR}$ Reports whether the rules used in validating addresses supplied to
     $\tsunknown{bind}()$ should allow reuse of local ports, if this is supported by the protocol.

  \end{itemize}

  The return value of the $\tsunknown{getsockbopt}()$ call is the boolean-value of the specified socket flag.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{getsockbopt}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tsunknown{ENOPROTOOPT}$
&  The specified flag is not supported by the protocol.

\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsunknown{getsockbopt\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tsunknown{getsockbopt}()$ is Posix \wasverb{getsockopt()} for boolean-valued socket flags.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int getsockopt(int socket, int level, int option\textunderscore{}name,}\\
             & \wasverb{               void *restrict option\textunderscore{}value, } \\
             & \wasverb{               socklen\textunderscore{}t *restrict option\textunderscore{}len);} \\
    FreeBSD: & \wasverb{int getsockopt(int s, int level, int optname, } \\
             & \wasverb{               void *optval, socklen\textunderscore{}t *optlen); } \\
    Linux:   & \wasverb{int getsockopt(int  s, int level, int optname, } \\
             & \wasverb{               void *optval, socklen\textunderscore{}t *optlen);} \\
    WinXP:   & \wasverb{int getsockopt(SOCKET s,int level,int optname, } \\
             & \wasverb{               char* optval, int* optlen); } \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket on which to get the flag,
     corresponding to the $\tsunknown{fd}$ argument of the model $\tsunknown{getsockbopt}()$.

    \item \wasverb{level} is the protocol level at which the flag resides: \wasverb{SOL\textunderscore{}SOCKET} for
     the socket level options, and \wasverb{option\textunderscore{}name} is the flag to be retrieved. These two
     correspond to the $\tsunknown{flag}$ argument to the model $\tsunknown{getsockbopt}()$ where the possible values of
     \wasverb{option\textunderscore{}name} are limited to: $\tscon{SO\_BSDCOMPAT}$, $\tscon{SO\_DONTROUTE}$, $\tscon{SO\_KEEPALIVE}$,
     $\tscon{SO\_OOBINLINE}$, and $\tscon{SO\_REUSEADDR}$.

    \item \wasverb{option\textunderscore{}value} is a pointer to a location of size \wasverb{option\textunderscore{}len} to store
     the value retrieved by \wasverb{getsockopt()}. These two correspond to the $\tstype{bool}$ return type
     of the model $\tsunknown{getsockbopt}()$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EFAULT} signifies the pointer passed as \wasverb{option\textunderscore{}value} was
     inaccessible. On WinXP, the error \wasverb{WSAEFAULT} may also signify that the
     \wasverb{optlen} parameter was too small.

    \item \wasverb{EINVAL} signifies the \wasverb{option\textunderscore{}name} was invalid at the specified socket
     \wasverb{level}. In the model, typing prevents an invalid flag from being specified in a call
     to $\tsunknown{getsockbopt}()$.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getsockbopt\_1}$
& \textbf{all: fast succeed}
&  Successfully retrieve value of boolean socket flag \\
$\tsrule{getsockbopt\_2}$
& \textbf{udp: fast succeed}
&  Fail with $\tsunknown{ENOPROTOOPT}$: option not valid on WinXP UDP socket \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getsockboptTI}{\rrulecc{getsockboptTI}{getsockbopt\_1}{all: fast succeed}{\tsholcomm{ Successfully retrieve value of boolean socket flag }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getsockbopt}(\tsvar{fd},\tsvar{f})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsvar{sf}.\tsunknown{b}(\tsvar{f})))}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sf} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{sf} \Mwedge {}\\{}
 (\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tsunknown{PROTO\_UDP}{}\\{}
\quad \implies  \tsvar{f} \;\notin  \{\tscon{SO\_KEEPALIVE} \})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{getsockbopt}(\tsvar{fd},\tsvar{f})$ call is made. $\tsvar{fd}$
    refers to a socket $\tsvar{sid}$ with boolean socket flags $\tsvar{sf}.\tsunknown{b}$, and $\tsvar{f}$ is a boolean socket
    flag. The call succeeds, returning the value of $\tsvar{f}$: $\Mtrue $ if $\tsvar{f}$ is set, and $\Mfalse $ if $\tsvar{f}$
    is not set in $\tsvar{sf}.\tsunknown{b}$.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getsockbopt}(\tsvar{fd},\tsvar{f})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}(\tsvar{sf}.\tsunknown{b}(\tsvar{f})))$ where $\tsvar{sf}.\tsunknown{b}(\tsvar{f})$ is the boolean value of the socket's flag $\tsvar{f}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    As above, except that if $\tsvar{sid}$ is a UDP socket, then $\tsvar{f}$ cannot be $\tscon{SO\_KEEPALIVE}$ or
    $\tscon{SO\_OOBINLINE}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\getsockboptTII}{\rrulecc{getsockboptTII}{getsockbopt\_2}{udp: fast succeed}{\tsholcomm{ Fail with $\tsunknown{ENOPROTOOPT}$: option not valid on WinXP UDP socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid}, \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getsockbopt}(\tsvar{fd},\tsvar{f})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOPROTOOPT}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{f} \;\in  \{\tscon{SO\_KEEPALIVE} \}}
{\rulesubsection{Description}

    On WinXP, consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in
    the $\tscon{Run}$ state, a $\tsunknown{getsockbopt}(\tsvar{fd},\tsvar{f})$ call is made, where $\tsvar{f}$ is either $\tscon{SO\_KEEPALIVE}$
    or $\tscon{SO\_OOBINLINE}$. The call fails with an $\tsunknown{ENOPROTOOPT}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getsockbopt}(\tsvar{fd},\tsvar{f})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOPROTOOPT}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommgetsockerr}{\clustersection{(TCP and UDP)}{$\tsunknown{getsockerr}()$}
\seccomm{  \[ \tsunknown{getsockerr}: \tsunknown{fd} \Mtotype  \tstype{unit} \]

  A call $\tsunknown{getsockerr}(\tsunknown{fd})$ returns the pending error of a socket, clearing it, if there is one.

  $\tsunknown{fd}$ is a file descriptor referring to a socket. If the socket has a pending error then the
  $\tsunknown{getsockerr}()$ call will fail with that error, otherwise it will return successfully.

}\clustersubsection{Errors}
\seccomm{
  In addition to failing with the pending error, a call to $\tsunknown{getsockerr}()$ can fail with the errors
  below, in which case the corresponding exception is raised:

\par\begin{ltstabular}
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsunknown{getsockerr\_1}$; $\tsunknown{return\_1}$

  $\tsunknown{getsockerr\_2}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tsunknown{getsockerr}()$ is Posix \wasverb{getsockopt()} for the \wasverb{SO\textunderscore{}ERROR} socket option.

  \begin{tabular}{ll}
     Posix:   & \wasverb{int getsockopt(int socket, int level, int option\textunderscore{}name,}\\
              & \wasverb{               void *restrict option\textunderscore{}value, } \\
              & \wasverb{               socklen\textunderscore{}t *restrict option\textunderscore{}len);} \\
     FreeBSD: & \wasverb{int getsockopt(int s, int level, int optname, } \\
              & \wasverb{               void *optval, socklen\textunderscore{}t *optlen); } \\
     Linux:   & \wasverb{int getsockopt(int  s, int level, int optname, } \\
              & \wasverb{               void *optval, socklen\textunderscore{}t *optlen);} \\
     WinXP:   & \wasverb{int getsockopt(SOCKET s,int level,int optname, } \\
              & \wasverb{               char* optval, int* optlen); } \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to get the option on, corresponding
     to the $\tsunknown{fd}$ argument of the model $\tsunknown{getsockerr}()$.

    \item \wasverb{level} is the protocol level at which the option resides: \wasverb{SOL\textunderscore{}SOCKET}
     for the socket level options, and \wasverb{option\textunderscore{}name} is the option to be retrieved. For
     $\tsunknown{getsockerr}()$ \wasverb{option\textunderscore{}name} is set to \wasverb{SO\textunderscore{}ERROR}.

    \item \wasverb{option\textunderscore{}value} is a pointer to a location of size \wasverb{option\textunderscore{}len} to store
     the value retrieved by \wasverb{getsockopt()}. When \wasverb{option\textunderscore{}name} is
     \wasverb{SO\textunderscore{}ERROR} these fields are not used.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate the socket has no pending
     error or \wasverb{-1} to indicate a pending error, in which case the error code is in
     \wasverb{errno}.  On WinXP an error is indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR},
     not \wasverb{-1}, with the actual error code available through a call to
     \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EFAULT} signifies the pointer passed as \wasverb{option\textunderscore{}value} was
     inaccessible. On WinXP, the error \wasverb{WSAEFAULT} may also signify that the
     \wasverb{optlen} parameter was too small.

    \item \wasverb{EINVAL} signifies the \wasverb{option\textunderscore{}name} was invalid at the specified socket
     \wasverb{level}. In the model, the flag for $\tsunknown{getsockerr}()$ is always \wasverb{SO\textunderscore{}ERROR} so
     this error cannot occur.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getsockerr\_1}$
& \textbf{all: fast succeed}
&  Return successfully: no pending error \\
$\tsrule{getsockerr\_2}$
& \textbf{all: fast fail}
&  Fail with pending error and clear the error \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getsockerrTI}{\rrulecc{getsockerrTI}{getsockerr\_1}{all: fast succeed}{\tsholcomm{ Return successfully: no pending error }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getsockerr}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{es} = *}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{getsockerr}(\tsvar{fd})$ call is made. $\tsvar{fd}$
    refers to a socket $\tsvar{sid}$ which has no pending errors. The call succeeds.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getsockerr}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$.

\rrulepad }
}

\newcommand{\getsockerrTII}{\rrulecc{getsockerrTII}{getsockerr\_2}{all: fast fail}{\tsholcomm{ Fail with pending error and clear the error }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getsockerr}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Msome  \;\tsvar{e} = \tsvar{sock}.\tsvar{es} \Mwedge {}\\{}
 \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  * \Mmagicrrec }
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{getsockerr}(\tsvar{fd})$ call is made. $\tsvar{fd}$
    refers to a socket $\tsvar{sid}$ which has pending error $\tsvar{e}$. The call fails, returning $\tsvar{e}$.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getsockerr}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$ and cleaing the error $\tsvar{e}$ from the socket.

\rrulepad }
}

\newcommand{\seccommgetsocklistening}{\clustersection{(TCP and UDP)}{$\tsunknown{getsocklistening}()$}
\seccomm{ \[ \tsunknown{getsocklistening}: \tsunknown{fd} \Mtotype  \tstype{bool} \]

  A call to $\tsunknown{getsocklistening}(\tsunknown{fd})$ returns $\Mtrue $ if the socket referenced by $\tsunknown{fd}$ is listening,
  or $\Mfalse $ otherwise. For TCP a socket is listening if it is in the $\tscon{LISTEN}$ state. For UDP, which
  is not a connection-oriented protocol, a socket can never be listening.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{getsocklistening}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tsunknown{ENOPROTOOPT}$
&  FreeBSD does not support this socket option, and on Linux and WinXP this
  option is not supported for UDP sockets.

\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsunknown{getsocklistening\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tsunknown{getsocklistening}()$ is Posix \wasverb{getsockopt()} for the \wasverb{SO\textunderscore{}ACCEPTCONN} socket
  option.

  \begin{tabular}{ll}
     Posix:   & \wasverb{int getsockopt(int socket, int level, int option\textunderscore{}name,}\\
              & \wasverb{               void *restrict option\textunderscore{}value, } \\
              & \wasverb{               socklen\textunderscore{}t *restrict option\textunderscore{}len);} \\
     FreeBSD: & \wasverb{int getsockopt(int s, int level, int optname, } \\
              & \wasverb{               void *optval, socklen\textunderscore{}t *optlen); } \\
     Linux:   & \wasverb{int getsockopt(int  s, int level, int optname, } \\
              & \wasverb{               void *optval, socklen\textunderscore{}t *optlen);} \\
     WinXP:   & \wasverb{int getsockopt(SOCKET s,int level,int optname, } \\
              & \wasverb{               char* optval, int* optlen); } \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to get the option on, corresponding
     to the $\tsunknown{fd}$ argument of the model $\tsunknown{getsocklistening}()$.

    \item \wasverb{level} is the protocol level at which the option resides: \wasverb{SOL\textunderscore{}SOCKET}
     for the socket level options, and \wasverb{option\textunderscore{}name} is the option to be retrieved. For
     $\tsunknown{getsocklistening}()$ \wasverb{option\textunderscore{}name} is set to \wasverb{SO\textunderscore{}ACCEPTCONN}.

    \item \wasverb{option\textunderscore{}value} is a pointer to a location of size \wasverb{option\textunderscore{}len} to store
     the value retrieved by \wasverb{getsockopt()}. The value stored in the location corresponds to
     the $\tstype{bool}$ return value of the model $\tsunknown{getsocklistening}()$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  The Linux and WinXP interfaces are similar except where noted. FreeBSD does not support the
  \wasverb{SO\textunderscore{}ACCEPTCONN} socket option.

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EFAULT} signifies the pointer passed as \wasverb{option\textunderscore{}value} was
     inaccessible. On WinXP, the error \wasverb{WSAEFAULT} may also signify that the
     \wasverb{optlen} parameter was too small.

    \item \wasverb{EINVAL} signifies the \wasverb{option\textunderscore{}name} was invalid at the specified socket
     \wasverb{level}. In the model, the flag for $\tsunknown{getsocklistening}()$ is always
     \wasverb{SO\textunderscore{}ACCEPTCONN} so this error cannot occur.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getsocklistening\_1}$
& \textbf{tcp: fast succeed}
&  Return successfully: $\Mtrue $ if socket is listening, $\Mfalse $ otherwise \\
$\tsrule{getsocklistening\_3}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{ENOPROTOOPT}$: on FreeBSD operation not supported \\
$\tsrule{getsocklistening\_2}$
& \textbf{udp: rc}
&  Return $\Mfalse $ or fail with $\tsunknown{ENOPROTOOPT}$: a UDP socket cannot be listening \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getsocklisteningTI}{\rrulecc{getsocklisteningTI}{getsocklistening\_1}{tcp: fast succeed}{\tsholcomm{ Return successfully: $\Mtrue $ if socket is listening, $\Mfalse $ otherwise }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getsocklistening}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} \;\tsvar{b})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} \Mwedge {}\\{}
 \tsvar{b} = (\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{LISTEN}) \Mwedge {}\\{}
 \neg{}(\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{getsocklistening}(\tsvar{fd})$ call is
    made where $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getsocklistening}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK} \;\tsvar{b})$ where $\tsvar{b}=\Mtrue $ if the socket is in the $\tscon{LISTEN}$ state, and $\tsvar{b}=\Mfalse $ otherwise.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply: see $\tsunknown{getsocklistening\_3}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\getsocklisteningTIII}{\rrulecc{getsocklisteningTIII}{getsocklistening\_3}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{ENOPROTOOPT}$: on FreeBSD operation not supported }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getsocklistening}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOPROTOOPT}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr}}
{\rulesubsection{Description}

    On FreeBSD, a $\tsunknown{getsocklistening}(\tsvar{fd})$ call is made from thread $\tsvar{tid}$ which is in the $\tscon{Run}$
    state where$\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$. The call fails with an $\tsunknown{ENOPROTOOPT}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getsocklistening}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsunknown{ENOPROTOOPT}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    This rule does not apply: see $\tsunknown{getsocklistening\_1}$.

\\\hline
WinXP
&
    This rule does not apply: see $\tsunknown{getsocklistening\_1}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\getsocklisteningTII}{\rrulecc{getsocklisteningTII}{getsocklistening\_2}{udp: rc}{\tsholcomm{ Return $\Mfalse $ or fail with $\tsunknown{ENOPROTOOPT}$: a UDP socket cannot be listening }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getsocklistening}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tsvar{ret})}{ \tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tsunknown{PROTO\_UDP} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mif  \;\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{rc} = \tscon{fast} \;\tscon{succeed} \Mwedge  \tsvar{ret} = \tscon{OK} \;\Mfalse {}\\{}
 \Melse                       \;\tsvar{rc} = \tscon{fast} \;\tscon{fail}    \Mwedge  \tsvar{ret} = \tscon{FAIL}\;{\tsunknown{ENOPROTOOPT}}}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in the
    $\tscon{Run}$ state, a $\tsunknown{getsocklistening}(\tsvar{fd})$ call is made. On Linux the call succeeds, returning
    $\Mfalse $; on FreeBSD and WinXP the call fails with an $\tsunknown{ENOPROTOOPT}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getsocklistening}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}(\Mfalse ))$ on Linux, and $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOPROTOOPT}})$ on FreeBSD and Linux.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    As above: the call fails with an $\tsunknown{ENOPROTOOPT}$ error.

\\\hline
FreeBSD
&
    As above: the call fails with an $\tsunknown{ENOPROTOOPT}$ error.

\\\hline
Linux
&
    As above: the call succeeds, returning $\Mfalse $.

\\\hline
WinXP
&
    As above: the call fails with an $\tsunknown{ENOPROTOOPT}$ error.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommgetsockname}{\clustersection{(TCP and UDP)}{$\tsunknown{getsockname}()$}
\seccomm{  \[ \tsunknown{getsockname}: \tsunknown{fd} \Mtotype  (\tsunknown{ip} \;\;\tstype{option} * \tsunknown{port} \;\;\tstype{option}) \]

  A call to $\tsunknown{getsockname}(\tsunknown{fd})$ returns the local address pair of a socket. If the file descriptor
  $\tsunknown{fd}$ refers to the socket $\tsunknown{sock}$ then the return value of a successfull call will be
  $(\tsunknown{sock}.\tsvar{is}_{1}, \tsunknown{sock}.\tsvar{ps}_{1})$.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{getsockname}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tsunknown{ECONNRESET}$
&  On FreeBSD, TCP socket has its $\tsvar{cb}.\tsunknown{bsd\_cantconnect}$ flag set due to previous connection establishment attempt.
\\\hline
$\tsunknown{EINVAL}$
&  Socket not bound to local address on WinXP.
\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\\\hline
$\tsunknown{ENOBUFS}$
&  Out of resources.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsunknown{getsockname\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:   & \wasverb{int getsockname(int socket, struct sockaddr *restrict address,} \\
             & \wasverb{                socklen\textunderscore{}t *restrict address\textunderscore{}len);} \\
    FreeBSD: & \wasverb{int getsockname(int s, struct sockaddr *name, } \\
             & \wasverb{                socklen\textunderscore{}t *namelen);} \\
    Linux:   & \wasverb{int getsockname(int s, struct sockaddr *name, } \\
             & \wasverb{                socklen\textunderscore{}t *namelen);} \\
    WinXP:   & \wasverb{int getsockname(SOCKET s, struct sockaddr* name, }\\
             & \wasverb{                int* namelen);} \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is a file descriptor referring to the socket to get the local address of,
     corresponding to the $\tsunknown{fd}$ argument in the model $\tsunknown{getsockname}()$.

    \item \wasverb{address} is a pointer to a \wasverb{sockaddr} structure of length
     \wasverb{address\textunderscore{}len}, which contains the local address of the socket upon return. These two
     correspond to the $(\tsunknown{ip} \;\;\tstype{option}, \tsunknown{port} \;\;\tstype{option})$ return type of the model $\tsunknown{getsockname}()$. If
     the \wasverb{sin\textunderscore{}addr.s\textunderscore{}addr} field of the \wasverb{name} structure is set to \wasverb{0} on
     return, then the socket's local IP address is not set: the $\tsunknown{ip} \;\;\tstype{option}$ member of the return
     tuple is set to $*$; otherwise, if it is set to \wasverb{i} then it corresponds to the
     socket having local IP address and so the $\tsunknown{ip} \;\;\tstype{option}$ member of the return tuple is$\Msome
\tsvar{i}$. If the \wasverb{sin\textunderscore{}port} field of the \wasverb{name} structure is set to \wasverb{0} on
     return then the socket does not have a local port set, corresponding to the $\tsunknown{port} \;\;\tstype{option}$ in
     the return tuple being $*$; otherwise the \wasverb{sin\textunderscore{}port} field is set to \wasverb{p}
     corresponding to the socket having its local port set: the $\tsunknown{port} \;\;\tstype{option}$ in the return tuple
     is $\Msome  \;\tsvar{p}$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item On FreeBSD, Linux, and WinXP, $\tsunknown{EFAULT}$ can be returned if the \wasverb{name} parameter
     points to memory not in a valid part of the process address space. This is an artefact of the C
     interface to \wasverb{getsockname()} that is excluded by the clean interface used in the model
     $\tsunknown{getsockname}()$.

    \item in Posix, $\tsunknown{EINVAL}$ can be returned if the socket has been shutdown. None of the
    implementations return $\tsunknown{EINVAL}$ in this case.

    \item in Posix, $\tsunknown{EOPNOTSUPP}$ is returned if the $\tsunknown{getsockname}()$ operation is not supported
     by the protocol. Both UDP and TCP support this operation.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getsockname\_1}$
& \textbf{all: fast succeed}
&  Successfully return socket's local address \\
$\tsrule{getsockname\_2}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{ECONNRESET}$: previous connection attempt has failed on FreeBSD \\
$\tsrule{getsockname\_3}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{EINVAL}$: socket not bound on WinXP \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getsocknameTI}{\rrulecc{getsocknameTI}{getsockname\_1}{all: fast succeed}{\tsholcomm{ Successfully return socket's local address }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getsockname}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{ps}_{1}))}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
 (\Mcase  \;\tsvar{sock}.\tsvar{pr} \;\Mof {}\\{}
\quad \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mtotype {}\\{}
\quad\quad \tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \implies  \Mtrue   \Mdpipe {}\\{}
\quad \tscon{UDP\_PROTO}(\tsunknown{\_444}) \Mtotype  \Mtrue ) \Mwedge {}\\{}
 (\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \implies  \tsvar{sock}.\tsvar{is}_{1} \neq  * \Mvee  \tsvar{sock}.\tsvar{ps}_{1} \neq  *)}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{getsockname}(\tsvar{fd})$ call is made where
    $\tsvar{fd}$ refers to socket $\tsvar{sock}$, identified by $\tsvar{sid}$. The socket's local address is returned:
    $(\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{ps}_{1})$.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getsockname}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}
(\tsvar{sock}.\tsvar{is}_{1}, \tsvar{sock}.\tsvar{ps}_{1}))$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply if the socket's $\tsunknown{bsd\_cantconnect}$ flag is set in its control block
    and its local port is not set.

\\\hline
WinXP
&
    As above with the additional condition that either the socket's local IP address or local port
    must be set.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\getsocknameTII}{\rrulecc{getsocknameTII}{getsockname\_2}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{ECONNRESET}$: previous connection attempt has failed on FreeBSD }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getsockname}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ECONNRESET}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 ( \tsvar{sock}.\tsvar{ps}_{1} = *) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{h}.\tsvar{files} \Mfapply{}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff})}
{\rulesubsection{Description}

    On FreeBSD, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{getsockname}(\tsvar{fd})$ call is
    made where $\tsvar{fd}$ refers to a TCP socket $\tsvar{sock}$, identified by $\tsvar{sid}$, which has its
    $\tsunknown{bsd\_cantconnect}$ flag set and is not bound to a local port.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getsockname}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ECONNRESET}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    This rule does not apply.

\\\hline
WinXP
&
    This rule does not apply.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\getsocknameTIII}{\rrulecc{getsocknameTIII}{getsockname\_3}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{EINVAL}$: socket not bound on WinXP }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{1} \Mass  *; \tsvar{ps}_{1} \Mass  * \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getsockname}(\tsvar{fd})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINVAL}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{1} \Mass  *; \tsvar{ps}_{1} \Mass  * \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff})}
{\rulesubsection{Description}

    On WinXP, a $\tsunknown{getsockname}(\tsvar{fd})$ call is made from thread $\tsvar{tid}$ which is in the $\tscon{Run}$
    state. $\tsvar{fd}$ refers to a socket $\tsvar{sid}$ which has neither its local IP address nor its local
    port set. The call fails with an $\tsunknown{EINVAL}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getsockname}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    This rule does not apply.

\\\hline
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommgetsocknopt}{\clustersection{(TCP and UDP)}{$\tsunknown{getsocknopt}()$}
\seccomm{ \[ \tsunknown{getsocknopt}: (\tsunknown{fd} * \tsunknown{socknflag}) \Mtotype  \tstype{int} \]

  A call to $\tsunknown{getsocknopt}(\tsunknown{fd},\tsunknown{flag})$ returns the value of one of the socket's numeric flags.  The
  $\tsunknown{fd}$ argument is a file descriptor referring to the socket to retrieve a flag's value from. The
  $\tsunknown{flag}$ argument is a numeric socket flag. Possible flags are:

  \begin{itemize}
    \item $\tscon{SO\_RCVBUF}$ Reports receive buffer size information.
    \item $\tscon{SO\_RCVLOWAT}$ Reports the minimum number of bytes to process for socket input
     operations.
    \item $\tscon{SO\_SNDBUF}$ Reports send buffer size information.
    \item $\tscon{SO\_SNDLOWAT}$ Reports the minimum number of bytes to process for socket output
     operations.
  \end{itemize}

  The return value of the $\tsunknown{getsocknopt}()$ call is the numeric-value of the specified $\tsunknown{flag}$.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{getsocknopt}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tsunknown{ENOPROTOOPT}$
&  The specified flag is not supported by the protocol.
\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsunknown{getsocknopt\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tsunknown{getsocknopt}()$ is Posix \wasverb{getsockopt()} for numeric socket flags.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int getsockopt(int socket, int level, int option\textunderscore{}name,}\\
             & \wasverb{               void *restrict option\textunderscore{}value, } \\
             & \wasverb{               socklen\textunderscore{}t *restrict option\textunderscore{}len);} \\
    FreeBSD: & \wasverb{int getsockopt(int s, int level, int optname, } \\
             & \wasverb{               void *optval, socklen\textunderscore{}t *optlen); } \\
    Linux:   & \wasverb{int getsockopt(int  s, int level, int optname, } \\
             & \wasverb{               void *optval, socklen\textunderscore{}t *optlen);} \\
    WinXP:   & \wasverb{int getsockopt(SOCKET s,int level,int optname, } \\
             & \wasverb{               char* optval, int* optlen); } \\
  \end{tabular}

  In the Posix interface:
  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to set the option on, corresponding
     to the $\tsunknown{fd}$ argument of the model $\tsunknown{getsocknopt}()$.

    \item \wasverb{level} is the protocol level at which the option resides: \wasverb{SOL\textunderscore{}SOCKET}
     for the socket level options, and \wasverb{option\textunderscore{}name} is the option to be retrieved. These
     two correspond to the $\tsunknown{flag}$ argument to the model $\tsunknown{getsocknopt}()$ where the possible
     values of \wasverb{option\textunderscore{}name} are limited to $\tscon{SO\_RCVBUF}$, $\tscon{SO\_RCVLOWAT}$, $\tscon{SO\_SNDBUF}$
     and $\tscon{SO\_SNDLOWAT}$.

    \item \wasverb{option\textunderscore{}value} is a pointer to a location of size \wasverb{option\textunderscore{}len} to store
     the value retrieved by \wasverb{getsockopt()}. They correspond to the $\tstype{int}$ return type of
     the model $\tsunknown{getsocknopt}()$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EFAULT} signifies the pointer passed as \wasverb{option\textunderscore{}value} was
     inaccessible. On WinXP, the error \wasverb{WSAEFAULT} may also signify that the
     \wasverb{optlen} parameter was too small.

    \item \wasverb{EINVAL} signifies the \wasverb{option\textunderscore{}name} was invalid at the specified socket
     \wasverb{level}. In the model, typing prevents an invalid flag from being specified in a call
     to $\tsunknown{getsocknopt}()$.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getsocknopt\_1}$
& \textbf{all: fast succeed}
&  Successfully retrieve value of a numeric socket flag \\
$\tsrule{getsocknopt\_4}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{ENOPROTOOPT}$: value of $\tscon{SO\_RCVLOWAT}$ and $\tscon{SO\_SNDLOWAT}$ not retrievable \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getsocknoptTI}{\rrulecc{getsocknoptTI}{getsocknopt\_1}{all: fast succeed}{\tsholcomm{ Successfully retrieve value of a numeric socket flag }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getsocknopt}(\tsvar{fd},\tsvar{f})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsholop{int\_of\_num} (\tsvar{sf}.\tsunknown{n}(\tsvar{f}))))}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sf} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{sf} \Mwedge {}\\{}
 (\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \implies  \tsvar{f} \;\notin  \{\tscon{SO\_RCVLOWAT}; \tscon{SO\_SNDLOWAT}\})}
{\rulesubsection{Description}

    Consider the socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, with socket flags $\tsvar{sf}$. From thread
    $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{getsocknopt}(\tsvar{fd},\tsvar{f})$ call is made. $\tsvar{f}$ is a numeric
    socket flag whose value is to be returned. The call succeeds, returning $\tsvar{sf}.\tsunknown{n}(\tsvar{f})$, the numeric
    value of flag $\tsvar{f}$ for socket $\tsvar{sid}$.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getsocknopt}(\tsvar{fd},\tsvar{f})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}
(\tsholop{int\_of\_num} (\tsvar{sf}.\tsunknown{n}(\tsvar{f}))))$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    The flag $\tsvar{f}$ is not $\tscon{SO\_RCVLOWAT}$ or $\tscon{SO\_SNDLOWAT}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\getsocknoptTIV}{\rrulecc{getsocknoptTIV}{getsocknopt\_4}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{ENOPROTOOPT}$: value of $\tscon{SO\_RCVLOWAT}$ and $\tscon{SO\_SNDLOWAT}$ not retrievable }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getsocknopt}(\tsvar{fd},\tsvar{f})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOPROTOOPT}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{f} \;\in  \{\tscon{SO\_RCVLOWAT}; \tscon{SO\_SNDLOWAT}\}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{getsocknopt}(\tsvar{fd},\tsvar{f})$ call is made where
    $\tsvar{fd}$ is a file descriptor. $\tsvar{f}$ is a numeric socket flag: either $\tscon{SO\_RCVLOWAT}$ or
    $\tscon{SO\_SNDLOWAT}$, both flags whose value is non-retrievable. The call fails with an
    $\tsunknown{ENOPROTOOPT}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getsocknopt}(\tsvar{fd},\tsvar{f})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOPROTOOPT}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommgetsocktopt}{\clustersection{(TCP and UDP)}{$\tsunknown{getsocktopt}()$}
\seccomm{ \[ \tsunknown{getsocktopt}: (\tsunknown{fd} * \tsunknown{socktflag}) \Mtotype  (\tstype{int} * \tstype{int}) \;\tstype{option} \]

  A call to $\tsunknown{getsocktopt}(\tsunknown{fd},\tsunknown{flag})$ returns the value of one of the socket's time-option flags.

  The $\tsunknown{fd}$ argument is a file descriptor referring to the socket to retrieve a flag's value
  from. The $\tsunknown{flag}$ argument is a time option socket flag. Possible flags are:

  \begin{itemize}
    \item $\tscon{SO\_RCVTIMEO}$ Reports the timeout value for input operations.

    \item $\tscon{SO\_SNDTIMEO}$ Reports the timeout value specifying the amount of time that an output
     function blocks because flow control prevents data from being sent.
  \end{itemize}

  The return value of the $\tsunknown{getsocktopt}()$ call is the time-value of the specified $\tsunknown{flag}$. A
  return value of $*$ means the timeout is disabled. A return value of $\Msome (\tsunknown{s},\tsunknown{ns})$ means the
  timeout value is $\tsunknown{s}$ seconds and $\tsunknown{ns}$ nano-seconds.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{getsocktopt}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tsunknown{ENOPROTOOPT}$
&  The specified flag is not supported by the protocol.
\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsunknown{getsocktopt\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tsunknown{getsocktopt}()$ is Posix \wasverb{getsockopt()} for time-valued socket options.

  \begin{tabular}{ll}
     Posix:   & \wasverb{int getsockopt(int socket, int level, int option\textunderscore{}name,}\\
              & \wasverb{               void *restrict option\textunderscore{}value, } \\
              & \wasverb{               socklen\textunderscore{}t *restrict option\textunderscore{}len);} \\
     FreeBSD: & \wasverb{int getsockopt(int s, int level, int optname, } \\
              & \wasverb{               void *optval, socklen\textunderscore{}t *optlen); } \\
     Linux:   & \wasverb{int getsockopt(int  s, int level, int optname, } \\
              & \wasverb{               void *optval, socklen\textunderscore{}t *optlen);} \\
     WinXP:   & \wasverb{int getsockopt(SOCKET s,int level,int optname, } \\
              & \wasverb{               char* optval, int* optlen); } \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to set the option on, corresponding
     to the $\tsunknown{fd}$ argument of the model $\tsunknown{getsocktopt}()$.

    \item \wasverb{level} is the protocol level at which the option resides: \wasverb{SOL\textunderscore{}SOCKET}
     for the socket level options, and \wasverb{option\textunderscore{}name} is the option to be retrieved. These
     two correspond to the $\tsunknown{flag}$ argument to the model $\tsunknown{getsocktopt}()$ where the possible
     values of \wasverb{option\textunderscore{}name} are limited to $\tscon{SO\_RCVTIMEO}$ and $\tscon{SO\_SNDTIMEO}$.

    \item \wasverb{option\textunderscore{}value} is a pointer to a location of size \wasverb{option\textunderscore{}len} to store
     the value retrieved by \wasverb{getsockopt()}. They correspond to the $(\tstype{int} * \tstype{int}) \;\tstype{option}$
     return type of the model $\tsunknown{getsocktopt}()$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EFAULT} signifies the pointer passed as \wasverb{option\textunderscore{}value} was
     inaccessible. On WinXP, the error \wasverb{WSAEFAULT} may also signify that the
     \wasverb{optlen} parameter was too small.

    \item \wasverb{EINVAL} signifies the \wasverb{option\textunderscore{}name} was invalid at the specified socket
     \wasverb{level}. In the model, typing prevents an invalid flag from being specified in a call
     to $\tsunknown{getsocktopt}()$.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getsocktopt\_1}$
& \textbf{all: fast succeed}
&  Successfully retrieve value of time-option socket flag \\
$\tsrule{getsocktopt\_4}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{ENOPROTOOPT}$: on WinXP $\tscon{SO\_LINGER}$ not retrievable for UDP sockets \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getsocktoptTI}{\rrulecc{getsocktoptTI}{getsocktopt\_1}{all: fast succeed}{\tsholcomm{ Successfully retrieve value of time-option socket flag }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getsocktopt}(\tsvar{fd},\tsvar{f})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} \;\tsvar{t})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sf} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{sf} \Mwedge {}\\{}
 \tsvar{t} = \tsunknown{tltimeopt\_of\_time} (\tsvar{sf}.\tsvar{t}(\tsvar{f})) \Mwedge {}\\{}
 \neg{}(\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tsunknown{PROTO\_UDP} \Mwedge {}\\{}
\quad \tsvar{f} = \tscon{SO\_LINGER})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{getsocktopt}(\tsvar{fd},\tsvar{f})$ call is made. $\tsvar{fd}$
    is a file descriptor referring to the socket $\tsvar{sid}$ which has socket flags $\tsvar{sf}$, and $\tsvar{f}$ is
    a time-option flag. The call succeeds, returning $\tscon{OK} (\tsvar{t})$ where $\tsvar{t}$ is the value of the
    socket's flag $\tsvar{f}$.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getsocktopt}(\tsvar{fd},\tsvar{f})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}
\tsvar{t})$.

\rulesubsection{Model details}

    The return type is $(\tstype{int} * \tstype{int}) \;\tstype{option}$, but the type of a time-option socket flag is
    $\tsunknown{time}$. The auxiliary function $\tsunknown{tltimeopt\_of\_time}$ is used to do the conversion.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    As above but in addition if $\tsvar{fd}$ refers to a UDP socket then the flag is not $\tscon{SO\_LINGER}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\getsocktoptTIV}{\rrulecc{getsocktoptTIV}{getsocktopt\_4}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{ENOPROTOOPT}$: on WinXP $\tscon{SO\_LINGER}$ not retrievable for UDP sockets }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{getsocktopt}(\tsvar{fd},\tsvar{f})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOPROTOOPT}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tsunknown{PROTO\_UDP} \Mwedge {}\\{}
 \tsvar{f} = \tscon{SO\_LINGER}}
{\rulesubsection{Description}

    On WinXP, from thread $\tsvar{tid}$ which is in the $\tscon{Run}$ state, a $\tsunknown{getsocktopt}(\tsvar{fd},\tsvar{f})$ call is
    made. $\tsvar{fd}$ is a file descriptor referring to a UDP socket $\tsvar{sid}$ and $\tsvar{f}$ is the socket flag
    $\tscon{SO\_LINGER}$.  The flag $\tsvar{f}$ is not retrievable so the call fails with an $\tsunknown{ENOPROTOOPT}$
    error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{getsocktopt}(\tsvar{fd},\tsvar{f})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tsunknown{ENOPROTOOPT})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommlisten}{\clustersection{(TCP only)}{$\tsvar{listen}()$}
\seccomm{  \[ \tsvar{listen}: \tsunknown{fd} * \tstype{int} \Mtotype  \tstype{unit}  \]

   A call to $\tsvar{listen}(\tsunknown{fd},\tsunknown{n})$ puts a TCP socket that is in the $\tscon{CLOSED}$ state into the $\tscon{LISTEN}$
   state, making it a passive socket, so that incoming connections for the socket will be accepted
   by the host and placed on its listen queue.  Here $\tsunknown{fd}$ is a file descriptor referring to the
   socket to put into the $\tscon{LISTEN}$ state and $\tsunknown{n}$ is the \textit{backlog} used to calculate the
   maximum lengths of the two components of the socket's listen queue: its pending connections
   queue, $\tsvar{lis}.\tsunknown{q0}$, and its complete connection queue, $\tsvar{lis}.\tsunknown{q}$.  The details of this calculation
   very between architectures.  The maximum useful value of $\tsunknown{n}$ is $\tsunknown{SOMAXCONN}$: if $\tsunknown{n}$ is
   greater than this then it will be truncated without generating an error. The minimum value of
   $\tsunknown{n}$ is $0$: if it a negative integer then it will be set to $0$.

   Once a socket is in the $\tscon{LISTEN}$ state, $\tsvar{listen}()$ can be called again to change the backlog
   value.

}\clustersubsection{Errors}
\seccomm{
   A call to $\tsvar{listen}()$ can fail with the errors below, in which case the corresponding exception
   is raised:

\par\begin{ltstabular}
$\tsunknown{EADDRINUSE}$
&  Another socket is listening on this local port.

\\\hline
$\tsunknown{EINVAL}$
&  On FreeBSD the socket has been shutdown for writing; on Linux the socket is not
   in the $\tscon{CLOSED}$ or $\tscon{LISTEN}$ state; or on WinXP the socket is not bound,

\\\hline
$\tsunknown{EISCONN}$
&  On WinXP the socket is already connected: it is not in the $\tscon{CLOSED}$ or
   $\tscon{LISTEN}$ state.

\\\hline
$\tsunknown{EOPNOTSUPP}$
&  The $\tsvar{listen}()$ operation is not supported for UDP.

\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
   A TCP socket is created, has its local address and port set by $\tsunknown{bind}()$, and then is put into
   the $\tscon{LISTEN}$ state which can accept new incoming connections: $\tsunknown{socket\_1}$; $\tsunknown{return\_1}$;
   $\tsunknown{bind\_1}$ $\tsunknown{return\_1}$; ${\tsvar{listen}}_{1}$; $\tsunknown{return\_1}$; $\dots$

}\clustersubsection{API}
\seccomm{
   \begin{tabular}{ll}
     Posix:   & \wasverb{int listen(int socket, int backlog);} \\
     FreeBSD: & \wasverb{int listen(int s, int backlog);} \\
     Linux:   & \wasverb{int listen(int s, int backlog);} \\
     WinXP:   & \wasverb{int listen(SOCKET s, int backlog);} \\
   \end{tabular}

   In the Posix interface:

   \begin{itemize}

     \item \wasverb{socket} is a file descriptor referring to the socket to put into the $\tscon{LISTEN}$
      state, corresponding to the $\tsunknown{fd}$ argument of the model $\tsvar{listen}()$.

     \item \wasverb{backlog} is an \wasverb{int} on which the maximum permitted length of the
      socket's listen queue depends. It corresponds to the $\tsunknown{n}$ argument of the model $\tsvar{listen}()$.

     \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
      indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
      indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual
      error code available through a call to \wasverb{WSAGetLastError()}.

    \end{itemize}

}\clustersubsection{Model details}
\seccomm{
   The following errors are not modelled:

   \begin{itemize}

     \item In Posix, $\tsunknown{EACCES}$ may be returned if the calling process does not have the appropriate
      privileges. This is not modelled here.

     \item In Posix, $\tsunknown{EDESTADDRREQ}$ shall be returned if the socket is not bound to a local
      address and the protocol does not support listening on an unbound socket. WinXP returns an
      $\tsunknown{EINVAL}$ error in this case; FreeBSD and Linux autobind the socket if $\tsvar{listen}()$ is called
      on an unbound socket.

     \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
      Windows Sockets 1.1 call is in progress, or the service provider is still processing a
      callback function". This is not modelled here.

   \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{listen\_1}$
& \textbf{tcp: fast succeed}
&  Successfully put socket in $\tscon{LISTEN}$ state \\
$\tsrule{listen\_1b}$
& \textbf{tcp: fast succeed}
&  Successfully update backlog value \\
$\tsrule{listen\_1c}$
& \textbf{tcp: fast succeed}
&  Successfully put socket in the $\tscon{LISTEN}$ state from any non-$\{\tscon{CLOSED};\tscon{LISTEN}\}$ state on FreeBSD \\
$\tsrule{listen\_2}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{EINVAL}$ on WinXP: socket not bound to local port \\
$\tsrule{listen\_3}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{EINVAL}$ on Linux or $\tsunknown{EISCONN}$ on WinXP: socket not in $\tscon{CLOSED}$ or $\tscon{LISTEN}$ state \\
$\tsrule{listen\_4}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{EADDRINUSE}$ on Linux: another socket already listening on local port \\
$\tsrule{listen\_5}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{EINVAL}$ on BSD: socket shutdown for writing or $\tsunknown{bsd\_cantconnect}$ flag set \\
$\tsrule{listen\_7}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{EOPNOTSUPP}$: $\tsvar{listen}()$ called on UDP socket \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\listenTI}{\rrulecc{listenTI}{listen\_1}{tcp: fast succeed}{\tsholcomm{ Successfully put socket in $\tscon{LISTEN}$ state }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{CLOSED},\tsvar{cb},*,[\,],[\,])))] ;{}\\{}
 \tsvar{listen} \Mass  \tsvar{listen}_{0} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsvar{listen}(\tsvar{fd},\tsvar{n})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis},[\,],[\,])))] ;{}\\{}
 \tsvar{listen} \Mass  \tsvar{sid} \Mcons  \tsvar{listen}_{0};{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mvee  \tsvar{cantrcvmore} = \Mfalse ) \Mwedge {}\\{}
 \neg{}(\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsunknown{IS\_NONE} \;\tsvar{ps}_{1}) \Mwedge {}\\{}
 (\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \implies  \Mtrue  ) \Mwedge {}\\{}
 \tsvar{p}_{1} \;\in  \;\tsaux{autobind}(\tsvar{ps}_{1},\tsunknown{PROTO\_TCP},\tsvar{h},\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}.\tsvar{bound}) \Mwedge {}\\{}
 \tsvar{lis} = \Mmagiclrec  \tsunknown{q0} \Mass  [\,];{}\\{}
 \tsunknown{q}  \Mass  [\,];{}\\{}
 \tsunknown{qlimit} \Mass  \tsvar{n} \Mmagicrrec }
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is currently in the $\tscon{Run}$ state, a $\tsvar{listen}(\tsvar{fd},\tsvar{n})$ call is
   made. $\tsvar{fd}$ is a file descriptor referring to a TCP socket identified by $\tsvar{sid}$ which is not
   shutdown for writing, is in the $\tscon{CLOSED}$ state, has an empty send and receive queue, and does
   not have its send or receive urgent pointers set. The host's list of listening sockets is
   $\tsvar{listen}_{0}$. Either the socket is bound to a local port $\tsvar{p}_{1}$, or it can be autobound to a local
   port $\tsvar{p}_{1}$.

   The call succeeds: a $\MLhcall{\tsvar{tid}}{\tsvar{listen}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread in
   state $\tscon{Ret} (\tscon{OK}())$. The socket is put in the $\tscon{LISTEN}$ state, with an empty listen queue,
   $\tsvar{lis}$, with $\tsvar{n}$ as its backlog. $\tsvar{sid}$ is added to the host's list of listening sockets,
   $\tsvar{listen} \Mass  \tsvar{sid}\Mcons \tsvar{listen}_{0}$, and if autobinding occurred, it is also added to the host's list of
   bound sockets, $\tsvar{h}.\tsvar{bound}$, to create a new list $\tsvar{bound}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   The $\tsunknown{bsd\_cantconnect}$ flag in the control block must not be set to $\Mtrue $ (from an earlier
   connection establishment attempt).

\\\hline
WinXP
&
   As above, except that the socket must be bound to a local port $\tsvar{p}_{1}$. If it is not bound then
   autobinding will not occur: the call will fail with an $\tsunknown{EINVAL}$ error. See also \ltslink{listenTII}{${\tsvar{listen}}_{2}$}.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\listenTIb}{\rrulecc{listenTIb}{listen\_1b}{tcp: fast succeed}{\tsholcomm{ Successfully update backlog value }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis},[\,],[\,])))] ;{}\\{}
 \tsvar{listen} \Mass  \tsvar{listen}_{0} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsvar{listen}(\tsvar{fd},\tsvar{n})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis}',[\,],[\,])))] ;{}\\{}
 \tsvar{listen} \Mass  \tsvar{sid} \Mcons  \tsvar{listen}_{0} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mvee  \tsvar{cantrcvmore} = \Mfalse ) \Mwedge {}\\{}
 \tsvar{lis}' = \tsvar{lis} \; \Mmagiclrec  \tsunknown{qlimit} \Mass  \tsvar{n} \Mmagicrrec }
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsvar{listen}(\tsvar{fd},\tsvar{n})$ call is made. $\tsvar{fd}$
   refers to a TCP socket identified by $\tsvar{sid}$ which is currently in the $\tscon{LISTEN}$ state. The host
   has a list of listening sockets, $\tsvar{listen}_{0}$. The call succeeds.

   A $\MLhcall{\tsvar{tid}}{\tsvar{listen}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$. The backlog value of the socket's listen queue, $\tsvar{lis}.\tsunknown{qlimit}$ is updated to be $\tsvar{n}$,
   resulting in a new listen queue $\tsvar{lis}'$ for the socket. $\tsvar{sid}$ is added to the head of the
   host's listen queue, $\tsvar{listen} \Mass  \tsvar{sid}\Mcons \tsvar{listen}_{0}$.

\rrulepad }
}

\newcommand{\listenTIc}{\rrulecc{listenTIc}{listen\_1c}{tcp: fast succeed}{\tsholcomm{ Successfully put socket in the $\tscon{LISTEN}$ state from any non-$\{\tscon{CLOSED};\tscon{LISTEN}\}$ state on FreeBSD }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{listen} \Mass  \tsvar{listen}_{0} \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsvar{listen}(\tsvar{fd},\tsvar{n})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock}')];{}\\{}
 \tsvar{listen} \Mass  \tsvar{sid} \Mcons  \tsvar{listen}_{0} \Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{TCP\_PROTO}(\tsunknown{tcp\_sock})) \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \;\notin  \{\tscon{CLOSED}; \tscon{LISTEN}\} \Mwedge {}\\{}
 \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{st} \Mass  \tscon{LISTEN}; \tsvar{lis} \Mass  \Msome  \;\tsvar{lis} \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
 \tsaux{destroy} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsvar{SS} \;\tsvar{S}' \Mwedge {}\\{}
 \tsvar{lis} = \Mmagiclrec  \tsunknown{q0} \Mass  [\,];{}\\{}
 \tsunknown{q}  \Mass  [\,];{}\\{}
 \tsunknown{qlimit} \Mass  \tsvar{n} \Mmagicrrec }
{\rulesubsection{Description}

   On BSD, calling $\tsvar{listen}()$ always succeeds on a socket regardless of its state: the state of the
   socket is just changed to $\tscon{LISTEN}$.

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsvar{listen}(\tsvar{fd},\tsvar{n})$ call is made. $\tsvar{fd}$
   refers to a TCP socket identified by $\tsvar{sid}$ which is currently in any non-$\{\tscon{CLOSED};\tscon{LISTEN}\}$
   state. The call succeeds.

   A $\MLhcall{\tsvar{tid}}{\tsvar{listen}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$. The socket state is updated to $\tscon{LISTEN}$, with empty listen queues.


\rrulepad }
}

\newcommand{\listenTII}{\rrulecc{listenTII}{listen\_2}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EINVAL}$ on WinXP: socket not bound to local port }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsvar{listen}(\tsvar{fd},\tsvar{n})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINVAL}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge   {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{socks}}{\tsvar{sid}} = \tsvar{sock} \Mwedge {}\\{}
 \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tsunknown{PROTO\_TCP} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{ps}_{1} = *}
{\rulesubsection{Description}

   On WinXP, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsvar{listen}(\tsvar{fd},\tsvar{n})$ call is
   made. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sock}$, identified by $\tsvar{sid}$, which is not bound to a
   local port: $\tsvar{sock}.\tsvar{ps}_{1} = *$. The call fails with an $\tsunknown{EINVAL}$ error.

   A $\MLhcall{\tsvar{tid}}{\tsvar{listen}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   This rule does not apply.

\\\hline
Linux
&
   This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\listenTIII}{\rrulecc{listenTIII}{listen\_3}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EINVAL}$ on Linux or $\tsunknown{EISCONN}$ on WinXP: socket not in $\tscon{CLOSED}$ or $\tscon{LISTEN}$ state }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsvar{listen}(\tsvar{fd},\tsvar{n})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{socks}}{\tsvar{sid}} = \tsvar{sock} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \;\notin  \{\tscon{CLOSED}; \tscon{LISTEN}\} \Mwedge {}\\{}
 \neg{}(\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge   {}\\{}
 (\Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen {}\\{}
\quad \tsvar{err} = \tsunknown{EISCONN}{}\\{}
 \Melse  \;\Mif  \;\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen {}\\{}
\quad \tsvar{err} = \tsunknown{EINVAL}{}\\{}
 \Melse {}\\{}
\quad \Mfalse )}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsvar{listen}(\tsvar{fd},\tsvar{n})$ call is made. $\tsvar{fd}$
   refers to a TCP socket $\tsvar{sock}$, identified by $\tsvar{sid}$, which is not in the $\tscon{CLOSED}$ or
   $\tscon{LISTEN}$ state. On Linux the call fails with an $\tsunknown{EINVAL}$ error; on WinXP it fails with an
   $\tsunknown{EISCONN}$ error.

   A $\MLhcall{\tsvar{tid}}{\tsvar{listen}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$ where $\tsvar{err}$ is one of the above errors.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   This rule does not apply: $\tsvar{listen}()$ can be called from any state.

\\\hline
Linux
&
   As above: the call fails with an $\tsunknown{EINVAL}$ error.

\\\hline
WinXP
&
   As above: the call fails with an $\tsunknown{EISCONN}$ error.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\listenTIV}{\rrulecc{listenTIV}{listen\_4}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EADDRINUSE}$ on Linux: another socket already listening on local port }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsvar{listen}(\tsvar{fd},\tsvar{n})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EADDRINUSE}})}{ \tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} = \tsvar{sock} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSED} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge {}\\{}
 (\exists \tsvar{sid}' \;\tsvar{sock}' \;\tsunknown{tcp\_sock'}. \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}'} = \tsvar{sock}' \Mwedge  \tsvar{sock}'.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock'}.\tsvar{st} = \tscon{LISTEN} \Mwedge  \tsvar{sock}'.\tsvar{ps}_{1} = \tsvar{sock}.\tsvar{ps}_{1} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \neg{}(\exists \tsvar{i}_{1} \;\tsvar{i}'_{1}. \tsvar{i}_{1} \neq  \tsvar{i}'_{1} \Mwedge  \tsvar{sock}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsvar{sock}'.\tsvar{is}_{1} = \Msome  \;\tsvar{i}'_{1}))}
{\rulesubsection{Description}

     On Linux, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsvar{listen}(\tsvar{fd},\tsvar{n})$ call is
     made. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sock}$, identified by $\tsvar{sid}$, in state $\tscon{CLOSED}$ and
     bound to local port $\tsvar{p}_{1}$. There is another TCP socket, $\tsvar{sock}'$, in the host's finite map of
     sockets, $\tsvar{h}.\tsvar{socks}$ that is also bound to local port $\tsvar{p}_{1}$, and is in the $\tscon{LISTEN}$
     state. The two sockets, $\tsvar{sock}$ and $\tsvar{sock}'$, are not bound to different IP addresses: either
     they are both bound to the same IP address, one is bound to an IP address and the other is not
     bound to an IP address, or neither is bound to an IP address. The call fails with an
     $\tsunknown{EADDRINUSE}$ error.

     A $\MLhcall{\tsvar{tid}}{\tsvar{listen}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EADDRINUSE}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
     This rule does not apply.

\\\hline
WinXP
&
     This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\listenTV}{\rrulecc{listenTV}{listen\_5}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EINVAL}$ on BSD: socket shutdown for writing or $\tsunknown{bsd\_cantconnect}$ flag set }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantsndmore} \Mass  \tsvar{cantsndmore}; \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{st} \Mass  \tsvar{st} \Mmagicrrec ) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsvar{listen}(\tsvar{fd},\tsvar{n})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINVAL}})}{ \tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantsndmore} \Mass  \tsvar{cantsndmore}; \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{st} \Mass  \tsvar{st} \Mmagicrrec ) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{st} \;\in  \{\tscon{CLOSED}; \tscon{LISTEN}\} \Mwedge  {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsvar{cantsndmore} = \Mtrue  \Mvee  \Mtrue  ) }
{\rulesubsection{Description}

    On FreeBSD, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsvar{listen}(\tsvar{fd},\tsvar{n})$ call is
    made. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sock}$, identified by $\tsvar{sid}$, which is in the $\tscon{CLOSED}$
    or $\tscon{LISTEN}$ state. The socket is either shutdown for writing or has its $\tsunknown{bsd\_cantconnect}$
    flag set due to an earlier connection-establishment attempt. The call fails with an $\tsunknown{EINVAL}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsvar{listen}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    This rule does not apply.

\\\hline
WinXP
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\listenTVII}{\rrulecc{listenTVII}{listen\_7}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EOPNOTSUPP}$: $\tsvar{listen}()$ called on UDP socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsvar{listen}(\tsvar{fd},\tsvar{n})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EOPNOTSUPP}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tsunknown{PROTO\_UDP}}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in the
    $\tscon{Run}$ state, a $\tsvar{listen}(\tsvar{fd},\tsvar{n})$ call is made. The call fails with an $\tsunknown{EOPNOTSUPP}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsvar{listen}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EOPNOTSUPP}})$.

    Calling $\tsvar{listen}()$ on a socket for a connectionless protocol (such as UDP) is meaningless
    and is thus an unsupported ($\tsunknown{EOPNOTSUPP}$) operation.

\rrulepad }
}

\newcommand{\seccommtcpTrecv}{\clustersection{(TCP only)}{$\tsunknown{recv}()$}
\seccomm{ \[ \tsunknown{recv}: \tsunknown{fd} * \tstype{int} * \tsunknown{msgbflag} \;\tstype{list} \Mtotype  (\tstype{string} * ((\tsunknown{ip} * \tsunknown{port}) * \tstype{bool}) \;\tstype{option})  \]

  A call to $\tsunknown{recv}(\tsunknown{fd},\tsunknown{n},\tsunknown{opts})$ reads data from a socket's receive queue.  This section describes
  the behaviour for TCP sockets.
  Here
  $\tsunknown{fd}$ is a file descriptor referring to a TCP socket to read data from,
  $\tsunknown{n}$ is the number of bytes of data to read, and
  $\tsunknown{opts}$ is a list of message flags. Possible flags are:

  \begin{itemize}

  \item $\tscon{MSG\_DONTWAIT}$: Do not block if there is no data available.

  \item $\tscon{MSG\_OOB}$: Return out-of-band data.

  \item $\tscon{MSG\_PEEK}$: Read data but do not remove it from the socket's receive queue.

  \item $\tscon{MSG\_WAITALL}$: Block until all $\tsunknown{n}$ bytes of data are available.

  \end{itemize}

  The returned $\tstype{string}$ is the data read from the socket's receive queue. The $((\tsunknown{ip} * \tsunknown{port}) *
\tstype{bool}) \;\tstype{option}$ is always returned as $*$ for a TCP socket.

  In order to receive data, a TCP socket must be connected to a peer; otherwise, the $\tsunknown{recv}()$ call
  will fail with an $\tsunknown{ENOTCONN}$ error.  If the socket has a pending error then the $\tsunknown{recv}()$ call
  will fail with this error even if there is data available.

  If there is no data available and non-blocking behaviour is not enabled (the socket's
  $\tscon{O\_NONBLOCK}$ flag is not set and the $\tscon{MSG\_DONTWAIT}$ flag was not used) then the $\tsunknown{recv}()$ call
  will block until data arrives or an error occurs. If non-blocking behaviour is enabled and there is no
  data or error then the call will fail with an $\tsunknown{EAGAIN}$ error.

  The $\tscon{MSG\_OOB}$ flag can be set in order to receive out-of-band data; for this,
the socket's $\tscon{SO\_OOBINLINE}$ cannot be set (i.e.~out-of-band data must not be being returned inline).

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{recv}()$ can fail with the errors below, in which case the corresponding exception
  is raised:

\par\begin{ltstabular}
$\tsunknown{EAGAIN}$
&  Non-blocking $\tsunknown{recv}()$ call made and no data available; or out-of-band data
  requested and none is available.

\\\hline
$\tsunknown{EINVAL}$
&  Out-of-band data requested and $\tscon{SO\_OOBINLINE}$ flag set or the out-of-band
  data has already been read.

\\\hline
$\tsunknown{ENOTCONN}$
&  Socket not connected.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{EINTR}$
&  The system was interrupted by a caught signal.

\\\hline
$\tsunknown{ENOBUFS}$
&  Out of resources.

\\\hline
$\tsunknown{ENOMEM}$
&  Out of resources.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  A TCP socket is created and then connected to a peer; a $\tsunknown{recv}()$ call is made to receive data
  from that peer: $\tsunknown{socket\_1}$; $\tsunknown{return\_1}$; $\tsunknown{connect\_1}$; $\tsunknown{return\_1}$; $\tsunknown{recv\_1}$; $\dots $

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:  &  \wasverb{ssize\textunderscore{}t recv(int socket, void *buffer, size\textunderscore{}t length, int flags); } \\
    FreeBSD:&  \wasverb{ssize\textunderscore{}t recv(int s, void *buf, size\textunderscore{}t len, int flags);} \\
    Linux:  &  \wasverb{int recv(int s, void *buf, size\textunderscore{}t len, int flags);} \\
    WinXP:  &  \wasverb{int recv(SOCKET s, char* buf, int len, int flags);} \\
  \end{tabular}\\

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to receive from, corresponding to
     the $\tsunknown{fd}$ argument of the model $\tsunknown{recv}()$.

    \item \wasverb{buffer} is a pointer to a buffer to place the received data in, which upon return
     contains the data received on the socket. This corresponds to the $\tstype{string}$ return value of
     the model $\tsunknown{recv}()$.

    \item \wasverb{length} is the amount of data to be read from the socket, corresponding to the $\tstype{int}$
     argument of the model $\tsunknown{recv}()$; it should be at most the length of \wasverb{buffer}.

    \item \wasverb{flags} is a disjunction of the message flags that are set for the call, corresponding to
     the $\tsunknown{msgbflag}$ $\tstype{list}$ argument of the model $\tsunknown{recv}()$.

    \item the returned \wasverb{ssize\textunderscore{}t} is either non-negative, in which case it is the the amount
     of data that was received by the socket, or it is \wasverb{-1} to indicate an error, in which
     case the error code is in \wasverb{errno}. On WinXP an error is indicated by a return value of
     \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error code available through a
     call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  The FreeBSD, Linux and WinXP interfaces are similar modulo argument renaming, except where
  noted above.

  There are other functions used to receive data on a socket. \wasverb{recvfrom()} is similar to
  \wasverb{recv()} except it returns the source address of the data; this is used for UDP but is not
  necessary for TCP as the source address will always be the peer the socket has connected
  to. \wasverb{recvmsg()}, another input function, is a more general form of \wasverb{recv()}.


}\clustersubsection{Model details}
\seccomm{
  If the call blocks then the thread enters state $\tscon{Recv2}(\tsunknown{sid},\tsunknown{n},\tsunknown{opts})$ where:

  \begin{itemize}

    \item $\tsunknown{sid} : \tsunknown{sid}$ is the identifier of the socket that the $\tsunknown{recv}()$ call was made on,

    \item $\tsunknown{n} : \tstype{num}$ is the number of bytes to be read, and

    \item $\tsunknown{opts} : \tsunknown{msgbflag} \;\tstype{list}$ is the list of message flags.

  \end{itemize}

  The following errors are not modelled:

  \begin{itemize}

   \item On FreeBSD, Linux, and WinXP, $\tsunknown{EFAULT}$ can be returned if the \wasverb{buffer}
    parameter points to memory not in a valid part of the process address space. This is an artefact
    of the C interface to \wasverb{ioctl()} that is excluded by the clean interface used in the
    model $\tsunknown{recv}()$.

    \item In Posix, \wasverb{EIO} may be returned to indicated that an I/O error occurred while
    reading from or writing to the file system; this is not modelled here.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}

  The following Linux message flags are not modelled: \wasverb{MSG\textunderscore{}NOSIGNAL}, \wasverb{MSG\textunderscore{}TRUNC}, and
  \wasverb{MSG\textunderscore{}ERRQUEUE}.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{recv\_1}$
& \textbf{tcp: fast succeed}
&  Successfully return data from the socket without blocking \\
$\tsrule{recv\_2}$
& \textbf{tcp: block}
&  Block, entering state $\tscon{Recv2}$ as not enough data is available \\
$\tsrule{recv\_3}$
& \textbf{tcp: slow nonurgent succeed}
&  Blocked call returns from $\tscon{Recv2}$ state \\
$\tsrule{recv\_4}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{EAGAIN}$: non-blocking call would block waiting for data \\
$\tsrule{recv\_7}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{ENOTCONN}$: socket not connected \\
$\tsrule{recv\_8}$
& \textbf{tcp: fast fail}
&  Fail with pending error \\
$\tsrule{recv\_8a}$
& \textbf{tcp: slow urgent fail}
&  Fail with pending error from blocked state \\
$\tsrule{recv\_9}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{ESHUTDOWN}$: socket shut down for reading on WinXP \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\recvTI}{\rrulecc{recvTI}{recv\_1}{tcp: fast succeed}{\tsholcomm{ Successfully return data from the socket without blocking }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsunknown{rcvq\_})))] \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsholop{IMPLODE} \;\tsvar{str},*))}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq}',\tsunknown{rcvq\_'})))] \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s}')],\tsvar{M})}
{((\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}; \tscon{CLOSING};{}\\{}
\quad \tscon{TIME\_WAIT}; \tscon{CLOSE\_WAIT}; \tscon{LAST\_ACK}\} \Mwedge {}\\{}
\quad \tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge  \tsvar{is}_{2}=\Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}_{2}=\Msome  \;\tsvar{p}_{2}) \Mvee {}\\{}
 (\tsvar{st} = \tscon{CLOSED}) ) \Mwedge {}\\{}
 \tsvar{n} = \tsunknown{clip\_int\_to\_num} \;\tsvar{n}_{0} \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ We return now if we can fill the buffer, or we can reach the low-water mark (usually
         ignored if $\tscon{MSG\_WAITALL}$ is set), or we can reach EOF or the next urgent-message boundary.
         Pending errors are not checked. }{}\\{}
 \Mlet  \;\tsunknown{have\_all\_data}     = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{n}) \Min  {}\\{}
 \Mlet  \;\tsunknown{have\_enough\_data}  = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})) \Min {}\\{}
 \Mlet  \;\tsunknown{partial\_data\_ok}   = (\tscon{MSG\_WAITALL} \;\notin  \;\tsvar{opts} \Mvee  \tsvar{n} > \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\neg{}(\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge  \tscon{MSG\_PEEK} \;\in  \;\tsvar{opts})) \Min {}\\{}
 (\tsunknown{have\_all\_data} \Mvee  (\tsunknown{have\_enough\_data} \Mwedge  \tsunknown{partial\_data\_ok}) \Mvee  \tsvar{cantrcvmore}) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ FIXME the reason this spec3 rule is correct is quite subtle. Essentially by cases on
     relative ordering of $\tsvar{n}$, $\tsholop{LENGTH} \;\tsvar{rcvq}$, $\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})$ in original spec1 rule. }{}\\{}
 {}\\{}
 \tsvar{str} = \tsvar{rcvq} \Mwedge {}\\{}
 {}\\{}
 \tsvar{peek} = (\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts}) \Mwedge {}\\{}
 \tsvar{inline} = \Mtrue  \Mwedge {}\\{}
 \tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsvar{peek} \;\tsvar{inline} (\tsvar{flgs},\tsvar{rcvq}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
 \tsholop{LENGTH} \;\tsvar{rcvq} \leq  \tsvar{n} }
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made where
    out-of-band data is not requested. $\tsvar{fd}$ refers to a synchronised TCP socket $\tsvar{sid}$ with
    binding quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ and no pending error. Alternatively the
    socket is uninitialised and in state $\tscon{CLOSED}$.

    The call can return immediately because either: (1) there are at least $\tsvar{n}$ bytes of data in
    the socket's receive queue (the $\tsunknown{have\_all\_data}$ case above); (2) the length of the socket's
    receive queue is greater than or equal to the minimum number of bytes for socket $\tsunknown{recv}()$
    operations, $\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})$, and the call does not have to return all $\tsvar{n}$ bytes of data;
    either because (i) the $\tscon{MSG\_WAITALL}$ flag is not set in $\tsvar{opts}_{0}$, (ii) the number of bytes requested
    is greater than the number of bytes in the socket's receive queue, or (iii) on non-FreeBSD
    architectures the $\tscon{MSG\_PEEK}$ flag is set in $\tsvar{opts}_{0}$ (the $\tsunknown{have\_enough\_data} \Mwedge
\tsunknown{partial\_data\_ok}$ case above); (3) there is urgent data available in the socket's receive queue
    (the $\tsunknown{urgent\_data\_ahead}$ case above); or (4) the socket has been shutdown for reading.

    The call succeeds, returning a string, $\tsholop{IMPLODE} \;\tsvar{str}$, which is either: (5) the smaller of the first
    $\tsvar{n}$ bytes of the socket's receive queue or its entire receive queue, if the urgent pointer is
    not set or the socket is at the urgent mark; or (6) the smaller of the first $\tsvar{n}$ bytes of the
    the socket's receive queue, the data in its receive queue up to the urgent mark, and its entire
    receive queue, if the urgent mark is set and the socket is not at the urgent mark.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made leaving the thread state $\tscon{Ret}
(\tscon{OK}(\tsholop{IMPLODE} \;\tsvar{str},*))$. If the $\tscon{MSG\_PEEK}$ flag was set in $\tsvar{opts}_{0}$ then the socket's
    receive queue remains unchanged; otherwise, the data $\tsvar{str}$ is removed from the head of the
    socket's receive queue, $\tsvar{rcvq}$, to leave the socket with new receive queue $\tsvar{rcvq}'$. If the
    receive urgent pointer was not set or was set to $\Msome  \;0$ then it will be set to $*$; if it
    was set to $\Msome  \;\tsunknown{om}$ and  $\tsunknown{om}$ is less than the length of the returned string then it will be
    set to $\Msome  \;0$ (because the returned string was the data in the receive queue up to the
    urgent mark); otherwise it will be set to $\Msome (\tsunknown{om}-\tsholop{LENGTH} \;\tsvar{str})$.

\rulesubsection{Model details}

    The amount of data requested, $\tsvar{n}_{0}$, is clipped to a natural number from an integer, using
    $\tsunknown{clip\_int\_to\_num}$. POSIX specifies an unsigned type for $\tsvar{n}_{0}$ and this is one possible model
    thereof.

    The $\tsvar{opts}_{0}$ argument to $\tsunknown{recv}()$ is of type $\tsunknown{msgbflag} \;\tstype{list}$, but it is converted to a set,
    $\tsvar{opts}$, using $\tsholop{LIST\_TO\_SET}$.

    The data itself is represented as a $\tstype{byte} \;\tstype{list}$ in the datagram but is returned a $\tstype{string}$:
    the $\tsholop{IMPLODE}$ function is used to do the conversion.

\rrulepad }
}

\newcommand{\recvTII}{\rrulecc{recvTII}{recv\_2}{tcp: block}{\tsholcomm{ Block, entering state $\tscon{Recv2}$ as not enough data is available }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})}{\tsunknown{never\_timer}}} \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s}')],\tsvar{M})}
{\tsvar{n} = \tsunknown{clip\_int\_to\_num} \;\tsvar{n}_{0} \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{socks}}{\tsvar{sid}} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsunknown{rcvq\_})) \Mwedge {}\\{}
 \tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}\} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ We block if not enough (see \ltslink{recvTI}{$\tsunknown{recv\_1}$}) data is available and there is no pending error. }{}\\{}
 \Mlet  \;\tsunknown{blocking}          = \neg{}(\tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts} \Mvee  \tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK})) \Min {}\\{}
 \Mlet  \;\tsunknown{have\_all\_data}     = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{n}) \Min  {}\\{}
 \Mlet  \;\tsunknown{have\_enough\_data}  = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})) \Min {}\\{}
 \Mlet  \;\tsunknown{partial\_data\_ok}   = (\tscon{MSG\_WAITALL} \;\notin  \;\tsvar{opts} \Mvee  \tsvar{n} > \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\neg{}(\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge  \tscon{MSG\_PEEK} \;\in  \;\tsvar{opts})) \Min {}\\{}
 \tsunknown{blocking} \Mwedge {}\\{}
 \neg{}(\tsunknown{have\_all\_data} \Mvee  (\tsunknown{have\_enough\_data} \Mwedge  \tsunknown{partial\_data\_ok}) \Mvee  \tsvar{cantrcvmore}) \Mwedge {}\\{}
 \tsvar{es} = *   \Mwedge {}\\{}
 {}\\{}
 \tsvar{peek} = \Mtrue  \Mwedge {}\\{}
 \tsvar{inline} = \Mtrue  \Mwedge {}\\{}
 \tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsvar{peek} \;\tsvar{inline} (\tsvar{flgs},\tsvar{rcvq}) \tsvar{s} \;\tsvar{s}'}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made where
    out-of-band data is not requested. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$ in state
    $\tscon{ESTABLISHED}$, $\tscon{SYN\_SENT}$, $\tscon{SYN\_RECEIVED}$, $\tscon{FIN\_WAIT\_1}$, or $\tscon{FIN\_WAIT\_2}$, with binding
    quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ and no pending error. The call is blocking: the
    $\tscon{MSG\_DONTWAIT}$ flag is not set in $\tsvar{opts}_{0}$ and the socket's $\tscon{O\_NONBLOCK}$ flag is not set.

    The call cannot return immediately because: (1) there are less than $\tsvar{n}$ bytes of data in the
    socket's receive queue; (2) there are less than $\tsvar{sf}.\tsvar{n}(\tsunknown{SO\_RVCLOWAT})$ (the minimum number of
    bytes for socket $\tsunknown{recv}()$ operations) bytes of data in the socket's receive queue or the call
    must return all $\tsvar{n}$ bytes of data: (i) the $\tscon{MSG\_WAITALL}$ flag is set in $\tsvar{opts}_{0}$, (ii) the
    number of bytes requested is greater than the length of the socket's receive queue, and (iii)
    the $\tscon{MSG\_PEEK}$ flag is not set in $\tsvar{opts}_{0}$; (3) there is no urgent data ahead in the socket's
    receive queue; and (4) the socket is not shutdown for reading.

    The call blocks in state $\tscon{Recv2}$ waiting for data; a $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$
    transition is made, leaving the thread state $\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})$.

\rulesubsection{Model details}

    The amount of data requested, $\tsvar{n}_{0}$, is clipped to a natural number from an integer, using
    $\tsunknown{clip\_int\_to\_num}$. POSIX specifies an unsigned type for $\tsvar{n}_{0}$, whereas the model uses $\tstype{int}$.

    The $\tsvar{opts}_{0}$ argument to $\tsunknown{recv}()$ is of type $\tsunknown{msgbflag} \;\tstype{list}$, but it is converted to a set,
    $\tsvar{opts}$, using $\tsholop{LIST\_TO\_SET}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    In case (iii) above, the $\tscon{MSG\_PEEK}$ flag may be set in $\tsvar{opts}_{0}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTIII}{\rrulecc{recvTIII}{recv\_3}{tcp: slow nonurgent succeed}{\tsholcomm{ Blocked call returns from $\tscon{Recv2}$ state }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsunknown{rcvq\_})))] \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsholop{IMPLODE} \;\tsvar{str}, *))}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq}',\tsunknown{rcvq\_'})))] \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s}')],\tsvar{M})}
{((\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}; \tscon{CLOSING};{}\\{}
\quad\quad\quad\quad \tscon{TIME\_WAIT}; \tscon{CLOSE\_WAIT}; \tscon{LAST\_ACK}\} \Mwedge  {}\\{}
\quad \tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge  \tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}) \Mvee {}\\{}
 \tsvar{st} = \tscon{CLOSED}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ We return at last if we now have enough (see \ltslink{recvTI}{$\tsunknown{recv\_1}$}) data available.  Pending errors are not checked. }{}\\{}
 \Mlet  \;\tsunknown{have\_all\_data}     = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{n}) \Min  {}\\{}
 \Mlet  \;\tsunknown{have\_enough\_data}  = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})) \Min {}\\{}
 \Mlet  \;\tsunknown{partial\_data\_ok}   = (\tscon{MSG\_WAITALL} \;\notin  \;\tsvar{opts} \Mvee  \tsvar{n} > \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\neg{}(\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge  \tscon{MSG\_PEEK} \;\in  \;\tsvar{opts})) \Min {}\\{}
 (\tsunknown{have\_all\_data} \Mvee  (\tsunknown{have\_enough\_data} \Mwedge  \tsunknown{partial\_data\_ok}) \Mvee  \tsvar{cantrcvmore}) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 \tsvar{str} = (\tsvar{rcvq}:\tsunknown{char} \;\tstype{list}) \Mwedge {}\\{}
 {}\\{}
 \tsvar{peek} = (\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts}) \Mwedge {}\\{}
 \tsvar{inline} = \Mtrue  \Mwedge {}\\{}
 \tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsvar{peek} \;\tsvar{inline} (\tsvar{flgs},\tsvar{rcvq}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
 \tsholop{LENGTH} \;\tsvar{rcvq} \leq  \tsvar{n}}
{\rulesubsection{Description}

    Thread $\tsvar{tid}$ is in the $\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})$ state after a previous $\tsunknown{recv}()$ call
    blocked. $\tsvar{sid}$ refers either to a synchronised TCP socket with binding quad $(\Msome  \;\tsvar{i}_{1},\Msome
\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$; or to a TCP socket in state $\tscon{CLOSED}$.

    Sufficient data is not available on the socket for the call to return: either (1) there is at
    least $\tsvar{n}$ bytes of data in the socket's receive queue (the $\tsunknown{have\_all\_data}$ case above); (2)
    the length of the socket's receive queue is greater than or equal to the minimum number of bytes
    for socket $\tsunknown{recv}()$ operations, $\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})$, and the call does not have to return
    all $\tsvar{n}$ bytes of data (the $\tsunknown{partial\_data\_ok}$ case): either (i) the $\tscon{MSG\_WAITALL}$ flag is
    not set in $\tsvar{opts}$, (ii) the number of bytes requested is greater than the number of bytes in
    the socket's receive queue, or (iii) on non-FreeBSD architectures the $\tscon{MSG\_PEEK}$ flag is set
    in $\tsvar{opts}$ (the $\tsunknown{have\_enough\_data} \Mwedge  \tsunknown{partial\_data\_ok}$ case above); (3) there is urgent data
    available in the socket's receive queue (the $\tsunknown{urgent\_data\_ahead}$ cae above); or (4) the socket
    has been shutdown for reading.

    The data returned, $\tsvar{str}$, is either: (1) the smaller of the first $\tsvar{n}$ bytes of the socket's
    receive queue or its entire receive queue, if the urgent pointer is not set or the socket is at
    the urgent mark; or (2) the smaller of the first $\tsvar{n}$ bytes of the the socket's receive queue,
    the data in its receive queue up to the urgent mark, and its entire receive queue, if the urgent
    mark is set and the socket is not at the urgent mark.

    A $\MLhtau $ transition is made leaving the thread state $\tscon{Ret} (\tscon{OK}(\tsholop{IMPLODE} \;\tsvar{str},*))$. If
    the $\tscon{MSG\_PEEK}$ flag was set in $\tsvar{opts}$ then the socket's receive queue remains unchanged;
    otherwise, the data $\tsvar{str}$ is removed from the head of the socket's receive queue, $\tsvar{rcvq}$, to
    leave the socket with new receive queue $\tsvar{rcvq}'$. If the receive urgent pointer was not set or was
    set to $\Msome  \;0$ then it will be set to $*$; if it was set to $\Msome  \;\tsunknown{om}$ and $\tsunknown{om}$ is
    less than the length of the returned string then it will be set to $\Msome  \;0$ (because the
    returned string was the data in the receive queue up to the urgent mark); otherwise it will be
    set to $\Msome (\tsunknown{om}-\tsholop{LENGTH} \;\tsvar{str})$.

\rulesubsection{Model details}

    The data itself is represented as a $\tstype{byte} \;\tstype{list}$ in the datagram but is returned a $\tstype{string}$:
    the $\tsholop{IMPLODE}$ function is used to do the conversion.

\rrulepad }
}

\newcommand{\recvTIV}{\rrulecc{recvTIV}{recv\_4}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EAGAIN}$: non-blocking call would block waiting for data }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EAGAIN}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s}')],\tsvar{M})}
{\tsvar{n} = \tsunknown{clip\_int\_to\_num} \;\tsvar{n}_{0} \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{socks}}{\tsvar{sid}} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsunknown{rcvq\_})) \Mwedge {}\\{}
 \tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}\} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ We fail if we would otherwise block (see \ltslink{recvTII}{$\tsunknown{recv\_2}$}; these conditions are identical). }{}\\{}
 \Mlet  \;\tsunknown{blocking}          = \neg{}(\tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts} \Mvee  \tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK})) \Min {}\\{}
 \Mlet  \;\tsunknown{have\_all\_data}     = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{n}) \Min  {}\\{}
 \Mlet  \;\tsunknown{have\_enough\_data}  = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})) \Min {}\\{}
 \Mlet  \;\tsunknown{partial\_data\_ok}   = (\tscon{MSG\_WAITALL} \;\notin  \;\tsvar{opts} \Mvee  \tsvar{n} > \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\neg{}(\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge  \tscon{MSG\_PEEK} \;\in  \;\tsvar{opts})) \Min {}\\{}
 \neg{}\tsunknown{blocking} \Mwedge {}\\{}
 \neg{}(\tsunknown{have\_all\_data} \Mvee  (\tsunknown{have\_enough\_data} \Mwedge  \tsunknown{partial\_data\_ok}) \Mvee  \tsvar{cantrcvmore}) \Mwedge {}\\{}
 (\tsvar{rcvq} = [\,] \implies  \tsvar{es} = *) \Mwedge  {}\\{}
 {}\\{}
 {}\\{}
 \tsvar{peek} = \Mtrue  \Mwedge {}\\{}
 \tsvar{inline} = \Mtrue  \Mwedge {}\\{}
 \tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsvar{peek} \;\tsvar{inline} (\tsvar{flgs},\tsvar{rcvq}) \tsvar{s} \;\tsvar{s}'}
{\rulesubsection{Description}

    From thead $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made where
    out-of-band data is not requested. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$ with binding quad
    $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ and no pending error, which is in state $\tscon{ESTABLISHED}$,
    $\tscon{SYN\_SENT}$, $\tscon{SYN\_RECEIVED}$, $\tscon{FIN\_WAIT\_1}$, or $\tscon{FIN\_WAIT\_2}$. The $\tsunknown{recv}()$ call is
    non-blocking: either the $\tscon{MSG\_DONTWAIT}$ flag was set in $\tsvar{opts}_{0}$ or the socket's
    $\tscon{O\_NONBLOCK}$ flag is set.

    The call would block because: (1) there are less than $\tsvar{n}$ bytes of data in the socket's
    receive queue; (2) there are less than $\tsvar{sf}.\tsvar{n}(\tsunknown{SO\_RVCLOWAT})$ (the minimum number of bytes for
    socket $\tsunknown{recv}()$ operations) bytes of data in the socket's receive queue or the call must
    return all $\tsvar{n}$ bytes of data: (i) the $\tscon{MSG\_WAITALL}$ flag is set in $\tsvar{opts}_{0}$, (ii) the
    number of bytes requested is greater than the length of the socket's receive queue, and (iii)
    the $\tscon{MSG\_PEEK}$ flag is not set in $\tsvar{opts}_{0}$; (3) there is no urgent data ahead in the socket's
    receive queue; (4) the socket is not shutdown for reading; and (5) if the socket's receive queue
    is empty then it has no pending error.

    The call fails with an $\tsunknown{EAGAIN}$ error. A $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is
    made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EAGAIN}})$.


\rulesubsection{Model details}

    The amount of data requested, $\tsvar{n}_{0}$, is clipped to a natural number from an integer, using
    $\tsunknown{clip\_int\_to\_num}$. POSIX specifies an unsigned type for $\tsvar{n}_{0}$ and this is one possible model
    thereof.

    The $\tsvar{opts}_{0}$ argument to $\tsunknown{recv}()$ is of type $\tsunknown{msgbflag} \;\tstype{list}$, but it is converted to a set,
    $\tsvar{opts}$, using $\tsholop{LIST\_TO\_SET}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    In case (iii) above, the $\tscon{MSG\_PEEK}$ flag may be set in $\tsvar{opts}_{0}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTVII}{\rrulecc{recvTVII}{recv\_7}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{ENOTCONN}$: socket not connected }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOTCONN}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = \tsvar{sock}.\tsvar{pr} \Mwedge {}\\{}
 (\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{LISTEN} \Mvee  {}\\{}
 (\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSED} \Mwedge  \tsvar{sock}.\tsvar{cantrcvmore}=\Mfalse ){}\\{}
   {}\\{}
 {}\\{}
 )}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made. $\tsvar{fd}$
    refers to a TCP socket $\tsvar{sock}$ identified by $\tsvar{sid}$ which is either in the $\tscon{LISTEN}$ state or
    is not shutdown for reading in the $\tscon{CLOSED}$ state. The call fails with an $\tsunknown{ENOTCONN}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsunknown{ENOTCONN}})$.

\rrulepad }
}

\newcommand{\recvTVIII}{\rrulecc{recvTVIII}{recv\_8}{tcp: fast fail}{\tsholcomm{ Fail with pending error }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\Msome  \;\tsvar{e},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{TCP\_PROTO}(\tsunknown{tcp\_sock})))] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{TCP\_PROTO}(\tsunknown{tcp\_sock})))] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 \tsvar{n} = \tsunknown{clip\_int\_to\_num} \;\tsvar{n}_{0} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 ((\tsunknown{tcp\_sock}.\tsvar{st} \;\notin  \{\tscon{CLOSED}; \tscon{LISTEN}\} \Mwedge  \tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}) \Mvee {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSED}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ We fail immediately if there is a pending error and we could not otherwise return data (see \ltslink{recvTI}{$\tsunknown{recv\_1}$}). }{}\\{}
 \Mlet  \;\tsvar{rcvq} = ([\,]: \tsunknown{char} \;\tstype{list}) \Min {}\\{}
 \Mlet  \;\tsunknown{blocking}          = \neg{}(\tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts} \Mvee  \tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK})) \Min {}\\{}
 \Mlet  \;\tsunknown{have\_all\_data}     = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{n}) \Min  {}\\{}
 \Mlet  \;\tsunknown{have\_enough\_data}  = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})) \Min {}\\{}
 \Mlet  \;\tsunknown{partial\_data\_ok}   = (\tscon{MSG\_WAITALL} \;\notin  \;\tsvar{opts} \Mvee  \tsvar{n} > \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\neg{}(\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge  \tscon{MSG\_PEEK} \;\in  \;\tsvar{opts})) \Min {}\\{}
 \neg{}(\tsunknown{have\_all\_data} \Mvee  (\tsunknown{have\_enough\_data} \Mwedge  \tsunknown{partial\_data\_ok})) \Mwedge {}\\{}
 (\tsunknown{blocking} \Mvee  \tsvar{rcvq} = [\,]) \Mwedge  {}\\{}
 {}\\{}
 \tsvar{es} = \Mif  \;\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \;\Mthen  \;\Msome  \;\tsvar{e} \;\Melse  \;*}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made. $\tsvar{fd}$
    refers to a TCP socket that either is in state $\tscon{CLOSED}$ or is in state other than $\tscon{CLOSED}$
    or $\tscon{LISTEN}$ with peer address set to $(\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$. The socket has a pending error
    $\tsvar{e}$.

    The call cannot immediately return data because: (1) there are less than $\tsvar{n}$ bytes of data in
    the socket's receive queue; (2) there are less than $\tsvar{sf}.\tsvar{n}(\tsunknown{SO\_RVCLOWAT})$ (the minimum number of
    bytes for socket $\tsunknown{recv}()$ operations) bytes of data in the socket's receive queue or the call
    must return all $\tsvar{n}$ bytes of data: (i) the $\tscon{MSG\_WAITALL}$ flag is set in $\tsvar{opts}_{0}$, (ii) the
    number of bytes requested is greater than the length of the socket's receive queue, and (iii)
    the $\tscon{MSG\_PEEK}$ flag is not set in $\tsvar{opts}_{0}$; (3) there is no urgent data ahead in the socket's
    receive queue; and (4) either the call is a blocking
    one: the $\tscon{MSG\_DONTWAIT}$ flag is set in $\tsvar{opts}_{0}$ or the socket's $\tscon{O\_NONBLOCK}$ flag is set,
    or the socket's receive queue is empty.

    The call fails, returning the pending error. A $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is
    made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$. If the $\tscon{MSG\_PEEK}$ flag was set in
    $\tsvar{opts}_{0}$ then the socket's pending error remains, otherwise it is cleared.

\rulesubsection{Model details}

    The $\tsvar{opts}_{0}$ argument to $\tsunknown{recv}()$ is of type $\tsunknown{msgbflag} \;\tstype{list}$, but it is converted to a
    set, $\tsvar{opts}$, using $\tsholop{LIST\_TO\_SET}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    In case (iii) above, the $\tscon{MSG\_PEEK}$ flag may be set in $\tsvar{opts}_{0}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTVIIIa}{\rrulecc{recvTVIIIa}{recv\_8a}{tcp: slow urgent fail}{\tsholcomm{ Fail with pending error from blocked state }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid}, \tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsvar{e}; \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid}, \tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{rcvq} = ([\,]:\tsunknown{char} \;\tstype{list}) \Mwedge  \tsholcomm{ always possible with stream spec FIXME invariant require $\tscon{SO\_RCVLOWAT}$ > 0, unless want to sync with stream }{}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ We fail now if there is a pending error and we could not otherwise return data (see \ltslink{recvTI}{$\tsunknown{recv\_1}$}). }{}\\{}
 \Mlet  \;\tsunknown{have\_all\_data}     = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{n}) \Min  {}\\{}
 \Mlet  \;\tsunknown{have\_enough\_data}  = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{sock}.\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})) \Min {}\\{}
 \Mlet  \;\tsunknown{partial\_data\_ok}   = (\tscon{MSG\_WAITALL} \;\notin  \;\tsvar{opts} \Mvee  \tsvar{n} > \tsvar{sock}.\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\neg{}(\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge  \tscon{MSG\_PEEK} \;\in  \;\tsvar{opts})) \Min {}\\{}
 \neg{}(\tsunknown{have\_all\_data} \Mvee  (\tsunknown{have\_enough\_data} \Mwedge  \tsunknown{partial\_data\_ok})) \Mwedge {}\\{}
 {}\\{}
 (\tsvar{es} = \Mif  \;\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \;\Mthen  \;\Msome  \;\tsvar{e} \;\Melse  \;*)}
{\rulesubsection{Description}

    Thread $\tsvar{tid}$ is blocked in state $\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})$ where $\tsvar{sid}$ identifies a socket with
    pending error $\Msome  \;\tsvar{e}$. The call fails, returning the pending error. Data cannot be returned
    because: (1) there are less than $\tsvar{n}$ bytes of data in the socket's receive queue; (2) there
    are less than $\tsvar{sf}.\tsvar{n}(\tsunknown{SO\_RVCLOWAT})$ (the minimum number of bytes for socket $\tsunknown{recv}()$
    operations) bytes of data in the socket's receive queue or the call must return all $\tsvar{n}$ bytes
    of data: (i) the $\tscon{MSG\_WAITALL}$ flag is set in $\tsvar{opts}$, (ii) the number of bytes requested is
    greater than the length of the socket's receive queue, and (iii) the $\tscon{MSG\_PEEK}$ flag is not
    set in $\tsvar{opts}$; and (3) there is no urgent data ahead in the socket's receive queue.

    The thread returns from the blocked state, returning the pending error. A $\MLhtau $ transition
    is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$. If the $\tscon{MSG\_PEEK}$ flag was set in
    $\tsvar{opts}$ then the socket's pending error remains, otherwise it is cleared.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    In case (iii) above, the $\tscon{MSG\_PEEK}$ flag may be set in $\tsvar{opts}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTIX}{\rrulecc{recvTIX}{recv\_9}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{ESHUTDOWN}$: socket shut down for reading on WinXP }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantrcvmore} \Mass  \Mtrue ; \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ESHUTDOWN}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantrcvmore} \Mass  \Mtrue ; \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff})}
{\rulesubsection{Description}

     On WinXP, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts})$ call is
     made where $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$ which is shut down for reading. The call fails
     with an $\tsunknown{ESHUTDOWN}$ error.

     A $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsunknown{ESHUTDOWN}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
     This rule does not apply.

\\\hline
Linux
&
     This rule does not apply.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommudpTrecv}{\clustersection{(UDP only)}{$\tsunknown{recv}()$}
\seccomm{ \[ \tsunknown{recv}: (\tsunknown{fd} * \tstype{int} * \tsunknown{msgbflag} \;\tstype{list}) \Mtotype  (\tstype{string} * ((\tsunknown{ip} * \tsunknown{port}) * \tstype{bool}) \;\tstype{option}) \]

  A call to $\tsunknown{recv}(\tsunknown{fd},\tsunknown{n},\tsunknown{opts})$ returns data from the datagram on the head of a socket's receive
  queue.
   This section describes
  the behaviour for UDP sockets.
  Here the $\tsunknown{fd}$ argument is a file descriptor referring to the socket to receive data from,   $\tsunknown{n}$ specifies the number of
  bytes of data to read from that socket, and the $\tsunknown{opts}$ argument is a list of flags for the $\tsunknown{recv}()$ call.  The possible flags are:

  \begin{itemize}

    \item $\tscon{MSG\_DONTWAIT}$: non-blocking behaviour is requested for this call. This flag only has
     effect on Linux. FreeBSD and WinXP ignore it. See rules $\tsunknown{recv\_12}$ and $\tsunknown{recv\_13}$.

    \item $\tscon{MSG\_PEEK}$: return data from the datagram on the head of the receive queue, without
     removing that datagram from the receive queue.

    \item $\tscon{MSG\_WAITALL}$: do not return until all $\tsunknown{n}$ bytes of data have been read. Linux and
     FreeBSD ignore this flag. WinXP fails with $\tsunknown{EOPNOTSUPP}$ as this is not meaningful for UDP
     sockets: the returned data is from only one datagram.

    \item $\tscon{MSG\_OOB}$: return out-of-band data. This flag is ignored on Linux. On WinXP and FreeBSD
     the call fails with $\tsunknown{EOPNOTSUPP}$ as out-of-band data is not meaningful for UDP sockets.

  \end{itemize}

  The returned value of the $\tsunknown{recv}()$ call, $(\tstype{string} * ((\tsunknown{ip} * \tsunknown{port}) * \tstype{bool}) \;\tstype{option})$, consists of
  the data read from the socket (the $\tstype{string}$), the source address of the data (the $\tsunknown{ip} *
\tsunknown{port}$), and a flag specifying whether or not all of the datagram's data was read (the
  $\tstype{bool}$). The latter two components are wrapped in an $\;\tstype{option}$ type (for type compatibility with the TCP $\tsunknown{recv}()$) but are always returned for UDP. The
  flag only has meaning on WinXP and should be ignored on FreeBSD and Linux.

  For a socket to receive data, it must be bound to a local port. On Linux and FreeBSD, if the
  socket is not bound to a local port, then it is autobound to an ephemeral port when the $\tsunknown{recv}()$
  call is made. On WinXP, calling $\tsunknown{recv}()$ on a socket that is not bound to a local port is an
  $\tsunknown{EINVAL}$ error.

  If a non-blocking $\tsunknown{recv}()$ call is made (the socket's $\tscon{O\_NONBLOCK}$ flag is set) and there are
  no datagrams on the socket's receive queue, then the call will fail with $\tsunknown{EAGAIN}$. If the call
  is a blocking one and the socket's receive queue is empty then the call will block, returning when
  a datagram arrives or an error occurs.

  If the socket has a pending error then on FreeBSD and Linux, the call will fail with that
  error. On WinXP, errors from ICMP messages are placed on the socket's receive queue, and so the
  error will only be returned when that message is at the head of the receive queue.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{recv}()$ can fail with the errors below, in which case the corresponding exception is
  raised.

\par\begin{ltstabular}
$\tsunknown{EAGAIN}$
&  The call would block and non-blocking behaviour is requested. This is done
   either via the $\tscon{MSG\_DONTWAIT}$ flag being set in the $\tsunknown{recv}()$ flags or the socket's
   $\tscon{O\_NONBLOCK}$ flag being set.

\\\hline
$\tsunknown{EMSGSIZE}$
&  The amount of data requested in the $\tsunknown{recv}()$ call on WinXP is less than the
   amount of data in the datagram on the head of the receive queue.

\\\hline
$\tsunknown{EOPNOTSUPP}$
&  Operation not supported: out-of-band data is requested on FreeBSD and WinXP,
   or the $\tscon{MSG\_WAITALL}$ flag is set on a $\tsunknown{recv}()$ call on WinXP.

\\\hline
$\tsunknown{ESHUTDOWN}$
&  On WinXP, a $\tsunknown{recv}()$ call is made on a socket that has been shutdown for
   reading.

\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\\\hline
$\tsunknown{EINTR}$
&  The system was interrupted by a caught signal.

\\\hline
$\tsunknown{ENOBUFS}$
&  Out of resources.

\\\hline
$\tsunknown{ENOMEM}$
&  Out of resources.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
   \

  A UDP socket is created and bound to a local address. Other calls are made and datagrams are
  delivered to the socket; $\tsunknown{recv}()$ is called to read from a datagram: $\tsunknown{socket\_1}$; $\tsunknown{return\_1}$;
  $\tsunknown{bind\_1}$; $ \ldots $ $\tsunknown{recv\_11}$; $\tsunknown{return\_1}$;

  A UDP socket is created and bound to a local address. $\tsunknown{recv}()$ is called and blocks; a datagram
  arrives addressed to the socket's local address and is placed on its receive queue; the call
  returns: $\tsunknown{socket\_1}$; $\tsunknown{return\_1}$; $\tsunknown{bind\_1}$; $ \ldots $ $\tsunknown{recv\_12}$; $\tsunknown{deliver\_in\_99}$;
  $\tsunknown{deliver\_in\_udp\_1}$; $\tsunknown{recv\_15}$; $\tsunknown{return\_1}$;

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:   & \wasverb{ssize\textunderscore{}t recvfrom(int socket, void *restrict buffer, size\textunderscore{}t length,}\\
             & \wasverb{                  int flags, struct sockaddr *restrict address,}\\
             & \wasverb{                 socklen\textunderscore{}t *restrict address\textunderscore{}len);}\\
    FreeBSD: & \wasverb{ssize\textunderscore{}t recvfrom(int s, void *buf, size\textunderscore{}t len, int flags,} \\
             & \wasverb{                 struct sockaddr *from, socklen\textunderscore{}t *fromlen);} \\
    Linux:   & \wasverb{int  recvfrom(int  s, void *buf, size\textunderscore{}t len, int flags,} \\
             & \wasverb{              struct sockaddr *from, socklen\textunderscore{}t *fromlen);} \\
    WinXP:   & \wasverb{int recvfrom(SOCKET s, char* buf, int len, int flags,} \\
             & \wasverb{             struct sockaddr* from, int* fromlen);} \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to receive from, corresponding to
     the $\tsunknown{fd}$ argument of the model $\tsunknown{recv}()$.

    \item \wasverb{buffer} is a pointer to a buffer to place the received data in, which upon return
     contains the data received on the socket. This corresponds to the $\tstype{string}$ return value of
     the model $\tsunknown{recv}()$.


    \item \wasverb{length} is the amount of data to be read from the socket, corresponding to the $\tstype{int}$
     argument of the model $\tsunknown{recv}()$; it should be at most the length of \wasverb{buffer}.

    \item \wasverb{flags} is a disjunction of the message flags that are set for the call, corresponding to
     the $\tsunknown{msgbflag}$ $\tstype{list}$ argument of the model $\tsunknown{recv}()$.

    \item \wasverb{address} is a pointer to a \wasverb{sockaddr} structure of length
     \wasverb{address\textunderscore{}len}, which upon return contains the source address of the data received by
     the socket corresponding to the $(\tsunknown{ip} * \tsunknown{port})$ in the return value of the model
     $\tsunknown{recv}()$. For the \wasverb{AF\textunderscore{}INET} sockets used in the model, it is actually a
     \wasverb{sockaddr\textunderscore{}in} that is used: the \wasverb{in\textunderscore{}addr.s\textunderscore{}addr} field corresponds to the
     $\tsunknown{ip}$ and the \wasverb{sin\textunderscore{}port} field corresponds to the $\tsunknown{port}$.

    \item the returned \wasverb{ssize\textunderscore{}t} is either non-negative, in which case it is the the amount
     of data that was received by the socket, or it is \wasverb{-1} to indicate an error, in which
     case the error code is in \wasverb{errno}. On WinXP an error is indicated by a return value of
     \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error code available through a
     call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  On WinXP, if the data from a datagram is not all read then the call fails with $\tsunknown{EMSGSIZE}$,
  but still fills the \wasverb{buffer} with data. This is modelled by the $\tstype{bool}$ flag in the model
  $\tsunknown{recv}()$: if it is set to $\Mtrue $ then the call succeeded and read all of the datagrams's data; if
  it is set to $\Mfalse $ then the call failed with $\tsunknown{EMSGSIZE}$ but still returned data.

  There are other functions used to receive data on a socket. \wasverb{recv()} is similar to
  \wasverb{recvfrom()} except it does not have the \wasverb{address} and \wasverb{address\textunderscore{}len}
  arguments. It is used when the source address of the data does not need to be returned from the
  call. \wasverb{recvmsg()}, another input function, is a more general form of \wasverb{recvfrom()}.

}\clustersubsection{Model details}
\seccomm{
  If the call blocks then the thread enters state $\tscon{Recv2}(\tsunknown{sid},\tsunknown{n},\tsunknown{opts})$ where:

  \begin{itemize}

    \item $\tsunknown{sid} : \tsunknown{sid}$ is the identifier of the socket that the $\tsunknown{recv}()$ call was made on,

    \item $\tsunknown{n} : \tstype{num}$ is the number of bytes to be read, and

    \item $\tsunknown{opts} : \tsunknown{msgbflag} \;\tstype{list}$ is the set of message flags.

  \end{itemize}

  The following errors are not modelled:

  \begin{itemize}

    \item On FreeBSD, Linux, and WinXP, $\tsunknown{EFAULT}$ can be returned if the \wasverb{buffer}
    parameter points to memory not in a valid part of the process address space. This is an artefact
    of the C interface to \wasverb{ioctl()} that is excluded by the clean interface used in the
    model $\tsunknown{recv}()$.

    \item In Posix, \wasverb{EIO} may be returned to indicated that an I/O error occurred while
    reading from or writing to the file system; this is not modelled here.

    \item \wasverb{EINVAL} may be returned if the $\tscon{MSG\_OOB}$ flag is set and no out-of-band data is
    available; out-of-band data does not exist for UDP so this does not apply.

    \item \wasverb{ENOTCONN} may be returned if the socket is not connected; this does not apply for
    UDP as the socket need not have a peer specified to receive datagrams.

    \item \wasverb{ETIMEDOUT} can be returned due to a transmission timeout on a connection; UDP is
    not connection-oriented so this does not apply.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}

   The following Linx message flags are not modelled: \wasverb{MSG\textunderscore{}NOSIGNAL}, \wasverb{MSG\textunderscore{}TRUNC}, and
  \wasverb{MSG\textunderscore{}ERRQUEUE}.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{recv\_11}$
& \textbf{udp: fast succeed}
&  Receive data successfully without blocking \\
$\tsrule{recv\_12}$
& \textbf{udp: block}
&  Block, entering $\tscon{Recv2}$ state as no datagrams available on socket \\
$\tsrule{recv\_13}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{EAGAIN}$: call would block and socket is non-blocking or, on Linux, non-blocking behaviour has been requested with the $\tscon{MSG\_DONTWAIT}$ flag \\
$\tsrule{recv\_14}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{EAGAIN}$, $\tsunknown{EADDRNOTAVAIL}$, or $\tsunknown{ENOBUFS}$: there are no ephemeral ports left \\
$\tsrule{recv\_15}$
& \textbf{udp: slow urgent succeed}
&  Blocked call returns from $\tscon{Recv2}$ state with data \\
$\tsrule{recv\_16}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{EOPNOTSUPP}$: $\tscon{MSG\_WAITALL}$ flag not supported on WinXP, or $\tscon{MSG\_OOB}$ flag not supported on FreeBSD and WinXP \\
$\tsrule{recv\_17}$
& \textbf{udp: rc}
&  Socket shutdown for reading: fail with $\tsunknown{ESHUTDOWN}$ on WinXP or succeed on Linux and FreeBSD \\
$\tsrule{recv\_20}$
& \textbf{udp: rc}
&  Successful partial read of datagram on head of socket's receive queue on WinXP \\
$\tsrule{recv\_21}$
& \textbf{udp: fast succeed}
&  Read zero bytes of data from an empty receive queue on FreeBSD \\
$\tsrule{recv\_22}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{EINVAL}$ on WinXP: socket is unbound \\
$\tsrule{recv\_23}$
& \textbf{udp: rc}
&  Read ICMP error from receive queue and fail with that error on WinXP \\
$\tsrule{recv\_24}$
& \textbf{udp: fast fail}
&  Fail with pending error \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\recvTXI}{\rrulecc{recvTXI}{recv\_11}{udp: fast succeed}{\tsholcomm{ Receive data successfully without blocking }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{ \tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{OK}(\tsholop{IMPLODE} \;\tsvar{data}',\Msome ((\tsvar{i}_{3},\tsvar{ps}_{3}),\tsvar{b})))}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
\quad \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
\quad \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
\quad \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},*,\tsvar{cantsndmore},\tsvar{cantrcvmore},\tsaux{UDP\_Sock}(\tsvar{rcvq}')) \Mwedge {}\\{}
\quad (\neg{}(\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch}) \implies  \tsvar{cantrcvmore} = \Mfalse ) \Mwedge {}\\{}
\quad \tsvar{rcvq} = (\tscon{Dgram\_msg}(\Mmagiclrec  \tsunknown{is} \Mass  \tsvar{i}_{3}; \tsunknown{ps} \Mass  \tsvar{ps}_{3}; \tsvar{data} \Mass  \tsvar{data} \Mmagicrrec ))\Mcons \tsvar{rcvq}'' \Mwedge {}\\{}
\quad \tsvar{n} = \tsunknown{clip\_int\_to\_num} \;\tsvar{n}_{0} \Mwedge {}\\{}
\quad ((\tsholop{LENGTH} \;\tsvar{data} \leq  \tsvar{n} \Mwedge  \tsvar{data} = \tsvar{data}') \Mvee {}\\{}
\quad\quad (\tsholop{LENGTH} \;\tsvar{data} > \tsvar{n} \Mwedge  \tsvar{data}' = \tsunknown{TAKE} \;\tsvar{n} \;\tsvar{data} \Mwedge  \tsholop{LENGTH} \;\tsvar{data}' = \tsvar{n} \Mwedge  \neg{}(\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch}))) \Mwedge {}\\{}
\quad (\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \implies  \tsvar{b} = \Mtrue ) \Mwedge {}\\{}
\quad \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
\quad \tsvar{rcvq}' = (\Mif  \;\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \;\Mthen  \;\tsvar{rcvq} \;\Melse  \;\tsvar{rcvq}'')}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$. It is not shutdown for reading, has no
    pending errors, and is bound to local port $\tsvar{p}_{1}$. Thread $\tsvar{tid}$ is in the $\tscon{Run}$ state.

    The socket's receive queue has a datagram at its head with data $\tsvar{data}$ and source address
    $\tsvar{i}_{3},\tsvar{ps}_{3}$. A call $\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$, from thread $\tsvar{tid}$, succeeds.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made. The thread is left in state $\tscon{Ret}
(\tscon{OK}(\tsholop{IMPLODE} \;\tsvar{data}',\Msome (\tsvar{i}_{3},\tsvar{ps}_{3})))$, where $\tsvar{data}'$ is either:

    \begin{itemize}

      \item all of the data in the datagram, $\tsvar{data}$, if the amount of data requested $\tsvar{n}_{0}$ is
       greater than or equal to the amount of data in the datagram, or

      \item the first $\tsvar{n}_{0}$ bytes of $\tsvar{data}$ if $\tsvar{n}_{0}$ is less than the amount of data in the
       datagram, unless the architecture is WinXP (see below).

    \end{itemize}

    If the $\tscon{MSG\_PEEK}$ option is set in $\tsvar{opts}_{0}$ then the entire datagram stays on the receive
    queue; the next call to $\tsunknown{recv}()$ will be able to access this datagram. Otherwise, the entire
    datagram is discarded from the receive queue, even if all of its data has not been read.

\rulesubsection{Model details}

    The amount of data requested, $\tsvar{n}_{0}$, is clipped to a natural number from an integer, using
    $\tsunknown{clip\_int\_to\_num}$. POSIX specifies an unsigned type for $\tsvar{n}_{0}$ and this is one possible model
    thereof.

    The $\tsvar{opts}_{0}$ argument to $\tsunknown{recv}()$ is of type $\tsunknown{msgbflag} \;\tstype{list}$, but it is converted to a set,
    $\tsvar{opts}$, using $\tsholop{LIST\_TO\_SET}$.

    The data itself is represented as a $\tstype{byte} \;\tstype{list}$ in the datagram but is returned a $\tstype{string}$:
    the $\tsholop{IMPLODE}$ function is used to do the conversion.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    The amount of data in bytes requested, $\tsvar{n}_{0}$, must be greater than or equal to the number of
    bytes of data in the datagram on the head of the receive queue. The boolean $\tsvar{b}$ equals $\Mtrue $,
    indicating that all of the datagram's data has been read. Otherwise refer to rule $\tsunknown{recv\_20}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXII}{\rrulecc{recvTXII}{recv\_12}{udp: block}{\tsholcomm{ Block, entering $\tscon{Recv2}$ state as no datagrams available on socket }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})}{\tsunknown{never\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{h}_{0}.\tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}'_{1} \Mmagicrrec )];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec   \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},*,\tsvar{cantsndmore},\Mfalse ,\tsaux{UDP\_Sock}([\,])) \Mwedge {}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{sock}.\tsvar{ps}_{1},\tsunknown{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{sock}.\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound}) \Mwedge {}\\{}
 \neg{}((\tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts} \Mwedge  \tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch}) \Mvee  \tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK})) \Mwedge {}\\{}
 (\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \implies  \neg{}(\tsvar{n}=0)) \Mwedge {}\\{}
 \tsvar{n} = \tsunknown{clip\_int\_to\_num} \;\tsvar{n}_{0} \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0}}
{\rulesubsection{Description}

     Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, that has no pending errors, is not
     shutdown for reading, has an empty receive queue, and does not have its $\tscon{O\_NONBLOCK}$ flag
     set. The socket is either bound to a local port $\Msome  \;\tsvar{p}'_{1}$ or can be autobound to a local
     port $\Msome  \;\tsvar{p}'_{1}$. From thread $\tsvar{tid}$, which in the $\tscon{Run}$ state, a $\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call
     is made. Because there are no datagrams on the socket's receive queue, the call will block.

     A $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition will be made, leaving the thread state
     $\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})$. If autobinding occurred then $\tsvar{sid}$ will be placed on the head of the
     host's list of bound sockets: $\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound}$.

\rulesubsection{Model details}

     The amount of data requested, $\tsvar{n}_{0}$, is clipped to a natural number $\tsvar{n}$ from an integer, using
     $\tsunknown{clip\_int\_to\_num}$. POSIX specifies an unsigned type for $\tsvar{n}_{0}$ and this is one possible model
     thereof.

     The $\tsvar{opts}_{0}$ argument to $\tsunknown{recv}()$ is of type $\tsunknown{msgbflag} \;\tstype{list}$, but it is converted to a
     set, $\tsvar{opts}$, using $\tsholop{LIST\_TO\_SET}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
     As above, with the added condition that the number of bytes requested to be read is not zero.

\\\hline
Linux
&
     As above, with the added condition that the $\tscon{MSG\_DONTWAIT}$ flag is not set in $\tsvar{opts}_{0}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXIII}{\rrulecc{recvTXIII}{recv\_13}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EAGAIN}$: call would block and socket is non-blocking or, on Linux, non-blocking behaviour has been requested with the $\tscon{MSG\_DONTWAIT}$ flag }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EAGAIN}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{s} \; \Mmagiclrec  \tsvar{es} \Mass  *; \tsvar{pr} \Mass  \tsaux{UDP\_Sock}([\,]) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{s} \; \Mmagiclrec  \tsvar{es} \Mass  *; \tsvar{pr} \Mass  \tsaux{UDP\_Sock}([\,]) \Mmagicrrec )] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 ((\tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts} \Mwedge  \tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch}) \Mvee  \tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}))}
{\rulesubsection{Description}

     Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. It has no pending errors, and an empty
     receive queue. The socket is non-blocking: its $\tscon{O\_NONBLOCK}$ flag has been set. From thread
     $\tsvar{tid}$, in the $\tscon{Run}$ state, a $\tsunknown{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts}_{0})$ call is made. The call would block
     because the socket has an empty receive queue, so the call fails with an $\tsunknown{EAGAIN}$ error.

     A $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts}_{0})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsunknown{EAGAIN}})$.

\rulesubsection{Model details}

     The $\tsvar{opts}_{0}$ argument is of type $\tstype{list}$. In the model it is converted to a $\tstype{set}$ $\tsvar{opts}$
     using $\tsholop{LIST\_TO\_SET}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
     As above, but the rule also applies if the socket's $\tscon{O\_NONBLOCK}$ flag is not set but the
     $\tscon{MSG\_DONTWAIT}$ flag is set in $\tsvar{opts}_{0}$. Also, note that $\tscon{EWOULDBLOCK}$ and $\tsunknown{EAGAIN}$ are
     aliased on Linux.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXIV}{\rrulecc{recvTXIV}{recv\_14}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EAGAIN}$, $\tsunknown{EADDRNOTAVAIL}$, or $\tsunknown{ENOBUFS}$: there are no ephemeral ports left }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts})} }{1}}
{(\tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid}, \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,*,*,*,*,\tsvar{cantsndmore},\tsvar{cantrcvmore},\tsaux{UDP\_Sock}([\,])))] \Mmagicrrec  \Mwedge {}\\{}
 \tsaux{autobind}(*,\tsunknown{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) = \emptyset  \Mwedge {}\\{}
 \tsvar{e} \;\in  \{\tsunknown{EAGAIN}; \tsunknown{EADDRNOTAVAIL}; \tsunknown{ENOBUFS}\} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff})}
{\rulesubsection{Description}

     Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$. The socket has no pending errors, an empty
     receive queue, and binding quad $*,*,*,*$. From thread $\tsvar{tid}$, which is in the
     $\tscon{Run}$ state, a $\tsunknown{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts})$ call is made. There is no ephemeral port to autobind the
     socket to, so the call fails with either $\tsunknown{EAGAIN}$, $\tsunknown{EADDRNOTAVAIL}$ or $\tsunknown{ENOBUFS}$.

     A $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$ where e is one of the above errors.

\rrulepad }
}

\newcommand{\recvTXV}{\rrulecc{recvTXV}{recv\_15}{udp: slow urgent succeed}{\tsholcomm{ Blocked call returns from $\tscon{Recv2}$ state with data }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}_{1}; \tsvar{es} \Mass  *; \tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{OK}(\tsholop{IMPLODE} \;\tsvar{data}',\Msome  ((\tsvar{i}_{3},\tsvar{ps}_{3}),\tsvar{b})))}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid}, \tsvar{sock} \; \Mmagiclrec  \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}_{1}; \tsvar{es} \Mass  *; \tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}') \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{rcvq} = (\tscon{Dgram\_msg}(\Mmagiclrec  \tsunknown{is} \Mass  \tsvar{i}_{3}; \tsunknown{ps} \Mass  \tsvar{ps}_{3}; \tsvar{data} \Mass  \tsvar{data} \Mmagicrrec ))\Mcons \tsvar{rcvq}'' \Mwedge {}\\{}
 (\tsvar{rcvq}' = \Mif  \;\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \;\Mthen  \;\tsvar{rcvq} \;\Melse  \;\tsvar{rcvq}'') \Mwedge {}\\{}
 ((\tsholop{LENGTH} \;\tsvar{data} \leq  \tsvar{n} \Mwedge  \tsvar{data}=\tsvar{data}') \Mvee {}\\{}
\quad (\tsholop{LENGTH} \;\tsvar{data} > \tsvar{n} \Mwedge  \neg{}(\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge  \tsvar{data}' = \tsunknown{TAKE} \;\tsvar{n} \;\tsvar{data}' \Mwedge  \tsholop{LENGTH} \;\tsvar{data}' = \tsvar{n} )) \Mwedge {}\\{}
 (\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \implies  \tsvar{b}=\Mtrue )}
{\rulesubsection{Description}

     Consider a UDP socket $\tsvar{sid}$ with no pending errors and bound to local port $\tsvar{p}_{1}$. At the
     head of the socket's receive queue, $\tsvar{rcvq}$, is a UDP datagram with source address
     $(\tsvar{i}_{3},\tsvar{ps}_{3})$ and data $\tsvar{data}$. Thread $\tsvar{tid}$ is blocked in state $\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})$.

     The blocked call successfully returns $(\tsholop{IMPLODE} \;\tsvar{data}',\Msome ((\tsvar{i}_{3},\tsvar{ps}_{3},\tsvar{b})))$. If the number of
     bytes requested, $\tsvar{n}$, is greater than or equal to the number of bytes of data in the
     datagram, $\tsvar{data}$, then all of $\tsvar{data}$ is returned. If $\tsvar{n}$ is less than the number of bytes
     in the datagram, then the first $\tsvar{n}$ bytes of data are returned.

     A $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}(\tsholop{IMPLODE}
\tsvar{data}',\Msome ((\tsvar{i}_{3},\tsvar{ps}_{3}),\tsvar{b})))$. If the $\tscon{MSG\_PEEK}$ flag was set in $\tsvar{opts}$ then the datagram
     stays on the head of the socket's receive queue; otherwise, it is discarded from the receive
     queue.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
     As above, except the number of bytes of data requested $\tsvar{n}$, must be greater than or equal to
     the length in bytes of $\tsvar{data}$. The boolean $\tsvar{b}$ equals $\Mtrue $, indicating that all of the
     datagram's data was read.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXVI}{\rrulecc{recvTXVI}{recv\_16}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EOPNOTSUPP}$: $\tscon{MSG\_WAITALL}$ flag not supported on WinXP, or $\tscon{MSG\_OOB}$ flag not supported on FreeBSD and WinXP }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EOPNOTSUPP}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 (\tscon{MSG\_WAITALL} \;\in  \;\tsvar{opts} \Mwedge  \tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch})}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, in the $\tscon{Run}$ state, a
    $\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made. The $\tscon{MSG\_OOB}$ or $\tscon{MSG\_WAITALL}$ flags are set in
    $\tsvar{opts}_{0}$. The call fails with an $\tsunknown{EOPNOTSUPP}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EOPNOTSUPP}})$.

\rulesubsection{Model details}

    The $\tsvar{opts}_{0}$ argument is of type $\tstype{list}$. In the model it is converted to a $\tstype{set}$ $\tsvar{opts}$
    using $\tsholop{LIST\_TO\_SET}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    As above, except the rule only applies when $\tscon{MSG\_OOB}$ is set in $\tsvar{opts}_{0}$.

\\\hline
FreeBSD
&
    As above, except the rule only applies when $\tscon{MSG\_OOB}$ is set in $\tsvar{opts}_{0}$.

\\\hline
Linux
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXVII}{\rrulecc{recvTXVII}{recv\_17}{udp: rc}{\tsholcomm{ Socket shutdown for reading: fail with $\tsunknown{ESHUTDOWN}$ on WinXP or succeed on Linux and FreeBSD }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts}\Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantrcvmore} \Mass  \Mtrue ; \tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{ \tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tsvar{ret})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantrcvmore} \Mass  \Mtrue ; \tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mif       \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{ret} = \tscon{FAIL}\;{(\tsunknown{ESHUTDOWN})} \Mwedge  \tsvar{rc} = \tscon{fast} \;\tscon{fail}{}\\{}
 \Melse  \;\Mif  \;\tsunknown{bsd\_arch}     \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{ret} = \tscon{OK}(\text{``''},\Msome ((*,*),\tsvar{b})) \Mwedge  \tsvar{rc} = \tscon{fast} \;\tscon{succeed} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{es} = *{}\\{}
 \Melse  \;\Mif  \;\tsunknown{linux\_arch}   \;\tsvar{h}.\tsvar{arch} \;\Mthen {}\\{}
\quad \tsvar{rcvq} = [\,] \Mwedge  \tsvar{ret} = \tscon{OK}(\text{``''},\Msome ((*,*),\tsvar{b})) \Mwedge  \tsvar{rc} = \tscon{fast} \;\tscon{succeed} \Mwedge  \tsvar{sock}.\tsvar{es} = *{}\\{}
 \Melse  \;\tsunknown{ASSERTION\_FAILURE} \text{``recv\textunderscore{}17''} }
{\rulesubsection{Description}

   Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, that has been shutdown for reading. From
   thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made. On FreeBSD
   and Linux, if the socket has no pending error the call is successfully, returning
   $(\text{``''},\Msome ((*,*),\tsvar{b}))$; on WinXP the call fails with an $\tsunknown{ESHUTDOWN}$ error.

   A $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}(\text{``''},\Msome ((*,*),\tsvar{b})))$ on FreeBSD and Linux, or $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ESHUTDOWN}})$ on WinXP.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   As above: the call succeeds.

\\\hline
Linux
&
   As above: the call succeeds with the additional condition that the socket has an empty receive
   queue.

\\\hline
WinXP
&
   As above: the call fails with an $\tsunknown{ESHUTDOWN}$ error.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXX}{\rrulecc{recvTXX}{recv\_20}{udp: rc}{\tsholcomm{ Successful partial read of datagram on head of socket's receive queue on WinXP }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{t}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \tsvar{lbl} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK}(\tsholop{IMPLODE} \;\tsvar{data}',\Msome ((\tsvar{i}_{3},\tsvar{ps}_{3}),\Mfalse )))}{ \tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{rcvq} = (\tscon{Dgram\_msg}(\Mmagiclrec  \tsunknown{is} \Mass  \tsvar{i}_{3}; \tsunknown{ps} \Mass  \tsvar{ps}_{3}; \tsvar{data} \Mass  \tsvar{data} \Mmagicrrec ))\Mcons \tsvar{rcvq}'' \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},*,\tsvar{cantsndmore},\tsvar{cantrcvmore},\tsaux{UDP\_Sock}(\tsvar{rcvq}')) \Mwedge {}\\{}
 ((\exists \tsvar{fd} \;\tsvar{ff} \;\tsvar{n} \;\tsvar{n}_{0} \;\tsvar{opts}_{0}.{}\\{}
\quad\quad \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
\quad\quad \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
\quad\quad \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
\quad\quad (\tsvar{rcvq}' = \Mif  \;\tscon{MSG\_PEEK} \;\in  (\tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0}) \Mthen  \;\tsvar{rcvq} \;\Melse  \;\tsvar{rcvq}'') \Mwedge {}\\{}
\quad\quad \tsvar{n} = \tsunknown{clip\_int\_to\_num} \;\tsvar{n}_{0} \Mwedge {}\\{}
\quad\quad \tsvar{n} < \tsholop{LENGTH} \;\tsvar{data} \Mwedge {}\\{}
\quad\quad \tsvar{data}' = \tsunknown{TAKE} \;\tsvar{n} \;\tsvar{data} \Mwedge {}\\{}
\quad\quad \tsvar{t} = \tscon{Run} \Mwedge {}\\{}
\quad\quad \tsvar{rc} = \tscon{fast} \;\tscon{succeed} \Mwedge {}\\{}
\quad\quad \tsvar{lbl} = \MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}) \Mvee {}\\{}
 (\exists \tsvar{n} \;\tsvar{opts}.{}\\{}
\quad\quad \tsvar{lbl} = \MLhtau   \Mwedge {}\\{}
\quad\quad \tsvar{t} = \tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts}) \Mwedge {}\\{}
\quad\quad \tsvar{rc} = \tscon{slow} \;\tsunknown{urgent} \;\tscon{succeed} \Mwedge {}\\{}
\quad\quad \tsvar{data}' = \tsunknown{TAKE} \;\tsvar{n} \;\tsvar{data} \Mwedge {}\\{}
\quad\quad \tsvar{n} < \tsholop{LENGTH} \;\tsvar{data} \Mwedge {}\\{}
\quad\quad \tsvar{rcvq}' = \Mif  \;\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \;\Mthen  \;\tsvar{rcvq} \;\Melse  \;\tsvar{rcvq}''))}
{\rulesubsection{Description}

   On WinXP, consider a UDP socket $\tsvar{sid}$ bound to a local port $\tsvar{p}_{1}$ and with no pending
   errors. At the head of the socket's receive queue is a datagram with source address $\tsunknown{is} \Mass  \tsvar{i}_{3};
\tsunknown{ps} \Mass  \tsvar{ps}_{3}$ and data $\tsvar{data}$. This rule covers two cases:

   In the first, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is
   made where $\tsvar{fd}$ refers to the socket $\tsvar{sid}$. The amount of data to be read, $\tsvar{n}_{0}$ bytes, is
   less than the number of bytes of data in the datagram, $\tsvar{data}$. The call successfully returns
   the first $\tsvar{n}_{0}$ bytes of data from the datagram, $\tsvar{data}'$. A $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$
   transition is made leaving the thread state $\tscon{Ret} (\tscon{OK}(\tsholop{IMPLODE} \;\tsvar{data}',\Msome ((\tsvar{i}_{3},\tsvar{ps}_{3}),\Mfalse )))$ where
   the $\Mfalse $ indicates that not all of the datagram's data was read. The datagram is discarded from
   the socket's receive queue unless the $\tscon{MSG\_PEEK}$ flag was set in $\tsvar{opts}_{0}$, in which case the
   whole datagram remains on the socket's receive queue.

   In the second case, thread $\tsvar{tid}$ is blocked in state $\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})$ where the number of
   bytes to be read, $\tsvar{n}$, is less than the number of bytes of data in the datagram. There is now
   data to be read so a $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}(\tsholop{IMPLODE}
\tsvar{data}',\Msome ((\tsvar{i}_{3},\tsvar{ps}_{3}),\Mfalse )))$ where the $\Mfalse $ indicated that not all of the datagram's data was
   read. The datagram is discarded from the socket's receive queue unless the $\tscon{MSG\_PEEK}$ flag was
   set in $\tsvar{opts}$, in which case the whole datagram remains on the socket's receive queue.

\rulesubsection{Model details}

   The amount of data requested, $\tsvar{n}_{0}$, is clipped to a natural number from an integer, using
   $\tsunknown{clip\_int\_to\_num}$. POSIX specifies an unsigned type for $\tsvar{n}_{0}$ and this is one possible model
   thereof.

   The data itself is represented as a $\tstype{byte} \;\tstype{list}$ in the datagram but is returned a $\tstype{string}$,
   so the $\tsholop{IMPLODE}$ function is used to do the conversion.

   In the model the return value is $\tscon{OK}(\tsholop{IMPLODE} \;\tsvar{data}',\Msome ((\tsvar{i}_{3},\tsvar{p}_{3}),\Mfalse ))$ where the $\Mfalse $ represents
   not all the data in the datagram at the head of the socket's receive queue being read. What
   actually happens is that an $\tsunknown{EMSGSIZE}$ error is returned, and the data is put into the read
   buffer specified when the $\tsunknown{recv}()$ call was made.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
   This rule does not apply.

\\\hline
FreeBSD
&
   This rule does not apply.

\\\hline
Linux
&
   This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXXI}{\rrulecc{recvTXXI}{recv\_21}{udp: fast succeed}{\tsholcomm{ Read zero bytes of data from an empty receive queue on FreeBSD }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tsaux{UDP\_Sock}([\,]) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK}(\text{``''},\Msome ((*,*),\tsvar{b})))}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tsaux{UDP\_Sock}([\,]) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 0 = \tsunknown{clip\_int\_to\_num} \;\tsvar{n}_{0}}
{\rulesubsection{Description}

    On FreeBSD, consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, with an empty receive
    queue. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made
    where $\tsvar{n}_{0} = 0$. The call succeeds, returning the empty string and not specifying an address:
    $\tscon{OK}(\text{``''},\Msome ((*,*),\tsvar{b}))$.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made, leaving the thread  state
    $\tscon{Ret} (\tscon{OK}(\text{``''},\Msome ((*,*),\tsvar{b})))$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    This rule does not apply: see rules $\tsunknown{recv\_12}$ and $\tsunknown{recv\_13}$.

\\\hline
Linux
&
    This rule does not apply: see rules $\tsunknown{recv\_12}$ and $\tsunknown{recv\_13}$.

\\\hline
WinXP
&
    This rule does not apply: see rules $\tsunknown{recv\_12}$ and $\tsunknown{recv\_13}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXXII}{\rrulecc{recvTXXII}{recv\_22}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EINVAL}$ on WinXP: socket is unbound }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{ps}_{1} \Mass  *; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec  )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINVAL}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{ps}_{1} \Mass  *; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec  )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff})}
{\rulesubsection{Description}

    On WinXP, consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ that is not bound to a local
    port. A $\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0}$ call is made from thread $\tsvar{tid}$ which is in the $\tscon{Run}$ state. The
    call fails with an $\tsunknown{EINVAL}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made, leaving the thread state
    $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    This rule does not apply.

\\\hline
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXXIII}{\rrulecc{recvTXXIII}{recv\_23}{udp: rc}{\tsholcomm{ Read ICMP error from receive queue and fail with that error on WinXP }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{t}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \tsvar{lbl} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{ \tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}') \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{rcvq} = (\tscon{Dgram\_error}(\Mmagiclrec  \tsunknown{e} \Mass  \tsvar{err} \Mmagicrrec ))\Mcons \tsvar{rcvq}' \Mwedge {}\\{}
 ((\exists \tsvar{fd} \;\tsvar{n}_{0} \;\tsvar{opts}_{0} \;\tsvar{fid} \;\tsvar{ff}. \tsvar{t} = \tscon{Run} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{lbl} = \MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{rc} = \tscon{fast} \;\tscon{fail} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff})) \Mvee {}\\{}
 (\exists \tsvar{n} \;\tsvar{opts}. \tsvar{t} = \tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{lbl} = \MLhtau  \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{rc} = \tscon{slow} \;\tsunknown{urgent} \;\tscon{fail}))}
{\rulesubsection{Description}

    On WinXP, consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. At the head of the socket's
    receive queue, $\tsvar{rcvq}$, is an ICMP message with error $\tsvar{err}$. This rule covers two cases.

    In the first, thread $\tsvar{tid}$ is in the $\tscon{Run}$ state and a $\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is
    made. The call fails with error $\tsvar{err}$, making a $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition.
    This leaves the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$, and the socket with the ICMP message removed
    from its receive queue.

    In the second case, thread $\tsvar{tid}$ is blocked in state $\tscon{Recv2}(\tsvar{sid},\tsvar{n}_{0},\tsvar{opts}_{0})$. A $\MLhtau $
    transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$, and the socket with the ICMP
    message removed from its receive queue.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    This rule does not apply.

\\\hline
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXXIV}{\rrulecc{recvTXXIV}{recv\_24}{udp: fast fail}{\tsholcomm{ Fail with pending error }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\Msome  \;\tsvar{e},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 (\neg{}\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \implies  \exists \tsvar{p}_{2}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}) \Mwedge {}\\{}
 \tsvar{es} = \Mif  \;\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \;\Mthen  \;\Msome  \;\tsvar{e} \;\Melse  \;*}
{\rulesubsection{Description}

     From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made.
     $\tsvar{fd}$ refers to a UDP socket that has local address $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1})$, has its peer port
     set: $\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}$, and has pending error $\Msome  \;\tsvar{e}$.

     The call fails returning the pending error: a $\MLhcall{\tsvar{tid}}{\tsunknown{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is
     made leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EAGAIN}})$. If the $\tscon{MSG\_PEEK}$ flag was set in
     $\tsvar{opts}_{0}$ then the socket's pending error remains, otherwise it is cleared.

\rulesubsection{Model details}

     The $\tsvar{opts}_{0}$ argument to $\tsunknown{recv}()$ is of type $\tsunknown{msgbflag} \;\tstype{list}$, but it is converted to a
     set, $\tsvar{opts}$, using $\tsholop{LIST\_TO\_SET}$.



\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
     The socket need not have its peer port set.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommtcpTsend}{\clustersection{(TCP only)}{$\tsunknown{send}()$}
\seccomm{ \[ \tsunknown{send}: \tsunknown{fd} * (\tsunknown{ip} * \tsunknown{port}) \;\tstype{option} * \tstype{string} * \tsunknown{msgbflag} \;\tstype{list} \Mtotype  \tstype{string}  \]

  This section describes
  the behaviour of $\tsunknown{send}()$ for TCP sockets.
  A call to $\tsunknown{send}(\tsunknown{fd},*,\tsvar{data},\tsunknown{flags})$ enqueues data on the TCP socket's send queue.
  Here
  $\tsunknown{fd}$ is a file descriptor referring to the TCP socket to enqueue data on.
  The second argument, of type $(\tsunknown{ip} * \tsunknown{port}) \;\tstype{option}$, is the destination address of the data for UDP, but for
  a TCP socket it should be set to $*$ (the socket must be
  connected to a peer before $\tsunknown{send}()$ can be called).
  The   $\tsvar{data}$ is the data to be sent.
  Finally, $\tsunknown{flags}$ is a list of flags for the $\tsunknown{send}()$ call; possible flags are: $\tscon{MSG\_OOB}$, specifying
  that the data to be sent is out-of-band data, and $\tscon{MSG\_DONTWAIT}$, specifying that non-blocking
  behaviour is to be used for this call. The $\tscon{MSG\_WAITALL}$ and $\tscon{MSG\_PEEK}$ flags may also be set,
  but as they are meaningless for $\tsunknown{send}()$ calls, FreeBSD ignores them, and Linux and WinXP fail
  with $\tsunknown{EOPNOTSUPP}$.
  The returned $\tstype{string}$ is any data that was not sent.

  For a successful $\tsunknown{send}()$ call, the socket must be in a synchronised state, must not be shutdown
  for writing, and must not have a pending error.

  If there is not enough room on a socket's send queue then a $\tsunknown{send}()$ call may block until space
  becomes available. For a successful blocking $\tsunknown{send}()$ call on FreeBSD the entire string will be
  enqueued on the socket's send queue.

}\clustersubsection{Errors}
\seccomm{
  In addition to errors returned via ICMP (see \ltslink{deliverTinTicmpTIII}{$\tsunknown{deliver\_in\_icmp\_3}$}), a call to $\tsunknown{send}()$
  can fail with the errors below, in which case the corresponding exception is raised:

\par\begin{ltstabular}
$\tsunknown{EAGAIN}$
&  Non-blocking $\tsunknown{send}()$ call would block.

\\\hline
$\tsunknown{ENOTCONN}$
&  Socket not connected on FreeBSD and WinXP.

\\\hline
$\tsunknown{EOPNOTSUPP}$
&  Message flags $\tscon{MSG\_PEEK}$ and $\tscon{MSG\_WAITALL}$ not supported. Linux and WinXP.

\\\hline
$\tsunknown{EPIPE}$
&  Socket not connected on Linux; or socket shutdown for writing on FreeBSD and Linux.

\\\hline
$\tsunknown{ESHUTDOWN}$
&  Socket shutdown for writing on WinXP.

\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{EINTR}$
&  The system was interrupted by a caught signal.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  A TCP socket is created and successfully connects with a peer; data is then sent to the peer:
  $\tsunknown{socket\_1}$; $\tsunknown{return\_1}$; $\tsunknown{connect\_1}$; $\tsunknown{return\_1}$; $\dots $ $\tsunknown{connect\_2}$; $\tsunknown{return\_1}$;
  $\tsunknown{send\_1}$; $\dots $

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:  &  \wasverb{ssize\textunderscore{}t send(int socket, const void *buffer, size\textunderscore{}t length, int flags);} \\
    FreeBSD:&  \wasverb{ssize\textunderscore{}t send(int s, const void *msg, size\textunderscore{}t len, int flags);} \\
    Linux:  &  \wasverb{int send(int s, const void *msg, size\textunderscore{}t len, int flags);} \\
    WinXP:  &  \wasverb{int send(SOCKET s, const char *buf, int len, int flags);} \\
  \end{tabular}\\

  In the Posix interface:
  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to send from, corresponding to the
     $\tsunknown{fd}$ argument of the model $\tsunknown{send}()$.

    \item \wasverb{message} is a pointer to the data to be sent of length \wasverb{length}. The two
     together correspond to the $\tstype{string}$ argument of the model $\tsunknown{send}()$.

    \item \wasverb{flags} is a disjunction of the message flags for the $\tsunknown{send}()$ call, corresponding to
     the $\tsunknown{msgbflag}$ $\tstype{list}$ in the model $\tsunknown{send}()$.

     \item the returned \wasverb{ssize\textunderscore{}t} is either non-negative or \wasverb{-1}. If it is
     non-negative then it is the amount of data from \wasverb{message} that was sent. If it is
     \wasverb{-1} then it indicates an error, in which case the error is stored in
     \wasverb{errno}. This corresponds to the model $\tsunknown{send}()$'s return value of type $\tstype{string}$
     which is the data that was not sent. On WinXP an error is indicated by a return value of
     \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error code available through a
     call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  The FreeBSD, Linux and WinXP interfaces are similar modulo argument renaming, except where
  noted above.

}\clustersubsection{Model details}
\seccomm{
  If the call blocks then the thread enters state $\tscon{Send2}(\tsunknown{sid},*,\tsunknown{str},\tsunknown{opts})$ (the optional
  parameter is used for UDP only), where

  \begin{itemize}

    \item $\tsunknown{sid} : \tsunknown{sid}$ is the identifier of the socket that made the $\tsunknown{send}()$ call,

    \item $\tsunknown{str} : \tstype{string}$ is the data to be sent, and

    \item $\tsunknown{opts} : \tsunknown{msgbflag} \;\tstype{list}$ is the set of options for the $\tsunknown{send}()$ call.

  \end{itemize}

  The following errors are not modelled:

  \begin{itemize}

    \item In Posix and on all three architectures, \wasverb{EDESTADDRREQ} indicates that the socket is not
    connection-mode and no peer address is set.  This doesn't apply to TCP, which is a
    connection-mode protocol.

   \item In Posix, \wasverb{EACCES} signifies that write access to the socket is denied. This is not
   modelled here.

   \item On FreeBSD and Linux, \wasverb{EFAULT} signifies that the pointers passed as either the \wasverb{address} or
   \wasverb{address\textunderscore{}len} arguments were inaccessible.  This is an artefact of the C interface to
   $\tsunknown{accept}()$ that is excluded by the clean interface used in the model.

    \item In Posix and on Linux, \wasverb{EINVAL} signifies that an invalid argument was passed. The typing
     of the model interface prevents this from happening.

    \item In Posix, \wasverb{EIO} signifies that an I/O error occurred while reading from or writing to the
    file system. This is not modelled.

    \item On Linux, \wasverb{EMSGSIZE} indicates that the message is too large to be sent all at once, as
    the socket requires; this is not a requirement for TCP sockets.

    \item In Posix, \wasverb{ENETDOWN} signifies that the local network interface used to reach the
    destination is down. This is not modelled.

  \end{itemize}

  The following flags are not modelled:

  \begin{itemize}

  \item On Linux, \wasverb{MSG\textunderscore{}CONFIRM} is used to tell the link layer not to probe the neighbour.

  \item On Linux, \wasverb{MSG\textunderscore{}NOSIGNAL} requests not to send \wasverb{SIGPIPE} errors on stream-oriented sockets
  when the other end breaks the connection.

  \item On FreeBSD and WinXP, \wasverb{MSG\textunderscore{}DONTROUTE} is used by routing programs.

  \item On FreeBSD, \wasverb{MSG\textunderscore{}EOR} is used to indicate the end of a record for protocols that support
   this. It is not modelled because TCP does not support records.

   \item On FreeBSD, \wasverb{MSG\textunderscore{}EOF} is used to implement Transaction TCP which is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{send\_1}$
& \textbf{tcp: fast succeed}
&  Successfully send data without blocking \\
$\tsrule{send\_2}$
& \textbf{tcp: block}
&  Block waiting for space in socket's send queue \\
$\tsrule{send\_3}$
& \textbf{tcp: slow nonurgent succeed}
&  Successfully return from blocked state having sent data \\
$\tsrule{send\_3a}$
& \textbf{tcp: block}
&  From blocked state, transfer some data to the send queue and remain blocked \\
$\tsrule{send\_4}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{EAGAIN}$: non-blocking semantics requested and call would block \\
$\tsrule{send\_5}$
& \textbf{tcp: fast fail}
&  Fail with pending error \\
$\tsrule{send\_5a}$
& \textbf{tcp: slow urgent fail}
&  Fail from blocked state with pending error \\
$\tsrule{send\_6}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{ENOTCONN}$ or $\tsunknown{EPIPE}$: socket not connected \\
$\tsrule{send\_7}$
& \textbf{tcp: rc}
&  Fail with $\tsunknown{EPIPE}$ or $\tsunknown{ESHUTDOWN}$: socket shut down for writing \\
$\tsrule{send\_8}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{EOPNOTSUPP}$:  message flag not valid \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\sendTI}{\rrulecc{sendTI}{send\_1}{tcp: fast succeed}{\tsholcomm{ Successfully send data without blocking }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq})))] \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsholop{IMPLODE} \;\tsvar{str}''))}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\Mappend{\tsvar{sndq}}{\tsvar{str}'},\tsvar{rcvq})))] \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s}')],\tsvar{M})}
{\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{CLOSE\_WAIT}\} \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 {}\\{}
 \tsvar{space} \;\in  \;\tsunknown{UNIV} \Mwedge  {}\\{}
 {}\\{}
 (\{\tscon{MSG\_PEEK}; \tscon{MSG\_WAITALL}\} \cap  \;\tsvar{opts} = \emptyset  \Mvee  \tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge {}\\{}
 {}\\{}
 (\Mif  \;\tsvar{space} \geq  \tsholop{LENGTH} \;\tsvar{str} \;\Mthen {}\\{}
\quad\quad \tsvar{str}'=\tsvar{str} \Mwedge  \tsvar{str}''=[\,]{}\\{}
 \Melse {}\\{}
\quad\quad (\tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK}) \Mvee  (\tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts} \Mwedge  \neg{}\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch})) \Mwedge {}\\{}
\quad\quad (\Mif  \;\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{space} \geq  \tsvar{sf}.\tsunknown{n}(\tscon{SO\_SNDLOWAT}){}\\{}
\quad\quad \Melse                     \;\tsvar{space} >  0) \Mwedge {}\\{}
\quad\quad (\tsvar{str}',\tsvar{str}'') = \tsunknown{SPLIT} \;\tsvar{space} \;\tsvar{str}{}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsvar{flgs} = \tsvar{flgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{FIN} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Mwedge {}\\{}
 \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{flgs},\tsvar{str}') \tsvar{s} \;\tsvar{s}'}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call
    is made. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$ that has binding quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome
\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$, has no pending error, is not shutdown for writing, and is in state
    $\tscon{ESTABLISHED}$ or $\tscon{CLOSE\_WAIT}$. The $\tscon{MSG\_PEEK}$ and $\tscon{MSG\_WAITALL}$ flags are not set in
    $\tsvar{opts}_{0}$. $\tsvar{space}$ is the space in the socket's send queue, calculated using \ltslink{sendTqueueTspace}{$\tsaux{send\_queue\_space}$}.

    This rule covers two cases: (1) there is space in the socket's send queue for all the data; and
    (2) there is not space for all the data but the call is non-blocking (the $\tscon{MSG\_DONTWAIT}$ flag
    is set in $\tsvar{opts}$ or the socket's $\tscon{O\_NONBLOCK}$ flag is set), and the space is greater than
    zero, or, on FreeBSD, greater than the minimum number of bytes for $\tsunknown{send}()$ operations on the
    socket, $\tsvar{sf}.\tsunknown{n}(\tscon{SO\_SNDLOWAT})$.

    In (1) all of the data $\tsvar{str}$ is appended to the socket's send queue and the returned
    string, $\tsvar{str}''$, is the empty string. In (2), the first $\tsvar{space}$ bytes of data, $\tsvar{str}'$, are
    appended to the socket's send queue and the remaining data, $\tsvar{str}''$, is returned.

    In both cases a $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made,
    leaving the thread state $\tscon{Ret} (\tscon{OK} (\tsholop{IMPLODE} \;\tsvar{str}''))$. If the data was marked as out-of-band,
    $\tscon{MSG\_OOB} \;\in  \;\tsvar{opts}$, then the socket's send urgent pointer will point to the end of the send
    queue.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tsunknown{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.

    The $\tsvar{opts}_{0}$ argument is of type $\tstype{list}$. In the model it is converted to a $\tstype{set}$ $\tsvar{opts}$
    using $\tsholop{LIST\_TO\_SET}$. The presence of $\tscon{MSG\_PEEK}$ is checked for in $\tsvar{opts}$ rather than in
    $\tsvar{opts}_{0}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    The $\tscon{MSG\_PEEK}$ and $\tscon{MSG\_WAITALL}$ flags may be set in $\tsvar{opts}_{0}$ but for the call to be
    non-blocking the socket's $\tscon{O\_NONBLOCK}$ flag must be set: the $\tscon{MSG\_DONTWAIT}$ flag has no
    effect.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTII}{\rrulecc{sendTII}{send\_2}{tcp: block}{\tsholcomm{ Block waiting for space in socket's send queue }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq})))] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})}{\tsunknown{never\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq})))] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \neg{}((\neg{}\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge   \tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts}) \Mvee  \tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK})) \Mwedge {}\\{}
 {}\\{}
 \tsvar{space} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 {}\\{}
 (\{\tscon{MSG\_PEEK}; \tscon{MSG\_WAITALL}\} \cap  \;\tsvar{opts} = \emptyset  \Mvee  \tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch})\Mwedge {}\\{}
 {}\\{}
 ((\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{CLOSE\_WAIT}\} \Mwedge {}\\{}
\quad \tsvar{space} < \tsholop{LENGTH} \;\tsvar{str}) \Mvee {}\\{}
 (\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsvar{st} \;\in  \{\tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}\}))}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call
    is made. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$ that has binding quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome
\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$, has no pending error, is not shutdown for writing, and is in state
    $\tscon{ESTABLISHED}$ or $\tscon{CLOSE\_WAIT}$. The call is a blocking one: the socket's $\tscon{O\_NONBLOCK}$ flag
    is not set and the $\tscon{MSG\_DONTWAIT}$ flag is not set in $\tsvar{opts}_{0}$. The $\tscon{MSG\_PEEK}$ and
    $\tscon{MSG\_WAITALL}$ flags are not set in $\tsvar{opts}_{0}$.

    The space in the socket's send queue, $\tsvar{space}$ (calculated using \ltslink{sendTqueueTspace}{$\tsaux{send\_queue\_space}$}), is less than the length in bytes of the data to be sent, $\tsvar{str}$.

    The call blocks, leaving the thread state $\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})$ via a
    $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tsunknown{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.


\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    The $\tscon{MSG\_PEEK}$, $\tscon{MSG\_WAITALL}$, and $\tscon{MSG\_DONTWAIT}$ flags may all be set in $\tsvar{opts}_{0}$: all
    three are ignored by FreeBSD.

\\\hline
Linux
&
    In addition to the above, the rule also applies if connection establishment is still taking
    place for the socket: it is in state $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTIII}{\rrulecc{sendTIII}{send\_3}{tcp: slow nonurgent succeed}{\tsholcomm{ Successfully return from blocked state having sent data }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq})))] \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsholop{IMPLODE} \;\tsvar{str}''))}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\Mappend{\tsvar{sndq}}{\tsvar{str}'},\tsvar{rcvq})))] \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')],\tsvar{M})}
{\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{CLOSE\_WAIT}\} \Mwedge {}\\{}
 {}\\{}
 \tsvar{space} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 {}\\{}
 \tsvar{space} \geq  \tsholop{LENGTH} \;\tsvar{str} \Mwedge {}\\{}
 \tsvar{str}'=\tsvar{str} \Mwedge  \tsvar{str}''=[\,] \Mwedge {}\\{}
 {}\\{}
 \tsvar{flgs} = \tsvar{flgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{FIN} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Mwedge {}\\{}
 \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{flgs},\tsvar{str}') \tsvar{s} \;\tsvar{s}'}
{\rulesubsection{Description}

    Thread $\tsvar{tid}$ is blocked in state $\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})$ where the TCP socket $\tsvar{sid}$ has
    binding quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$, has no pending error, is not shutdown for
    writing, and is in state $\tscon{ESTABLISHED}$ or $\tscon{CLOSE\_WAIT}$.

    The space in the socket's send queue, $\tsvar{space}$ (calculated using \ltslink{sendTqueueTspace}{$\tsaux{send\_queue\_space}$}),
    is greater than or equal to the length of the data to be sent, $\tsvar{str}$. The data is appended to
    the socket's send queue and the call successfully returns the empty string. A $\MLhtau $
    transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK} \text{``''})$. If the data was marked as
    out-of-band, $\tscon{MSG\_OOB} \;\in  \;\tsvar{opts}$, then the socket's urgent pointer will be updated to point to
    the end of the socket's send queue.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tsunknown{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.


\rrulepad }
}

\newcommand{\sendTIIIa}{\rrulecc{sendTIIIa}{send\_3a}{tcp: block}{\tsholcomm{ From blocked state, transfer some data to the send queue and remain blocked }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq})))] \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Send2}(\tsvar{sid},*,\tsvar{str}'',\tsvar{opts})}{\tsunknown{never\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\Mappend{\tsvar{sndq}}{\tsvar{str}'},\tsvar{rcvq})))] \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')],\tsvar{M})}
{\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{CLOSE\_WAIT}\} \Mwedge {}\\{}
 \tsvar{space} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 \tsvar{space} < \tsholop{LENGTH} \;\tsvar{str} \Mwedge  \tsvar{space} > 0 \Mwedge {}\\{}
 (\tsvar{str}',\tsvar{str}'') = \tsunknown{SPLIT} \;\tsvar{space} \;\tsvar{str} \Mwedge {}\\{}
 {}\\{}
 \tsvar{flgs} = \tsvar{flgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{FIN} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Mwedge {}\\{}
 \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{flgs},\tsvar{str}') \tsvar{s} \;\tsvar{s}'}
{\rulesubsection{Description}

    Thread $\tsvar{tid}$ is blocked in state $\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})$ where TCP socket $\tsvar{sid}$ has
    binding quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$, has no pending error, is not shutdown for
    writing, and is in state $\tscon{ESTABLISHED}$ or $\tscon{CLOSE\_WAIT}$. The amount of space in the socket's
    send queue, $\tsvar{space}$ (calculated using \ltslink{sendTqueueTspace}{$\tsaux{send\_queue\_space}$}), is less than the length
    of the remaining data to be sent, $\tsvar{str}$, and greater than $0$. The socket's send queue is
    filled by appending the first $\tsvar{space}$ bytes of $\tsvar{str}$, $\tsvar{str}'$, to it.

    A $\MLhtau $ transition is made, leaving the thread state $\tscon{Send2}(\tsvar{sid},*,\tsvar{str}'',\tsvar{opts})$
    where $\tsvar{str}''$ is the remaining data to be sent. If the data in $\tsvar{str}$ is out-of-band,
    $\tscon{MSG\_OOB}$ is set in $\tsvar{opts}$, then the socket's urgent pointer is updated to point to the end
    of the socket's send queue.

    Note it is unclear whether or not $\tscon{MSG\_OOB}$ should be removed from $\tsvar{opts}$ in the state.


\rrulepad }
}

\newcommand{\sendTIV}{\rrulecc{sendTIV}{send\_4}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EAGAIN}$: non-blocking semantics requested and call would block }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EAGAIN}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{socks}}{\tsvar{sid}} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq})) \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 {}\\{}
 (\{\tscon{MSG\_PEEK};\tscon{MSG\_WAITALL}\} \cap  \;\tsvar{opts} = \emptyset  \Mvee  \tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge {}\\{}
 {}\\{}
 ((\neg{}\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts}) \Mvee  \tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK})) \Mwedge {}\\{}
 {}\\{}
 ((\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{CLOSE\_WAIT}\} \Mwedge  {}\\{}
\quad \tsvar{space} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
\quad \neg{}(\tsvar{space} \geq  \tsholop{LENGTH} \;\tsvar{str} \Mvee  (\Mif  \;\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{space} \geq  \tsvar{sf}.\tsunknown{n}(\tscon{SO\_SNDLOWAT}) \Melse  \;\tsvar{space} > 0))) \Mvee {}\\{}
 (\tsvar{st} \;\in  \{\tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}\} \Mwedge  {}\\{}
\quad \tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch}))}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call
    is made. $\tsvar{fd}$ refers to a TCP socket that has binding quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome
\tsvar{p}_{2})$, has no pending error, is not shutdown for writing, and is in state $\tscon{ESTABLISHED}$ or
    $\tscon{CLOSE\_WAIT}$. The call is a non-blocking one: either the socket's $\tscon{O\_NONBLOCK}$ flag is set
    or the $\tscon{MSG\_DONTWAIT}$ flag is set in $\tsvar{opts}_{0}$. The $\tscon{MSG\_PEEK}$ and $\tscon{MSG\_WAITALL}$ flags are
    not set in $\tsvar{opts}_{0}$.

    The space in the socket's send queue, $\tsvar{space}$ (calculated using \ltslink{sendTqueueTspace}{$\tsaux{send\_queue\_space}$}),
    is less than both the length of the data to send $\tsvar{str}$; and on FreeBSD is less than the
    minimum number of bytes for socket send operations, $\tsvar{sf}.\tsunknown{n}(\tscon{SO\_SNDLOWAT})$, or on Linux and WinXP
    is equal to zero. The call would have to block, but because it is non-blocking, it fails with an
    $\tsunknown{EAGAIN}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made, leaving the thread in
    state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EAGAIN}})$.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tsunknown{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.

    The $\tsvar{opts}_{0}$ argument is of type $\tstype{list}$. In the model it is converted to a $\tstype{set}$ $\tsvar{opts}$
    using $\tsholop{LIST\_TO\_SET}$. The presence of $\tscon{MSG\_PEEK}$ is checked for in $\tsvar{opts}$ rather than in
    $\tsvar{opts}_{0}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    For the call to be non-blocking, the socket's $\tscon{O\_NONBLOCK}$ flag must be set; the
    $\tscon{MSG\_DONTWAIT}$ flag is ignored. Additionally, the $\tscon{MSG\_PEEK}$ and $\tscon{MSG\_WAITALL}$ flags may
    be set in $\tsvar{opts}_{0}$ as they are also ignored.

\\\hline
Linux
&
    This rule also applies if the socket is in state $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$, in which case
    the send queue size does not matter.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTV}{\rrulecc{sendTV}{send\_5}{tcp: fast fail}{\tsholcomm{ Fail with pending error }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsvar{e} \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  * \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tsunknown{PROTO\_TCP}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call
    is made. $\tsvar{fd}$ refers to a socket $\tsvar{sock}$ identified by $\tsvar{sid}$ with pending error $\Msome
\tsvar{e}$. The call fails, returning the pending error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsunknown{opts})}$ transition is made, leaving the thread in
    state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tsunknown{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.


\rrulepad }
}

\newcommand{\sendTVa}{\rrulecc{sendTVa}{send\_5a}{tcp: slow urgent fail}{\tsholcomm{ Fail from blocked state with pending error }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsvar{e} \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  * \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tsunknown{PROTO\_TCP}}
{\rulesubsection{Description}

    Thread $\tsvar{tid}$ is blocked in state $\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})$ from an earlier $\tsunknown{send}()$
    call. The TCP socket $\tsvar{sid}$ has pending error $\Msome  \;\tsvar{e}$ so the call can now return, failing
    with the error.

    A $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$.


\rrulepad }
}

\newcommand{\sendTVI}{\rrulecc{sendTVI}{send\_6}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{ENOTCONN}$ or $\tsunknown{EPIPE}$: socket not connected }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = \tsvar{sock}.\tsvar{pr} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{es} = * \Mwedge {}\\{}
 (\tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{CLOSED}; \tscon{LISTEN}\} \Mvee {}\\{}
\quad  {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad {}\\{}
\quad (\tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}\} \Mwedge  \neg{}(\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch})) \Mvee {}\\{}
\quad \Mfalse  \tsholcomm{ Placeholder for: if \wasverb{tcp\textunderscore{}disconnect} or \wasverb{tcp\textunderscore{}usrclose} has been invoked } {}\\{}
 ) \Mwedge {}\\{}
 \tsvar{err} = (\Mif  \;\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsunknown{EPIPE} \;\Melse  \;\tsunknown{ENOTCONN})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call
    is made. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sock}$ identified by $\tsvar{sid}$ that does not have a
    pending error. The socket is not synchronised: it is in state $\tscon{CLOSED}$, $\tscon{LISTEN}$,
    $\tscon{SYN\_SENT}$, or $\tscon{SYN\_RECEIVED}$. The call fails with an $\tsunknown{ENOTCONN}$ error, or $\tsunknown{EPIPE}$ on
    Linux.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made, leaving the thread in
    state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$ where $\tsvar{err}$ is one of the above errors.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tsunknown{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.


\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    The rule does not apply if the socket is in state $\tscon{SYN\_RECEIVED}$ or $\tscon{SYN\_SENT}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTVII}{\rrulecc{sendTVII}{send\_7}{tcp: rc}{\tsholcomm{ Fail with $\tsunknown{EPIPE}$ or $\tsunknown{ESHUTDOWN}$: socket shut down for writing }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{t}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\Mtrue ,\tsvar{cantrcvmore},\tscon{TCP\_PROTO}(\tsvar{tcp})))] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \tsvar{lbl} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\Mtrue ,\tsvar{cantrcvmore},\tscon{TCP\_PROTO}(\tsvar{tcp})))] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mboxedor{\exists \tsvar{fd} \;\tsvar{ff} \;\tsvar{str} \;\tsvar{opts}_{0} \;\tsvar{i}_{2} \;\tsvar{p}_{2}.   {}\\{}
\quad \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
\quad \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
\quad \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
\quad \tsvar{t} = \tscon{Run} \Mwedge {}\\{}
\quad \tsvar{lbl} = \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} \Mwedge {}\\{}
\quad \tsvar{rc} = \tscon{fast} \;\tscon{fail} \Mwedge {}\\{}
\quad \tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2} \Mwedge {}\\{}
\quad (\Mif  \;\tsvar{tcp}.\tsvar{st} \neq  \tscon{CLOSED} \;\Mthen {}\\{}
\quad\quad\quad \exists \tsvar{i}_{1} \;\tsvar{p}_{1}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1}{}\\{}
\quad\quad \Melse  \;\Mtrue ){}\\{}
\quad }{\exists \tsvar{opts} \;\tsvar{str}.  {}\\{}
\quad \tsvar{t} = \tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts}) \Mwedge {}\\{}
\quad \tsvar{lbl} = \MLhtau  \Mwedge {}\\{}
\quad \tsvar{rc} = \tscon{slow} \;\tsunknown{urgent} \;\tscon{fail}{}\\{}
\quad } \Mwedge {}\\{}
 (\Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{err} = \tsunknown{ESHUTDOWN}{}\\{}
 \Melse                         \;\tsvar{err} = \tsunknown{EPIPE})}
{\rulesubsection{Description}

    This rule covers two cases: (1) from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a
    $\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call is made; and (2) thread $\tsvar{tid}$ is blocked in state
    $\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})$. In (1), fd refers to a TCP socket $\tsvar{sid}$ that has binding quad
    $(\tsvar{is}_{1},\tsvar{ps}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$. In both cases the socket is shutdown for writing. The call fails
    with an $\tsunknown{EPIPE}$ error.

    The thread is left in state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EPIPE}})$, via a $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition in (1) or a $\MLhtau $ transition in (2).

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tsunknown{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    The call fails with an $\tsunknown{ESHUTDOWN}$ error instead of $\tsunknown{EPIPE}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTVIII}{\rrulecc{sendTVIII}{send\_8}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EOPNOTSUPP}$:  message flag not valid }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EOPNOTSUPP}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tsunknown{PROTO\_TCP} \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 (\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \Mvee  \tscon{MSG\_WAITALL} \;\in  \;\tsvar{opts}) \Mwedge {}\\{}
 \neg{}\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call
    is made. $\tsvar{fd}$ refers to a TCP socket identified by $\tsvar{sid}$. Either the $\tscon{MSG\_PEEK}$ or
    $\tscon{MSG\_WAITALL}$ flag is set in $\tsvar{opts}_{0}$. These flags are not supported so the call fails with
    an $\tsunknown{EOPNOTSUPP}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made, leaving the thread in
    state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EOPNOTSUPP}})$.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tsunknown{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.

    The $\tsvar{opts}_{0}$ argument is of type $\tstype{list}$. In the model it is converted to a $\tstype{set}$ $\tsvar{opts}$
    using $\tsholop{LIST\_TO\_SET}$. The presence of $\tscon{MSG\_PEEK}$ is checked for in $\tsvar{opts}$ rather than in
    $\tsvar{opts}_{0}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommudpTsend}{\clustersection{(UDP only)}{$\tsunknown{send}()$}
\seccomm{ \[ \tsunknown{send}: (\tsunknown{fd} * (\tsunknown{ip} * \tsunknown{port}) \;\tstype{option} * \tstype{string} * \tsunknown{msgbflag} \;\tstype{list}) \Mtotype  \tstype{string} \]

  This section describes
  the behaviour of $\tsunknown{send}()$ for UDP sockets.
  A call to $\tsunknown{send}(\tsunknown{fd},\tsunknown{addr},\tsvar{data},\tsunknown{flags})$ enqueues a UDP datagram to send to a peer.
  Here the $\tsunknown{fd}$ argument is a file descriptor referring to a UDP socket from which to send data.
  The destination address of the data can be specified either by the $\tsunknown{addr}$ argument, which can be
  $\Msome (\tsvar{i}_{3},\tsvar{p}_{3})$ or $*$, or by the socket's peer address (its $\tsvar{is}_{2}$ and $\tsvar{ps}_{2}$ fields) if set. For a successful $\tsunknown{send}()$, at least one of these two must be specified. If the socket
  has a peer address set and $\tsunknown{addr}$ is set to $\Msome (\tsvar{i}_{3},\tsvar{p}_{3})$, then the address used is
  architecture-dependent: on FreeBSD the $\tsunknown{send}()$ call will fail with an $\tsunknown{EISCONN}$ error; on
  Linux and WinXP $\tsvar{i}_{3},\tsvar{p}_{3}$ will be used.

  The $\tstype{string}$, $\tsvar{data}$, is the data to be sent. The length in bytes of $\tsvar{data}$ must be less
  than the architecture-dependent maximum payload for a UDP datagram. Sending a $\tstype{string}$ of length
  zero bytes is acceptable.

  The $\tsunknown{msgbflag}$ $\tstype{list}$ is the list of message flags for the $\tsunknown{send}()$ call. The possible flags
  are $\tscon{MSG\_DONTWAIT}$ and $\tscon{MSG\_OOB}$. $\tscon{MSG\_DONTWAIT}$ specifies that non-blocking behaviour
  should be used for this call: see rules $\tsunknown{send\_10}$ and $\tsunknown{send\_11}$.  $\tscon{MSG\_OOB}$ specifies that
  the data to be sent is out-of-band data, which is not meaningful for UDP sockets.  FreeBSD ignores
  this flag, but on Linux and WinXP the $\tsunknown{send}()$ call will fail: see rule $\tsunknown{send\_20}$.

  The return value of the $\tsunknown{send}()$ call is a $\tstype{string}$ of the data which was not sent. A partial
  send may occur when the call is interrupted by a signal after having sent some data.

  For a datagram to be sent, the socket must be bound to a local port. When a $\tsunknown{send}()$ call is
  made, the socket is autobound to an ephemeral port if it does not have its local port bound.

  A successful $\tsunknown{send}()$ call only guarantees that the datagram has been placed on the host's out
  queue. It does not imply that the datagram has left the host, let alone been successfully
  delivered to its destination.

  A call to $\tsunknown{send}()$ may block if there is no room on the socket's send buffer and non-blocking
  behaviour has not been requested.

}\clustersubsection{Errors}
\seccomm{
  In addition to errors returned via ICMP (see \ltslink{deliverTinTicmpTIII}{$\tsunknown{deliver\_in\_icmp\_3}$}), a call to $\tsunknown{send}()$
  can fail with the errors below, in which case the corresponding exception is raised:

\par\begin{ltstabular}
$\tsunknown{EADDRINUSE}$
&  The socket's peer address is not set and the destination address specified
   would give the socket a binding quad $\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}$ which is already in use by another
   socket.

\\\hline
$\tsunknown{EADDRNOTAVAIL}$
&  There are no ephemeral ports left for autobinding to.

\\\hline
$\tsunknown{EAGAIN}$
&  The $\tsunknown{send}()$ call would block and non-blocking behaviour is requested. This
   may have been done either via the $\tscon{MSG\_DONTWAIT}$ flag being set in the $\tsunknown{send}()$ flags or the
   socket's $\tscon{O\_NONBLOCK}$ flag being set.

\\\hline
$\tsunknown{EDESTADDRREQ}$
&  The socket does not have its peer address set, and no destination address
   was specified.

\\\hline
$\tsunknown{EINTR}$
&  A signal interrupted $\tsunknown{send}()$ before any data was transmitted.

\\\hline
$\tsunknown{EISCONN}$
&  On FreeBSD, a destination address was specified and the socket has a peer
   address set.

\\\hline
$\tsunknown{EMSGSIZE}$
&  The message is too large to be sent in one datagram.

\\\hline
$\tsunknown{ENOTCONN}$
&  The socket does not have its peer address set, and no destination address was
   specified. This can occur either when the call is first made, or if it blocks and if the peer
   address is unset by a call to $\tsunknown{disconnect}()$ whilst blocked.

\\\hline
$\tsunknown{EOPNOTSUPP}$
&  The $\tscon{MSG\_OOB}$ flag is set on Linux or WinXP.

\\\hline
$\tsunknown{EPIPE}$
&  Socket shut down for writing.

\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\\\hline
$\tsunknown{ENOBUFS}$
&  Out of resources.

\\\hline
$\tsunknown{ENOMEM}$
&  Out of resources.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsunknown{send\_9}$; $\tsunknown{return\_1}$;

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:   & \wasverb{ssize\textunderscore{}t sendto(int socket, const void *message, size\textunderscore{}t length,}\\
             & \wasverb{               int flags, const struct sockaddr *dest\textunderscore{}addr}\\
             & \wasverb{               socklen\textunderscore{}t dest\textunderscore{}len);}\\
    FreeBSD: & \wasverb{ssize\textunderscore{}t sendto(int s, const void *msg, size\textunderscore{}t len, int flags,}\\
             & \wasverb{               const struct sockaddr *to, socklen\textunderscore{}t tolen);} \\
    Linux:   & \wasverb{int sendto(int s, const void *msg, size\textunderscore{}t len, int flags,}\\
             & \wasverb{           const struct sockaddr *to, socklen\textunderscore{}t tolen);} \\
    WinXP:   & \wasverb{int sendto(SOCKET s, const char* buf, int len, int flags,} \\
             & \wasverb{           const struct sockaddr* to, int tolen);} \\
  \end{tabular}

  In the Posix interface:
  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to send from, corresponding to the
     $\tsunknown{fd}$ argument of the model $\tsunknown{send}()$.

    \item \wasverb{message} is a pointer to the data to be sent of length \wasverb{length}. The two
     together correspond to the $\tstype{string}$ argument of the model $\tsunknown{send}()$.

    \item \wasverb{flags} is an OR of the message flags for the $\tsunknown{send}()$ call, corresponding to
     the $\tsunknown{msgbflag}$ $\tstype{list}$ in the model $\tsunknown{send}()$.

    \item \wasverb{dest\textunderscore{}addr} and \wasverb{dest\textunderscore{}len} correspond to the $\tsunknown{addr}$ argument of the
     model $\tsunknown{send}()$. \wasverb{dest\textunderscore{}addr} is either null or a pointer to a sockaddr structure
     containing the destination address for the data. If it is null it corresponds to $\tsunknown{addr} =
*$. If it contains an address, then it corresponds to $\tsunknown{addr} = \Msome (\tsvar{i}_{3},\tsvar{p}_{3})$ where $\tsvar{i}_{3}$
     and $\tsvar{p}_{3}$ are the IP address and port specified in the sockaddr structure.

    \item the returned \wasverb{ssize\textunderscore{}t} is either non-negative or \wasverb{-1}. If it is
     non-negative then it is the amount of data from \wasverb{message} that was sent. If it is
     \wasverb{-1} then it indicates an error, in which case the error is stored in
     \wasverb{errno}. This is different to the model $\tsunknown{send}()$'s return value of type $\tstype{string}$
     which is the data that was not sent. On WinXP an error is indicated by a return value of
     \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error code available through a
     call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  There are other functions used to send data on a socket. \wasverb{send()} is similar to
  \wasverb{sendto()} except it does not have the \wasverb{address} and \wasverb{address\textunderscore{}len}
  arguments. It is used when the destination address of the data does not need to be
  specified. \wasverb{sendmsg()}, another output function, is a more general form of
  \wasverb{sendto()}.

}\clustersubsection{Model details}
\seccomm{
  If the call blocks then the thread enters state $\tscon{Send2}(\tsunknown{sid},\Msome (\tsunknown{addr},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsunknown{str},\tsunknown{opts})$ where

  \begin{itemize}

    \item $\tsunknown{sid} : \tsunknown{sid}$ is the identifier of the socket that made the $\tsunknown{send}()$ call,

    \item $\tsunknown{addr} : (\tsunknown{ip} * \tsunknown{port}) \;\tstype{option}$ is the destination address specified in the $\tsunknown{send}()$ call,

    \item $\tsvar{is}_{1} : \tsunknown{ip} \;\;\tstype{option}$ is the socket's local IP address, possibly $*$,

    \item $\tsvar{ps}_{1} : \tsunknown{port} \;\;\tstype{option}$ is the socket's local port, possibly $*$,

    \item $\tsvar{is}_{2} : \tsunknown{ip} \;\;\tstype{option}$ is the IP address of the socket's peer, possibly $*$,

    \item $\tsvar{ps}_{2} : \tsunknown{ip} \;\;\tstype{option}$ is the port of the socket's peer, possibly $*$,

    \item $\tsunknown{str} : \tstype{string}$ is the data to be sent, and

    \item $\tsunknown{opts} : \tsunknown{msgbflag} \;\tstype{list}$ is the set of options for the $\tsunknown{send}()$ call.

  \end{itemize}

  The following errors are not modelled:

  \begin{itemize}

   \item On FreeBSD, \wasverb{EACCES} signifies that the destination address is a broadcast address and the
   \wasverb{SO\textunderscore{}BROADCAST} flag has not been set on the socket. Broadcast is not modelled here.

   \item In Posix, \wasverb{EACCES} signifies that write access to the socket is denied. This is not
   modelled here.

   \item On FreeBSD and Linux, \wasverb{EFAULT} signifies that the pointers passed as either the \wasverb{address} or
   \wasverb{address\textunderscore{}len} arguments were inaccessible.  This is an artefact of the C interface to
   $\tsunknown{accept}()$ that is excluded by the clean interface used in the model.

    \item In Posix and on Linux, \wasverb{EINVAL} signifies that an invalid argument was passed. The typing
     of the model interface prevents this from happening.

    \item In Posix, \wasverb{EIO} signifies that an I/O error occurred while reading from or writing to the
    file system. This is not modelled.

    \item In Posix, \wasverb{ENETDOWN} signifies that the local network interface used to reach the
    destination is down. This is not modelled.

  \end{itemize}

  The following flags are not modelled:

  \begin{itemize}

  \item On Linux, \wasverb{MSG\textunderscore{}CONFIRM} is used to tell the link layer not to probe the neighbour.

  \item On Linux, \wasverb{MSG\textunderscore{}NOSIGNAL} requests not to send \wasverb{SIGPIPE} errors on stream-oriented sockets
  when the other end breaks the connection. UDP is not stream-oriented.

  \item On FreeBSD and WinXP, \wasverb{MSG\textunderscore{}DONTROUTE} is used by routing programs.

  \item On FreeBSD, \wasverb{MSG\textunderscore{}EOR} is used to indicate the end of a record for protocols that support
   this. It is not modelled because UDP does not support records.

   \item On FreeBSD, \wasverb{MSG\textunderscore{}EOF} is used to implement Transaction TCP.

  \end{itemize}



}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{send\_9}$
& \textbf{udp: fast succeed}
&  Enqueue datagram and return successfully \\
$\tsrule{send\_10}$
& \textbf{udp: block}
&  Block waiting to enqueue datagram \\
$\tsrule{send\_11}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{EAGAIN}$: call would block and non-blocking behaviour has been requested \\
$\tsrule{send\_12}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{ENOTCONN}$: no peer address set in socket and no destination address provided \\
$\tsrule{send\_13}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{EMSGSIZE}$: string to be sent is bigger than $\tsunknown{UDPpayloadMax}$ \\
$\tsrule{send\_14}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{EAGAIN}$, $\tsunknown{EADDRNOTAVAIL}$ or $\tsunknown{ENOBUFS}$: there are no ephemeral ports left \\
$\tsrule{send\_15}$
& \textbf{udp: slow urgent succeed}
&  Return from blocked state after datagram enqueued \\
$\tsrule{send\_16}$
& \textbf{udp: slow urgent fail}
&  Fail: blocked socket has entered an error state \\
$\tsrule{send\_17}$
& \textbf{udp: slow urgent fail}
&  Fail with $\tsunknown{EMSGSIZE}$ or $\tsunknown{ENOTCONN}$: blocked socket has had peer address unset or string to be sent is too big \\
$\tsrule{send\_18}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{EOPNOTSUPP}$: $\tscon{MSG\_PEEK}$ flag not supported for $\tsunknown{send}()$ calls on WinXP; or $\tscon{MSG\_OOB}$ flag not supported on WinXP and Linux  \\
$\tsrule{send\_19}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{EADDRINUSE}$: on FreeBSD, local and destination address quad in use by another socket \\
$\tsrule{send\_21}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{EISCONN}$: socket has peer address set and destination address is specified in call on FreeBSD \\
$\tsrule{send\_22}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{EPIPE}$ or $\tsunknown{ESHUTDOWN}$: socket shut down for writing \\
$\tsrule{send\_23}$
& \textbf{udp: fast fail}
&  Fail with pending error \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\sendTIX}{\rrulecc{sendTIX}{send\_9}{udp: fast succeed}{\tsholcomm{ Enqueue datagram and return successfully }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{OK} (\text{``''}))}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}'_{1}; \tsvar{pr}\Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{cantsndmore} = \Mfalse  \Mwedge {}\\{}
 \tsunknown{STRLEN} (\tsholop{IMPLODE} \;\tsvar{str}) \leq  \tsunknown{UDPpayloadMax} \;\tsvar{h}_{0}.\tsvar{arch} \Mwedge {}\\{}
 ((\tsvar{addr} \neq  *) \Mvee  (\tsvar{sock}.\tsvar{is}_{2} \neq  *)) \Mwedge {}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{sock}.\tsvar{ps}_{1},\tsunknown{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{sock}.\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound}) \Mwedge {}\\{}
 \tsaux{dosend}(\tsvar{h}.\tsvar{ifds},\tsvar{h}.\tsvar{rttab},(\tsvar{addr},\tsvar{str}),(\tsvar{sock}.\tsvar{is}_{1},\Msome  \;\tsvar{p}'_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}),\tsvar{h}_{0}.\tsvar{oq},\tsvar{oq}',\Mtrue ) \Mwedge {}\\{}
 (\Mif  \;\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  (\tsvar{h}_{0}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{sf}.\tsunknown{n}(\tscon{SO\_SNDBUF}) \geq  \tsunknown{STRLEN} (\tsholop{IMPLODE} \;\tsvar{str}){}\\{}
\quad \Melse  \;\Mtrue ) \Mwedge {}\\{}
 (\neg{}(\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch}) \implies  \tsvar{es} = *)}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ that is not shutdown for writing and has no
    pending errors. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a call
    $\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ succeeds if:

    \begin{itemize}

      \item the length of $\tsvar{str}$ is less than \ltslink{UDPpayloadMax}{$\tsunknown{UDPpayloadMax}$}, the architecture-dependent
       maximum payload for a UDP datagram.

      \item The socket has a peer IP address set in its $\tsvar{is}_{2}$ field or the $\tsvar{addr}$ argument is
       $\Msome (\tsvar{i}_{3},\tsvar{p}_{3})$, specifying a destination address.

      \item The socket is bound to a local port $\tsvar{p}'_{1}$, or it can be autobound to $\tsvar{p}'_{1}$ and
       $\tsvar{sid}$ added to the list of bound sockets.

      \item A UDP datagram is constructed from the socket's binding quad $(\tsvar{sock}.\tsvar{is}_{1},\Msome
\tsvar{p}'_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2})$, the destination address argument $\tsvar{addr}$, and the data
       $\tsvar{str}$. This datagram is successfully enqueued on the outqueue of the host, $\tsvar{oq}$ to form
       outqueue $\tsvar{oq}'$ using auxiliary function \ltslink{dosend}{$\tsaux{dosend}$}.

    \end{itemize}

    A $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made, leaving the thread in
    state $\tscon{Ret} (\tscon{OK}(\text{``''}))$ and the host with new outqueue $\tsvar{oq}'$. If the socket was autobound to a
    port then $\tsvar{sid}$ is appended to the host's list of bound sockets.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tsunknown{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.




\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    The $\tscon{MSG\_OOB}$ flag is not set in $\tsvar{opts}_{0}$.

\\\hline
FreeBSD
&
    On FreeBSD there is an additional condition for a successful $\tsunknown{send}()$: the amount of data to
    be sent must be less than or equal to the size of the socket's send buffer.

\\\hline
Linux
&
    The $\tscon{MSG\_OOB}$ flag is not set in $\tsvar{opts}_{0}$.

\\\hline
WinXP
&
    The $\tscon{MSG\_OOB}$ flag is not set in $\tsvar{opts}_{0}$ and any pending errors are ignored.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTX}{\rrulecc{sendTX}{send\_10}{udp: block}{\tsholcomm{ Block waiting to enqueue datagram }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass {}\\{}
 \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mtimed{\tscon{Send2}(\tsvar{sid},\Msome  (\tsvar{addr},\tsvar{sock}.\tsvar{is}_{1},\Msome  \;\tsvar{p}'_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}), \tsvar{str},\tsvar{opts})}{ \tsunknown{never\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}'_{1}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
\quad \tsvar{S},\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{cantsndmore} = \Mfalse  \Mwedge {}\\{}
 (\neg{}(\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch}) \implies  \tsvar{es} = *) \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 \neg{}((\neg{}\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge \tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts}) \Mvee  \tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK})) \Mwedge {}\\{}
 ((\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \Mvee  \tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch}) \implies  \Mtrue  \tsholcomm{ FIXME }) \Mwedge {}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{sock}.\tsvar{ps}_{1},\tsunknown{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{sock}.\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound}) \Mwedge {}\\{}
 \tsaux{dosend}(\tsvar{h}_{0}.\tsvar{ifds},\tsvar{h}_{0}.\tsvar{rttab},(\tsvar{addr},\tsvar{str}),(\tsvar{sock}.\tsvar{is}_{1},\Msome  \;\tsvar{p}'_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}),\tsvar{h}_{0}.\tsvar{oq},\tsvar{oq}',\Mfalse ) \Mwedge {}\\{}
 ((\tsvar{addr} \neq  *) \Mvee  (\tsvar{sock}.\tsvar{is}_{2} \neq  *))}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ that is not shutdown for writing and has no
    pending errors. A $\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call is made from thread $\tsvar{tid}$ which is
    in the $\tscon{Run}$ state.

    Either the socket is a blocking one: its $\tscon{O\_NONBLOCK}$ flag is not set, or the call is a
    blocking one: the $\tscon{MSG\_DONTWAIT}$ flag is not set in $\tsvar{opts}_{0}$.

    The socket is either bound to local port $\tsvar{p}'_{1}$ or can be autobound to a port $\tsvar{p}'_{1}$.  Either
    the socket has its peer IP address set, or the destination address of the $\tsunknown{send}()$ call is
    set: $\tsvar{addr}\neq *$.

    A UDP datagram, constructed from the socket's binding quad $\tsvar{sock}.\tsvar{is}_{1},\Msome
\tsvar{p}'_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}$, the destination address argument $\tsvar{addr}$, and the data $\tsvar{str}$, cannot
    be placed on the outqueue of the host $\tsvar{oq}$.

    The call blocks, waiting for the datagram to be enqueued on the host's outqueue. The thread is
    left in state $\tscon{Send2}(\tsvar{sid},\Msome (\tsvar{addr},\tsvar{sock}.\tsvar{is}_{1},\Msome  \;\tsvar{p}'_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}),\tsvar{str},\tsvar{opts})$. If the
    socket was autobound to a port then $\tsvar{sid}$ is appended to the head of the host's list of bound
    sockets.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tsunknown{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.

    The $\tsvar{opts}_{0}$ argument is of type $\tstype{list}$. In the model it is converted to a $\tstype{set}$ $\tsvar{opts}$
    using $\tsholop{LIST\_TO\_SET}$. The presence of $\tscon{MSG\_PEEK}$ is checked for in $\tsvar{opts}$ rather than in
    $\tsvar{opts}_{0}$.


\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    The $\tscon{MSG\_DONTWAIT}$ flag may be set in $\tsvar{opts}_{0}$: it is ignored by FreeBSD.

\\\hline
Linux
&
    The $\tscon{MSG\_OOB}$ flag must not be set in $\tsvar{opts}_{0}$.

\\\hline
WinXP
&
    The $\tscon{MSG\_OOB}$ flag must not be set in $\tsvar{opts}_{0}$, and any pending error on the socket is
    ignored.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXI}{\rrulecc{sendTXI}{send\_11}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EAGAIN}$: call would block and non-blocking behaviour has been requested }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EAGAIN}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}'_{1}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{cantsndmore} = \Mfalse  \Mwedge {}\\{}
 (\neg{}(\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch}) \implies  \tsvar{es} = *) \Mwedge {}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{sock}.\tsvar{ps}_{1},\tsunknown{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{sock}.\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound}) \Mwedge {}\\{}
 ((\tsvar{addr} \neq  *) \Mvee  (\tsvar{sock}.\tsvar{is}_{2} \neq  *)) \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 ((\neg{}\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts}) \Mvee  \tsvar{ff}.\tsunknown{b}(\tscon{O\_NONBLOCK})) \Mwedge {}\\{}
 \tsaux{dosend}(\tsvar{h}_{0}.\tsvar{ifds},\tsvar{h}_{0}.\tsvar{rttab},(\tsvar{addr},\tsvar{str}),(\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{ps}_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}),\tsvar{h}_{0}.\tsvar{oq},\tsvar{oq}',\Mfalse )}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ that is not shutdown for writing and has no
    pending errors. The thread $\tsvar{tid}$ is in the $\tscon{Run}$ state and a call $\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE}
\tsvar{str},\tsvar{opts}_{0}$ is made.

    The socket is either locally bound to a port $\tsvar{p}'_{1}$ or can be autobound to a port $\tsvar{p}'_{1}$.
    Either the socket has a peer IP address set, or a destination address was provided in the
    $\tsunknown{send}()$ call: $\tsvar{addr}\neq *$.

    Either the socket is non-blocking: its $\tscon{O\_NONBLOCK}$ flag is set, or the call is non-blocking:
    $\tscon{MSG\_DONTWAIT}$ flag was set in the $\tsvar{opts}_{0}$ argument of $\tsunknown{send}()$.

    A UDP datagram (constructed from the socket's binding quad
    $(\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{ps}_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2})$, the destination address argument $\tsvar{addr}$, and the data
    $\tsvar{str}$) cannot be placed on the outqueue of the host $\tsvar{oq}$.

    The $\tsunknown{send}()$ call fails with an $\tsunknown{EAGAIN}$ error. A $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made, leaving the thread state $\tscon{FAIL}\;{(\tsunknown{EAGAIN})}$, and the host
    with outqueue $\tsvar{oq}'$. If the socket was autobound to a port, $\tsvar{sid}$ is appended to the host's
    list of bound sockets.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tsunknown{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.

    The $\tsvar{opts}_{0}$ argument is of type $\tstype{list}$. In the model it is converted to a $\tstype{set}$ $\tsvar{opts}$
    using $\tsholop{LIST\_TO\_SET}$. The presence of $\tscon{MSG\_PEEK}$ is checked for in $\tsvar{opts}$ rather than in
    $\tsvar{opts}_{0}$.

    Note that on Linux $\tscon{EWOULDBLOCK}$ and $\tsunknown{EAGAIN}$ are aliased.



\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    The socket's $\tscon{O\_NONBLOCK}$ flag must be set for the rule to apply; the $\tscon{MSG\_DONTWAIT}$ flag is
    ignored by FreeBSD.

\\\hline
WinXP
&
    Pending errors on the socket are ignored.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXII}{\rrulecc{sendTXII}{send\_12}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{ENOTCONN}$: no peer address set in socket and no destination address provided }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{ \tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}'_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\Mif  \;\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{err}=\tsunknown{EDESTADDRREQ}{}\\{}
\quad \Melse                     \;\tsvar{err}=\tsunknown{ENOTCONN}) \Mwedge {}\\{}
 (\neg{}(\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch}) \implies  \tsvar{es} = *) \Mwedge {}\\{}
 (\Mif  \;\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen {}\\{}
\quad\quad\quad \exists \tsvar{p}'_{1}. \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{ps}_{1},\tsunknown{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge  \tsvar{ps}'_{1} = \Msome  \;\tsvar{p}'_{1} \Mwedge {}\\{}
\quad\quad\quad (\Mif  \;\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound}){}\\{}
\quad \Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound} \Mwedge  \tsvar{ps}'_{1} = \tsvar{ps}_{1})}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ that has no pending errors.

    A call $\tsunknown{send}(\tsvar{fd},\tsunknown{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0}$ is made from thread $\tsvar{tid}$ which is in the $\tscon{Run}$
    state. The socket is either locally bound to a port $\tsvar{p}'_{1}$ or it can be autobound to a port
    $\tsvar{p}'_{1}$.

    The socket does not have a peer address set, and no destination address is specified in the
    $\tsunknown{send}()$ call: $\tsunknown{addr} = *$. The call will fail with an $\tsunknown{ENOTCONN}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition will be made, leaving the thread
    in state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOTCONN}}$. If the socket was autobound then $\tsvar{sid}$ is appended to the
    head of the host's list of bound sockets, $\tsvar{h}_{0}.\tsvar{bound}$, resulting in the new list $\tsvar{bound}$.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tsunknown{send}()$ call but is a $\tstype{byte} \;\tstype{list}$ when the
    datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte} \;\tstype{list}$ and in the transition
    $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    On FreeBSD the error returned is $\tsunknown{EDESTADDRREQ}$, the socket must not be shut down for writing,
    and if it is not bound to a local port it will not be autobound.

\\\hline
WinXP
&
    Any pending error on the socket is ignored, and if the socket's local port is not bound, $\tsvar{ps}_{1} =
*$, then it will not be autobound.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXIII}{\rrulecc{sendTXIII}{send\_13}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EMSGSIZE}$: string to be sent is bigger than $\tsunknown{UDPpayloadMax}$ }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EMSGSIZE}})}{ \tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{ps}_{1} \Mass  \tsvar{ps}'_{1}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsunknown{STRLEN} (\tsholop{IMPLODE} \;\tsvar{str}) > \tsunknown{UDPpayloadMax} \;\tsvar{h}_{0}.\tsvar{arch} \Mvee {}\\{}
\quad\quad (\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsunknown{STRLEN} (\tsholop{IMPLODE} \;\tsvar{str}) > (\tsvar{h}_{0}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{sf}.\tsunknown{n}(\tscon{SO\_SNDBUF}))) \Mwedge {}\\{}
 \tsvar{ps}'_{1} \;\in  \{\tsvar{sock}.\tsvar{ps}_{1}\} \cup  (\tsholop{IMAGE} (\Msome ) (\tsaux{autobind}(\tsvar{sock}.\tsvar{ps}_{1},\tsunknown{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}))) \Mwedge {}\\{}
 (\Mif  \;\tsvar{sock}.\tsvar{ps}_{1} = * \Mwedge  \tsvar{ps}'_{1} \neq  * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound})}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. A call $\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ is
    made from thread $\tsvar{tid}$ which is in the $\tscon{Run}$ state.

    The length in bytes of $\tsvar{str}$ is greater than $\tsunknown{UDPpayloadMax}$, the architecture-dependent
    maximum payload size for a UDP datagram. The $\tsunknown{send}()$ call fails with an $\tsunknown{EMSGSIZE}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made leaving the thread in
    state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EMSGSIZE}})$.  Additionally, the socket's local port $\tsvar{ps}_{1}$ may be autobound
    if it was not bound to a local port when the $\tsunknown{send}()$ call was made. If the autobinding
    occurs, then the socket's $\tsvar{sid}$ is added to the list of bound sockets $\tsvar{h}_{0}.\tsvar{bound}$, leaving
    the host's list of bound sockets as $\tsvar{bound}$.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tsunknown{send}()$ call but is a $\tstype{byte} \;\tstype{list}$ when the
    datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte} \;\tstype{list}$ and in the transition
    $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    On FreeBSD, the $\tsunknown{send}()$ call may also fail with $\tsunknown{EMSGSIZE}$ if the size of $\tsvar{str}$ is
    greater than the value of the socket's $\tscon{SO\_SNDBUF}$ option.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXIV}{\rrulecc{sendTXIV}{send\_14}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EAGAIN}$, $\tsunknown{EADDRNOTAVAIL}$ or $\tsunknown{ENOBUFS}$: there are no ephemeral ports left }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,*,*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{ \tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,*,*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{cantsndmore} = \Mfalse  \Mwedge {}\\{}
 (\neg{}(\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch}) \implies  \tsvar{es} = *) \Mwedge {}\\{}
 \tsaux{autobind}(*,\tsunknown{PROTO\_UDP},\tsvar{h},\tsvar{h}.\tsvar{socks}) = \emptyset  \Mwedge {}\\{}
 \tsvar{e} \;\in  \{\tsunknown{EAGAIN}; \tsunknown{EADDRNOTAVAIL}; \tsunknown{ENOBUFS}\}}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ that is not shutdown for writing and has no
    pending errors. The socket has no peer address set, and is not bound to a local IP address or
    port.

    From the $\tscon{Run}$ state, thread $\tsvar{tid}$ makes a $\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call.  The
    socket cannot be auto-bound to an ephemeral port so the call fails. The error returned will be
    $\tsunknown{EAGAIN}$, $\tsunknown{EADDRNOTAVAIL}$, or $\tsunknown{ENOBUFS}$.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition will be made. The thread will be
    left in state $\tsunknown{RET} (\tscon{FAIL}\;{\tsvar{e}})$ where $\tsvar{e}$ is one of the above errors.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tsunknown{send}()$ call but is a $\tstype{byte} \;\tstype{list}$ when the
    datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte} \;\tstype{list}$ and in the transition
    $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.


\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    Any pending error on the socket is ignored.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXV}{\rrulecc{sendTXV}{send\_15}{udp: slow urgent succeed}{\tsholcomm{ Return from blocked state after datagram enqueued }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Send2}(\tsvar{sid},\Msome  (\tsvar{addr},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsvar{str},\tsvar{opts})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{OK} (\text{``''}))}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{sock}.\tsvar{cantsndmore} = \Mfalse  \Mwedge {}\\{}
 (\neg{}(\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch}) \implies  \tsvar{es} = *) \Mwedge {}\\{}
 \tsunknown{STRLEN} (\tsholop{IMPLODE} \;\tsvar{str}) \leq  \tsunknown{UDPpayloadMax} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 (\tsaux{dosend}(\tsvar{h}.\tsvar{ifds},\tsvar{h}.\tsvar{rttab},(\tsvar{addr},\tsvar{str}),(\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsvar{h}.\tsvar{oq},\tsvar{oq}',\Mtrue ) \Mvee {}\\{}
\quad \tsaux{dosend}(\tsvar{h}.\tsvar{ifds},\tsvar{h}.\tsvar{rttab},(\tsvar{addr},\tsvar{str}),(\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{ps}_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}),\tsvar{h}.\tsvar{oq},\tsvar{oq}',\Mtrue )) \Mwedge {}\\{}
 (\tsvar{addr} \neq  * \Mvee  \tsvar{sock}.\tsvar{is}_{2} \neq  * \Mvee  \tsvar{is}_{2} \neq  *)}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ that is not shutdown for writing and has no pending errors. The
    thread $\tsvar{tid}$ is blocked in state $\tscon{Send2}(\tsvar{sid},\Msome (\tsvar{addr},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsvar{str})$.

    A datagram can be constructed using $\tsvar{str}$ as its data. The length in bytes of $\tsvar{str}$ is less
    than or equal to $\tsunknown{UDPpayloadMax}$, the architecture-dependent maximum payload size for a UDP
    datagram. There are three possible destination addresses:

    \begin{itemize}
      \item $\tsvar{addr}$, the destination address specified in the $\tsunknown{send}()$ call.
      \item $\tsvar{is}_{2},\tsvar{ps}_{2}$, the socket's peer address when the $\tsunknown{send}()$ call was made.
      \item $\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}$, the socket's current peer address.
    \end{itemize}

    At least one of $\tsvar{addr}$, $\tsvar{is}_{2}$, and $\tsvar{sock}.\tsvar{is}_{2}$ must specify an IP address: they are not all
    set to $*$. One of the three addresses will be used as the destination address of the
    datagram.  The datagram can be successfully enqueued on the host's outqueue, $\tsvar{h}.\tsvar{oq}$, resulting
    in a new outqueue $\tsvar{oq}'$.

    An $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}(\text{``''}))$, and the host
    with new outqueue $\tsvar{oq}'$.

\rrulepad }
}

\newcommand{\sendTXVI}{\rrulecc{sendTXVI}{send\_16}{udp: slow urgent fail}{\tsholcomm{ Fail: blocked socket has entered an error state }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Send2}(\tsvar{sid},\Msome  (\tsvar{addr},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsvar{str})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsvar{e}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  *; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\neg{}(\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch})}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ that has pending error $\Msome  \;\tsvar{e}$. The thread $\tsvar{tid}$ is blocked
    in state $\tscon{Send2}(\tsvar{sid},\Msome  (\tsvar{addr},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsvar{str})$. The error, $\tsvar{e}$, will be returned to
    the caller.

    At $\MLhtau $ transition is made, leaving the thread state $\tsunknown{RET} (\tscon{FAIL}\;{\tsvar{e}})$.

    Note that the error has occurred after the thread entered the $\tscon{Send2}$ state: rule $\tsunknown{send\_11}$
    specifies that the call cannot block if there is a pending error.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    This rule does not apply: all pending errors on a socket are ignored for a $\tsunknown{send}()$ call.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXVII}{\rrulecc{sendTXVII}{send\_17}{udp: slow urgent fail}{\tsholcomm{ Fail with $\tsunknown{EMSGSIZE}$ or $\tsunknown{ENOTCONN}$: blocked socket has had peer address unset or string to be sent is too big }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Send2}(\tsvar{sid},\Msome (\tsvar{addr},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsvar{str},\tsvar{opts})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{sf} \Mass  \tsvar{sf}; \tsvar{es} \Mass  \tsvar{es}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{sf} \Mass  \tsvar{sf}; \tsvar{es} \Mass  \tsvar{es}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{(\neg{}(\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch}) \implies  \tsvar{es} = *) \Mwedge {}\\{}
 (\exists \tsvar{oq}'. \tsaux{dosend}(\tsvar{h}.\tsvar{ifds},\tsvar{h}.\tsvar{rttab},(\tsvar{addr},\tsvar{str}),(\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsvar{h}.\tsvar{oq},\tsvar{oq}',\Mtrue )) \Mwedge {}\\{}
 ((\tsunknown{STRLEN} (\tsholop{IMPLODE} \;\tsvar{str}) > \tsunknown{UDPpayloadMax} \;\tsvar{h}.\tsvar{arch} \Mwedge  (\tsvar{e} = \tsunknown{EMSGSIZE})) \Mvee {}\\{}
\quad (\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsunknown{STRLEN} (\tsholop{IMPLODE} \;\tsvar{str}) > \tsvar{sf}.\tsunknown{n}(\tscon{SO\_SNDBUF}) \Mwedge  (\tsvar{e} = \tsunknown{EMSGSIZE})) \Mvee {}\\{}
\quad ((\tsvar{sock}.\tsvar{is}_{2} = *) \Mwedge  (\tsvar{addr} = *) \Mwedge  (\tsvar{e} = \tsunknown{ENOTCONN})))}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ with no pending errors. The thread $\tsvar{tid}$ is blocked in state
    $\tscon{Send2}(\tsvar{sid},\Msome (\tsvar{addr},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsvar{str})$.

    A datagram is constructed with $\tsvar{str}$ as its payload. Its destination address is taken from
    $\tsvar{addr}$, the destination address specified when the $\tsunknown{send}()$ call was made, or
    $(\tsvar{is}_{2},\tsvar{ps}_{2})$, the socket's peer address when the $\tsunknown{send}()$ call was made. It is possible to
    enqueue the datagram on the host's outqueue, $\tsvar{h}.\tsvar{oq}$.

    This rule covers two cases. In the first, the length in bytes of $\tsvar{str}$ is greater than
    $\tsunknown{UDPpayloadMax}$, the architecture-dependent maximum payload size for a UDP datagram. The error
    $\tsunknown{EMSGSIZE}$ is returned.

    In the second case, the original $\tsunknown{send}()$ call did not have a destination address specified:
    $\tsvar{addr} = *$, and the socket has had the IP address of its peer address unset:
    $\tsvar{sock}.\tsvar{is}_{2}=*$.  The peer address of the socket when the $\tsunknown{send}()$ call was made,
    $(\tsvar{is}_{2},\tsvar{ps}_{2})$, is ignored, and an $\tsunknown{ENOTCONN}$ error is returned.

    In either case, a $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$
    where $\tsvar{e}$ is either $\tsunknown{EMSGSIZE}$ or $\tsunknown{ENOTCONN}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    An $\tsunknown{EMSGSIZE}$ error can also be returned if the size of $\tsvar{str}$ is greater than the value of
    the socket's $\tscon{SO\_SNDBUF}$ option.

\\\hline
WinXP
&
    Any pending error on the socket is ignored.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXVIII}{\rrulecc{sendTXVIII}{send\_18}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EOPNOTSUPP}$: $\tscon{MSG\_PEEK}$ flag not supported for $\tsunknown{send}()$ calls on WinXP; or $\tscon{MSG\_OOB}$ flag not supported on WinXP and Linux  }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EOPNOTSUPP}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{ps}_{1} \Mass  \tsvar{ps}'_{1}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{ps}_{1} \Mass  \tsvar{ps}_{1}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec  )] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 (\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \Mwedge  \tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch}) \Mwedge {}\\{}
 (\Mif  \;\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen {}\\{}
\quad\quad \exists \tsvar{p}'_{1}. \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{ps}_{1},\tsunknown{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge  \tsvar{ps}'_{1} = \Msome  \;\tsvar{p}'_{1} \Mwedge {}\\{}
\quad\quad (\Mif  \;\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound}){}\\{}
 \Melse {}\\{}
\quad\quad \tsvar{ps}_{1} = \tsvar{ps}'_{1} \Mwedge  \tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound})}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$
    state, a $\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call is made.

    This rule covers two cases. In the first, on WinXP, the $\tscon{MSG\_PEEK}$ flag is set in
    $\tsvar{opts}_{0}$. In the second case, on Linux and WinXP, the socket has not been shut down for
    writing, and the $\tscon{MSG\_OOB}$ flag is set in $\tsvar{opts}_{0}$. In either case, the $\tsunknown{send}()$ call fail
    with an $\tsunknown{EOPNOTSUPP}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made, leaving the thread in
    state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EOPNOTSUPP}})$.

\rulesubsection{Model details}

    The $\tsvar{opts}_{0}$ argument is of type $\tstype{list}$. In the model it is converted to a $\tstype{set}$ $\tsvar{opts}$
    using $\tsholop{LIST\_TO\_SET}$. The presence of $\tscon{MSG\_PEEK}$ is checked for in $\tsvar{opts}$ rather than in
    $\tsvar{opts}_{0}$.



\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    FreeBSD ignores the $\tscon{MSG\_PEEK}$ and $\tscon{MSG\_OOB}$ flags for $\tsunknown{send}()$.

\\\hline
Linux
&
    Linux ignores the $\tscon{MSG\_PEEK}$ flag for $\tsunknown{send}()$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXIX}{\rrulecc{sendTXIX}{send\_19}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EADDRINUSE}$: on FreeBSD, local and destination address quad in use by another socket }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\Msome  (\tsvar{i}_{2},\tsvar{p}_{2}),\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EADDRINUSE}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{cantsndmore} = \Mfalse  \Mwedge {}\\{}
 (\neg{}(\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch}) \implies  \tsvar{sock}.\tsvar{es} = *) \Mwedge {}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{sock}.\tsvar{ps}_{1},\tsunknown{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{sock}.\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound}) \Mwedge {}\\{}
 \tsvar{i}'_{1} \;\in  \;\tsunknown{auto\_outroute}(\tsvar{i}_{2},\tsvar{sock}.\tsvar{is}_{1},\tsvar{h}_{0}.\tsvar{rttab},\tsvar{h}_{0}.\tsvar{ifds}) \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = (\tsvar{h}_{0}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}) \Mwedge {}\\{}
 \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tsunknown{PROTO\_UDP} \Mwedge {}\\{}
 (\exists \tsvar{sid}'.{}\\{}
\quad \tsvar{sid}' \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{socks}} \Mwedge {}\\{}
\quad \Mlet  \;\tsunknown{s} = \tsvar{h}_{0}.\tsvar{socks} \Mfapply{}{\tsvar{sid}'} \Min {}\\{}
\quad \tsunknown{s}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}'_{1} \Mwedge  \tsunknown{s}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}'_{1} \Mwedge {}\\{}
\quad \tsunknown{s}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2}  \Mwedge  \tsunknown{s}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}  \Mwedge {}\\{}
\quad \tsaux{proto\_of} \;\tsunknown{s}.\tsvar{pr} = \tsunknown{PROTO\_UDP})}
{\rulesubsection{Description}

    On FreeBSD, consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ that is not shutdown for
    writing. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{send}(\tsvar{fd},\Msome (\tsvar{i}_{2},\tsvar{p}_{2}),\tsholop{IMPLODE}
\tsvar{str},\tsvar{opts}_{0})$ call is made. The socket is bound to local port $\tsvar{p}'_{1}$ or it can be autobound to
    port $\tsvar{p}'_{1}$. The socket can be bound to a local IP address $\tsvar{i}'_{1}$ which has a route to
    $\tsvar{i}_{2}$. Another socket, $\tsvar{sid}'$, is locally bound to $(\tsvar{i}'_{1},\tsvar{p}'_{1})$ and has its peer address set
    to $(\tsvar{i}_{2},\tsvar{p}_{2})$. The $\tsunknown{send}()$ call will fail with an $\tsunknown{EADDRINUSE}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\Msome (\tsvar{i}_{2},\tsvar{p}_{2}),\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition will be made, leaving the
    thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EADDRINUSE}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    This rule does not apply.

\\\hline
WinXP
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXXI}{\rrulecc{sendTXXI}{send\_21}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EISCONN}$: socket has peer address set and destination address is specified in call on FreeBSD }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  *; \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i}_{2}; \tsvar{ps}_{2} \Mass  \Msome  \;\tsvar{p}_{2}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp})  \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\Msome (\tsvar{i}_{3},\tsvar{p}_{3}),\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EISCONN}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  *; \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i}_{2}; \tsvar{ps}_{2} \Mass  \Msome  \;\tsvar{p}_{2}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp})  \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch}}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ that has its peer address set: $\tsvar{is}_{2} = \Msome
\tsvar{i}_{2}$, and $\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}$. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a
    $\tsunknown{send}(\tsvar{fd},\Msome (\tsvar{i}_{3},\tsvar{p}_{3}),\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call is made. On FreeBSD, the call will fail with the
    $\tsunknown{EISCONN}$ error, as the call specified a destination address even though the socket has a peer
    address set.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\Msome (\tsvar{i}_{3},\tsvar{p}_{3}),\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition will be made, leaving the
    thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EISCONN}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    If the socket is connectionless-mode, the message shall be sent to the address specified by
    $\Msome (\tsvar{i}_{3},\tsvar{p}_{3})$. See the above $\tsunknown{send}()$ rules.

\\\hline
Linux
&
    This rule does not apply. Linux allows the $\tsunknown{send}()$ call to occur. See the above $\tsunknown{send}()$
    rules.

\\\hline
WinXP
&
    This rule does not apply. WinXP allows the $\tsunknown{send}()$ call to occur. See the above $\tsunknown{send}()$
    rules.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXXII}{\rrulecc{sendTXXII}{send\_22}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{EPIPE}$ or $\tsunknown{ESHUTDOWN}$: socket shut down for writing }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\Mtrue ,\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\Mtrue ,\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{err} = \tsunknown{ESHUTDOWN}{}\\{}
 \Melse                         \;\tsvar{err} = \tsunknown{EPIPE}}
{\rulesubsection{Description}

     From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call
     is made where $\tsvar{fd}$ refers to a UDP socket $\tsvar{sid}$ that is shut down for writing. The call
     fails with an $\tsunknown{EPIPE}$ error.

     A $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made, leaving the thread in
     state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EPIPE}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
     The call fails with an $\tsunknown{ESHUTDOWN}$ error rather than $\tsunknown{EPIPE}$.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXXIII}{\rrulecc{sendTXXIII}{send\_23}{udp: fast fail}{\tsholcomm{ Fail with pending error }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsvar{e} \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  * \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tsunknown{PROTO\_UDP} \Mwedge {}\\{}
 \neg{}(\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call
    is made where $\tsvar{fd}$ refers to a UDP socket $\tsvar{sid}$ that has pending error $\Msome  \;\tsvar{e}$.  The call
    fails, returning the pending error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made, leaving the thread in
    state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    This rule does not apply: all pending errors are ignored for $\tsunknown{send}()$ calls on WinXP.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommsetfileflags}{\clustersection{(TCP and UDP)}{$\tsunknown{setfileflags}()$}
\seccomm{ \[ \tsunknown{setfileflags}: (\tsunknown{fd} * \tsunknown{filebflag} \;\tstype{list}) \Mtotype  \tstype{unit} \]

  A call to $\tsunknown{setfileflags}(\tsunknown{fd},\tsunknown{flags})$ sets the flags on a file referred to by $\tsunknown{fd}$. $\tsunknown{flags}$ is
  the list of file flags to set. The possible flags are:

  \begin{itemize}
    \item $\tscon{O\_ASYNC}$ Specifies whether signal driven I/O is enabled.
    \item $\tscon{O\_NONBLOCK}$ Specifies whether a socket is non-blocking.
  \end{itemize}

  The call returns successfully if the flags were set, or fails with an error otherwise.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{setfileflags}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsunknown{setfileflags\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tsunknown{setfileflags}()$ is Posix \wasverb{fcntl(fd,F\textunderscore{}GETFL,flags)}. On WinXP it is
  \wasverb{ioctlsocket()} with the \wasverb{FIONBIO} command.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int fcntl(int fildes, int cmd, ...);}\\
    FreeBSD: & \wasverb{int fcntl(int fd, int cmd, ...);}\\
    Linux:   & \wasverb{int fcntl(int fd, int cmd);}\\
    WinXP:   & \wasverb{int ioctlsocket(SOCKET s, long cmd, u\textunderscore{}long* argp)}
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{fildes} is a file descriptor for the file to retrieve flags from. It corresponds
     to the $\tsunknown{fd}$ argument of the model $\tsunknown{setfileflags}()$. On WinXP the \wasverb{s} is a socket
     descriptor corresponding to the $\tsunknown{fd}$ argument of the model $\tsunknown{setfileflags}()$.

    \item \wasverb{cmd} is a command to perform an operation on the file. This is set to
     \wasverb{F\textunderscore{}GETFL} for the model $\tsunknown{setfileflags}()$. On WinXP, \wasverb{cmd} is set to
     \wasverb{FIONBIO} to get the $\tscon{O\_NONBLOCK}$ flag; there is no $\tscon{O\_ASYNC}$ flag on WinXP.

    \item The call takes a variable number of arguments. For the model $\tsunknown{setfileflags}()$ it takes
     three arguments: the two described above and a third of type \wasverb{long} which represents
     the list of flags to set, corresponding to the $\tsunknown{flags}$ argument of the model
     $\tsunknown{setfileflags}()$. On WinXP this is the \wasverb{argp} argument.

    \item The returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

    \item \wasverb{WSAENOTSOCK} is a possible error on WinXP as the \wasverb{ioctlsocket()} call is
     specific to a socket. In the model the $\tsunknown{setfileflags}()$ call is performed on a file.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{setfileflags\_1}$
& \textbf{all: fast succeed}
&  Update all the file flags for an open file description \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\setfileflagsTI}{\rrulecc{setfileflagsTI}{setfileflags\_1}{all: fast succeed}{\tsholcomm{ Update all the file flags for an open file description }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus  [(\tsvar{fid},\tscon{File}(\tsvar{ft},\tsvar{ff} \; \Mmagiclrec  \tsunknown{b}\Mass \tsvar{ffb} \Mmagicrrec ))] \Mmagicrrec {}\\{}
 ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{setfileflags}(\tsvar{fd},\tsvar{flags})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus  [(\tsvar{fid},\tscon{File}(\tsvar{ft},\tsvar{ff} \; \Mmagiclrec  \tsunknown{b}\Mass \tsvar{ffb}' \Mmagicrrec ))] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{ffb}' = \lambda \tsvar{x}. \tsvar{x} \;\in  \;\tsvar{flags}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{setfileflags}(\tsvar{fd},\tsvar{flags})$ call is
    made. $\tsvar{fd}$ refers to the open file description $(\tsvar{fid},\tscon{File}(\tsvar{ft},\tsvar{ff} \; \Mmagiclrec  \tsunknown{b} \Mass  \tsvar{ffb} \Mmagicrrec ))$ where
    $\tsvar{ffb}$ is the set of boolean file flags currently set. $\tsvar{flags}$ is a list of boolean file
    flags, possibly containing duplicates.

    All of the boolean file flags for the file description will be updated. The flags in $\tsvar{flags}$
    will all be set to $\Mtrue $, and all other flags will be set to $\Mfalse $, resulting in a new set of
    boolean file flags, $\tsvar{ffb}'$.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{setfileflags}(\tsvar{fd},\tsvar{flags})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$.


     Note this is not exactly the same as $\tsunknown{getfileflags\_1}$:
         $\tsunknown{getfileflags}$ never returns duplicates, but duplicates may be
         passed to $\tsunknown{setfileflags}$.

\rrulepad }
}

\newcommand{\seccommsetsockbopt}{\clustersection{(TCP and UDP)}{$\tsunknown{setsockbopt}()$}
\seccomm{  \[ \tsunknown{setsockbopt}: (\tsunknown{fd} * \tsunknown{sockbflag} * \tstype{bool}) \Mtotype  \tstype{unit} \]

  A call $\tsunknown{setsockbopt}(\tsunknown{fd},\tsunknown{f},\tsunknown{b})$ sets the value of one of a socket's boolean flags.

  Here the $\tsunknown{fd}$ argument is a file descriptor referring to a socket on which to set a flag, $\tsunknown{f}$ is
  the boolean socket flag to set, and $\tsunknown{b}$ is the value to set it to. Possible boolean flags are:

  \begin{itemize}

    \item $\tscon{SO\_BSDCOMPAT}$ Specifies whether the BSD semantics for delivery of ICMPs to UDP sockets
     with no peer address set is enabled.

    \item $\tscon{SO\_DONTROUTE}$ Requests that outgoing messages bypass the standard routing
     facilities. The destination shall be on a directly-connected network, and messages are directed
     to the appropriate network interface according to the destination address.

    \item $\tscon{SO\_KEEPALIVE}$ Keeps connections active by enabling the periodic transmission of
     messages, if this is supported by the protocol.

    \item $\tscon{SO\_OOBINLINE}$ Leaves received out-of-band data (data marked urgent) inline.

    \item $\tscon{SO\_REUSEADDR}$ Specifies that the rules used in validating addresses supplied to
     $\tsunknown{bind}()$ should allow reuse of local ports, if this is supported by the protocol.

  \end{itemize}

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{setsockbopt}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tsunknown{ENOPROTOOPT}$
&  The option is not supported by the protocol.

\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsunknown{setsockbopt\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tsunknown{setsockbopt}()$ is Posix \wasverb{setsockopt()} for boolean-valued socket flags.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int setsockopt(int socket, int level, int option\textunderscore{}name,} \\
             & \wasverb{               const void *option\textunderscore{}value,}\\
             & \wasverb{               socklen\textunderscore{}t option\textunderscore{}len);}\\
    FreeBSD: & \wasverb{int setsockopt(int s, int level, int optname, } \\
             & \wasverb{               const void *optval, socklen\textunderscore{}t optlen);} \\
    Linux:   & \wasverb{int setsockopt(int s, int  level,  int  optname,} \\
             & \wasverb{               const  void  *optval, socklen\textunderscore{}t optlen);} \\
    WinXP:   & \wasverb{int setsockopt(SOCKET s, int level, int optname,} \\
             & \wasverb{               const char* optval,int optlen);}
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to set the option on, corresponding
     to the $\tsunknown{fd}$ argument of the model $\tsunknown{setsockbopt}()$.

    \item \wasverb{level} is the protocol level at which the flag resides: \wasverb{SOL\textunderscore{}SOCKET} for
     the socket level options, and \wasverb{option\textunderscore{}name} is the flag to be set. These two
     correspond to the $\tsunknown{flag}$ argument of the model $\tsunknown{setsockbopt}()$ where the possible values of
     \wasverb{option\textunderscore{}name} are limited to: $\tscon{SO\_BSDCOMPAT}$, $\tscon{SO\_DONTROUTE}$, $\tscon{SO\_KEEPALIVE}$,
     $\tscon{SO\_OOBINLINE}$, and $\tscon{SO\_REUSEADDR}$.

    \item \wasverb{option\textunderscore{}value} is a pointer to a location of size \wasverb{option\textunderscore{}len}
     containing the value to set the flag to. These two correspond to the $\tsunknown{b}$ argument of type
     $\tstype{bool}$ in the model $\tsunknown{setsockbopt}()$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EFAULT} signifies the pointer passed as \wasverb{option\textunderscore{}value} was
     inaccessible. On WinXP, the error \wasverb{WSAEFAULT} may also signify that the
     \wasverb{optlen} parameter was too small. Note this error is not specified by Posix.

    \item \wasverb{EINVAL} signifies the \wasverb{option\textunderscore{}name} was invalid at the specified socket
     \wasverb{level}. In the model, typing prevents an invalid flag from being specified in a call
     to $\tsunknown{setsockbopt}()$.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{setsockbopt\_1}$
& \textbf{all: fast succeed}
&  Successfully set a boolean socket flag \\
$\tsrule{setsockbopt\_2}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{ENOPROTOOPT}$: $\tscon{SO\_KEEPALIVE}$ and $\tscon{SO\_OOBINLINE}$ options not supported for a UDP socket on WinXP \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\setsockboptTI}{\rrulecc{setsockboptTI}{setsockbopt\_1}{all: fast succeed}{\tsholcomm{ Successfully set a boolean socket flag }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{setsockbopt}(\tsvar{fd},\tsvar{f},\tsvar{b})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{sf} \Mass  \tsvar{sock}.\tsvar{sf} \; \Mmagiclrec  \tsvar{b} \Mass  \Mfupdate{\tsvar{sock}.\tsvar{sf}.\tsvar{b}}{\tsvar{f}}{\tsvar{b}} \Mmagicrrec  \Mmagicrrec {}\\{}
\quad  \Mwedge {}\\{}
 {}\\{}
 (\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tsunknown{PROTO\_UDP}{}\\{}
\quad\quad \implies  \tsvar{f} \;\notin  \{\tscon{SO\_KEEPALIVE}\})}
{\rulesubsection{Description}

    Consider a socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, and with socket flags $\tsvar{sock}.\tsvar{sf}$. From thread
    $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{setsockbopt}(\tsvar{fd},\tsvar{f},\tsvar{b})$ call is made. $\tsvar{f}$ is the
    boolean socket flag to be set, and $\tsvar{b}$ is the boolean value to set it to. The call succeeds.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{setsockbopt}(\tsvar{fd},\tsvar{f},\tsvar{b})}$ is made, leaving the thread state $\tscon{Ret} (\tscon{OK}())$. The
    socket's boolean flags, $\tsvar{sock}.\tsvar{sf}.\tsvar{b}$, are updated such that $\tsvar{f}$ has the value $\tsvar{b}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    As above, except that if $\tsvar{sid}$ is a UDP socket, then $\tsvar{f}$ cannot be $\tscon{SO\_KEEPALIVE}$ or
    $\tscon{SO\_OOBINLINE}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\setsockboptTII}{\rrulecc{setsockboptTII}{setsockbopt\_2}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{ENOPROTOOPT}$: $\tscon{SO\_KEEPALIVE}$ and $\tscon{SO\_OOBINLINE}$ options not supported for a UDP socket on WinXP }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{setsockbopt}(\tsvar{fd},\tsvar{f},\tsvar{b})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOPROTOOPT}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{f} \;\in  \{\tscon{SO\_KEEPALIVE}\}}
{\rulesubsection{Description}

    On WinXP, consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in
    the $\tscon{Run}$ state, a $\tsunknown{setsockbopt}(\tsvar{fd},\tsvar{f},\tsvar{b})$ call is made, where $\tsvar{f}$ is either
    $\tscon{SO\_KEEPALIVE}$ or $\tscon{SO\_OOBINLINE}$. The call fails with an $\tsunknown{ENOPROTOOPT}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{setsockbopt}(\tsvar{fd},\tsvar{f},\tsvar{b})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsunknown{ENOPROTOOPT}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommsetsocknopt}{\clustersection{(TCP and UDP)}{$\tsunknown{setsocknopt}()$}
\seccomm{  \[ \tsunknown{setsocknopt}: (\tsunknown{fd} * \tsunknown{socknflag} * \tstype{int}) \Mtotype  \tstype{unit} \]

  A call $\tsunknown{setsocknopt}(\tsunknown{fd},\tsunknown{f},\tsunknown{n})$ sets the value of one of a socket's numeric flags. The $\tsunknown{fd}$
  argument is a file descriptor referring to a socket to set a flag on, $\tsunknown{f}$ is the numeric socket
  flag to set, and $\tsunknown{n}$ is the value to set it to. Possible numeric flags are:

  \begin{itemize}
    \item $\tscon{SO\_RCVBUF}$ Specifies the receive buffer size.

    \item $\tscon{SO\_RCVLOWAT}$ Specifies the minimum number of bytes to process for socket input
     operations.

     \item $\tscon{SO\_SNDBUF}$ Specifies the send buffer size.

     \item $\tscon{SO\_SNDLOWAT}$ Specifies the minimum number of bytes to process for socket output
      operations.
  \end{itemize}

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{setsocknopt}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tsunknown{EINVAL}$
&  On FreeBSD, attempting to set a numeric flag to zero.
\\\hline
$\tsunknown{ENOPROTOOPT}$
&  The option is not supported by the protocol.
\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsunknown{setsocknopt\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tsunknown{setsocknopt}()$ is Posix \wasverb{setsockopt()} for numeric-valued socket flags.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int setsockopt(int socket, int level, int option\textunderscore{}name,} \\
             & \wasverb{               const void *option\textunderscore{}value,}\\
             & \wasverb{               socklen\textunderscore{}t option\textunderscore{}len);}\\
    FreeBSD: & \wasverb{int setsockopt(int s, int level, int optname, } \\
             & \wasverb{               const void *optval, socklen\textunderscore{}t optlen);} \\
    Linux:   & \wasverb{int setsockopt(int s, int  level,  int  optname,} \\
             & \wasverb{               const  void  *optval, socklen\textunderscore{}t optlen);} \\
    WinXP:   & \wasverb{int setsockopt(SOCKET s, int level, int optname,} \\
             & \wasverb{               const char* optval,int optlen);}
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to set the option on, corresponding
     to the $\tsunknown{fd}$ argument of the model $\tsunknown{setsocknopt}()$.

    \item \wasverb{level} is the protocol level at which the flag resides: \wasverb{SOL\textunderscore{}SOCKET} for
     the socket level options, and \wasverb{option\textunderscore{}name} is the flag to be set. These two
     correspond to the $\tsunknown{flag}$ argument of the model $\tsunknown{setsocknopt}()$ where the possible values of
     \wasverb{option\textunderscore{}name} are limited to: $\tscon{SO\_RCVBUF}$, $\tscon{SO\_RCVLOWAT}$, $\tscon{SO\_SNDBUF}$, and
     $\tscon{SO\_SNDLOWAT}$.

    \item \wasverb{option\textunderscore{}value} is a pointer to a location of size \wasverb{option\textunderscore{}len}
     containing the value to set the flag to. These two correspond to the $\tsunknown{n}$ argument of type
     $\tstype{int}$ in the model $\tsunknown{setsocknopt}()$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EFAULT} signifies the pointer passed as \wasverb{option\textunderscore{}value} was
     inaccessible. On WinXP, the error \wasverb{WSAEFAULT} may also signify that the
     \wasverb{optlen} parameter was too small. Note this error is not specified by Posix.

    \item \wasverb{EINVAL} signifies the \wasverb{option\textunderscore{}name} was invalid at the specified socket
     \wasverb{level}. In the model, typing prevents an invalid flag from being specified in a call
     to $\tsunknown{setsocknopt}()$.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{setsocknopt\_1}$
& \textbf{all: fast succeed}
&  Successfully set a numeric socket flag \\
$\tsrule{setsocknopt\_2}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{EINVAL}$: on FreeBSD numeric socket flags cannot be set to zero \\
$\tsrule{setsocknopt\_4}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{ENOPROTOOPT}$: $\tscon{SO\_SNDLOWAT}$ not settable on Linux \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\setsocknoptTI}{\rrulecc{setsocknoptTI}{setsocknopt\_1}{all: fast succeed}{\tsholcomm{ Successfully set a numeric socket flag }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{n}' = \tsholop{MAX} (\tsunknown{sf\_min\_n} \;\tsvar{h}.\tsvar{arch} \;\tsvar{f}) (\tsholop{MIN} (\tsunknown{sf\_max\_n} \;\tsvar{h}.\tsvar{arch} \;\tsvar{f}) (\tsunknown{clip\_int\_to\_num} \;\tsvar{n})) \Mwedge {}\\{}
 \tsvar{ns} = (\Mif  \;\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsvar{f} = \tscon{SO\_SNDBUF} \Mwedge  \tsvar{n}' < \tsvar{sock}.\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDLOWAT}) \Mthen {}\\{}
\quad\quad\quad\quad\quad \Mfupdate{(\Mfupdate{\tsvar{sock}.\tsvar{sf}.\tsvar{n}}{\tsvar{f}}{\tsvar{n}'})}{\tscon{SO\_SNDLOWAT}}{\tsvar{n}'}{}\\{}
\quad\quad \Melse  \Mfupdate{\tsvar{sock}.\tsvar{sf}.\tsvar{n}}{\tsvar{f}}{\tsvar{n}'}) \Mwedge {}\\{}
 \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{sf} \Mass  \tsvar{sock}.\tsvar{sf} \; \Mmagiclrec  \tsvar{n} \Mass  \tsvar{ns} \Mmagicrrec  \Mmagicrrec }
{\rulesubsection{Description}

    Consider the socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, with numeric socket flags $\tsvar{sock}.\tsvar{sf}.\tsvar{n}$. From
    the thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})$ call is made where
    $\tsvar{f}$ is a numeric socket flag to be updated, and $\tsvar{n}$ is the integer value to set it to. The
    call succeeds.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$. The socket's numeric flag $\tsvar{f}$ is updated to be the value $\tsvar{n}'$ which is: the
    architecture-specific minimum value for $\tsvar{f}$ $\tsunknown{sf\_min\_n} \;\tsvar{h}.\tsvar{arch} \;\tsvar{f}$, if $\tsvar{n}$ is less than this
    value; the architecture-specific maximum value for $\tsvar{f}$, i.e.~$\tsunknown{sf\_max\_n} \;\tsvar{h}.\tsvar{arch} \;\tsvar{f}$, if $\tsvar{n}$ is
    greater than this value, or $\tsvar{n}$ otherwise.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    If the flag to be set is $\tscon{SO\_SNDBUF}$ and the new value $\tsvar{n}$ is less than the value of the
    socket's $\tscon{SO\_SNDLOWAT}$ flag then the $\tscon{SO\_SNDLOWAT}$ flag is also set to $\tsvar{n}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\setsocknoptTII}{\rrulecc{setsocknoptTII}{setsocknopt\_2}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{EINVAL}$: on FreeBSD numeric socket flags cannot be set to zero }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINVAL}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{clip\_int\_to\_num} \;\tsvar{n} = 0 \Mwedge {}\\{}
 \tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch}}
{\rulesubsection{Description}

    On FreeBSD, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})$ call
    is made where $\tsvar{fd}$ is a file descriptor, $\tsvar{f}$ is a numeric socket flag, and $\tsvar{n}$ is an
    integer value to set $\tsvar{f}$ to. Because the numeric value of $\tsvar{n}$ equals $0$, the call fails
    with an $\tsunknown{EINVAL}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsunknown{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.

\\\hline
WinXP
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\setsocknoptTIV}{\rrulecc{setsocknoptTIV}{setsocknopt\_4}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{ENOPROTOOPT}$: $\tscon{SO\_SNDLOWAT}$ not settable on Linux }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOPROTOOPT}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{f} = \tscon{SO\_SNDLOWAT}}
{\rulesubsection{Description}

    On Linux, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})$ call is
    made. $\tsvar{f} = \tscon{SO\_SNDLOWAT}$, which is not settable, so the call fails with an $\tsunknown{ENOPROTOOPT}$
    error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsunknown{ENOPROTOOPT}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\\\hline
WinXP
&
    This rule does not apply. Note the warning from the Win32 docs (at MSDN setsockopt):

    "If the setsockopt function is called before the bind function,
    TCP/IP options will not be checked with TCP/IP until the bind
    occurs. In this case, the setsockopt function call will always
    succeed, but the bind function call may fail because of an early
    setsockopt failing."

    This is currently unimplemented.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommsetsocktopt}{\clustersection{(TCP and UDP)}{$\tsunknown{setsocktopt}()$}
\seccomm{ \[ \tsunknown{setsocktopt}: (\tsunknown{fd} * \tsunknown{socktflag} * (\tstype{int} * \tstype{int}) \;\tstype{option}) \Mtotype  \tstype{unit} \]

  A call $\tsunknown{setsocktopt}(\tsunknown{fd},\tsunknown{f},\tsunknown{t})$ sets the value of one of a socket's time-option flags.

  The $\tsunknown{fd}$ argument is a file descriptor referring to a socket to set a flag on, $\tsunknown{f}$ is the
  time-option socket flag to set, and $\tsunknown{t}$ is the value to set it to. Possible time-option flags
  are:

  \begin{itemize}
    \item $\tscon{SO\_RCVTIMEO}$ Specifies the timeout value for input operations.

    \item $\tscon{SO\_SNDTIMEO}$ Specifies the timeout value that an output function blocks because flow
     control prevents data from being sent.
  \end{itemize}

  If $\tsunknown{t}=*$ then the timeout is disabled. If $\tsunknown{t}=\Msome (\tsunknown{s},\tsunknown{ns})$ then the timeout is set to $\tsunknown{s}$
  seconds and $\tsunknown{ns}$ nanoseconds.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{setsocktopt}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tsunknown{EBADF}$
&  The file descriptor $\tsunknown{fd}$ does not refer to a valid file descriptor.
\\\hline
$\tsunknown{EDOM}$
&  The timeout value is too big to fit in the socket structure.
\\\hline
$\tsunknown{ENOPROTOOPT}$
&  The option is not supported by the protocol.
\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor $\tsunknown{fd}$ does not refer to a socket.
\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsunknown{setsocktopt\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tsunknown{setsocktopt}()$ is Posix \wasverb{setsockopt()} for time-option socket flags.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int setsockopt(int socket, int level, int option\textunderscore{}name,} \\
             & \wasverb{               const void *option\textunderscore{}value,}\\
             & \wasverb{               socklen\textunderscore{}t option\textunderscore{}len);}\\
    FreeBSD: & \wasverb{int setsockopt(int s, int level, int optname, } \\
             & \wasverb{               const void *optval, socklen\textunderscore{}t optlen);} \\
    Linux:   & \wasverb{int setsockopt(int s, int  level,  int  optname,} \\
             & \wasverb{               const  void  *optval, socklen\textunderscore{}t optlen);} \\
    WinXP:   & \wasverb{int setsockopt(SOCKET s, int level, int optname,} \\
             & \wasverb{               const char* optval,int optlen);}
   \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to set the option on, corresponding
     to the $\tsunknown{fd}$ argument of the model $\tsunknown{setsocktopt}()$.

    \item \wasverb{level} is the protocol level at which the flag resides: \wasverb{SOL\textunderscore{}SOCKET} for
     the socket level options, and \wasverb{option\textunderscore{}name} is the flag to be set. These two
     correspond to the $\tsunknown{flag}$ argument of the model $\tsunknown{setsocktopt}()$ where the possible values of
     \wasverb{option\textunderscore{}name} are limited to: $\tscon{SO\_RCVTIMEO}$ and $\tscon{SO\_SNDTIMEO}$.

    \item \wasverb{option\textunderscore{}value} is a pointer to a location of size \wasverb{option\textunderscore{}len}
     containing the value to set the flag to. These two correspond to the $\tsunknown{t}$ argument of type
     $(\tstype{int} * \tstype{int}) \;\tstype{option}$ in the model $\tsunknown{setsocktopt}()$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EFAULT} signifies the pointer passed as \wasverb{option\textunderscore{}value} was
     inaccessible. On WinXP, the error \wasverb{WSAEFAULT} may also signify that the
     \wasverb{optlen} parameter was too small. Note this error is not specified by Posix.

    \item \wasverb{EINVAL} signifies the \wasverb{option\textunderscore{}name} was invalid at the specified socket
     \wasverb{level}. In the model, typing prevents an invalid flag from being specified in a call
     to $\tsunknown{setsocknopt}()$.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{setsocktopt\_1}$
& \textbf{all: fast succeed}
&  Successfully set a time-option socket flag \\
$\tsrule{setsocktopt\_4}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{ENOPROTOOPT}$: on WinXP $\tscon{SO\_LINGER}$ not settable for a UDP socket \\
$\tsrule{setsocktopt\_5}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{EDOM}$:  timeout value too long to fit in socket structure \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\setsocktoptTI}{\rrulecc{setsocktoptTI}{setsocktopt\_1}{all: fast succeed}{\tsholcomm{ Successfully set a time-option socket flag }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsunknown{tltimeopt\_wf} \;\tsvar{t} \Mwedge   {}\\{}
 \tsvar{t}' = \tsunknown{time\_of\_tltimeopt} \;\tsvar{t} \Mwedge {}\\{}
 \tsvar{t}' \geq  0 \Mwedge {}\\{}
 (\Mif  \;\tsvar{f} \;\in  \{\tscon{SO\_RCVTIMEO}; \tscon{SO\_SNDTIMEO}\} \Mwedge  \tsvar{t}' = 0{}\\{}
 \Mthen  \;\tsvar{t}'' = \infty{}\\{}
 \Melse  \;\tsvar{t}'' = \tsvar{t}') \Mwedge {}\\{}
 (\Mif  \;\tsvar{f} = \tscon{SO\_LINGER} \Mwedge   \tsvar{t} = \Msome (\tsvar{s},\tsvar{ns}) \Mthen  \;\tsvar{ns} = 0 \;\Melse  \;\Mtrue ) \Mwedge {}\\{}
 (\tsvar{f} \;\in  \{\tscon{SO\_RCVTIMEO}; \tscon{SO\_SNDTIMEO}\} \implies  \tsvar{t}'' = \infty \Mvee  \tsvar{t}'' \leq  \tsunknown{sndrcv\_timeo\_t\_max}) \Mwedge {}\\{}
 \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{sf} \Mass  \tsvar{sock}.\tsvar{sf} \; \Mmagiclrec  \tsvar{t} \Mass  \Mfupdate{\tsvar{sock}.\tsvar{sf}.\tsvar{t}}{\tsvar{f}}{\tsvar{t}''} \Mmagicrrec  \Mmagicrrec }
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})$ call is
    made. $\tsvar{fd}$ refers to a socket $\tsvar{sid}$ which has time-option socket flags $\tsvar{sock}.\tsvar{sf}.\tsvar{t}$; $\tsvar{f}$
    is a time-option socket flag: either $\tscon{SO\_RCVTIMEO}$ or $\tscon{SO\_SNDTIMEO}$; and $\tsvar{t}$ is the
    well formed time-option value to set $\tsvar{f}$ to. The call succeeds.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$. If $\tsvar{t}=*$ or $\tsvar{t}=\Msome  (0,0)$ then the socket's time-option flags are updated such
    that $\tsvar{sock}.\tsvar{sf}.\tsvar{t}(\tsvar{f})=*$, representing $\infty$; otherwise the socket's time-option
    flags are updated such that $\tsvar{f}$ has the time value represented by $\tsvar{t}$, which must be less
    than $\tsunknown{snd\_rcv\_timeo\_t\_max}$.

\rulesubsection{Model details}

    The type of $\tsvar{t}$ is $(\tstype{int} * \tstype{int}) \;\tstype{option}$, but the type of a time-option socket flag is
    $\tsunknown{time}$. The auxiliary function $\tsunknown{time\_of\_tltimeopt}$ is used to do the conversion.

\rrulepad }
}

\newcommand{\setsocktoptTIV}{\rrulecc{setsocktoptTIV}{setsocktopt\_4}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{ENOPROTOOPT}$: on WinXP $\tscon{SO\_LINGER}$ not settable for a UDP socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOPROTOOPT}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge  \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tsunknown{PROTO\_UDP} \Mwedge {}\\{}
 \tsvar{f} = \tscon{SO\_LINGER}}
{\rulesubsection{Description}

    On WinXP, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})$ call is
    made. $\tsvar{fd}$ is a file descriptor referring to a UDP socket $\tsvar{sid}$, $\tsvar{f}$ is the time-option
    socket $\tscon{SO\_LINGER}$. The flag $\tsvar{f}$ is not settable, so the call fails with an $\tsunknown{ENOPROTOOPT}$
    error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsunknown{ENOPROTOOPT}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\setsocktoptTV}{\rrulecc{setsocktoptTV}{setsocktopt\_5}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{EDOM}$:  timeout value too long to fit in socket structure }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EDOM}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{f} \;\in  \{\tscon{SO\_RCVTIMEO}; \tscon{SO\_SNDTIMEO}\} \Mwedge {}\\{}
 \tsunknown{tltimeopt\_wf} \;\tsvar{t} \Mwedge   {}\\{}
 \tsvar{t}' = \tsunknown{time\_of\_tltimeopt} \;\tsvar{t} \Mwedge {}\\{}
 (\Mif  \;\tsvar{t}' = 0{}\\{}
 \Mthen  \;\tsvar{t}'' = \infty{}\\{}
 \Melse  \;\tsvar{t}'' = \tsvar{t}') \Mwedge {}\\{}
 \neg{}(\tsvar{t}'' = \infty \Mvee  \tsvar{t}'' \leq  \tsunknown{sndrcv\_timeo\_t\_max})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is currently in the $\tscon{Run}$ state, a $\tsunknown{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})$ call is
    made. $\tsvar{f}$ is a time-option socket flag that is either $\tscon{SO\_RCVTIMEO}$ or $\tscon{SO\_SNDTIMEO}$, and
    $\tsvar{t}$ is the time value to set $\tsvar{f}$ to. The call fails with an $\tsunknown{EDOM}$ error because the value
    $\tsvar{t}$ is too large to fit in the socket structure: it is not zero and it is greater than
    $\tsunknown{sndrcv\_timeo\_t\_max}$.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})}$ call is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EDOM}})$.

\rulesubsection{Model details}

    The type of $\tsvar{t}$ is $(\tstype{int} * \tstype{int}) \;\tstype{option}$, but the type of a time-option socket flag is
    $\tsunknown{time}$. The auxiliary function $\tsunknown{time\_of\_tltimeopt}$ is used to do the conversion.

\rrulepad }
}

\newcommand{\seccommshutdown}{\clustersection{(TCP and UDP)}{$\tsunknown{shutdown}()$}
\seccomm{  \[ \tsunknown{shutdown}: (\tsunknown{fd} * \tstype{bool} * \tstype{bool}) \Mtotype  \tstype{unit} \]

  A call of $\tsunknown{shutdown}(\tsunknown{fd},\tsunknown{r},\tsunknown{w})$ shuts down either the read-half of a connection, the write-half of
  a connection, or both. The $\tsunknown{fd}$ is a file descriptor referring to the socket to shutdown; the $\tsunknown{r}$ and $\tsunknown{w}$ indicate whether the socket should be shut down for reading and writing respectively.

  For a TCP socket, shutting down the read-half empties the socket's receive queue, but data will
  still be delivered to it and subsequent $\tsunknown{recv}()$ calls will return data. Shutting down the
  write-half of a TCP connection causes the remaining data in the socket's send queue to be sent and
  then TCP's connection termination to occur.

  For Linux and WinXP, a TCP socket may only be shut down if it is in the $\tscon{ESTABLISHED}$ state; on
  FreeBSD a socket may be shut down in any state.

  For a UDP socket, if the socket is shutdown for reading, data may still be read from the socket's
  receive queue on Linux, but on FreeBSD and WinXP this is not the case. Shutting down the socket
  for writing causes subsequent $\tsunknown{send}()$ calls to fail.


}\clustersubsection{Errors}
\seccomm{
  A call to $\tsunknown{shutdown}()$ can fail with the errors below, in which case the corresponding exception
  is raised:

\par\begin{ltstabular}
$\tsunknown{ENOTCONN}$
&  The socket is not connected and so cannot be shut down.
\\\hline
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\\\hline
$\tsunknown{ENOBUFS}$
&  Out of resources.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
 A TCP socket is created and connects to a peer; data is transferred between the two; the socket has
 no more data to send so calls $\tsunknown{shutdown}()$ to inform the peer of this: $\tsunknown{socket\_1}$; $\dots $;
 $\tsunknown{connect\_1}$; $\dots $; $\tsunknown{shutdown\_1}$; $\tsunknown{return\_1}$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:   & \wasverb{int shutdown(int socket, int how);} \\
    FreeBSD: & \wasverb{int shutdown(int s, int how);} \\
    Linux:   & \wasverb{int shutdown(int s, int how);} \\
    WinXP:   & \wasverb{int shutdown(SOCKET s, int how);}
  \end{tabular}

  In the Posix interface:
  \begin{itemize}

    \item \wasverb{socket} is a file descriptor referring to the socket to shut down. This
     corresponds to the $\tsunknown{fd}$ argument of the model $\tsunknown{shutdown}()$.

    \item \wasverb{how} is an integer specifying the type of shutdown corresponding to the $(\tsunknown{r},\tsunknown{w})$
     arguments in the model $\tsunknown{shutdown}()$. If \wasverb{how} is set to \wasverb{SHUT\textunderscore{}RD} then the
     read half of the connection is to be shut down, corresponding to a $\tsunknown{shutdown}(\tsunknown{fd},\Mtrue ,\Mfalse )$ call in
     the model; if it is set to \wasverb{SHUT\textunderscore{}WR} then the write half of the connection is to be
     shut down, corresponding to a $\tsunknown{shutdown}(\tsunknown{fd},\Mfalse ,\Mtrue )$ call in the model; if it is set to
     \wasverb{SHUT\textunderscore{}RDWR} then both the read and write halves of the connection are to be shut down,
     corresponding to a $\tsunknown{shutdown}(\tsunknown{fd},\Mtrue ,\Mtrue )$ call in the model.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  The FreeBSD, Linux, and WinXP interfaces are similar, except where noted.

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:
  \begin{itemize}

    \item \wasverb{EINVAL} signifies that the \wasverb{how} argument is invalid. In the model the
     \wasverb{how} argument is represented by the two boolean flags $\tsunknown{r}$ and $\tsunknown{w}$ which guarantees
     that the only values allowed are $(\Mtrue ,\Mtrue )$, $(\Mtrue ,\Mfalse )$, $(\Mfalse ,\Mtrue )$, and $(\Mfalse ,\Mfalse )$. The first
     three correspond to the allowed values of \wasverb{how}: \wasverb{SHUT\textunderscore{}RD},
     \wasverb{SHUT\textunderscore{}WR}, and \wasverb{SHUT\textunderscore{}RDWR}. The last possible value, $(\Mfalse ,\Mfalse )$, is not
     allowed by Posix, but the model allows a $\tsunknown{shutdown}(\tsunknown{fd},\Mfalse ,\Mfalse )$ call,
     which has no effect on the socket.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

   \end{itemize}

}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{shutdown\_1}$
& \textbf{tcp: fast succeed}
&  Shut down read or write half of TCP connection \\
$\tsrule{shutdown\_2}$
& \textbf{udp: fast succeed}
&  Shutdown UDP socket for reading, writing, or both \\
$\tsrule{shutdown\_3}$
& \textbf{tcp: fast fail}
&  Fail with $\tsunknown{ENOTCONN}$: cannot shutdown a socket that is not connected on Linux and WinXP \\
$\tsrule{shutdown\_4}$
& \textbf{udp: fast fail}
&  Fail with $\tsunknown{ENOTCONN}$: socket's peer address not set on Linux \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\shutdownTI}{\rrulecc{shutdownTI}{shutdown\_1}{tcp: fast succeed}{\tsholcomm{ Shut down read or write half of TCP connection }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock}')] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tsvar{pr}) \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{pr} = \tscon{TCP\_PROTO} \;\tsunknown{tcp\_sock} \Mwedge {}\\{}
 \Mif  \;\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{CLOSED};\tscon{LISTEN}\} \Mwedge  \tsvar{w}  \;\Mthen {}\\{}
\quad {}\\{}
\quad {}\\{}
\quad {}\\{}
\quad \Mlet  \;\tsvar{sock}'' = (\tsaux{tcp\_close} \;\tsvar{h}.\tsvar{arch} \;\tsvar{sock}) \Min {}\\{}
\quad \tsvar{sock}' = \tsvar{sock}'' \; \Mmagiclrec  \tsvar{cantsndmore} \Mass  (\tsvar{w}\Mvee \tsvar{cantsndmore});{}\\{}
 \tsvar{cantrcvmore} \Mass  (\tsvar{r}\Mvee \tsvar{cantrcvmore});{}\\{}
 \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsaux{tcp\_sock\_of} \;\tsvar{sock}'' \;{}\\{}
\quad\quad\quad\quad \Mmagiclrec  \tsvar{lis} \Mass  * \Mmagicrrec ){}\\{}
 \Mmagicbolrrec {}\\{}
 \Melse {}\\{}
\quad (\neg{}\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \implies  \exists \tsvar{i}_{1} \;\tsvar{p}_{1} \;\tsvar{i}_{2} \;\tsvar{p}_{2}. \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{ESTABLISHED} \Mwedge  \tsvar{is}_{1}=\Msome  \;\tsvar{i}_{1} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{ps}_{1}=\Msome  \;\tsvar{p}_{1} \Mwedge  \tsvar{is}_{2}=\Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}_{2}=\Msome  \;\tsvar{p}_{2} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{lis} = *) \Mwedge {}\\{}
\quad \tsvar{pr}' = \tsvar{pr} \Mwedge {}\\{}
\quad \tsvar{sock}' = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{w} \Mvee  \tsvar{cantsndmore},\tsvar{r} \Mvee \tsvar{cantrcvmore},\tsvar{pr}')}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})$ call is made. $\tsvar{fd}$
    refers to a TCP socket $\tsvar{sid}$ which is in the $\tscon{ESTABLISHED}$ state and has binding quad
    $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$.

    The call suceeds: a $\MLhcall{\tsvar{tid}}{\tsunknown{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})}$ transition is made, leaving the thread in
    state $\tscon{Ret} (\tscon{OK}())$. If $\tsvar{r}=\Mtrue $ then the read-half of the connection is shut down, setting
    $\tsvar{cantrcvmore}=\Mtrue $ and emptying the socket's receive queue; if $\tsvar{w}=\Mtrue $ then the write-half of the
    connection is shut down, setting $\tsvar{cantsndmore}=\Mtrue $; otherwise, the socket is unchanged.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    The TCP socket can be in any state, not just $\tscon{ESTABLISHED}$. If the socket is in the $\tscon{CLOSED}$
    or $\tscon{LISTEN}$ and is to be shutdown for writing, $\tsvar{w}=\Mtrue $, then the socket is closed, see \ltslink{tcpTclose}{$\tsaux{tcp\_close}$}.

    Note that testing has shown the socket's listen queue is not always set to $*$ after a
    $\tsunknown{shutdown}()$ call. The precise condition for this being done needs to be investigated.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\shutdownTII}{\rrulecc{shutdownTII}{shutdown\_2}{udp: fast succeed}{\tsholcomm{ Shutdown UDP socket for reading, writing, or both }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantrcvmore} \Mass  \tsvar{cantrcvmore};{}\\{}
 \tsvar{cantsndmore} \Mass  \tsvar{cantsndmore};{}\\{}
 \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsunknown{udp\_pr}) \Mmagicrrec  )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK}())}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantrcvmore} \Mass  (\tsvar{r} \Mvee  \tsvar{cantrcvmore});{}\\{}
 \tsvar{cantsndmore} \Mass  (\tsvar{w} \Mvee  \tsvar{cantsndmore});{}\\{}
 \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsunknown{udp\_pr}) \Mmagicrrec  )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \implies  \tsvar{sock}.\tsvar{is}_{2} \neq  *)}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in the
    $\tscon{Run}$ state, a $\tsunknown{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})$ call is made and succeeds.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$. If the socket was shutdown for reading when the call was made or $\tsvar{r} = \Mtrue $ then the
    socket is shutdown for reading. If the socket was shutdown for writing when the call was made or
    $\tsvar{w} = \Mtrue $ then the socket is shutdown for writing.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    As above, with the added condition that the socket's peer IP address must be set: $\tsvar{sock}.\tsvar{is}_{2} \neq
*$.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\shutdownTIII}{\rrulecc{shutdownTIII}{shutdown\_3}{tcp: fast fail}{\tsholcomm{ Fail with $\tsunknown{ENOTCONN}$: cannot shutdown a socket that is not connected on Linux and WinXP }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOTCONN}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \neq  \tscon{ESTABLISHED} \Mwedge {}\\{}
 \neg{}(\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})$ call is made where
    $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$ which is not in the $\tscon{ESTABLISHED}$ state. The call fails
    with an $\tsunknown{ENOTCONN}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOTCONN}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\shutdownTIV}{\rrulecc{shutdownTIV}{shutdown\_4}{udp: fast fail}{\tsholcomm{ Fail with $\tsunknown{ENOTCONN}$: socket's peer address not set on Linux }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{2} \Mass  *; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec  ) ] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsunknown{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOTCONN}})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{2} \Mass  *;{}\\{}
 \tsvar{cantsndmore} \Mass  (\tsvar{w} \Mvee  \tsvar{sock}.\tsvar{cantsndmore});{}\\{}
 \tsvar{cantrcvmore} \Mass  (\tsvar{r} \Mvee  \tsvar{sock}.\tsvar{cantrcvmore});{}\\{}
 \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsunknown{linux\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff})}
{\rulesubsection{Description}

    On Linux, consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ with no peer IP address set: $\tsvar{is}_{2}
\Mass  *$. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tsunknown{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})$ call is
    made, and fails with an $\tsunknown{ENOTCONN}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsunknown{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOTCONN}})$. If the socket was shutdown for reading when the call was made or $\tsvar{r} = \Mtrue $ then the
    socket is shutdown for reading. If the socket was shutdown for writing when the call was made or
    $\tsvar{w} = \Mtrue $ then the socket is shutdown for writing.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply: see rule $\tsunknown{shutdown\_2}$.

\\\hline
WinXP
&
    This rule does not apply: see rule $\tsunknown{shutdown\_2}$.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommsocket}{\clustersection{(TCP and UDP)}{$\tstype{socket}()$}
\seccomm{ \[ \tstype{socket}: \tsunknown{sock\_type} \Mtotype  \tsunknown{fd} \]

  A call to $\tstype{socket}(\tsunknown{type})$ creates a new socket. Here $\tsunknown{type}$ is the type of socket to create:
  $\tscon{SOCK\_STREAM}$ for TCP and $\tscon{SOCK\_DGRAM}$ for UDP. The returned $\tsunknown{fd}$ is the file descriptor of
  the new socket.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tstype{socket}()$ can fail with the errors below, in which case the corresponding exception
  is raised:

\par\begin{ltstabular}
$\tsunknown{EMFILE}$
&  No more file descriptors for this process.
\\\hline
$\tsunknown{ENOBUFS}$
&  Out of resources.

\\\hline
$\tsunknown{ENOMEM}$
&  Out of resources.

\\\hline
$\tsunknown{ENFILE}$
&  Out of resources.


\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  TCP: $\tsunknown{socket\_1}$; $\tsunknown{return\_1}$; $\tsunknown{connect\_1}$; $\dots$
  UDP: $\tsunknown{socket\_1}$; $\tsunknown{return\_1}$; $\tsunknown{bind\_1}$; $\tsunknown{return\_1}$; $\tsunknown{send\_9}$; $\dots$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:  &  \wasverb{int socket(int domain, int type, int protocol);} \\
    FreeBSD:&  \wasverb{int socket(int domain, int type, int protocol);} \\
    Linux:  &  \wasverb{int socket(int doamin, int type, int protocol);} \\
    WinXP:  &  \wasverb{SOCKET socket(int af, int type, int protocol);} \\
  \end{tabular}\\

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{domain} specifies the communication domain in which the socket is to be created,
    specifying the protocol family to be used. Only IPv4 sockets are modelled here, so
    \wasverb{domain} is set to \wasverb{AF\textunderscore{}INET} or \wasverb{PF\textunderscore{}INET}.

    \item \wasverb{type} specifies the communication semantics: \wasverb{SOCK\textunderscore{}STREAM} provides
          sequenced, reliable, two-way, connection-based byte streams; \wasverb{SOCK\textunderscore{}DGRAM}
          supports datagrams (connectionless, unreliable messages of a fixed maximum length). This
          corresponds to the $\tsunknown{sock\_type}$ argument of the model $\tstype{socket}()$.

    \item \wasverb{protocol} specifies the particular protocol to be used for the socket. A
    \wasverb{protocol} of \wasverb{0} requests to use the default for the appropriate socket
    \wasverb{type}: TCP for \wasverb{SOCK\textunderscore{}STREAM} and UDP for \wasverb{SOCK\textunderscore{}DGRAM}. Alternatively
    a specific protocol number can be used: \wasverb{6} for TCP and \wasverb{17} for UDP. In the
    model, $\tscon{SOCK\_STREAM}$ refers to a TCP socket and $\tscon{SOCK\_DGRAM}$ to a UDP socket so the
    \wasverb{protocol} argument is not necessary.

  \end{itemize}

  A call to $\tstype{socket}(\tscon{SOCK\_STREAM})$ in the model interface, would be a
  \wasverb{socket(AF\textunderscore{}INET,SOCK\textunderscore{}STREAM,0)} call in Posix; a call to $\tstype{socket}(\tscon{SOCK\_DGRAM})$ in the
  model interface would be a \wasverb{socket(AF\textunderscore{}INET,SOCK\textunderscore{}DGRAM,0)} call in Posix.

  The FreeBSD, Linux and WinXP interfaces are similar modulo argument renaming, except where noted
  above.


}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item In Posix and on Linux, \wasverb{EACCES} specifies that the process does not have appropriate
    privileges.  We do not model a privilege state in which socket creation would be disallowed.

    \item In Posix and  on Linux, \wasverb{EAFNOSUPPORT}, specifies that the implementation does not
    support the address \wasverb{domain}. FreeBSD, Linux, and WinXP all support \wasverb{AF\textunderscore{}INET}
    sockets.

    \item On Linux, \wasverb{EINVAL} means unknown protocol, or protocol domain not available. Both
    TCP and UDP are known protocols for Linux, and \wasverb{AF\textunderscore{}INET} is a known domain on Linux.

    \item In Posix and on Linux, \wasverb{EPROTONOTSUPPORT} specifies that the protocol is not
    supported by the address family, or the protocol is not supported by the
    implementation. FreeBSD, Linux, and WinXP all support the TCP and UDP protocols.

    \item In Posix, \wasverb{EPROTOTYPE} signifies that the socket type is not supported by the
    protocol. Both \wasverb{SOCK\textunderscore{}STREAM} and \wasverb{SOCK\textunderscore{}DGRAM} are supported by TCP and UDP
    respectively.

    \item On WinXP, \wasverb{WSAESOCKTNOSUPPORT} means the specified socket type is not supported in
    this address family. The \wasverb{AF\textunderscore{}INET} family supports both \wasverb{SOCK\textunderscore{}STREAM} and
    \wasverb{SOCK\textunderscore{}DGRAM} sockets.

  \end{itemize}

  The \wasverb{AF\textunderscore{}INET6}, \wasverb{AF\textunderscore{}LOCAL}, \wasverb{AF\textunderscore{}ROUTE}, and \wasverb{AF\textunderscore{}KEY} address
  families; \wasverb{SOCK\textunderscore{}RAW} socket type; and all protocols other than TCP and UDP are not modelled.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{socket\_1}$
& \textbf{all: fast succeed}
&  Successfully return a new file descriptor for a fresh socket \\
$\tsrule{socket\_2}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{EMFILE}$: out of file descriptors for this process \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\socketTI}{\rrulecc{socketTI}{socket\_1}{all: fast succeed}{\tsholcomm{ Successfully return a new file descriptor for a fresh socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds};{}\\{}
 \tsvar{files} \Mass  \tsvar{files};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{(\tstype{socket} (\tsvar{socktype}))} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} \;\tsvar{fd})}{\tsunknown{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}';{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus  [(\tsvar{fid},\tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsunknown{ff\_default}))];{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsholop{CARD} (\Mfdom{\tsvar{fds}}) < \tsunknown{OPEN\_MAX} \Mwedge {}\\{}
 \tsvar{fid} \;\notin  (\Mfdom{\tsvar{files}}) \Mwedge {}\\{}
 \tsvar{sid} \;\notin  (\Mfdom{\tsvar{socks}}) \Mwedge {}\\{}
 \tsunknown{nextfd} \;\tsvar{h}.\tsvar{arch} \;\tsvar{fds} \;\tsvar{fd} \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \oplus  (\tsvar{fd}, \tsvar{fid}) \Mwedge {}\\{}
 (\Mcase  \;\tsvar{socktype} \;\Mof {}\\{}
\quad \tscon{SOCK\_DGRAM} \Mtotype  (\tsvar{sock} ={}\\{}
\quad\quad \tscon{Sock}(\Msome  \;\tsvar{fid},\tsunknown{sf\_default} \;\tsvar{h}.\tsvar{arch} \;\tsvar{socktype},*,*,*,*,*,\Mfalse ,\Mfalse ,\tsaux{UDP\_Sock}([\,]))) \Mdpipe {}\\{}
\quad \tscon{SOCK\_STREAM} \Mtotype  (\tsvar{sock} ={}\\{}
\quad\quad \tscon{Sock}(\Msome  \;\tsvar{fid},\tsunknown{sf\_default} \;\tsvar{h}.\tsvar{arch} \;\tsvar{socktype},*,*,*,*,*,\Mfalse ,\Mfalse ,{}\\{}
\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{CLOSED},\tsaux{initial\_cb},*,[\,],[\,])))){}\\{}
 }
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tstype{socket}(\tsvar{socktype})$ call is made. The
    number of open file descriptors is less than the maximum permitted, $\tsunknown{OPEN\_MAX}$.

    If $\tsvar{socktype}=\tscon{SOCK\_STREAM}$ then a new TCP socket $\tsvar{sock}$ is created, in the $\tscon{CLOSED}$ state,
    with \ltslink{initialTcb}{$\tsaux{initial\_cb}$} as its control block, and all other fields uninitialised; if
    $\tsvar{socktype}=\tscon{SOCK\_DGRAM}$ then a new, unitialised UDP socket $\tsvar{sock}$ is created. A new open file
    description is created pointing to the socket, and a new file descriptor, $\tsvar{fd}$, is allocated
    in an architecture specific way (see \ltslink{nextfd}{$\tsunknown{nextfd}$}) to point to the open file
    description. The host's finite map of sockets is updated to include an entry mapping the socket
    identifier $\tsvar{sid}$ to the socket; its finite map of file descriptions is updated to add an entry
    mapping the file descriptor $\tsvar{fid}$ to the file description of the socket; and its finite map of
    file descriptors is updated, adding a mapping from $\tsvar{fd}$ to $\tsvar{fid}$.

    A $\MLhcall{\tsvar{tid}}{\tstype{socket}(\tsunknown{sock\_type})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}
\tsvar{fd})$ to return the new file descriptor.

\rrulepad }
}

\newcommand{\socketTII}{\rrulecc{socketTII}{socket\_2}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{EMFILE}$: out of file descriptors for this process }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{(\tstype{socket} (\tsvar{s}))} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EMFILE}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsholop{CARD} (\Mfdom{\tsvar{h}.\tsvar{fds}}) \geq  \tsunknown{OPEN\_MAX}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tstype{socket}(\tsvar{s})$ call is made. The number of
    open file descriptors is greater than the maximum allowed number, $\tsunknown{OPEN\_MAX}$, and so the call
    fails with an $\tsunknown{EMFILE}$ error.

    A $\MLhcall{\tsvar{tid}}{\tstype{socket}(\tsvar{s})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EMFILE}})$.

\rrulepad }
}

\newcommand{\seccommmisc}{\clustersection{(TCP and UDP)}{Miscellaneous}
\seccomm{
  This section collects the remaining Sockets API rules:
  \begin{itemize}

  \item The rule $\tsunknown{return\_1}$ characterising how the the results of system calls
  are returned to the caller, with transitions from the thread state $\Mtimed{\tscon{Ret} \;\tsunknown{v}}{\tsunknown{d}}$.

  \item Rules $\tsunknown{badf\_1}$ and $\tsunknown{notsock\_1}$ deal with all the Sockets API calls that take a file descriptor
  argument, dealing uniformly with the error cases in which that file descriptor is not valid or
  does not refer to a socket.

  \item Rule $\tsunknown{intr\_1}$ applies to all the thread states for blocked calls, $\tscon{Accept2}(\tsunknown{sid})$ etc.,
  characterising the behaviour in the case where the call is interrupted by a signal.

  \item Rules $\tsunknown{resourcefail\_1}$ and $\tsunknown{resourcefail\_2}$ deal with the cases where calls fail due to a lack
  of system resources.
  \end{itemize}

}\clustersubsection{Errors}
\seccomm{
Common errors.

\par\begin{ltstabular}
$\tsunknown{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tsunknown{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\\\hline
$\tsunknown{EINTR}$
&  The system was interrupted by a caught signal.

\\\hline
$\tsunknown{ENOMEM}$
&  Out of resources.

\\\hline
$\tsunknown{ENOBUFS}$
&  Out of resources.

\\\hline
$\tsunknown{ENFILE}$
&  Out of resources.


\end{ltstabular}\par
}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{return\_1}$
& \textbf{all: misc nonurgent}
&  Return result of system call to caller \\
$\tsrule{badf\_1}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{EBADF}$: not a valid file descriptor \\
$\tsrule{notsock\_1}$
& \textbf{all: fast fail}
&  Fail with $\tsunknown{ENOTSOCK}$: file descriptor not a valid socket \\
$\tsrule{intr\_1}$
& \textbf{all: slow nonurgent fail}
&  Fail with $\tsunknown{EINTR}$: blocked system call interrupted by
     signal \\
$\tsrule{resourcefail\_1}$
& \textbf{all: fast badfail}
&  Fail with $\tsunknown{ENFILE}$, $\tsunknown{ENOBUFS}$ or $\tsunknown{ENOMEM}$: out
     of resources \\
$\tsrule{resourcefail\_2}$
& \textbf{all: slow nonurgent badfail}
&  Fail with $\tsunknown{ENFILE}$, $\tsunknown{ENOBUFS}$ or
     $\tsunknown{ENOMEM}$: from a blocked state with out of resources \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\returnTI}{\rrulecc{returnTI}{return\_1}{all: misc nonurgent}{\tsholcomm{ Return result of system call to caller }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} \;\tsvar{v}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhreturn{\tsvar{tid}}{\tsvar{v}} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsunknown{never\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtrue }
{\rulesubsection{Description}

    A system call from thread $\tsvar{tid}$ has completed, leaving the thread state $\Mtimed{\tscon{Ret} \;\tsvar{v}}{\tsvar{d}}$.  The value $\tsvar{v}$ (which may be of the form $\tscon{OK} \;\tsvar{v}'$ or $\tscon{FAIL}\;{\tsvar{v}'}$, for success or failure respectively) is returned to the caller before the timer $\tsvar{d}$ expires.  The thread continues its execution, indicated by the resulting thread state $\Mtimed{\tscon{Run}}{\tsunknown{never\_timer}}$.

\rrulepad }
}

\newcommand{\badfTI}{\rrulecc{badfTI}{badf\_1}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{EBADF}$: not a valid file descriptor }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsvar{opn}} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{fd\_op} \;\tsvar{fd} \;\tsvar{opn} \Mwedge {}\\{}
 \tsvar{fd} \;\notin  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 (\Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsvar{e} = \tsunknown{ENOTSOCK} \;\Melse  \;\tsvar{e} = \tsunknown{EBADF})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a system call $\tsvar{opn}$ is made. The call
    requires a single valid file descriptor, but the descriptor passed, $\tsvar{fd}$ is not valid: it does
    not refer to an open file description. The call fails with an $\tsunknown{EBADF}$ error, or an
    $\tsunknown{ENOTSOCK}$ error on WinXP.

    A $\MLhcall{\tsvar{tid}}{\tsvar{opn}}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$ where
    $\tsvar{e}$ is one of the above errors.

    The system calls this rule applies to are: $\tsunknown{accept}()$, $\tsunknown{bind}()$, $\tsunknown{close}()$, $\tsunknown{connect}()$,
    $\tsunknown{disconnect}()$, $\tsunknown{dup}()$, $\tsunknown{dupfd}()$, $\tsunknown{getfileflags}()$, $\tsunknown{setfileflags}()$,
    $\tsunknown{getsockname}()$, $\tsunknown{getpeername}()$, $\tsunknown{getsockbopt}()$, $\tsunknown{getsockerr}()$,
    $\tsunknown{getsocklistening}()$, $\tsunknown{getsocknopt}()$, $\tsunknown{getsocktopt}()$, $\tsvar{listen}()$, $\tsunknown{recv}()$,
    $\tsunknown{send}()$, $\tsunknown{setsockbopt}()$, $\tsunknown{setsocknopt}()$, $\tsunknown{setsocktopt}()$, $\tsunknown{shutdown}()$, and
    $\tsunknown{sockatmark}()$.  See the definition of \ltslink{fdTop}{$\tsunknown{fd\_op}$}.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    As above: the call fails with an $\tsunknown{EBADF}$ error.

\\\hline
Linux
&
    As above: the call fails with an $\tsunknown{EBADF}$ error.

\\\hline
WinXP
&
    As above: the call fails with an $\tsunknown{ENOTSOCK}$ error.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\notsockTI}{\rrulecc{notsockTI}{notsock\_1}{all: fast fail}{\tsholcomm{ Fail with $\tsunknown{ENOTSOCK}$: file descriptor not a valid socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsvar{opn}} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOTSOCK}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{fd\_sockop} \;\tsvar{fd} \;\tsvar{opn} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsvar{ft},\tsvar{ff}) \Mwedge {}\\{}
 \neg{}(\exists \tsvar{sid}. \tsvar{ft} = \tsunknown{FT\_Socket}(\tsvar{sid}))}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a system call $\tsvar{opn}$ is made. The call
    requires a single file descriptor referring to a socket. The file descriptor $\tsvar{fd}$ that the
    user passes refers to an open file description $\tscon{File}(\tsvar{ft},\tsvar{ff})$ that does not refer to a
    socket. The call fails with an $\tsunknown{ENOTSOCK}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsvar{opn}}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{ENOTSOCK}})$.

    The system calls this rule applies to are: $\tsunknown{accept}()$, $\tsunknown{bind}()$, $\tsunknown{connect}()$,
    $\tsunknown{disconnect}()$, $\tsunknown{getpeername}()$, $\tsunknown{getsockbopt}()$, $\tsunknown{getsockerr}()$,
    $\tsunknown{getsocklistening}()$, $\tsunknown{getsockname}()$, $\tsunknown{getsocknopt}()$, $\tsunknown{getsocktopt}()$, $\tsvar{listen}()$,
    $\tsunknown{recv}()$, $\tsunknown{send}()$, $\tsunknown{setsockbopt}()$, $\tsunknown{setsocknopt}()$, $\tsunknown{setsocktopt}()$, $\tsunknown{shutdown}()$,
    and $\tsunknown{sockatmark}()$.  See the definition of \ltslink{fdTsockop}{$\tsunknown{fd\_sockop}$}.

\rrulepad }
}

\newcommand{\intrTI}{\rrulecc{intrTI}{intr\_1}{all: slow nonurgent fail}{\tsholcomm{ Fail with $\tsunknown{EINTR}$: blocked system call interrupted by
     signal }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{st}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsunknown{EINTR}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{sock} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}) \Mwedge {}\\{}
 (\tsvar{st} = \tscon{Close2}(\tsvar{sid}) \Mvee {}\\{}
 \tsvar{st} = \tscon{Connect2}(\tsvar{sid}) \Mvee {}\\{}
 \tsvar{st} = \tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts}) \Mvee {}\\{}
 \tsvar{st} = \tscon{Send2}(\tsvar{sid},\tsvar{addr},\tsvar{str},\tsvar{opts}) \Mvee {}\\{}
 \tsvar{st} = \tscon{PSelect2}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds}) \Mvee {}\\{}
 \tsvar{st} = \tscon{Accept2}(\tsvar{sid}))}
{\rulesubsection{Description}

    If on socket $\tsvar{sid}$ as user call blocked leaving a thread in one of the states:
    $\tscon{Close2}(\tsvar{sid})$, $\tscon{Connect2}(\tsvar{sid})$, $\tscon{Recv2}(\tsvar{sid})$, $\tscon{Send2}(\tsvar{sid})$, $\tscon{PSelect2}(\tsvar{sid})$ or
    $\tscon{Accept2}(\tsvar{sid})$ and a signal is caught, the calls fails returning error $\tsunknown{EINTR}$.

\rulesubsection{Model details}

    This rule is non-deterministic, allowing blocked calls to be interrupted at any point, as the specification does not model the dynamics of signals.

\rulesubsection{Variations}
\par\begin{ltstabular}
POSIX
&
    POSIX says that a system call "shall fail" if "interrupted by a signal".

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\resourcefailTI}{\rrulecc{resourcefailTI}{resourcefail\_1}{all: fast badfail}{\tsholcomm{ Fail with $\tsunknown{ENFILE}$, $\tsunknown{ENOBUFS}$ or $\tsunknown{ENOMEM}$: out
     of resources }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhcall{\tsvar{tid}}{ \tsvar{call}} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\neg{}\tsunknown{INFINITE\_RESOURCES} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsunknown{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}) \Mwedge {}\\{}
 ((\tsvar{call} = \tstype{socket}(\tsvar{socktype}) \Mwedge  \tsvar{e} \;\in  \{\tsunknown{ENFILE}; \tsunknown{ENOBUFS}; \tsunknown{ENOMEM}\}) \Mvee {}\\{}
 (\tsvar{call} = \tsunknown{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1}) \Mwedge  \tsvar{e} = \tsunknown{ENOBUFS}) \Mvee {}\\{}
 (\tsvar{call} = \tsunknown{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2}) \Mwedge  \tsvar{e} = \tsunknown{ENOBUFS}) \Mvee {}\\{}
 (\tsvar{call} = \tsvar{listen}(\tsvar{fd},\tsvar{n}) \Mwedge  \tsvar{e} = \tsunknown{ENOBUFS}) \Mvee {}\\{}
 (\tsvar{call} = \tsunknown{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts}) \Mwedge  \tsvar{e} \;\in  \{\tsunknown{ENOMEM};\tsunknown{ENOBUFS}\}) \Mvee {}\\{}
 (\tsvar{call} = \tsunknown{getsockname}(\tsvar{fd}) \Mwedge  \tsvar{e} = \tsunknown{ENOBUFS}) \Mvee {}\\{}
 (\tsvar{call} = \tsunknown{getpeername}(\tsvar{fd}) \Mwedge  \tsvar{e} = \tsunknown{ENOBUFS}) \Mvee {}\\{}
 (\tsvar{call} = \tsunknown{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w}) \Mwedge  \tsvar{e} = \tsunknown{ENOBUFS}) \Mvee {}\\{}
 (\tsvar{call} = \tsunknown{accept}(\tsvar{fd}) \Mwedge  \tsvar{e} \;\in  \{\tsunknown{ENFILE}; \tsunknown{ENOBUFS}; \tsunknown{ENOMEM}\}{}\\{}
 \Mwedge   \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tsunknown{PROTO\_TCP}))}
{\rulesubsection{Description}

    Thread $\tsvar{tid}$ performs a $\tstype{socket}()$, $\tsunknown{bind}()$, $\tsunknown{connect}()$, $\tsvar{listen}()$, $\tsunknown{recv}()$,
    $\tsunknown{getsockname}()$, $\tsunknown{getpeername}()$, $\tsunknown{shutdown}()$ or $\tsunknown{accept}()$ system call on socket
    $\tsvar{sid}$, referred to by $\tsvar{fd}$, when insufficient system-wide resources are available to
    complete the request. Return a failure of $\tsunknown{ENFILE}$, $\tsunknown{ENOBUFS}$ or $\tsunknown{ENOMEM}$ immediately to
    the calling thread.

    This rule applies only when it is assumed that the host being modelled does not have
    $\tsunknown{INFINITE\_RESOURCES}$, i.e. the host does not have unlimited memory, mbufs, file descriptors,
    etc.

\rulesubsection{Model details}

    The modelling of failure is deliberately non-deterministic because the cause of errors such as
    $\tsunknown{ENFILE}$ are determined by more than is modelled in this specification. In order to be more
    precise, the model would need to describe the whole system to determine when such error
    conditions could and should arise.

\rrulepad }
}

\newcommand{\resourcefailTII}{\rrulecc{resourcefailTII}{resourcefail\_2}{all: slow nonurgent badfail}{\tsholcomm{ Fail with $\tsunknown{ENFILE}$, $\tsunknown{ENOBUFS}$ or
     $\tsunknown{ENOMEM}$: from a blocked state with out of resources }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{t}}{\tsvar{d}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsunknown{sched\_timer}}} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\neg{}\tsunknown{INFINITE\_RESOURCES} \Mwedge {}\\{}
 \tsvar{sock} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}) \Mwedge {}\\{}
 ((\tsvar{t} = \tscon{Accept2}(\tsvar{sid}) \Mwedge  \tsvar{e} \;\in  \{\tsunknown{ENFILE}; \tsunknown{ENOBUFS}; \tsunknown{ENOMEM}\}) \Mvee {}\\{}
 (\tsvar{t} = \tscon{Connect2}(\tsvar{sid}) \Mwedge  \tsvar{e} = \tsunknown{ENOBUFS}) \Mvee {}\\{}
 (\tsvar{t} = \tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts}) \Mwedge  \tsvar{e} \;\in  \{\tsunknown{ENOBUFS}; \tsunknown{ENOMEM}\}))}
{\rulesubsection{Description}

    If thread $\tsvar{tid}$ of host $\tsvar{h}$ is in state $\tscon{Accept2}(\tsvar{sid})$, $\tscon{Connect2}(\tsvar{sid})$ or
    $\tscon{Recv2}(\tsvar{sid})$ following an $\tsunknown{accept}()$, $\tsunknown{connect}()$ or $\tsunknown{recv}()$ system call that blocked,
    and the host has subsequently exhausted its system-wide resources, fail with $\tsunknown{ENFILE}$,
    $\tsunknown{ENOBUFS}$ or $\tsunknown{ENOMEM}$. The error is immediately returned to the thread that made the system
    call.

    Calls to $\tsunknown{connect}()$ only return $\tsunknown{ENOBUFS}$ when resources are exhausted and calls to
    $\tsunknown{recv}()$ only return $\tsunknown{ENOBUFS}$ or $\tsunknown{ENOMEM}$.

    This rule applies only when it is assumed that the host being modelled does not have
    $\tsunknown{INFINITE\_RESOURCES}$, i.e. the host does not have unlimited memory, mbufs, file descriptors,
    etc.

\rulesubsection{Model details}

    The modelling of failure is deliberately non-deterministic because the cause of errors such as
    $\tsunknown{ENFILE}$ are determined by more than is modelled in this specification. In order to be more
    precise, the model would need to describe the whole system to determine when such error
    conditions could and should arise.

\rrulepad }
}

\newcommand{\chapcommtcpTinputTprocessing}{\chaptersection{ Host LTS: TCP Input Processing}
\label{tcp_input_processing}%
\chapcomm{}
}

\newcommand{\seccommtcpTinputTprocessing}{\clustersection{(TCP only)}{Input Processing}
\seccomm{
These rules deal with the processing of TCP segments from the host's input queue.
The most important are $\tsunknown{deliver\_in\_1}$, $\tsunknown{deliver\_in\_2}$, and $\tsunknown{deliver\_in\_3}$.

$\tsunknown{deliver\_in\_1}$ deals with a passive open: a socket in $\tscon{LISTEN}$ state that receives a $\tsvar{SYN}$ and sends a $\tsvar{SYN},\tsunknown{ACK}$.

$\tsunknown{deliver\_in\_2}$ deals with the completion of an active open: a socket in $\tscon{SYN\_SENT}$ state (that has previously sent a $\tsvar{SYN}$ with the $\tsunknown{connect\_1}$ rule) that receives a $\tsvar{SYN},\tsunknown{ACK}$ and sends an $\tsunknown{ACK}$.  It also deals with simultaneous opens.

$\tsunknown{deliver\_in\_3}$ deals with the common cases of TCP data exchange and connection close: sockets in connected states that receive data, $\tsunknown{ACK}$s, and $\tsvar{FIN}$s.
This rule is structured using the relational monad, combining auxiliaries
$\tsaux{di3\_topstuff}$, $\tsaux{di3\_ackstuff}$, $\tsaux{di3\_datastuff}$ etc., to factor out many of the imperative effects of the code.

The other rules deal with $\tsvar{RST}$s and a variety of pathological situations.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{deliver\_in\_1}$
& \textbf{tcp: network nonurgent}
&  Passive open: receive SYN, send SYN,ACK \\
$\tsrule{deliver\_in\_2}$
& \textbf{tcp: network nonurgent}
&  Completion of active open (in $\tscon{SYN\_SENT}$ receive SYN,ACK and send ACK) or simultaneous open (in $\tscon{SYN\_SENT}$ receive SYN and send SYN,ACK) \\
$\tsrule{deliver\_in\_3}$
& \textbf{tcp: network nonurgent}
&  Receive data, FINs, and ACKs in a connected state \\
$\tsrule{di3\_topstuff}$
&
&  $\tsunknown{deliver\_in\_3}$ initial checks \\
$\tsrule{di3\_newackstuff}$
&
&  $\tsunknown{deliver\_in\_3}$ new ack processing, used in $\tsaux{di3\_ackstuff}$  \\
$\tsrule{di3\_ackstuff}$
&
&  $\tsunknown{deliver\_in\_3}$ ACK processing \\
$\tsrule{di3\_datastuff}$
&
&  $\tsunknown{deliver\_in\_3}$ data processing \\
$\tsrule{!}$
&
& \\
$\tsrule{di3\_socks\_update}$
&
&  $\tsunknown{deliver\_in\_3}$ socket update processing \\
$\tsrule{deliver\_in\_3b}$
& \textbf{tcp: network nonurgent}
&  Receive data after process has gone away \\
$\tsrule{deliver\_in\_4}$
& \textbf{tcp: network nonurgent}
&  Receive and drop (silently) a non-sane or martian segment \\
$\tsrule{deliver\_in\_5}$
& \textbf{tcp: network nonurgent}
&  Receive and drop (maybe with RST) a sane segment that does not match any socket \\
$\tsrule{deliver\_in\_7}$
& \textbf{tcp: network nonurgent}
&  Receive RST and zap non-$\{\tscon{CLOSED}$; $\tscon{LISTEN}$; $\tscon{SYN\_SENT}$; $\tscon{SYN\_RECEIVED}$; $\tscon{TIME\_WAIT}\}$ socket \\
$\tsrule{deliver\_in\_7a}$
& \textbf{tcp: network nonurgent}
&  Receive RST and zap $\tscon{SYN\_RECEIVED}$ socket \\
$\tsrule{deliver\_in\_7b}$
& \textbf{tcp: network nonurgent}
&  Receive RST and ignore for $\tscon{LISTEN}$ socket \\
$\tsrule{deliver\_in\_7c}$
& \textbf{tcp: network nonurgent}
&  Receive RST and ignore for $\tscon{SYN\_SENT}$(unacceptable ack) or $\tscon{TIME\_WAIT}$ socket \\
$\tsrule{deliver\_in\_7d}$
& \textbf{tcp: network nonurgent}
&  Receive RST and zap $\tscon{SYN\_SENT}$(acceptable ack) socket \\
$\tsrule{deliver\_in\_8}$
& \textbf{tcp: network nonurgent}
&  Receive SYN in non-$\{\tscon{CLOSED}$; $\tscon{LISTEN}$; $\tscon{SYN\_SENT}$; $\tscon{TIME\_WAIT}\}$ state \\
$\tsrule{deliver\_in\_9}$
& \textbf{tcp: network nonurgent}
&  Receive SYN in $\tscon{TIME\_WAIT}$ state if there is no matching $\tscon{LISTEN}$ socket or sequence number has not increased \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\deliverTinTI}{\rrulecc{deliverTinTI}{deliver\_in\_1}{tcp: network nonurgent}{\tsholcomm{ Passive open: receive SYN, send SYN,ACK }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks}' \oplus {}\\{}
 \tsholcomm{ Listening socket }{}\\{}
 [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis}',[\,],[\,])));{}\\{}
 \tsholcomm{ New socket formed by the incoming SYN }{}\\{}
 (\tsvar{sid}',\tscon{Sock}(*,\tsvar{sf}',\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{SYN\_RECEIVED},\tsvar{cb}'',*,[\,],[\,])))] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}'')],\tsvar{M})}
{\tsholcomm{ \textbf{Summary:} A host $\tsvar{h}$ with listening socket $\tsvar{sock}$ referenced by index $\tsvar{sid}$ receives a valid and
    well-formed $\tsvar{SYN}$ segment $\tsvar{seg}$ addressed to socket $\tsvar{sock}$. A new socket in the
    $\tscon{SYN\_RECEIVED}$ state is constructed, referenced by $\tsvar{sid}' (\neq  \tsvar{sid})$, is added to the queue of
    incomplete incoming connection attempts $\tsunknown{q}$, and a $\tsvar{SYN}$,$\tsunknown{ACK}$ segment is generated in
    reply with some field values being chosen or negotiated. The reply segment is finally queued on
    the host's output queue for transmission, ignoring any errors upon queueing failure.
    }{}\\{}
 {}\\{}
 \tsvar{sid} \;\notin  (\Mfdom{\tsvar{socks}}) \Mwedge {}\\{}
 \tsvar{sid}' \;\notin  (\Mfdom{\tsvar{socks}}) \Mwedge {}\\{}
 \tsvar{sid} \neq  \tsvar{sid}' \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ The segment must be of an acceptable form }{}\\{}
 \tsholcomm{ Note: some segment fields are ignored during TCP connection establishment and as such may
        contain arbitrary values. These are equal to the identifiers postfixed with
        $\tsunknown{\_discard}$ below, which are otherwise unconstrained. }{}\\{}
 \tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \Mtrue  \;\Mfalse  (\tsvar{iflgs},\tsvar{idata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
 \tsvar{iflgs} = \tsvar{iflgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mtrue ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{idata} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ The segment is addressed to an $\tsunknown{IP}$ address belonging to one of the interfaces of host
        $\tsvar{h}$ and is not addressed from or to a link-layer multicast or an IP-layer broadcast
        address }{}\\{}
 \tsvar{i}_{1} \;\in  \;\tsunknown{local\_ips} \;\tsvar{h}.\tsvar{ifds} \Mwedge {}\\{}
 \neg{}(\tsunknown{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{1}) \Mwedge {}\\{}
 \neg{}(\tsunknown{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{2}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Find the socket $\tsvar{sock}$ that has the best match for the address quad in segment
        $\tsvar{seg}$, see \ltslink{tcpTsocketTbestTmatch}{$\tsaux{tcp\_socket\_best\_match}$}. Socket $\tsvar{sock}$ must have a form matching the patten $\tscon{Sock}$(\dots). }{}\\{}
 \tsaux{tcp\_socket\_best\_match} \;\tsvar{socks} (\tsvar{sid},\tsvar{sock}) \tsvar{seg} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis},[\,],[\,])) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ A BSD socket in the $\tscon{LISTEN}$ state may have its peer's $\tsunknown{IP}$ address $\tsvar{is}_{2}$ and port
        $\tsvar{ps}_{2}$ set because $\tsvar{listen}()$ can be called from any TCP state. On other architectures
        they are both constrained to $*$. }{}\\{}
 ((\tsvar{is}_{2} = * \Mwedge  \tsvar{ps}_{2} = *) \Mvee {}\\{}
 (\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ If socket $\tsvar{sid}$ has a local $\tsunknown{IP}$ address specified it should be the same as the
        destination $\tsunknown{IP}$ address of the segment $\tsvar{seg}$, otherwise the $\tsvar{seg}$ is not
        addressed to this socket. If the socket does not have a local $\tsunknown{IP}$ address the segment is
        acceptable because the socket is listening on all local $\tsunknown{IP}$ addresses. The segment must
        not have been sent by socket $\tsvar{sock}$.  Note: a socket is permitted to connect to itself by
        a simultaneous open. This is handled by \ltslink{deliverTinTII}{$\tsunknown{deliver\_in\_2}$} and not here. }{}\\{}
 (\Mcase  \;\tsvar{is}_{1} \;\Mof  \;\Msome  \;\tsvar{i}'_{1} \Mtotype  \tsvar{i}'_{1} = \tsvar{i}_{1} \Mdpipe  * \Mtotype  \Mtrue ) \Mwedge {}\\{}
 \neg{}(\tsvar{i}_{1} = \tsvar{i}_{2} \Mwedge  \tsvar{p}_{1} = \tsvar{p}_{2}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ If another socket in the $\tscon{TIME\_WAIT}$ state matches the address quad of the SYN segment
        then only proceed with the new incoming connection attempt if the sequence number of the
        segment $\tsunknown{seq}$ is strictly greater than the next expected sequence number on the
        $\tscon{TIME\_WAIT}$ socket, $\tsunknown{rcv\_nxt}$. This prevents old or duplicate SYN segments from previous
        incarnations of the connection from inadvertently creating new connections. }{}\\{}
 \neg{}(\exists  (\tsvar{sid}, \tsvar{sock}) \Mcons  \tsvar{socks}.{}\\{}
\quad \exists  \tsunknown{tcp\_sock}.{}\\{}
\quad \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{TIME\_WAIT} \Mwedge {}\\{}
\quad \tsvar{sock}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsvar{sock}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge  \tsvar{sock}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{sock}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2} \Mwedge {}\\{}
\quad \Mfalse   ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Otherwise, the $\tscon{TIME\_WAIT}$ sock is completely defunct because there is a new connection
        attempt from the same remote end-point. Close it completely. }{}\\{}
 \tsholcomm{ Note: this models the behaviour in RFC1122 Section 4.2.2.13 which states that a new $\tsvar{SYN}$
        with a sequence number larger than the maximum seen in the last incarnation may reopen the
        connection, \ie, reuse the socket for the new connection changing out of the $\tscon{TIME\_WAIT}$
        state. This is modelled by closing the existing $\tscon{TIME\_WAIT}$ socket and creating the new
        socket from scratch. }{}\\{}
 \tsvar{socks}' = \tsunknown{\$o\_f} (\lambda \tsvar{sock}.{}\\{}
\quad \Mif  \exists \tsunknown{tcp\_sock}. \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{TIME\_WAIT} \Mwedge {}\\{}
\quad\quad\quad \tsvar{sock}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsvar{sock}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge {}\\{}
\quad\quad\quad \tsvar{sock}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{sock}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}{}\\{}
\quad \Mthen {}\\{}
\quad\quad\quad \tsaux{tcp\_close} \;\tsvar{h}.\tsvar{arch} \;\tsvar{sock}{}\\{}
\quad \Melse {}\\{}
\quad\quad\quad \tsvar{sock}{}\\{}
 ) \tsvar{socks} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Accept the new connection attempt to the incomplete connection queue if the queue of
        completed (established) connections is not already full }{}\\{}
 {}\\{}
 \tsunknown{accept\_incoming\_q0} \;\tsvar{lis} \;\Mtrue  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Possibly drop an arbitrary connection from the queue of incomplete connection
        attempts -- this covers the behaviour of FreeBSD when the oldest connection in the SYN bucket
        or in the whole SYN cache is dropped, depending upon which became full. }{}\\{}
 (\tsholop{choose} \;\tsunknown{drop} \Mcons  \tsunknown{drop\_from\_q0} \;\tsvar{lis}.{}\\{}
\quad \Mif  \;\tsunknown{drop} \;\Mthen {}\\{}
\quad\quad \exists \tsvar{q0L} \;\tsvar{sid}'' \;\tsvar{q0R}.{}\\{}
\quad\quad\quad \tsvar{lis}.\tsunknown{q0} = \Mappend{\tsvar{q0L}}{(\tsvar{sid}'' \Mcons  \tsvar{q0R})} \Mwedge {}\\{}
\quad\quad\quad \tsvar{q}'_{0} = \Mappend{\tsvar{q0L}}{\tsvar{q0R}}{}\\{}
\quad \Melse {}\\{}
\quad\quad \tsvar{q}'_{0} = \tsvar{lis}.\tsunknown{q0}{}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Put the new incomplete connection on the (possibly pruned) incomplete connections queue. }{}\\{}
 \tsvar{lis}' = \tsvar{lis} \; \Mmagiclrec  \tsunknown{q0} \Mass  \tsvar{sid}' \Mcons  \tsvar{q}'_{0} \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Create a SYN,ACK segment in reply: }{}\\{}
 \tsvar{rcvbufsize}' \;\in  \;\tsunknown{UNIV} \Mwedge  \tsvar{sndbufsize}' \;\in  \;\tsunknown{UNIV} \Mwedge  {}\\{}
 {}\\{}
 \tsholcomm{ Store the new receive and send buffer sizes }{}\\{}
 \tsvar{sf}' = \tsvar{sf} \; \Mmagiclrec  \tsunknown{n} \Mass  \tsunknown{funupd\_list} \;\tsvar{sf}.\tsunknown{n} [(\tscon{SO\_RCVBUF},\tsvar{rcvbufsize}'); (\tscon{SO\_SNDBUF},\tsvar{sndbufsize}')] \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Update the new connection's control block in light of above. }{}\\{}
 \tsvar{cb}' = \tsvar{cb} \; \Mmagiclrec {}\\{}
 {}\\{}
 \tsfield{tt\_keep}           \Mass  \Msome  (\Mtimed{()}{\tsunknown{slow\_timer} \;\tsunknown{TCPTV\_KEEP\_IDLE}}){}\\{}
 \Mmagicbolrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Construct the SYN,ACK segment using the values stored in the updated control block for the
         new connection. See \ltslink{makeTsynTackTsegment}{$\tsaux{make\_syn\_ack\_segment}$}. }{}\\{}
 \tsvar{oflgs} = \tsvar{oflgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mtrue ; \tsvar{FIN} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{odata} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s}' \;\tsvar{s}''{}\\{}
 {}\\{}
 }
{\rulesubsection{Model details}

    During TCP connection establishment, BSD uses syn-caches and syn-buckets to protect against some
    types of denial-of-service attack. These techniques delay the memory allocation for a socket's
    data structures until connection establishment is complete. They are not modelled directly in
    this specification, which instead favours the use of the full socket structure for clarity. The
    behaviour is observationally equivalent provided correct bounds are applied to the lengths of
    the incoming connection queues.

    When a socket completes connection establishment, \ie, enters the $\tscon{ESTABLISHED}$ state, BSD
    updates the socket's control block $\tsunknown{t\_maxseg}$ field to the minimum of the maximum segment size
    it advertised in the emitted SYN,ACK segment and that received in the SYN segment from the
    remote end. This update is later than perhaps it need be. This model updates the $\tsunknown{t\_maxseg}$ at
    the moment both the maximum segment values are known. As a consequence the initial maximum
    segment value advertised by the host must be stored just in case the SYN,ACK segment need be
    retransmitted.


\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    On FreeBSD, the $\tsvar{listen}()$ socket call can be called on a TCP socket in any state, thus it is
    possible for a listening TCP socket to have a peer address, \ie, $\tsvar{is}_{2}$ and $\tsvar{ps}_{2}$ pair,
    specified. This in turn affects the behaviour of connection establishment because an incoming
    $\tsvar{SYN}$ segment only matches this type of listening socket if its address quad matches the
    socket's entire address quad, heavily restricting the usefulness of such a socket.

    Such a restrictive peer address binding is permitted by the model for FreeBSD only.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\deliverTinTII}{\rrulecc{deliverTinTII}{deliver\_in\_2}{tcp: network nonurgent}{\tsholcomm{ Completion of active open (in $\tscon{SYN\_SENT}$ receive SYN,ACK and send ACK) or simultaneous open (in $\tscon{SYN\_SENT}$ receive SYN and send SYN,ACK) }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{TCP\_PROTO} \;\tsunknown{tcp\_sock}))] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf}',\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{cantsndmore},\tsvar{cantrcvmore}',{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st}',\tsvar{cb}'',*,[\,],\tsvar{rcvq}')))] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}'')],\tsvar{M})}
{\tsholcomm{ FIXME this rule is a load of rubbish and should be done better }{}\\{}
 \tsunknown{tcp\_sock} = \tsaux{TCP\_Sock0}(\tscon{SYN\_SENT},\tsvar{cb},*,[\,],[\,]) \Mwedge {}\\{}
 {}\\{}
 \tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \Mtrue  \;\Mfalse  (\tsvar{iflgs},\tsvar{idata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
 {}\\{}
 (\tsvar{iflgs}.\tsvar{RST} = \Mfalse  \Mwedge  (\tsvar{iflgs}.\tsvar{SYN} = \Mtrue  \Mvee  \tsvar{iflgs}.\tsvar{SYNACK} = \Mtrue )) \Mwedge {}\\{}
 {}\\{}
 \tsvar{rcvbufsize}' \;\in  \;\tsunknown{UNIV} \Mwedge  \tsvar{sndbufsize}' \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 \tsvar{sf}' = \tsvar{sf} \; \Mmagiclrec  \tsunknown{n} \Mass  \tsunknown{funupd\_list} \;\tsvar{sf}.\tsunknown{n} [(\tscon{SO\_RCVBUF},\tsvar{rcvbufsize}');{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tscon{SO\_SNDBUF},\tsvar{sndbufsize}')] \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ softerror may be cleared during an active open }{}\\{}
 (\Mif  \;\tsvar{iflgs}.\tsvar{SYNACK} \;\Mthen  \;\tsunknown{t\_softerror'} = * \Mvee  \tsunknown{t\_softerror'} = \tsvar{cb}.\tsfield{t\_softerror}{}\\{}
 \Melse  \;\tsunknown{t\_softerror'} = \tsvar{cb}.\tsfield{t\_softerror}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ data processing is much simpler here than in $\tsunknown{deliver\_in\_3}$ because we know
     we will only ever receive the one $\tsvar{SYN},\tsunknown{ACK}$ datagram (duplicates will
     be rejected, and there's only one datagram and so cannot be
     reordered). }{}\\{}
 \tsvar{data}' = \tsvar{idata} \Mwedge {}\\{}
 \tsvar{FIN}' = \tsvar{iflgs}.\tsvar{FIN} \Mwedge {}\\{}
 \tsvar{rcvq}' = \tsvar{data}' \Mwedge  {}\\{}
 {}\\{}
 \tsvar{cb}' = \tsvar{cb} \; \Mmagiclrec {}\\{}
 \tsfield{tt\_keep}     \Mass  \Msome  (\Mtimed{()}{\tsunknown{slow\_timer} \;\tsunknown{TCPTV\_KEEP\_IDLE}});  {}\\{}
 \tsfield{t\_softerror}   \Mass  \tsunknown{t\_softerror'}{}\\{}
 \Mmagicbolrrec  \Mwedge {}\\{}
 {}\\{}
 (\tsvar{oflgs},\tsvar{odata}) \in  (\Mif  \;\tsvar{iflgs}.\tsvar{SYNACK} \;\Mthen  \;\tsaux{null\_flgs\_data}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  (\Mif  \;\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\tsaux{null\_flgs\_data}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsaux{make\_syn\_ack\_flgs\_data})) \Mwedge {}\\{}
 \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s}' \;\tsvar{s}'' \Mwedge {}\\{}
 {}\\{}
 \tsaux{FIXMEstream\_enqueue\_or\_fail} \;\Mtrue  \;\tsvar{h}.\tsvar{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} (\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{i}_{2}) \tsvar{cb}' \;\tsvar{cb}'' \Mwedge    {}\\{}
 {}\\{}
 \tsholcomm{ N.B. the flags are already written to the stream during the sync }{}\\{}
 {}\\{}
 \tsholcomm{ Note that we change state even if enqueuing or routing returned an error,
            trusting to retransmit to solve our problem. }{}\\{}
 (\Mif  \;\tsvar{iflgs}.\tsvar{SYNACK} \;\Mthen {}\\{}
\quad\quad \tsholcomm{ completion of active open }{}\\{}
\quad\quad (\Mif  \neg{}\tsvar{FIN}' \;\Mthen {}\\{}
\quad\quad\quad\quad (\tsvar{cantrcvmore}' = \tsvar{cantrcvmore} \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{st}' \;\in {}\\{}
\quad\quad\quad\quad\quad (\Mif  \;\tsvar{cantsndmore} = \Mfalse  \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \{\tscon{ESTABLISHED}\}  {}\\{}
\quad\quad\quad\quad\quad\quad \Melse  \{\tscon{FIN\_WAIT\_2};\tscon{FIN\_WAIT\_1}\})) \tsholcomm{ we were trying to send a FIN from $\tscon{SYN\_SENT}$, so move straight
                                                  to $\tscon{FIN\_WAIT\_2}$. Definitely the case with BSD; should also be
                                                  true for other archs. }{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad (\tsvar{cantrcvmore}' = \Mtrue  \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{st}' ={}\\{}
\quad\quad\quad\quad\quad\quad (\Mif  \;\tsvar{cantsndmore} = \Mfalse  \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tscon{CLOSE\_WAIT}{}\\{}
\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tscon{LAST\_ACK})))         \tsholcomm{ we were trying to send a FIN from $\tscon{SYN\_SENT}$ and also receive a
                                                  FIN, so we move straight into $\tscon{LAST\_ACK}$. }{}\\{}
 \Melse {}\\{}
\quad\quad \tsholcomm{ simultaneous open }{}\\{}
\quad\quad (\Mif  \neg{}\tsvar{FIN}' \;\Mthen {}\\{}
\quad\quad\quad\quad (\tsvar{st}' = \tscon{SYN\_RECEIVED} \Mwedge {}\\{}
\quad\quad\quad\quad \tsvar{cantrcvmore}' = \tsvar{cantrcvmore}){}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad (\tsvar{st}' = \tscon{CLOSE\_WAIT} \Mwedge   \tsholcomm{ yes, really! (in BSD) even though we've not yet had our initial SYN acknowledged! See \wasverb{tcp\textunderscore{}input.c:2065 +/-2000} }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad \tsvar{cantrcvmore}' = \Mtrue )){}\\{}
 )}
{\rrulepad }
}

\newcommand{\deliverTinTIII}{\rrulecc{deliverTinTIII}{deliver\_in\_3}{tcp: network nonurgent}{\tsholcomm{ Receive data, FINs, and ACKs in a connected state }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid}, \tsvar{sock})];{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm} \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks}';{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm}' \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}'')],\tsvar{M})}
{\tsvar{sid} \;\notin  (\Mfdom{\tsvar{socks}}) \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock})  \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Assert that the socket meets some sanity properties. This is logically superfluous  but
        aids semi-automatic model checking. See \ltslink{saneTsocket}{$\tsaux{sane\_socket}$} for further details. }{}\\{}
 \tsaux{sane\_socket} \;\tsvar{sock} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Take TCP segment $\tsunknown{seg}$ from the head of the host's input queue }{}\\{}
 \tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \Mtrue  \;\Mfalse  (\tsvar{iflgs},\tsvar{idata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ The segment must be of an acceptable form }{}\\{}
 \tsholcomm{ Note: some segment fields (namely TCP options $\tsunknown{ws}$ and $\tsunknown{mss}$), are only used during
        connection establishment and any values assigned to them in segments during a connection are
        simply ignored. They are equal to the identifiers $\tsunknown{ws\_discard}$ and
        $\tsunknown{mss\_discard}$ respectively, which are otherwise unconstrained. }{}\\{}
 \tsvar{iflgs}.\tsvar{RST} = \Mfalse  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ The socket is fully connected so its complete address quad must match the address
        quad of the segment $\tsunknown{seg}$. By definition, $\tsvar{sock}$ is the socket with the best address
        match thus the auxiliary function $\tsaux{tcp\_socket\_best\_match}$ is not required here. }{}\\{}
 \tsvar{sock}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsvar{sock}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{sock}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ The socket must be in a connected state, or is in the $\tscon{SYN\_RECEIVED}$ state and
        $\tsunknown{seg}$ is the final segment completing a passive or simultaneous open. }{}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \;\notin  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT}\} \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{SYN\_RECEIVED};\tscon{ESTABLISHED};\tscon{CLOSE\_WAIT};\tscon{FIN\_WAIT\_1};\tscon{FIN\_WAIT\_2};{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tscon{CLOSING};\tscon{LAST\_ACK};\tscon{TIME\_WAIT}\} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ If socket $\tsvar{sock}$ has previously emitted a $\tsvar{FIN}$ segment check that a thread is still
        associated with the socket, i.e.~check that the socket still has a valid file identifier
        $\tsvar{fid} \neq  *$. If not, and the segment contains new data, the segment should not be
        processed by this rule as there is no thread to read the data from the socket after
        processing.  Query: how does this $\tsvar{st}$ condition relate to $\tsvar{wesentafin}$ below? }{}\\{}
 {}\\{}
 (\exists  \tsvar{cond}. \neg{}(\tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{FIN\_WAIT\_1}; \tscon{CLOSING}; \tscon{LAST\_ACK}; \tscon{FIN\_WAIT\_2}; \tscon{TIME\_WAIT}\} \Mwedge {}\\{}
 \tsvar{cond})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ A $\tsvar{SYN}$ should be received only in the $\tscon{SYN\_RECEIVED}$ state. }{}\\{}
 (\tsvar{iflgs}.\tsvar{SYN} \implies  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ If the socket $\tsvar{sock}$ has previously sent a $\tsvar{FIN}$ segment it has been acknowledged by
        segment $\tsunknown{seg}$ if the segment has the $\tsunknown{ACK}$ flag set and an acknowledgment number $\tsunknown{ack}
\geq  \tsvar{cb}.\tsunknown{snd\_max}$. }{}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 (\tsvar{ourfinisacked} \implies  \tsvar{wesentafin}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ $\tsvar{wercvdafin}$ approximated by $\tsvar{iflgs}.\tsvar{FIN}$ }{}\\{}
 (\tsvar{wercvdafin} = \tsvar{iflgs}.\tsvar{FIN}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Process the segment and return an updated socket state }{}\\{}
 {}\\{}
 {}\\{}
 ({}\\{}
\quad {}\\{}
\quad \exists  \tsvar{sock}_{0}. \tsaux{di3\_topstuff} \;\tsvar{sock} \;\tsvar{sock}_{0} \Mwedge {}\\{}
 {}\\{}
\quad {}\\{}
\quad \exists  \tsvar{sock}_{1} \;\tsvar{FIN}_{1} \;\tsvar{stop}_{1}. \tsaux{di3\_ackstuff} \;\tsunknown{tcp\_sock} \;\tsvar{ourfinisacked} \;\tsvar{h}.\tsvar{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{sock}_{0} (\tsvar{sock}_{1},\tsvar{FIN}_{1},\tsvar{stop}_{1}) \Mwedge {}\\{}
\quad \Mif  \;\tsvar{stop}_{1} = \Mtrue {}\\{}
\quad \Mthen {}\\{}
\quad\quad\quad (\tsvar{sock}',\tsvar{oflgs}.\tsvar{FIN}) = (\tsvar{sock}_{1},\tsvar{FIN}_{1}){}\\{}
\quad \Melse {}\\{}
 {}\\{}
\quad {}\\{}
\quad \Mlet  \;\tsunknown{datastuff} \;\tsunknown{theststuff} ={}\\{}
\quad\quad\quad \tsholcomm{ Extract and reassemble data (including urgent data). See \ltslink{diIIITdatastuff}{$\tsaux{di3\_datastuff}$}. }{}\\{}
\quad\quad\quad {}\\{}
\quad\quad\quad \tsaux{di3\_datastuff} \;\tsvar{wercvdafin}  \;\tsunknown{theststuff} \;\tsvar{ourfinisacked}{}\\{}
\quad \Mand  \;\tsunknown{ststuff} \;\tsunknown{FIN\_reass} ={}\\{}
\quad\quad\quad \tsholcomm{ Possibly change the socket's state (especially on receipt of a valid $\tsvar{FIN}$). See
                \ltslink{diIIITststuff}{$\tsaux{di3\_ststuff}$}. }{}\\{}
\quad\quad\quad \tsaux{di3\_ststuff} \;\tsvar{wercvdafin}  \;\tsvar{ourfinisacked}{}\\{}
\quad \Min {}\\{}
\quad \exists \tsvar{sock}_{2} \;\tsvar{FIN}_{2}. \tsunknown{datastuff} \;\tsunknown{ststuff} \;\tsvar{sock}_{1} (\tsvar{sock}_{2},\tsvar{FIN}_{2}) \Mwedge {}\\{}
\quad (\tsvar{sock}',\tsvar{oflgs}.\tsvar{FIN}) = (\tsvar{sock}_{2}, \tsvar{FIN}_{2} \Mvee  \tsvar{FIN}_{1}){}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsvar{sock}'.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) \Mwedge {}\\{}
 \tsvar{rcvq} \;\in  \;\tsunknown{UNIV} \Mwedge  {}\\{}
 \tsvar{sndq} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 \tsvar{sock}'' = \tsvar{sock}' \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'} \; \Mmagiclrec  \tsvar{rcvq}\Mass \tsvar{rcvq}; \tsvar{sndq}\Mass \tsvar{sndq} \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ If socket $\tsvar{sock}$ was initially in the $\tscon{SYN\_RECEIVED}$ state and after processing $\tsunknown{seg}$
        is in the $\tscon{ESTABLISHED}$ state (or if the segment contained a $\tsvar{FIN}$ and the socket is in one of the
        $\tscon{FIN\_WAIT\_1}$, $\tscon{FIN\_WAIT\_2}$ or $\tscon{CLOSE\_WAIT}$ states), the socket is probably on some
        other socket's incomplete connections queue and $\tsunknown{seg}$ is the final segment in a passive
        open. If it is on some other socket's incomplete connections queue the other socket is
        updated to move the newly connected socket's reference from the incomplete to the complete
        connections queue (unless the complete connection queue is full, in which case the new
        connection is dropped and all references to it are removed).  If not, $\tsunknown{seg}$ is the final
        segment in a simultaneous open in which case no other sockets are updated.  The auxiliary
        function \ltslink{diIIITsocksTupdate}{$\tsaux{di3\_socks\_update}$} does all the hard work, updating the relevant
        sockets in the finite map $\tsvar{socks}$ to yield $\tsvar{socks}'$. }{}\\{}
 (\Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge {}\\{}
\quad \tsunknown{tcp\_sock'}.\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}; \tscon{CLOSE\_WAIT}\} \Mthen {}\\{}
\quad\quad \tsaux{di3\_socks\_update} \;\tsvar{sid} (\tsvar{socks} \oplus  (\tsvar{sid},\tsvar{sock}'')) \tsvar{socks}'{}\\{}
 \Melse {}\\{}
\quad \tsholcomm{ If the socket was not initially in the $\tscon{SYN\_RECEIVED}$ state, \ie $\tsunknown{seg}$ was processed
            by an already connected socket, ensure the updated socket is in the final finite
            maps of sockets. }{}\\{}
\quad \tsvar{socks}' = \tsvar{socks} \oplus  (\tsvar{sid},\tsvar{sock}'')) \Mwedge {}\\{}
 \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},[\,]) \tsvar{s}' \;\tsvar{s}'' }
{\rrulepad }
}

\newcommand{\defndiIIITtopstuff}{\ddefnc{diIIITtopstuff}{\iA{di3\_topstuff}}{\subddefnA[{ $\tsunknown{deliver\_in\_3}$ initial checks }]{di3\_topstuff}{\tsaux{di3\_topstuff} \;\tsunknown{sock} \;\tsunknown{sock'} ={}\\{}
 \exists  \tsunknown{tcp\_sock}.{}\\{}
 \tsunknown{sock}.\tsvar{pr} = \tscon{TCP\_PROTO} \;\tsunknown{tcp\_sock} \Mwedge {}\\{}
 \Mlet  \;\tsvar{cb} = \tsunknown{tcp\_sock}.\tsvar{cb} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Reset the socket's idle timer and keepalive timer to start counting from zero as
        activity is taking place on the socket: a segment is being processed. If the
        $\tscon{FIN\_WAIT\_2}$ timer is enabled this may be reset upon processing this segment. See
        \ltslink{updateTidle}{$\tsaux{update\_idle}$} for further details }{}\\{}
 \tsholop{choose} \;\tsunknown{tt\_keep'} \Mcons  \tsaux{update\_idle} \;\tsunknown{tcp\_sock}.{}\\{}
 {}\\{}
 \tsholcomm{ Note: if a reasonably continuous stream of segments is being received with increasing
        timestamp values and few data segments are sent in return such that acknowledgments are
        delayed, \ie, every other segment is acknowledged, then only the timestamp from every other
        segment is recorded by these conditions. This is still sufficient to protect against
        wrapped sequence numbers. }{}\\{}
 \tsunknown{sock'} = \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO} (\tsunknown{tcp\_sock} \;{}\\{}
\quad\quad\quad\quad\quad\quad \Mmagiclrec  \tsvar{cb} \Mass  \tsunknown{tcp\_sock}.\tsvar{cb} \; \Mmagiclrec  \tsfield{tt\_keep} \Mass  \tsunknown{tt\_keep'} \Mmagicrrec  \Mmagicrrec ){}\\{}
 \Mmagicbolrrec }
}
{\rrulepad }
}

\newcommand{\defndiIIITnewackstuff}{\ddefnc{diIIITnewackstuff}{\iA{di3\_newackstuff}}{\subddefnA[{ $\tsunknown{deliver\_in\_3}$ new ack processing, used in $\tsaux{di3\_ackstuff}$  }]{di3\_newackstuff}{\tsaux{di3\_newackstuff} \;\tsunknown{tcp\_sock\_0} \;\tsunknown{ourfinisacked} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{sock} (\tsunknown{sock'},\tsvar{FIN},\tsunknown{sto\_p}) ={}\\{}
 {}\\{}
 \exists  (\tsunknown{sock''},\tsvar{FIN}'',\tsunknown{stop''}) \Mcons  \{(\tsunknown{sock'},\tsvar{FIN},\tsunknown{sto\_p}) \mid {}\\{}
 \exists  \tsunknown{t\_dupacks} \Mcons  (\tsunknown{UNIV}:\tstype{num} \;\tstype{set}).{}\\{}
 \exists  \tsunknown{ack\_lt\_snd\_recover} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
 (\Mif  \neg{}\tsunknown{TCP\_DO\_NEWRENO} \Mvee  \tsunknown{t\_dupacks} < 3 \;\Mthen {}\\{}
\quad\quad (\tsunknown{sock'},\tsvar{FIN},\tsunknown{sto\_p}) = (\tsunknown{sock},\Mfalse ,\Mfalse ){}\\{}
\quad \Melse  \;\Mif  \;\tsunknown{TCP\_DO\_NEWRENO} \Mwedge  \tsunknown{t\_dupacks} \geq  3 \Mwedge  \tsunknown{ack\_lt\_snd\_recover} \;\Mthen {}\\{}
 {}\\{}
\quad\quad \tsholcomm{ Attempt to create a segment for output using the modified control block (this is a
             relational monad idiom) }{}\\{}
\quad\quad \tsaux{FIXMEstream\_mlift\_tcp\_output\_perhaps\_or\_fail} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{sock} (\tsunknown{sock'},\tsvar{FIN}) \Mwedge {}\\{}
\quad\quad \tsunknown{sto\_p} = \Mfalse {}\\{}
 {}\\{}
\quad \Melse  \;\Mif  \;\tsunknown{TCP\_DO\_NEWRENO} \Mwedge  \tsunknown{t\_dupacks} \geq  3 \Mwedge  \neg{} \tsunknown{ack\_lt\_snd\_recover} \;\Mthen {}\\{}
\quad\quad \tsholcomm{ The host supports NewReno-style Fast Recovery, the socket has received at least three
             duplicate $\tsunknown{ACK}$ segments and the new $\tsunknown{ACK}$ acknowledges at least everything upto
             $\tsunknown{snd\_recover}$, completing the recovery process. }{}\\{}
\quad\quad (\tsunknown{sock'},\tsvar{FIN},\tsunknown{sto\_p}) = (\tsunknown{sock},\Mfalse ,\Mfalse ){}\\{}
 {}\\{}
\quad \Melse  \;\tsunknown{K} \;\tsunknown{ARB} \text{``FIXME assert failure: di3\textunderscore{}newackstuff''} \tsholcomm{ impossible }{}\\{}
 {}\\{}
 )\}.{}\\{}
 \tscomm{ we never stop in the above, so always continue, but rebind sock }{}\\{}
 \Mlet  \;\tsunknown{sock} = \tsunknown{sock''} \;\Min {}\\{}
 \exists  (\tsunknown{sock'''},\tsvar{FIN}''',\tsunknown{stop'''}) \Mcons  \{(\tsunknown{sock'},\tsvar{FIN},\tsunknown{sto\_p}) \mid {}\\{}
 {}\\{}
 \tsholcomm{ If the retransmit timer is set and the socket has done only one retransmit and it is still
        within the bad retransmit timer window, then because this is an $\tsunknown{ACK}$ of new data the
        retransmission was done in error. Flag this so that the control block can be recovered
        from retransmission mode. This is known as a "bad retransmit". }{}\\{}
 \exists  \tsunknown{IS\_SOME\_emission\_time} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
 \exists  \tsunknown{tcp\_sock}.{}\\{}
 (\tsunknown{sock}.\tsvar{pr} = \tscon{TCP\_PROTO} \;\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsholcomm{ rebind sock in the process of updating }{}\\{}
 \Mlet  \;\tsunknown{sock} = \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO} (\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsunknown{tcp\_sock}.\tsvar{cb} \;{}\\{}
 \Mmagiclrec {}\\{}
 {}\\{}
 \tsholcomm{ If the $\tsunknown{ACK}$ segment allowed us to successfully time a segment (and update the
              round-trip time estimates) then clear the soft error flag and clear the segment
              round-trip timer in order that it can be used on a future segment. }{}\\{}
 \tsfield{t\_softerror} \;\Mupdby  \;* \;\tsholop{onlywhen} \;\tsunknown{IS\_SOME\_emission\_time}{}\\{}
 \Mmagicbolrrec  \Mmagicrrec ) \Mmagicrrec  \Min {}\\{}
 {}\\{}
 \exists  \tsunknown{ack\_gt\_snd\_una} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
 \exists  \tsunknown{tcp\_sock}.{}\\{}
 (\tsunknown{sock}.\tsvar{pr} = \tscon{TCP\_PROTO} \;\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 (\Mif  \;\tsunknown{tcp\_sock\_0}.\tsvar{st} = \tscon{LAST\_ACK} \Mwedge  \tsunknown{ourfinisacked} \;\Mthen {}\\{}
\quad \tsholcomm{ If the socket's $\tsvar{FIN}$ has been acknowledged and the socket is in the $\tscon{LAST\_ACK}$
            state, close the socket and stop processing this segment }{}\\{}
\quad \tsunknown{sock'} = \tsaux{tcp\_close} \;\tsvar{arch} \;\tsunknown{sock} \Mwedge {}\\{}
\quad \tsvar{FIN} = \Mfalse  \Mwedge {}\\{}
\quad \tsunknown{sto\_p} = \Mtrue {}\\{}
 \Melse {}\\{}
\quad \tsholcomm{ Otherwise, flag that $\tsunknown{deliver\_in\_3}$ can continue processing the segment if need be }{}\\{}
\quad (\tsunknown{sock'},\tsvar{FIN},\tsunknown{sto\_p}) = (\tsunknown{sock},\Mfalse ,\Mfalse )){}\\{}
 \}.{}\\{}
 \tsunknown{sock'} = \tsunknown{sock'''} \Mwedge {}\\{}
 (\tsvar{FIN} = (\tsvar{FIN}'' \Mvee  \tsvar{FIN}''')) \Mwedge {}\\{}
 \tsunknown{sto\_p} = \tsunknown{stop'''}}
}
{\rrulepad }
}

\newcommand{\defndiIIITackstuff}{\ddefnc{diIIITackstuff}{\iA{di3\_ackstuff}}{\subddefnA[{ $\tsunknown{deliver\_in\_3}$ ACK processing }]{di3\_ackstuff}{\tsaux{di3\_ackstuff} \;\tsunknown{tcp\_sock\_0} \;\tsunknown{ourfinisacked} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{sock} (\tsunknown{sock'},\tsvar{FIN},\tsunknown{sto\_p}) ={}\\{}
 \exists  \tsunknown{ack\_le\_snd\_una} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
 \exists  \tsunknown{maybe\_dup\_ack} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
 \Mif  \;\tsunknown{ack\_le\_snd\_una} \Mwedge  \tsunknown{maybe\_dup\_ack} \;\Mthen {}\\{}
\quad \tsholcomm{ Received a duplicate acknowledgement: it is an old acknowledgement (strictly less than
            $\tsunknown{snd\_una}$) and it meets the duplicate acknowledgement conditions above.
            Do Fast Retransmit/Fast Recovery Congestion Control (RFC 2581 Ch3.2 Pg6) and
            NewReno-style Fast Recovery (RFC 2582, Ch3 Pg3), updating the control block variables
            and creating segments for transmission as appropriate. }{}\\{}
 {}\\{}
\quad\quad \exists  \tsunknown{t\_dupacks'} \Mcons  (\tsunknown{UNIV} \;\tsholop{DIFF} \{0:\tstype{num}\}).{}\\{}
\quad\quad \exists  \tsunknown{ack\_lt\_snd\_recover} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
 {}\\{}
\quad\quad \Mif  \;\tsunknown{t\_dupacks'} < 3  \;\Mthen {}\\{}
\quad\quad\quad \tsholcomm{ Fewer than three duplicate acks received so far. Just increment the duplicate ack
                counter.  We must continue processing, in case $\tsvar{FIN}$ is set. }{}\\{}
\quad\quad\quad (\tsunknown{sock'},\tsvar{FIN},\tsunknown{sto\_p}) = (\tsunknown{sock},\Mfalse ,\Mfalse ){}\\{}
 {}\\{}
 {}\\{}
\quad\quad \Melse  \;\Mif  \;\tsunknown{t\_dupacks'} > 3 \Mvee  (\tsunknown{t\_dupacks'} = 3 \Mwedge  \tsunknown{TCP\_DO\_NEWRENO} \Mwedge  \tsunknown{ack\_lt\_snd\_recover}) \Mthen {}\\{}
\quad\quad\quad \tsholcomm{ If this is the 4th or higher duplicate $\tsunknown{ACK}$ then Fast Retransmit/Fast Recovery
                congestion control is already in progress. Increase the congestion window by another
                maximum segment size (as the duplicate $\tsunknown{ACK}$ indicates another out-or-order
                segment has been received by the other end and is no longer consuming network
                resource), increment the duplicate $\tsunknown{ACK}$ counter, and attempt to output another
                segment. }{}\\{}
\quad\quad\quad \tsholcomm{ If this is the 3rd duplicate $\tsunknown{ACK}$, the host supports NewReno extensions and
                $\tsunknown{ack}$ is strictly less than the fast recovery "recovered" sequence number
                $\tsunknown{snd\_recover}$, then the host is already doing NewReno-style fast recovery and has
                possibly falsely retransmitted a segment, the retransmitted segment has been lost or
                it has been delayed. Reset the duplicate $\tsunknown{ACK}$ counter, increase the congestion
                window by a maximum segment size (for the same reason as before) and attempt to output
                another segment. NB: this will not cause a cycle to develop! The retransmission
                timer will eventually fire if recovery does not happen "fast". }{}\\{}
\quad\quad\quad \tsaux{FIXMEstream\_mlift\_tcp\_output\_perhaps\_or\_fail} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{sock} (\tsunknown{sock'},\tsvar{FIN}) \Mwedge {}\\{}
\quad\quad\quad \tsunknown{sto\_p} = \Mtrue  \tsholcomm{ no need to process the segment any further }{}\\{}
 {}\\{}
 {}\\{}
\quad\quad \Melse  \;\Mif  \;\tsunknown{t\_dupacks'} = 3 \Mwedge  \neg{}(\tsunknown{TCP\_DO\_NEWRENO} \Mwedge  \tsunknown{ack\_lt\_snd\_recover}) \Mthen {}\\{}
\quad\quad\quad \tsholcomm{ If this is the 3rd duplicate segment and if the host supports NewReno extensions, a
               NewReno-style Fast Retransmit is not already in progress, then do a Fast Retransmit }{}\\{}
 {}\\{}
\quad\quad\quad \tsholcomm{ Attempt to create a segment for output using the modified control block (this is all
                a relational monad idiom) }{}\\{}
\quad\quad\quad \tsaux{FIXMEstream\_mlift\_tcp\_output\_perhaps\_or\_fail} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{sock} (\tsunknown{sock'},\tsvar{FIN}) \Mwedge {}\\{}
 {}\\{}
\quad\quad\quad \tsunknown{sto\_p} = \Mtrue  \tsholcomm{ no need to process the segment any further }{}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
\quad\quad \Melse  \;\Mfalse   \tsholcomm{ "FIXME failure: $\tsaux{di3\_ackstuff}$" Believed to be impossible---here for completion and safety }{}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
\quad \Melse  \;\Mif  \;\tsunknown{ack\_le\_snd\_una} \Mwedge  \neg{}\tsunknown{maybe\_dup\_ack} \;\Mthen {}\\{}
\quad\quad \tsholcomm{ Have received an old (would use the word "duplicate" if it did not have a special
              meaning) $\tsunknown{ACK}$ and it is neither a duplicate $\tsunknown{ACK}$ nor the $\tsunknown{ACK}$ of a new
              sequence number thus just clear the duplicate $\tsunknown{ACK}$ counter. }{}\\{}
\quad\quad (\tsunknown{sock'},\tsvar{FIN},\tsunknown{sto\_p}) = (\tsunknown{sock},\Mfalse ,\Mfalse ){}\\{}
 {}\\{}
\quad \Melse  \tsholcomm{ Must be: $\tsunknown{ack} > \tsvar{cb}.\tsunknown{snd\_una}$ }{}\\{}
\quad\quad \tsholcomm{ This is the $\tsunknown{ACK}$ of a new sequence number---this case is handled by the auxiliary
              function \ltslink{diIIITnewackstuff}{$\tsaux{di3\_newackstuff}$} }{}\\{}
\quad\quad \tsaux{di3\_newackstuff} \;\tsunknown{tcp\_sock\_0} \;\tsunknown{ourfinisacked} \;\tsvar{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{sock} (\tsunknown{sock'},\tsvar{FIN},\tsunknown{sto\_p})}
}
{\rrulepad }
}

\newcommand{\defndiIIITdatastuff}{\ddefnc{diIIITdatastuff}{\iA{di3\_datastuff}}{\subddefnA[{ $\tsunknown{deliver\_in\_3}$ data processing }]{di3\_datastuff}{(\tsaux{di3\_datastuff} (\tsunknown{FIN\_reass}:\tstype{bool}) \tsunknown{the\_ststuff} \;\tsunknown{ourfinisacked} \;\tsunknown{sock} (\tsunknown{sock'}:\tstype{socket},\tsvar{FIN}:\tstype{bool})):\tstype{bool} ={}\\{}
 {}\\{}
 \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsunknown{sock} \;\Min {}\\{}
 {}\\{}
 \Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{TIME\_WAIT} \Mvee  (\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSING} \Mwedge  \tsunknown{ourfinisacked}) \Mthen {}\\{}
\quad \tsunknown{the\_ststuff} \;\Mfalse  \;\tsunknown{sock} (\tsunknown{sock'},\tsvar{FIN}){}\\{}
 \Melse {}\\{}
\quad \tsunknown{the\_ststuff} \;\tsunknown{FIN\_reass} \;\tsunknown{sock} (\tsunknown{sock'},\tsvar{FIN})}
}
{\rrulepad }
}

\newcommand{\defnT}{\ddefnc{T}{\iA{!}}{\subddefnA{!}{\forall  \tsaux{stop}.{}\\{}
 \tsholcomm{ $\tsunknown{deliver\_in\_3}$ TCP state change processing }{}\\{}
 \tsaux{di3\_ststuff} \;\tsunknown{FIN\_reass} \;\tsunknown{ourfinisacked} \;\tsunknown{sock} (\tsunknown{sock'},\tsaux{stop}) ={}\\{}
 {}\\{}
 \tsholcomm{ The entirety of this function is an encoding of the TCP State Transition Diagram (as it is, not as it is traditionally depicted)
        post-$\tscon{SYN\_SENT}$ state. It specifies for given start state and set of conditions (all or
        some of which are affected by the processing of the current segment), which state the TCP
        socket should be moved into next }{}\\{}
 {}\\{}
 \tsholcomm{ If the processing of the current segment has led to $\tsunknown{FIN\_reass}$ being asserted then the
          whole data stream from the other end has been received and reconstructed, including
          the final $\tsvar{FIN}$ flag. The socket should have its read-half flagged as shut down, \ie,
          $\tsvar{cantrcvmore} = \Mtrue $, otherwise the socket is not modified. }{}\\{}
 \Mlet  \;\tsunknown{sock} = (\Mif  \;\tsunknown{FIN\_reass} \;\Mthen {}\\{}
\quad\quad \tsunknown{sock} \; \Mmagiclrec  \tsvar{cantrcvmore} \Mass  \Mtrue  \Mmagicrrec {}\\{}
\quad \Melse  \;\tsunknown{sock}) \Min {}\\{}
 \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsunknown{sock} \;\Min {}\\{}
 \Mlet  \;\tsaux{cont} = (\tsunknown{sock'} = \tsunknown{sock} \Mwedge  \tsaux{stop} = \Mfalse ) \Min {}\\{}
 \Mlet  \;\tsunknown{enter\_TIME\_WAIT} = (\tsunknown{sock'} = \tsunknown{sock} \;{}\\{}
\quad\quad\quad\quad \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO} (\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{st} \Mass  \tscon{TIME\_WAIT};{}\\{}
 \tsvar{cb} \Mass   \tsunknown{tcp\_sock} \; \Mmagiclrec  \tsfield{tt\_keep} \Mass  * \Mmagicrrec {}\\{}
 \Mmagicbolrrec ){}\\{}
 \Mmagicbolrrec  \Mwedge {}\\{}
\quad \tsaux{stop} = \Mfalse ) \Min {}\\{}
 {}\\{}
 \tsholcomm{ State Transition Diagram encoding: }{}\\{}
 \tsholcomm{ The state transition encoding, case-split on the current state and whether a $\tsvar{FIN}$ from
          the remote end has been reassembled }{}\\{}
 \Mcase  ((\tsaux{tcp\_sock\_of} \;\tsunknown{sock}).\tsvar{st}, \tsunknown{FIN\_reass}) \Mof {}\\{}
 {}\\{}
\quad (\tscon{SYN\_RECEIVED},\Mfalse ) \Mtotype  \tsholcomm{ In $\tscon{SYN\_RECEIVED}$ and have not received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ FIXME tjr not happy about this- shouldn't we be more deterministic? }{}\\{}
\quad\quad (\exists  \tsunknown{ack\_ge\_suc\_iss} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
\quad\quad \Mif  \;\tsunknown{ack\_ge\_suc\_iss} \;\Mthen {}\\{}
\quad\quad\quad \tsholcomm{ This socket's initial $\tsvar{SYN}$ has been acknowledged }{}\\{}
\quad\quad\quad \tsunknown{sock'} = \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO} (\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{st} \Mass  \Mif  \neg{}\tsunknown{sock}.\tsvar{cantsndmore} \;\Mthen {}\\{}
\quad \tscon{ESTABLISHED} \tsholcomm{ socket is now fully connected }{}\\{}
 \Melse {}\\{}
\quad \tsholcomm{ The connecting socket had it's write-half shutdown by $\tsunknown{shutdown}()$
                               forcing a $\tsvar{FIN}$ to be emitted to the other end }{}\\{}
\quad \Mif  \;\tsunknown{ourfinisacked} \;\Mthen {}\\{}
\quad\quad \tsholcomm{ The emitted $\tsvar{FIN}$ has been acknowledged }{}\\{}
\quad\quad \tscon{FIN\_WAIT\_2}{}\\{}
\quad \Melse {}\\{}
\quad\quad \tsholcomm{ Still waiting for the emitted $\tsvar{FIN}$ to be acknowledged }{}\\{}
\quad\quad \tscon{FIN\_WAIT\_1}{}\\{}
 \Mmagicbolrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad \tsaux{stop} = \Mfalse {}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad \tsholcomm{ Not a valid path }{}\\{}
\quad\quad\quad \tsaux{stop}) \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{SYN\_RECEIVED},\Mtrue ) \Mtotype   \tsholcomm{ In $\tscon{SYN\_RECEIVED}$ and have received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ Enter the $\tscon{CLOSE\_WAIT}$ state, missing out $\tscon{ESTABLISHED}$ }{}\\{}
\quad\quad \tsunknown{sock'} = \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO} (\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{st} \Mass  \tscon{CLOSE\_WAIT} \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad \tsaux{stop} = \Mfalse  \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{ESTABLISHED},\Mfalse )  \Mtotype   \tsholcomm{ In $\tscon{ESTABLISHED}$ and have not received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ Doing common-case data delivery and acknowledgements. Remain in $\tscon{ESTABLISHED}$. }{}\\{}
\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
 {}\\{}
\quad (\tscon{ESTABLISHED},\Mtrue )  \Mtotype   \tsholcomm{ In $\tscon{ESTABLISHED}$ and received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ Move into the $\tscon{CLOSE\_WAIT}$ state }{}\\{}
\quad\quad \tsunknown{sock'} = \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO} (\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{st} \Mass  \tscon{CLOSE\_WAIT} \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad \tsaux{stop} = \Mfalse  \Mdpipe {}\\{}
 {}\\{}
 {}\\{}
\quad (\tscon{CLOSE\_WAIT},\Mfalse )   \Mtotype   \tsholcomm{ In $\tscon{CLOSE\_WAIT}$ and have not received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ Do nothing and remain in $\tscon{CLOSE\_WAIT}$. The socket has its receive-side shut down due to
             the $\tsvar{FIN}$ it received previously from the remote end. It can continue to emit
             segments containing data and receive acknowledgements back until such a time that it
             closes down and emits a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{CLOSE\_WAIT},\Mtrue )   \Mtotype   \tsholcomm{ In $\tscon{CLOSE\_WAIT}$ and received (another) $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ The duplicate $\tsvar{FIN}$ will have had a new sequence number to be valid and reach this
             point; RFC793 says "ignore" it so do not change state! If it were a duplicate with the
             same sequence number as the previously accepted $\tsvar{FIN}$, then the $\tsunknown{deliver\_in\_3}$
             acknowledgement processing function $\tsaux{di3\_ackstuff}$ would have dropped it. }{}\\{}
\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{FIN\_WAIT\_1},\Mfalse )   \Mtotype   \tsholcomm{ In $\tscon{FIN\_WAIT\_1}$ and have not received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ This socket will have emitted a $\tsvar{FIN}$ to enter $\tscon{FIN\_WAIT\_1}$. }{}\\{}
\quad\quad \Mif  \;\tsunknown{ourfinisacked} \;\Mthen {}\\{}
\quad\quad\quad \tsholcomm{ If this socket's $\tsvar{FIN}$ has been acknowledged, enter state $\tscon{FIN\_WAIT\_2}$ and start
                the $\tscon{FIN\_WAIT\_2}$ timer. The timer ensures that if the other end has gone away
                without emitting a $\tsvar{FIN}$ and does not transmit any more data the socket is closed
                rather left dangling. }{}\\{}
\quad\quad\quad \tsunknown{sock'} = \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO} (\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{st} \Mass  \tscon{FIN\_WAIT\_2} \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad \tsaux{stop} = \Mfalse {}\\{}
 {}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad \tsholcomm{ If this socket's $\tsvar{FIN}$ has not been acknowledged then remain in $\tscon{FIN\_WAIT\_1}$ }{}\\{}
\quad\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{FIN\_WAIT\_1},\Mtrue )   \Mtotype   \tsholcomm{ In $\tscon{FIN\_WAIT\_1}$ and received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \Mif  \;\tsunknown{ourfinisacked} \;\Mthen {}\\{}
\quad\quad\quad \tsholcomm{ ...and this socket's $\tsvar{FIN}$ has been acknowledged then the connection has been
                closed successfully so enter $\tscon{TIME\_WAIT}$. Note: this differs slightly from the
                behaviour of BSD which momentarily enters the $\tscon{FIN\_WAIT\_2}$ and after a little more
                processing enters $\tscon{TIME\_WAIT}$ }{}\\{}
\quad\quad\quad \tsunknown{enter\_TIME\_WAIT}{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad \tsholcomm{ If this socket's $\tsvar{FIN}$ has not been acknowledged then the other end is attempting
                to close the connection simultaneously (a simultaneous close). Move to the
                $\tscon{CLOSING}$ state }{}\\{}
\quad\quad\quad \tsunknown{sock'} = \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO} (\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{st} \Mass  \tscon{CLOSING} \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad \tsaux{stop} = \Mfalse  \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{FIN\_WAIT\_2},\Mfalse )   \Mtotype   \tsholcomm{ In $\tscon{FIN\_WAIT\_2}$ and have not received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ This socket has previously emitted a $\tsvar{FIN}$ which has already been acknowledged. It
              can continue to receive data from the other end which it must acknowledge. During
              this time the socket should remain in $\tscon{FIN\_WAIT\_2}$ until such a time that it
              receives a valid $\tsvar{FIN}$ from the remote end, or if no activity occurs on the
              connection the $\tscon{FIN\_WAIT\_2}$ timer will fire, eventually closing the socket }{}\\{}
\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{FIN\_WAIT\_2},\Mtrue )   \Mtotype   \tsholcomm{ In $\tscon{FIN\_WAIT\_2}$ and have received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ Connection has been shutdown so enter $\tscon{TIME\_WAIT}$ }{}\\{}
\quad\quad \tsunknown{enter\_TIME\_WAIT} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{CLOSING},\Mfalse )      \Mtotype    \tsholcomm{ In $\tscon{CLOSING}$ and have not received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \Mif  \;\tsunknown{ourfinisacked} \;\Mthen {}\\{}
\quad\quad\quad \tsholcomm{ If this socket's $\tsvar{FIN}$ has been acknowledged (common-case), enter $\tscon{TIME\_WAIT}$ as
                the connection has been successfully closed }{}\\{}
\quad\quad\quad \tsunknown{enter\_TIME\_WAIT}{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad \tsholcomm{ Otherwise, the other end has not yet received or processed the $\tsvar{FIN}$ emitted by
                this socket. Remain in the $\tscon{CLOSING}$ state until it does so. Note: if the
                previosuly emitted $\tsvar{FIN}$ is not acknowledged this socket's retransmit timer will
                eventually fire causing retransmission of the $\tsvar{FIN}$. }{}\\{}
\quad\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{CLOSING},\Mtrue )      \Mtotype   \tsholcomm{ In $\tscon{CLOSING}$ and have received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ The received $\tsvar{FIN}$ is a duplicate $\tsvar{FIN}$ with a new sequence number so as per RFC793 is
              ignored -- if it were a duplicate with the same sequence number as the previously
              accepted $\tsvar{FIN}$, then the $\tsunknown{deliver\_in\_3}$ acknowledgement processing function
              $\tsaux{di3\_ackstuff}$ would have dropped it. }{}\\{}
\quad\quad\quad \Mif  \;\tsunknown{ourfinisacked} \;\Mthen {}\\{}
\quad\quad\quad\quad \tsholcomm{ If this socket's $\tsvar{FIN}$ has been acknowledged then the connection is now
                 successfully closed, so enter $\tscon{TIME\_WAIT}$ state }{}\\{}
\quad\quad\quad\quad \tsunknown{enter\_TIME\_WAIT}{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad \tsholcomm{ Otherwise, ignore the new $\tsvar{FIN}$ and remain in the same state }{}\\{}
\quad\quad\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{LAST\_ACK},\Mfalse )     \Mtotype   \tsholcomm{ In $\tscon{LAST\_ACK}$ and have not received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ Remain in $\tscon{LAST\_ACK}$ until this socket's $\tsvar{FIN}$ is acknowledged. Note: eventually
              the retransmit timer will fire forcing the $\tsvar{FIN}$ to be retransmitted. }{}\\{}
\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{LAST\_ACK},\Mtrue )     \Mtotype   \tsholcomm{ In $\tscon{LAST\_ACK}$ and have received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ This transition is handled specially at the end of $\tsaux{di3\_newackstuff}$ at which point
              processing stops, thus this transition is not possible }{}\\{}
\quad\quad \tsunknown{K} \;\Mfalse  \text{``FIXME assert\textunderscore{}failure di3\textunderscore{}ststuff''} \tsholcomm{ impossible } \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{TIME\_WAIT},\Mfalse )    \Mtotype   \tsholcomm{ In $\tscon{TIME\_WAIT}$ and have not received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ Remaining in $\tscon{TIME\_WAIT}$ until the \wasverb{2MSL} timer expires }{}\\{}
\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{TIME\_WAIT},\Mtrue )    \Mtotype   \tsholcomm{ In $\tscon{TIME\_WAIT}$ and have received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ Remaining in $\tscon{TIME\_WAIT}$ until the \wasverb{2MSL} timer expires }{}\\{}
\quad\quad \tsaux{cont}}
}
{\rrulepad }
}

\newcommand{\defndiIIITsocksTupdate}{\ddefnc{diIIITsocksTupdate}{\iA{di3\_socks\_update}}{\subddefnA[{ $\tsunknown{deliver\_in\_3}$ socket update processing }]{di3\_socks\_update}{\tsaux{di3\_socks\_update} \;\tsunknown{sid} \;\tsvar{socks} \;\tsvar{socks}' ={}\\{}
 {}\\{}
 \Mlet  \;\tsunknown{sock\_1} = \tsvar{socks} \Mfapply{}{\tsunknown{sid}} \Min {}\\{}
 \exists \tsunknown{tcp\_sock\_1}.{}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock\_1}) = \tsunknown{sock\_1}.\tsvar{pr} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Socket $\tsunknown{sock\_1}$ referenced by identifier $\tsunknown{sid}$ has just finished connection establishement
      and either there is another socket with $\tsunknown{sock\_1}$ on its pending connections queue and this
      is the completion of a passive open, or there is not another socket and this is the completion
      of a simultaneous open. See the inline comment in \ltslink{deliverTinTIII}{$\tsunknown{deliver\_in\_3}$} for further
      details. }{}\\{}
 {}\\{}
 \Mlet  \;\tsunknown{interesting} = \lambda \tsvar{sid}'.{}\\{}
\quad\quad \tsvar{sid}' \neq  \tsunknown{sid} \Mwedge {}\\{}
\quad\quad \Mcase  (\tsvar{socks} \Mfapply{}{\tsvar{sid}'}).\tsvar{pr} \;\Mof {}\\{}
\quad\quad\quad \tscon{UDP\_PROTO} \;\tsunknown{udp\_sock} \Mtotype  \Mfalse {}\\{}
\quad\quad \Mdpipe  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) \Mtotype {}\\{}
\quad\quad\quad\quad \Mcase  \;\tsunknown{tcp\_sock'}.\tsvar{lis} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad * \Mtotype  \Mfalse {}\\{}
\quad\quad\quad\quad \Mdpipe  \Msome  \;\tsvar{lis} \Mtotype {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsunknown{sid} \;\in  \;\tsvar{lis}.\tsunknown{q0} \;\Min {}\\{}
 {}\\{}
 \Mlet  \;\tsunknown{interesting\_sids} = (\Mfdom{\tsvar{socks}}) \cap  \;\tsunknown{interesting} \;\Min {}\\{}
 {}\\{}
 \Mif  \;\tsunknown{interesting\_sids} \neq  \{\} \Mthen {}\\{}
 \tsholcomm{ There exists another socket $\tsvar{sock}'$ that is listening and has socket $\tsunknown{sock\_1}$ referenced by
          $\tsunknown{sid}$ on its queue of incomplete connections $\tsvar{lis}.\tsunknown{q0}$. }{}\\{}
 \exists \tsvar{sid}' \;\tsvar{sock}' \;\tsunknown{tcp\_sock'} \;\tsvar{lis} \;\tsvar{q0L} \;\tsvar{q0R}.{}\\{}
 \tsvar{sid}' \;\in  \;\tsunknown{interesting\_sids} \Mwedge {}\\{}
 \tsvar{sock}' = \tsvar{socks} \Mfapply{}{\tsvar{sid}'} \Mwedge {}\\{}
 \tsvar{sock}'.\tsvar{pr} = \tscon{TCP\_PROTO} \;\tsunknown{tcp\_sock'} \Mwedge {}\\{}
 \tsvar{sid}' \neq  \tsunknown{sid} \Mwedge {}\\{}
 \tsunknown{tcp\_sock'}.\tsvar{lis} = \Msome  \;\tsvar{lis} \Mwedge {}\\{}
 \tsvar{lis}.\tsunknown{q0} = \Mappend{\tsvar{q0L}}{(\tsunknown{sid} \Mcons  \tsvar{q0R})} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Choose non-deterministically whether there is room on the queue of completed connections }{}\\{}
 \tsholop{choose} \;\tsunknown{ok} \Mcons  \tsunknown{accept\_incoming\_q} \;\tsvar{lis}.{}\\{}
 {}\\{}
 \Mif  \;\tsunknown{ok} \;\Mthen {}\\{}
\quad \tsholcomm{ If there is room, then remove socket $\tsunknown{sid}$ from the queue of incomplete connections
            and add it to the queue of completed connections. }{}\\{}
\quad \Mlet  \;\tsvar{lis}' = \tsvar{lis} \; \Mmagiclrec  \tsunknown{q0} \Mass  \Mappend{\tsvar{q0L}}{\tsvar{q0R}};{}\\{}
 \tsunknown{q} \Mass  \tsunknown{sid} \Mcons  \tsvar{lis}.\tsunknown{q} \Mmagicrrec  \Min {}\\{}
\quad \tslongcomm{ X
        (*: Update the newly connected sockets receive window :*)
        let rcv\textunderscore{}window = calculate\textunderscore{}bsd\textunderscore{}rcv\textunderscore{}wnd sock\textunderscore{}1.sf tcp\textunderscore{}sock\textunderscore{}1 in
        (*: BSD bug - [[rcv\textunderscore{}adv]] gets incorrectly set using the old value of [[rcv\textunderscore{}wnd]], as this is done
                     by the syncache, which is called from |tcp\textunderscore{}input()| before the [[rcv\textunderscore{}wnd]] update
                     takes place. Note that we have the following:
                     |SYN\textunderscore{}SENT-\textgreater{}ESTABLISHED =\textgreater{}| update [[rcv\textunderscore{}wnd]] then [[rcv\textunderscore{}adv]]
                     |SYN\textunderscore{}RCVD-\textgreater{}ESTABLISHED =\textgreater{}| update [[rcv\textunderscore{}adv]] then [[rcv\textunderscore{}wnd]] :*) X }{}\\{}
\quad \Mlet  \;\tsvar{cb}' = \tsunknown{tcp\_sock\_1}.\tsvar{cb} \tslongcomm{ X with \textless{}| rcv\textunderscore{}wnd := rcv\textunderscore{}window;
                                        rcv\textunderscore{}adv := tcp\textunderscore{}sock\textunderscore{}1.cb.rcv\textunderscore{}nxt + tcp\textunderscore{}sock\textunderscore{}1.cb.rcv\textunderscore{}wnd |\textgreater{} X } \Min {}\\{}
 {}\\{}
\quad \tsholcomm{ Update both the newly connected socket and the listening socket }{}\\{}
\quad \tsvar{socks}' = \tsvar{socks} \oplus {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad [(\tsunknown{sid}, \tsunknown{sock\_1} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock\_1} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}' \Mmagicrrec ) \Mmagicrrec );{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{sid}', \tsvar{sock}' \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'} \; \Mmagiclrec  \tsvar{lis} \Mass  \Msome  \;\tsvar{lis}' \Mmagicrrec ) \Mmagicrrec )]{}\\{}
 \Melse {}\\{}
\quad \tsholcomm{ ...otherwise there is no room on the listening socket's completed connections queue, so
           drop the newly connected socket and remove it from the listening socket's queue of
           incomplete connections. Note: the dropped connection is not sent a $\tsvar{RST}$ but a $\tsvar{RST}$
           is sent upon receipt of further segments from the other end as the socket entry has gone
           away. }{}\\{}
\quad \tscomm{ Note that the above note needs to be verified by testing. }{}\\{}
\quad \Mlet  \;\tsvar{lis}' = \tsvar{lis} \; \Mmagiclrec  \tsunknown{q0} \Mass  \Mappend{\tsvar{q0L}}{\tsvar{q0R}} \Mmagicrrec  \Min {}\\{}
\quad \tsvar{socks}' = \tsvar{socks} \oplus  (\tsvar{sid}', \tsvar{sock}' \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'} \; \Mmagiclrec  \tsvar{lis} \Mass  \Msome  \;\tsvar{lis}' \Mmagicrrec ) \Mmagicrrec ){}\\{}
 {}\\{}
 \Melse {}\\{}
 \tsholcomm{ There is no such socket with socket $\tsunknown{sid}$ on its queue of incomplete connections, thus
         socket $\tsunknown{sid}$ was involved in a simultaneous open. Do not update any socket. }{}\\{}
 \tsvar{socks}' = \tsvar{socks}}
}
{\rrulepad }
}

\newcommand{\deliverTinTIIIb}{\rrulecn{deliverTinTIIIb}{deliver\_in\_3b}{tcp: network nonurgent}{\tsholcomm{ Receive data after process has gone away }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks};{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm} \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks}';{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm}' \Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{{}\\{}
 \tsholcomm{ \textbf{Summary:} if data arrives after the process associated with a socket has gone away,  close socket and emit RST segment. }{}\\{}
 {}\\{}
 \tsvar{sid} \;\in  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 \tsunknown{sock\_0} = \tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
 \tsunknown{sock\_0}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsunknown{sock\_0}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge  \tsunknown{sock\_0}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsunknown{sock\_0}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2} \Mwedge {}\\{}
 \tsunknown{sock\_0}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock\_0}) \Mwedge {}\\{}
 {}\\{}
 \exists  \tsvar{S}_{0} \;\tsvar{s} \;\tsvar{s}'.  \tsvar{SS} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})] \Mwedge {}\\{}
 \tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \Mtrue  \;\Mfalse  (\tsvar{iflgs},\tsvar{idata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
 \tsvar{iflgs} = \tsvar{iflgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{idata} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Note that there does not exist a better socket match to which the segment should be sent, as the whole quad is matched exactly. }{}\\{}
 {}\\{}
 \tsholcomm{ test that this is data arriving after process has gone away }{}\\{}
 \tsunknown{tcp\_sock\_0}.\tsvar{st} \;\in  \{\tscon{FIN\_WAIT\_1}; \tscon{CLOSING}; \tscon{LAST\_ACK}; \tscon{FIN\_WAIT\_2}; \tscon{TIME\_WAIT}\} \Mwedge {}\\{}
 \tsunknown{sock\_0}.\tsvar{fid} = * \Mwedge   {}\\{}
 {}\\{}
 \tsholcomm{ close socket and emit RST segment }{}\\{}
 \tsvar{socks}' = \tsvar{socks} \oplus  (\tsvar{sid},\tsaux{tcp\_close} \;\tsvar{h}.\tsvar{arch} \;\tsunknown{sock\_0}) \Mwedge {}\\{}
 {}\\{}
 \tsvar{oflgs} = \tsvar{oflgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{FIN} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mtrue  \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{odata} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 \exists  \tsvar{s}''.{}\\{}
 \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s}' \;\tsvar{s}'' \Mwedge {}\\{}
 \tsaux{destroy} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}'')]) \tsvar{S}'}
{}
}

\newcommand{\deliverTinTIV}{\rrulecn{deliverTinTIV}{deliver\_in\_4}{tcp: network nonurgent}{\tsholcomm{ Receive and drop (silently) a non-sane or martian segment }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsholcomm{ \textbf{Summary:}
   Receive and drop any segment for this host that does not have sensible checksum or offset fields,
   or one that originates from a martian address.  The first part of this condition is a
   placeholder, awaiting the day when we switch to a non-lossy segment representation, hence the
   $\Mfalse $.
   }{}\\{}
 {}\\{}
 \tsunknown{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tsunknown{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 \tsvar{seg}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge   {}\\{}
 \tsvar{is}_{1} = \tsvar{seg}.\tsvar{is}_{1} \Mwedge {}\\{}
 \tsvar{i}_{2} \;\in  \;\tsunknown{local\_ips}(\tsvar{h}.\tsvar{ifds}) \Mwedge   {}\\{}
 (\Mfalse  \Mvee                   \tsholcomm{ placeholder for segment checksum and offset field not sensible }{}\\{}
 \neg{}( {}\\{}
\quad \Mtrue  \Mwedge   \tsholcomm{ placeholder for not a link-layer multicast or broadcast }{}\\{}
\quad \neg{}(\tsunknown{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{2}) \Mwedge   \tsholcomm{ seems unlikely, since $\tsvar{i}_{1} \;\in  \;\tsunknown{local\_ips} \;\tsvar{h}.\tsvar{ifds}$ }{}\\{}
\quad \neg{}(\tsvar{is}_{1} = *) \Mwedge {}\\{}
\quad \neg{}\tsunknown{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} (\tsholop{THE} \;\tsvar{is}_{1}){}\\{}
 ){}\\{}
 )}
{}
}

\newcommand{\deliverTinTV}{\rrulecc{deliverTinTV}{deliver\_in\_5}{tcp: network nonurgent}{\tsholcomm{ Receive and drop (maybe with RST) a sane segment that does not match any socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq} ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm} \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec \tsvar{iq} \Mass  \tsvar{iq}' ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm}' \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}'')],\tsvar{M})}
{\tsholcomm{ \textbf{Summary:}
   Receive and drop any segment for this host that does not match any sockets (but does have
   sensible checksum and offset fields). Typically, generate RST in response, computing $\tsunknown{ack}$ and $\tsunknown{seq}$ to supposedly  make the other
   end see this as an 'acceptable ack'.
   }{}\\{}
 {}\\{}
 {}\\{}
 \tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \Mtrue  \;\Mfalse  (\tsvar{iflgs},\tsvar{idata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 \tsvar{i}_{1} \;\in  \;\tsunknown{local\_ips}(\tsvar{h}.\tsvar{ifds}) \Mwedge   {}\\{}
 {}\\{}
 \Mtrue  \Mwedge                                               \tsholcomm{ placeholder for segment checksum and offset field sensible }{}\\{}
 {}\\{}
 \neg{}(\exists  ((\tsunknown{sid},\tsunknown{sock}) \Mcons  \tsvar{h}.\tsvar{socks}) \tsunknown{tcp\_sock}.{}\\{}
\quad\quad \tsunknown{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad\quad \tsaux{match\_score} (\tsunknown{sock}.\tsvar{is}_{1}, \tsunknown{sock}.\tsvar{ps}_{1}, \tsunknown{sock}.\tsvar{is}_{2}, \tsunknown{sock}.\tsvar{ps}_{2}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{i}_{2} , \Msome  \;\tsvar{p}_{2}, \tsvar{i}_{1},\Msome  \;\tsvar{p}_{1}) > 0{}\\{}
\quad ) \Mwedge  {}\\{}
 {}\\{}
 {}\\{}
 \tsaux{dropwithreset} \;\tsvar{iflgs}.\tsvar{RST} (\Msome  \;\tsvar{i}_{2}, \Msome  \;\tsvar{i}_{1}) \tsvar{h}.\tsvar{ifds} \;\tsvar{oflgs}.\tsvar{RST} \Mwedge {}\\{}
 \tsvar{oflgs}.\tsvar{SYN} = \Mfalse  \Mwedge {}\\{}
 \tsvar{oflgs}.\tsvar{SYNACK} = \Mfalse  \Mwedge {}\\{}
 \tsvar{oflgs}.\tsvar{FIN} = \Mfalse  \Mwedge {}\\{}
 \tsvar{odata} = [\,] \Mwedge {}\\{}
 \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s}' \;\tsvar{s}''}
{\rrulepad }
}

\newcommand{\deliverTinTVII}{\rrulecn{deliverTinTVII}{deliver\_in\_7}{tcp: network nonurgent}{\tsholcomm{ Receive RST and zap non-$\{\tscon{CLOSED}$; $\tscon{LISTEN}$; $\tscon{SYN\_SENT}$; $\tscon{SYN\_RECEIVED}$; $\tscon{TIME\_WAIT}\}$ socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{{\tsvar{ts}}_{\tsvar{st}}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{{\tsvar{ts}}_{\tsvar{st}}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{\tsholcomm{ \textbf{Summary:} receive RST and silently zap non-$\{\tscon{CLOSED}$; $\tscon{LISTEN}$; $\tscon{SYN\_SENT}$; $\tscon{SYN\_RECEIVED}$; $\tscon{TIME\_WAIT}\}$ socket }{}\\{}
 {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq})) \Mwedge {}\\{}
 \tsvar{st} \;\notin  \{\tscon{CLOSED}; \tscon{LISTEN}; \tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}; \tscon{TIME\_WAIT}\} \Mwedge {}\\{}
 {}\\{}
 \exists  \tsvar{S}_{0} \;\tsvar{s} \;\tsvar{s}'. \tsvar{SS} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})] \Mwedge {}\\{}
 \tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \Mtrue  \;\Mfalse  (\tsvar{iflgs},\tsvar{idata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
 \tsvar{iflgs}.\tsvar{RST} = \Mtrue  \Mwedge {}\\{}
 \tsvar{idata} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 ( \tsholcomm{ $\tsvar{sock}.\tsvar{st} \;\in  \{\tscon{CLOSED}; \tscon{LISTEN}; \tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}; \tscon{TIME\_WAIT}\}$
          excluded already above }{}\\{}
 \Mif  \;\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}; \tscon{CLOSE\_WAIT}\} \Mthen {}\\{}
\quad\quad \tsvar{err} = \Msome  \;\tsunknown{ECONNRESET}{}\\{}
 \Melse  \tsholcomm{ $\tsvar{sock}.\tsvar{st} \;\in  \{\tscon{CLOSING}; \tscon{LAST\_ACK}\}$ -- leave existing error }{}\\{}
\quad\quad \tsvar{err} = \tsvar{sock}.\tsvar{es}) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ see \ltslink{tcpTclose}{$\tsaux{tcp\_close}$} }{}\\{}
 \tsvar{sock}' = \tsaux{tcp\_close} \;\tsvar{h}.\tsvar{arch} (\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{err} \Mmagicrrec  ) \Mwedge {}\\{}
 \tsaux{destroy} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')]) \tsvar{S}'{}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 }
{}
}

\newcommand{\deliverTinTVIIa}{\rrulecc{deliverTinTVIIa}{deliver\_in\_7a}{tcp: network nonurgent}{\tsholcomm{ Receive RST and zap $\tscon{SYN\_RECEIVED}$ socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  \tsunknown{socks\_update'};{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{\tsholcomm{ \textbf{Summary:} receive RST and zap $\tscon{SYN\_RECEIVED}$ socket, removing from listen queue etc. }{}\\{}
 {}\\{}
 \exists  \tsvar{S}_{0} \;\tsvar{s} \;\tsvar{s}'. \tsvar{SS} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})] \Mwedge {}\\{}
 \tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \Mtrue  \;\Mfalse  (\tsvar{iflgs},\tsvar{idata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
 \tsvar{iflgs}.\tsvar{RST} = \Mtrue  \Mwedge {}\\{}
 \tsvar{idata} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 {}\\{}
 \tsvar{sid} \;\notin  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{SYN\_RECEIVED},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq})) \Mwedge {}\\{}
 {}\\{}
 ( \tsholcomm{ There is a corresponding listening socket -- passive open }{}\\{}
 (\exists (\tsvar{sid}',\tsunknown{lsock}) \Mcons  \tsvar{socks} \backslash{}\backslash{} \tsvar{sid}.{}\\{}
 \exists \tsunknown{tcp\_lsock} \;\tsvar{lis} \;\tsvar{q0L} \;\tsvar{q0R} \;\tsvar{lsock}'.{}\\{}
\quad \tsunknown{lsock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_lsock}) \Mwedge {}\\{}
\quad \tsunknown{tcp\_lsock}.\tsvar{st} = \tscon{LISTEN} \Mwedge {}\\{}
\quad \tsunknown{tcp\_lsock}.\tsvar{lis} = \Msome  \;\tsvar{lis} \Mwedge {}\\{}
\quad \tsvar{lis}.\tsunknown{q0} = \Mappend{\tsvar{q0L}}{(\tsvar{sid} \Mcons  \tsvar{q0R})} \Mwedge {}\\{}
\quad \tsvar{lsock}' = \tsunknown{lsock} \;{}\\{}
\quad\quad \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_lsock} \; \Mmagiclrec  \tsvar{lis} \Mass {}\\{}
 \Msome  (\tsvar{lis} \; \Mmagiclrec  \tsunknown{q0} \Mass  \Mappend{\tsvar{q0L}}{\tsvar{q0R}} \Mmagicrrec ) \Mmagicrrec ) \Mmagicrrec  \Mwedge   {}\\{}
\quad \tsunknown{socks\_update'} = [(\tsvar{sid}',\tsvar{lsock}'); (\tsvar{sid},\tsvar{sock}')]{}\\{}
 ) \Mvee {}\\{}
 ( \tsholcomm{ No corresponding socket -- simultaneous open }{}\\{}
 \tsunknown{socks\_update'} = [(\tsvar{sid},\tsvar{sock}')] )) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ We do not delete the socket entry here because of simultaneous opens.
    Keep existing error for $\tscon{SYN\_RECEIVED}$ socket on RST }{}\\{}
 \tsvar{sock}' = (\tsaux{tcp\_close} \;\tsvar{h}.\tsvar{arch} \;\tsvar{sock})  \Mmagiclrec  \tsvar{ps}_{1} \Mass  \Mif  \;\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;* \;\Melse  \;\tsvar{sock}.\tsvar{ps}_{1} \Mmagicrrec  \Mwedge {}\\{}
 \tsaux{destroy} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')]) \tsvar{S}'}
{\rrulepad }
}

\newcommand{\deliverTinTVIIb}{\rrulecn{deliverTinTVIIb}{deliver\_in\_7b}{tcp: network nonurgent}{\tsholcomm{ Receive RST and ignore for $\tscon{LISTEN}$ socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsholcomm{ \textbf{Summary:} receive RST and ignore for $\tscon{LISTEN}$ socket }{}\\{}
 {}\\{}
 \tsunknown{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tsunknown{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\tsvar{lis},\tsvar{sndq},\tsvar{rcvq})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ BSD listen bug -- since we can call $\tsvar{listen}()$ from any state, the peer IP/port may have been set }{}\\{}
 ((\tsvar{is}_{2} = * \Mwedge  \tsvar{ps}_{2} = *) \Mvee {}\\{}
 (\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge  \tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2})) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 \tsvar{i}_{1} \;\in  \;\tsunknown{local\_ips} \;\tsvar{h}.\tsvar{ifds} \Mwedge {}\\{}
 \Mtrue  \Mwedge   \tsholcomm{ placeholder for not a link-layer multicast or broadcast }{}\\{}
 \tsholcomm{ seems unlikely, since $\tsvar{i}_{1} \;\in  \;\tsunknown{local\_ips} \;\tsvar{h}.\tsvar{ifds}$ }{}\\{}
 \neg{}(\tsunknown{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{1}) \Mwedge {}\\{}
 \neg{}(\tsunknown{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{2}) \Mwedge {}\\{}
 (\Mcase  \;\tsvar{is}_{1} \;\Mof {}\\{}
\quad\quad \Msome  \;\tsvar{i}'_{1} \Mtotype  \tsvar{i}'_{1} = \tsvar{i}_{1} \Mdpipe {}\\{}
\quad\quad * \Mtotype  \Mtrue ) \Mwedge {}\\{}
 {}\\{}
 (\exists \tsunknown{seq\_discard} \;\tsunknown{ack\_discard} \;\tsunknown{URG\_discard} \;\tsunknown{ACK\_discard} \;\tsunknown{PSH\_discard} \;\tsunknown{SYN\_discard} \;\tsunknown{FIN\_discard}{}\\{}
\quad \tsunknown{win\_discard} \;\tsunknown{ws\_discard} \;\tsunknown{urp\_discard} \;\tsunknown{mss\_discard} \;\tsunknown{ts\_discard} \;\tsunknown{data\_discard}.{}\\{}
 \tsvar{seg} = \Mmagiclrec {}\\{}
 \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsunknown{seq}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsunknown{seq\_discard}:\tsunknown{tcp\_seq\_foreign});{}\\{}
 \tsunknown{ack}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsunknown{ack\_discard}:\tsunknown{tcp\_seq\_local});{}\\{}
 \tsunknown{URG}  \Mass  \tsunknown{URG\_discard};{}\\{}
 \tsunknown{ACK}  \Mass  \tsunknown{ACK\_discard};{}\\{}
 \tsunknown{PSH}  \Mass  \tsunknown{PSH\_discard};{}\\{}
 \tsvar{RST}  \Mass  \Mtrue ;{}\\{}
 \tsvar{SYN}  \Mass  \tsunknown{SYN\_discard};{}\\{}
 \tsvar{FIN}  \Mass  \tsunknown{FIN\_discard};{}\\{}
 \tsunknown{win}  \Mass  \tsunknown{win\_discard};{}\\{}
 \tsunknown{ws}   \Mass  \tsunknown{ws\_discard};{}\\{}
 \tsunknown{urp}  \Mass  \tsunknown{urp\_discard};{}\\{}
 \tsunknown{mss}  \Mass  \tsunknown{mss\_discard};{}\\{}
 \tsvar{ts}   \Mass  \tsunknown{ts\_discard};{}\\{}
 \tsvar{data} \Mass  \tsunknown{data\_discard}{}\\{}
 \Mmagicbolrrec {}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsaux{tcp\_socket\_best\_match} (\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}) (\tsvar{sid},\tsvar{sock}) \tsvar{seg} \;\tsvar{h}.\tsvar{arch} \tsholcomm{ there does not exist a better socket match to which the segment should be sent }}
{}
}

\newcommand{\deliverTinTVIIc}{\rrulecc{deliverTinTVIIc}{deliver\_in\_7c}{tcp: network nonurgent}{\tsholcomm{ Receive RST and ignore for $\tscon{SYN\_SENT}$(unacceptable ack) or $\tscon{TIME\_WAIT}$ socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')],\tsvar{M})}
{\tsholcomm{ \textbf{Summary:} receive RST and ignore for $\tscon{SYN\_SENT}$(unacceptable ack) or $\tscon{TIME\_WAIT}$ socket }{}\\{}
 {}\\{}
 \tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \Mtrue  \;\Mfalse  (\tsvar{iflgs},\tsvar{idata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
 \tsvar{sid} \;\notin  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq})) \Mwedge {}\\{}
 \tsvar{st} \;\in  \{\tscon{SYN\_SENT}; \tscon{TIME\_WAIT}\} \Mwedge {}\\{}
 {}\\{}
 \tsvar{iflgs}.\tsvar{RST} = \Mtrue  \Mwedge {}\\{}
 \tsvar{idata} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ no- or unacceptable- ACK }{}\\{}
 (\tsvar{st} = \tscon{SYN\_SENT} \implies  \Mfalse ) \Mwedge  {}\\{}
 {}\\{}
 \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{st} = \tscon{TIME\_WAIT} \;\Mthen   \tsholcomm{ only update if $\geq  \tscon{ESTABLISHED}$, c.f.\ \wasverb{tcp\textbackslash{}\textunderscore{}input.c:887} }{}\\{}
\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsfield{tt\_keep} \Mass  \Msome  (\Mtimed{()}{\tsunknown{slow\_timer} \;\tsunknown{TCPTV\_KEEP\_IDLE}})  \Mmagicrrec {}\\{}
 \Mmagicbolrrec ) \Mmagicrrec {}\\{}
 \Melse  \tsholcomm{ $\tsvar{st} = \tscon{SYN\_SENT}$ }{}\\{}
\quad \tsholcomm{ BSD \wasverb{rcv\textunderscore{}wnd} bug: the receive window updated code in \wasverb{tcp\textunderscore{}input} gets executed \emph{before} the segment is
          processed, so even for bad segments, it gets updated }{}\\{}
\quad \tsvar{sock}' = \tsvar{sock})}
{\rrulepad }
}

\newcommand{\deliverTinTVIId}{\rrulecn{deliverTinTVIId}{deliver\_in\_7d}{tcp: network nonurgent}{\tsholcomm{ Receive RST and zap $\tscon{SYN\_SENT}$(acceptable ack) socket }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')];{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{\tsholcomm{ \textbf{Summary}
   Receiving an acceptable-ack RST segment: kill the connection and set the socket's error field appropriately,
   unless we are WinXP where we simply ignore the RST.
   }{}\\{}
 {}\\{}
 \exists  \tsvar{S}_{0} \;\tsvar{s} \;\tsvar{s}'. \tsvar{SS} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})] \Mwedge {}\\{}
 \tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \Mfalse  \;\Mfalse  (\tsvar{iflgs},\tsvar{idata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
 \tsvar{sid} \;\notin  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{SYN\_SENT},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq})) \Mwedge {}\\{}
 {}\\{}
 \tsvar{iflgs}.\tsvar{RST} = \Mtrue  \Mwedge {}\\{}
 \tsvar{idata} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen {}\\{}
\quad\quad \tsvar{sock}' = \tsvar{sock}   \tsholcomm{ Windows XP just ignores RST's with a valid ack during connection establishment } \Mwedge {}\\{}
\quad\quad \tsvar{S}' = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')]{}\\{}
 \Melse {}\\{}
\quad\quad (\exists \tsvar{err}.{}\\{}
\quad\quad\quad\quad \tsvar{err} \;\in  \{\tsunknown{ECONNREFUSED}; \tsunknown{ECONNRESET}\} \Mwedge  \tsholcomm{ Note it is unclear whether or not this error will overwrite any existing error on the socket }{}\\{}
\quad\quad\quad\quad \tsvar{sock}' = (\tsaux{tcp\_close} \;\tsvar{h}.\tsvar{arch} \;\tsvar{sock})  \Mmagiclrec  \tsvar{ps}_{1} \Mass  \Mif  \;\tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;* \;\Melse  \;\tsvar{sock}.\tsvar{ps}_{1}; \tsvar{es} \Mass  \Msome  \;\tsvar{err} \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad\quad \tsaux{destroy} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')]) \tsvar{S}')}
{}
}

\newcommand{\deliverTinTVIII}{\rrulecn{deliverTinTVIII}{deliver\_in\_8}{tcp: network nonurgent}{\tsholcomm{ Receive SYN in non-$\{\tscon{CLOSED}$; $\tscon{LISTEN}$; $\tscon{SYN\_SENT}$; $\tscon{TIME\_WAIT}\}$ state }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm} \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm}' \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}'')],\tsvar{M})}
{\tsholcomm{ \textbf{Summary:}
     Receive a SYN in non-$\{\tscon{CLOSED}$; $\tscon{LISTEN}$; $\tscon{SYN\_SENT}$; $\tscon{TIME\_WAIT}\}$ state.
     Drop it and (depending on the architecture) generate a RST. }{}\\{}
 {}\\{}
 \tsvar{sid} \;\notin  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq})) \Mwedge {}\\{}
 \tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \Mtrue  \;\Mfalse  (\tsvar{iflgs},\tsvar{idata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
 \tsvar{iflgs}.\tsvar{RST} = \Mfalse  \Mwedge  (\tsvar{iflgs}.\tsvar{SYN} \Mvee  \tsvar{iflgs}.\tsvar{SYNACK}) \Mwedge  {}\\{}
 \tsvar{idata} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Note that it may be the case that this rule should only apply when the SYN is \emph{in the
     trimmed window}, should not it?; it's OK if there's a SYN bit set, for example in a
     retransmission. }{}\\{}
 {}\\{}
 \tsvar{st} \;\notin  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT};\tscon{TIME\_WAIT}\} \Mwedge {}\\{}
 {}\\{}
 \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \Mlet  \;\tsunknown{tt\_keep'} = \Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} \neq  \tscon{SYN\_RECEIVED} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  (\Mtimed{()}{\tsunknown{slow\_timer} \;\tsunknown{TCPTV\_KEEP\_IDLE}}){}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_keep} \;\Min {}\\{}
 {}\\{}
 \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{cb} \Mass  \tsunknown{tcp\_sock}.\tsvar{cb} \; \Mmagiclrec  \tsfield{tt\_keep} \Mass  \tsunknown{tt\_keep'} \Mmagicrrec {}\\{}
 \Mmagicbolrrec ) \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 \tsvar{oflgs} = \tsvar{oflgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{FIN} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mtrue  \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{odata} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s}' \;\tsvar{s}''}
{}
}

\newcommand{\deliverTinTIX}{\rrulecc{deliverTinTIX}{deliver\_in\_9}{tcp: network nonurgent}{\tsholcomm{ Receive SYN in $\tscon{TIME\_WAIT}$ state if there is no matching $\tscon{LISTEN}$ socket or sequence number has not increased }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq};{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm} \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}';{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}';{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm}' \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}'')],\tsvar{M})}
{\tsholcomm{ \textbf{Summary:}
     Receive a SYN in $\tscon{TIME\_WAIT}\}$ state where there is no matching $\tscon{LISTEN}$ socket.
     Drop it and (depending on the architecture) generate a RST. }{}\\{}
 {}\\{}
 \tsunknown{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tsunknown{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 {}\\{}
 \tsvar{sid} \;\notin  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{TIME\_WAIT},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq})) \Mwedge {}\\{}
 \tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \Mtrue  \;\Mfalse  (\tsvar{iflgs},\tsvar{idata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
 \tsvar{iflgs}.\tsvar{RST} = \Mfalse  \Mwedge  (\tsvar{iflgs}.\tsvar{SYN} \Mvee  \tsvar{iflgs}.\tsvar{SYNACK}) \Mwedge  {}\\{}
 \tsvar{idata} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ no matching LISTEN socket, or the sequence number has not increased }{}\\{}
 (\Mtrue {}\\{}
\quad \Mvee {}\\{}
 \neg{}(\exists  ((\tsvar{sid},\tsvar{sock}) \Mcons  \tsvar{socks}) \tsunknown{tcp\_sock}.{}\\{}
\quad \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{LISTEN} \Mwedge {}\\{}
\quad \tsvar{sock}.\tsvar{is}_{1} \;\in  \{*;\Msome  \;\tsvar{i}_{1}\} \Mwedge {}\\{}
\quad \tsvar{sock}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1}){}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsvar{oflgs} = \tsvar{oflgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{FIN} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mtrue  \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{odata} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s}' \;\tsvar{s}''}
{\rulesubsection{Description}
(PARSED OLD-STYLE COMMENT)


   This rule does not appear in the BSD code; what happens there is that the old $\tscon{TIME\_WAIT}$ state
   socket is closed, and then the code jumps back to the top.  So this rule covers the case where it
   then discovers nothing else is listening, like $\tsunknown{deliver\_in\_5}$.

\rrulepad }
}

\newcommand{\chapcommtcpToutput}{\chaptersection{ Host LTS: TCP Output}
\label{tcp_output}%
\chapcomm{}
}

\newcommand{\seccommtcpToutputTsection}{\clustersection{(TCP only)}{Output}
\seccomm{


  A TCP implementation would typically perform output deterministically, e.g.\ during the processing
  a received segment it may construct and enqueue an acknowledgement segment to be emitted.  This
  means that the detailed behaviour of a particular implementation depends on exactly where the
  output routines are called, affecting when segments are emitted.  The contents of an emitted
  segment, on the other hand, must usually be determined by the socket state (especially the
  $\tstype{tcpcb}$), not from transient program variables, so that retransmissions can be performed.



  In this specification we choose to be somewhat nondeterministic, loosely specifying when
  common-case TCP output to occur.  This simplifies the modelling of existing implementations
  (avoiding the need to capture the code points at which the output routines are called) and should
  mean the specification is closer to capturing the set of all reasonable implementations.

  A significant defect in the current specification is that it does not impose a very tight lower
  bound on how often output takes place.  The satisfactory dynamic behaviour of TCP connections
  depends on an "ACK clock" property, with receivers  acknowledging data sufficiently often to
  update the sender's send window.  Characterising this may need additional constraints.

  The rule presented in this chapter describes TCP output in the common case, i.e.~the behaviour of
  TCP when emitting a non-SYN, non-RST segment. The whole behaviour is captured by the single rule
  $\tsunknown{deliver\_out\_1}$ which relies upon the auxiliary functions \ltslink{tcpToutputTrequired}{$\tsaux{tcp\_output\_required}$} and
  \ltslink{tcpToutputTreally}{$\tsaux{tcp\_output\_really}$}.  Output (strictly, adding segments to the host's output queue) may take
  place whenever this rule can fire; it does construct the output segments purely from the socket state.



% This specification
% allows a little more non-determinism than any given implementation: common case TCP output may
% take place, i.e. rule [[deliver_out_1]] may be applicable, at any time that a socket in the host's
% finite map of sockets is in a compatible state. This was a deliberate design choice that
% simplifies the modelling of existing TCP implementations which may emit segments under different
% conditions. All these may be valid behaviours either with respect to one or more of the TCP RFCs,
% or simply because their behaviour has become widely adopted and accepted. Either way, this rule
% encompasses all the observed behaviour of the implementations and the acceptable behaviour defined
% by the TCP RFCs (SB coughs!).


  The two auxiliary functions are loosely based on BSD's TCP output function, which can be logically
  divided into two halves. The first of these ---to some approximation--- is a guard that prevents
  output from occuring unless it is valid to do so, and the second actually creates a segment and
  passes it to the IP layer for output. This distinction is mirrored in the specification, with $\tsaux{tcp\_output\_required}$
  acting as the guard and $\tsaux{tcp\_output\_really}$ forming the segment ready to be appended to the
  host's output queue. Unfortunately it is not possible to be as clean here as one might hope,
  because under some circumstances $\tsaux{tcp\_output\_required}$ may have side-effects. It should be noted
  that $\tsaux{tcp\_output\_really}$ only creates a segment and does not perform any "output" --- the
  act of adding the segment (perhaps unreliably) to the host's output queue is the job of the
  caller.

  The output cases not covered by $\tsunknown{deliver\_out\_1}$ are handled specially and often in a more
  deterministic way. Segments with the SYN flag set are created by the auxiliary functions
  \ltslink{makeTsynTsegment}{$\tsaux{make\_syn\_segment}$} and \ltslink{makeTsynTackTsegment}{$\tsaux{make\_syn\_ack\_segment}$} and are output deterministically in response to
  either user events or segment input. SYN segments are emitted by the rules commonly involved in
  connection establishment, namely $\tsunknown{connect\_1}$, $\tsunknown{deliver\_in\_1}$, $\tsunknown{deliver\_in\_2}$,
  $\tsunknown{timer\_tt\_rexmtsyn\_1}$ and $\tsunknown{timer\_tt\_rexmt\_1}$ and are special-cased in this way for clarity
  because connection establishment performs extra work such as option negotiation and state
  initialisation.

  The creation of RST segments is performed by the auxiliaries \ltslink{makeTrstTsegmentTfromTcb}{$\tsaux{make\_rst\_segment\_from\_cb}$} and
  \ltslink{makeTrstTsegmentTfromTseg}{$\tsaux{make\_rst\_segment\_from\_seg}$}, and are used by the rules that require a reset segment to be
  emitted in response to a user event, e.g.\ a $\tsunknown{close}()$ call on a socket with a zero linger time,
  or as a socket's response to receiving some types of invalid segment.

  In a few places, mainly in the specification of certain congestion control methods, some rules use
  \ltslink{tcpToutputTreally}{$\tsaux{tcp\_output\_really}$} or the wrapper functions \ltslink{tcpToutputTperhaps}{$\tsaux{tcp\_output\_perhaps}$} and
  \ltslink{mliftTtcpToutputTperhapsTorTfail}{$\tsaux{mlift\_tcp\_output\_perhaps\_or\_fail}$} directly and---more importantly---deterministically. This is
  partly for clarity, perhaps because an RFC states that output "MUST" occur at that point, and
  partly for convenience, possibly because the model would require much extra state (hence adding
  unnecessary complexity) if the output function was not used in-place.

  The $\tsaux{tcp\_output\_perhaps}$ function almost entirely mimics an implementation's TCP output
  function. It calls $\tsaux{tcp\_output\_required}$ to check that output can take place, applying any
  side-effects that it returns, and finally creates the segment with $\tsaux{tcp\_output\_really}$.  See
  \ltslink{tcpToutputTperhaps}{$\tsaux{tcp\_output\_perhaps}$} and \ltslink{mliftTtcpToutputTperhapsTorTfail}{$\tsaux{mlift\_tcp\_output\_perhaps\_or\_fail}$} for more
  information.

  Other auxiliary functions are involved in TCP output and are described earlier. Once a
  segment has been constructed it is added to the host's output queue by one of \ltslink{enqueueTorTfail}{$\tsaux{enqueue\_or\_fail}$},
  \ltslink{enqueueTorTfailTsock}{$\tsunknown{enqueue\_or\_fail\_sock}$}, \ltslink{enqueueTandTignoreTfail}{$\tsaux{enqueue\_and\_ignore\_fail}$}, \ltslink{enqueueTeachTandTignoreTfail}{$\tsaux{enqueue\_each\_and\_ignore\_fail}$} or
  \ltslink{mliftTtcpToutputTperhapsTorTfail}{$\tsaux{mlift\_tcp\_output\_perhaps\_or\_fail}$}.  These functions are used by $\tsunknown{deliver\_out\_1}$ and other
  rules in the specification to non-deterministically add a segment to the host's output queue. In
  the common case, a segment is added to the host's output queue successfully. In other cases, the
  auxiliary function \ltslink{rollbackTtcpToutput}{$\tsaux{rollback\_tcp\_output}$} may assert a segment is unroutable and prevent the
  segment from being added to the queue. Some failures are non-deterministic in order to model "out
  of resource" style errors, although most are deterministic routing failures determined from the
  socket and host states. $\tsaux{rollback\_tcp\_output}$ has a second task to "undo" several of the
  socket's control block changes upon an error condition. Some of the enqueue functions ignore
  failure, e.g. $\tsaux{enqueue\_and\_ignore\_fail}$, and upon an error they just fail to queue the segment
  and do not update the socket with the "rolled-back" control block returned by
  $\tsaux{rollback\_tcp\_output}$. %All of these functions are documented towards the end of this chapter.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{deliver\_out\_1}$
& \textbf{tcp: network nonurgent}
&  Common case TCP output \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\deliverToutTI}{\rrulecc{deliverToutTI}{deliver\_out\_1}{tcp: network nonurgent}{\tsholcomm{ Common case TCP output }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}'')] ;{}\\{}
 \tsvar{oq} \Mass   \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')],\tsvar{M})}
{\tsholcomm{ \textbf{Summary:} output TCP segment if possible.  In some cases update the socket's persist
    timer without performing output. }{}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ The TCP socket is connected }{}\\{}
 \tsvar{sid} \;\notin  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},{}\\{}
\quad\quad\quad\quad\quad \tsvar{cantrcvmore},\tscon{TCP\_PROTO}(\tsunknown{tcp\_sock})) \Mwedge {}\\{}
 \tsunknown{tcp\_sock} = \tsaux{TCP\_Sock0}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ and either is in a synchronised state with initial $\tsvar{SYN}$ acknowledged\dots }{}\\{}
 ( (\tsvar{st} \;\in  \{\tscon{ESTABLISHED};\tscon{CLOSE\_WAIT};\tscon{FIN\_WAIT\_1};\tscon{FIN\_WAIT\_2};\tscon{CLOSING};{}\\{}
\quad\quad\quad\quad \tscon{LAST\_ACK};\tscon{TIME\_WAIT}\}) \Mvee {}\\{}
 \tsholcomm{ \dots{}or is in the $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$ state and a $\tsvar{FIN}$ needs to be emitted }{}\\{}
 (\tsvar{st} \;\in  \{\tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}\} \Mwedge  \tsvar{cantsndmore}){}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ A segment will be emitted if $\tsaux{tcp\_output\_required}$ asserts that a segment can be
        output ($\tsunknown{do\_output}$). If $\tsaux{tcp\_output\_required}$ returns a function to alter the socket's
        persist timer ($\tsunknown{persist\_fun}$), then this does not of itself mean that a segment is
        required, however $\tsunknown{deliver\_out\_1}$ should still fire to allow the update to take place. }{}\\{}
 (\tsunknown{do\_output},\tsunknown{persist\_fun}) \in  \;\tsaux{tcp\_output\_required} \Mwedge  {}\\{}
 (\tsunknown{do\_output} \Mvee  \tsunknown{persist\_fun} \neq  *) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Apply any persist timer side-effect from $\tsaux{tcp\_output\_required}$ }{}\\{}
 \Mlet  \;\tsvar{sock}_{0} = \tsholop{option\_case}\Mspiii{\tsvar{sock}}{(\lambda  \tsvar{f}. \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \;\tsvar{cb} \;\Mupdby  \;\tsvar{f}) \Mmagicrrec )}{\tsunknown{persist\_fun}} \Min {}\\{}
 {}\\{}
 (\Mif  \;\tsunknown{do\_output} \;\Mthen  \tsholcomm{ output a segment }{}\\{}
\quad \tsholcomm{ Construct the segment to emit, updating the socket's state }{}\\{}
\quad \tsaux{FIXMEstream\_tcp\_output\_really} \;\tsvar{sock}_{0} (\tsvar{sock}',\tsvar{FIN}) \Mwedge {}\\{}
 {}\\{}
\quad \tsvar{sock}'.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) \Mwedge {}\\{}
 {}\\{}
\quad \tsholcomm{ Add the segment to the host's output queue, rolling back the socket's control block state if
           an error occurs }{}\\{}
\quad \tsvar{oflgs} = \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{FIN} \Mass  \tsvar{FIN}; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Mwedge {}\\{}
\quad \tsvar{odata} = [\,] \Mwedge {}\\{}
\quad \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
\quad \tsaux{FIXMEstream\_enqueue\_or\_fail\_sock} (\tsunknown{tcp\_sock'}.\tsvar{st} \;\in  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT}\}) \tsvar{h}.\tsvar{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Msome  \;\tsvar{i}_{1}, \Msome  \;\tsvar{i}_{2}) \tsvar{sock}_{0} \;\tsvar{sock}' \;\tsvar{sock}''{}\\{}
 {}\\{}
 \Melse  \tsholcomm{ Do not output a segment, but ensure things are tidied up }{}\\{}
\quad \tsvar{oq} = \tsvar{oq}' \Mwedge {}\\{}
\quad \tsvar{sock}'' = \tsvar{sock}_{0} \Mwedge {}\\{}
\quad \tsvar{s}' = \tsvar{s}{}\\{}
 )}
{\rrulepad }
}

\newcommand{\chapcommtcpTtimers}{\chaptersection{ Host LTS: TCP Timers}
\label{tcp_timers}%
\chapcomm{}
}

\newcommand{\seccommtcpTtimersTsection}{\clustersection{(TCP only)}{Timers}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{timer\_tt\_rexmtsyn\_1}$
& \textbf{tcp: misc nonurgent}
&  SYN retransmit timer expires \\
$\tsrule{timer\_tt\_rexmt\_1}$
& \textbf{tcp: misc nonurgent}
&  retransmit timer expires \\
$\tsrule{timer\_tt\_persist\_1}$
& \textbf{tcp: misc nonurgent}
&  persist timer expires \\
$\tsrule{timer\_tt\_keep\_1}$
& \textbf{tcp: network nonurgent}
&  keepalive timer expires \\
$\tsrule{timer\_tt\_2msl\_1}$
& \textbf{tcp: misc nonurgent}
&  2*MSL timer expires \\
$\tsrule{timer\_tt\_delack\_1}$
& \textbf{tcp: misc nonurgent}
&  delayed-ACK timer expires \\
$\tsrule{timer\_tt\_conn\_est\_1}$
& \textbf{tcp: misc nonurgent}
&  connection establishment timer expires \\
$\tsrule{timer\_tt\_fin\_wait\_2\_1}$
& \textbf{tcp: misc nonurgent}
&  $\tscon{FIN\_WAIT\_2}$ timer expires \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\timerTttTrexmtsynTI}{\rrulecc{timerTttTrexmtsynTI}{timer\_tt\_rexmtsyn\_1}{tcp: misc nonurgent}{\tsholcomm{ SYN retransmit timer expires }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{\tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsvar{shift} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_SENT} \Mwedge   \tsholcomm{ this rule is incomplete: $\tsunknown{RexmtSyn}$ is possible in other states, since $\tsunknown{deliver\_in\_2}$ may change state without clearing $\tsunknown{tt\_rexmt}$ }{}\\{}
 {}\\{}
 \tsvar{cb} = \tsunknown{tcp\_sock}.\tsvar{cb} \Mwedge {}\\{}
 {}\\{}
 \exists \tsvar{i}_{1} \;\tsvar{i}_{2} \;\tsvar{p}_{1} \;\tsvar{p}_{2}. (\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{is}_{2}, \tsvar{sock}.\tsvar{ps}_{1}, \tsvar{sock}.\tsvar{ps}_{2}) = (\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{p}_{2}) \Mwedge {}\\{}
 \Mif  \;\tsvar{shift}+1 \geq  \tsunknown{TCP\_MAXRXTSHIFT} \;\Mthen {}\\{}
\quad\quad \tsholcomm{ Timer has expired too many times. Drop and close the connection }{}\\{}
 {}\\{}
\quad\quad \tsholcomm{ since socket state is $\tscon{SYN\_SENT}$, no segments can be output }{}\\{}
\quad\quad \tsaux{tcp\_drop\_and\_close} \;\tsvar{h}.\tsvar{arch} (\Msome  \;\tsunknown{ETIMEDOUT}) \tsvar{sock} (\tsvar{sock}',(\tsvar{oflgs},\tsvar{odata})) \Mwedge  {}\\{}
\quad\quad \exists  \tsvar{S}_{0} \;\tsvar{s} \;\tsvar{s}'. \tsvar{SS} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})] \Mwedge {}\\{}
\quad\quad \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
\quad\quad \tsaux{destroy} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')]) \tsvar{S}'{}\\{}
 {}\\{}
 \Melse {}\\{}
\quad\quad \tsholcomm{ Update the control block based upon the number of occasions on which the timer expired }{}\\{}
 {}\\{}
\quad\quad \tsvar{cb}' = \tsvar{cb} \Mwedge {}\\{}
 {}\\{}
\quad\quad \exists  \tsvar{S}_{0} \;\tsvar{s} \;\tsvar{s}'. \tsvar{SS} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})] \Mwedge {}\\{}
\quad\quad \tsholcomm{ Create the segment to be retransmitted }{}\\{}
\quad\quad (\tsvar{oflgs}, \tsvar{odata}) \in  \;\tsaux{make\_syn\_flgs\_data} \Mwedge {}\\{}
\quad\quad \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
\quad\quad \tsvar{S}' = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')] \Mwedge {}\\{}
\quad\quad \tsholcomm{ Attempt to add the new segment to the host's output queue, constraining the final control block state }{}\\{}
\quad\quad \tsaux{FIXMEstream\_enqueue\_or\_fail} \;\Mfalse  \;\tsvar{h}.\tsvar{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} (\Msome  \;\tsvar{i}_{1}, \Msome  \;\tsvar{i}_{2}) \tsvar{cb}' \;\tsvar{cb}'' \Mwedge {}\\{}
\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}'' \Mmagicrrec ) \Mmagicrrec }
{\rrulepad }
}

\newcommand{\timerTttTrexmtTI}{\rrulecc{timerTttTrexmtTI}{timer\_tt\_rexmt\_1}{tcp: misc nonurgent}{\tsholcomm{ retransmit timer expires }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock}'')] ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{\tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsvar{sock}'.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) \Mwedge {}\\{}
 (\tsunknown{tcp\_sock}.\tsvar{st} \;\notin  \{\tscon{CLOSED}; \tscon{LISTEN}; \tscon{SYN\_SENT}; \tscon{CLOSE\_WAIT}; \tscon{FIN\_WAIT\_2}; \tscon{TIME\_WAIT}\} \Mvee {}\\{}
\quad\quad (\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{LISTEN} \Mwedge  \tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch})) \Mwedge   {}\\{}
 {}\\{}
 \tsvar{shift} \;\in  \;\tsunknown{UNIV} \Mwedge {}\\{}
 {}\\{}
 \tsvar{cb} = \tsunknown{tcp\_sock}.\tsvar{cb} \Mwedge {}\\{}
 {}\\{}
 (\Mif {}\\{}
\quad\quad \tsvar{shift}+1 > (\Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED} \;\Mthen  \;\tsunknown{TCP\_SYNACKMAXRXTSHIFT} \;\Melse  \;\tsunknown{TCP\_MAXRXTSHIFT}){}\\{}
 \Mthen {}\\{}
\quad\quad \tsholcomm{ Note that BSD's syncaches have a much lower threshold for retransmitting SYN,ACKs than normal }{}\\{}
\quad\quad \tsholcomm{ drop connection }{}\\{}
 {}\\{}
\quad\quad {}\\{}
\quad\quad \tsaux{tcp\_drop\_and\_close} \;\tsvar{h}.\tsvar{arch} (\Msome  \;\tsunknown{ETIMEDOUT}) \tsvar{sock} (\tsvar{sock}',(\tsvar{oflgs},\tsvar{odata})) \Mwedge  \tsholcomm{ will always get exactly one segment }{}\\{}
\quad\quad \Mif  \;\tsaux{exists\_quad\_of} \;\tsvar{sock} \;\Mthen {}\\{}
\quad\quad\quad\quad \Mlet  (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) = \tsaux{quad\_of} \;\tsvar{sock} \;\Min {}\\{}
\quad\quad\quad\quad \exists  \tsvar{S}_{0} \;\tsvar{s} \;\tsvar{s}'.  \tsvar{SS} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})] \Mwedge {}\\{}
\quad\quad\quad\quad \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
\quad\quad\quad\quad \Mcase  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{LISTEN} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad \Mtrue  \Mtotype  \tsvar{S}' = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')] {}\\{}
\quad\quad\quad\quad\quad\quad \Mdpipe  \Mfalse  \Mtotype  \tsaux{destroy} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')]) \tsvar{S}'{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad\quad \tsvar{S}' = \tsvar{SS}{}\\{}
 {}\\{}
 \Melse {}\\{}
 {}\\{}
\quad \tsholcomm{ backoff the timer and do a retransmit }{}\\{}
\quad \tsvar{cb}' = \tsvar{cb} \Mwedge {}\\{}
 {}\\{}
\quad (\Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED} \;\Mthen {}\\{}
\quad\quad\quad (\exists \tsvar{i}_{1} \;\tsvar{i}_{2} \;\tsvar{p}_{1} \;\tsvar{p}_{2}.{}\\{}
\quad\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad\quad \tsholcomm{ If we're Linux doing a simultaneous open and support timestamping then ensure
                    timestamping is enabled in any retransmitted SYN,ACK segments. See $\tsunknown{deliver\_in\_2}$
                    for the rationale in full, but in short Linux is RFC1323 compliant and makes
                    a hash of option negotiation during a simultaneous open. We make the option decision
                    early (as per the RFC and BSD) and have to hack up SYN,ACK segments to contain
                    timestamp options if the Linux host supports timestamping.  }{}\\{}
\quad\quad\quad\quad\quad \tsholcomm{ Note: this behaviour is also safe if we are here due to a passive open. In this
                    case, if the remote end does not support timestamping, $\tsunknown{tf\_req\_tstmp}$ is $\Mfalse $ due to
                    the option negotiation in $\tsunknown{deliver\_in\_1}$. Then $\tsunknown{tf\_doing\_tstmp}$ is necessarily $\Mfalse $ too
                    and the retransmitted SYN,ACK segment does not contain a timestamp. OTOH, if
                    $\tsunknown{tf\_req\_tstmp}$ is still $\Mtrue $ then so is $\tsunknown{tf\_doing\_tstmp}$ and the faked up $\tsvar{cb}$ below is safe. }{}\\{}
\quad\quad\quad\quad\quad \tsholcomm{ Note that similar to the above note on timestamping, window scaling may also have to be dealt with here. }{}\\{}
\quad\quad\quad\quad\quad \Mlet  \;\tsvar{cb}''' = \tsvar{cb}' \;\Min {}\\{}
 {}\\{}
\quad\quad\quad\quad\quad \tsholcomm{ Note that $\tsunknown{tt\_delack}$ and possibly other timers should be cleared here }{}\\{}
\quad\quad\quad\quad\quad (\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{is}_{2}, \tsvar{sock}.\tsvar{ps}_{1}, \tsvar{sock}.\tsvar{ps}_{2}) = (\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{p}_{2}) \Mwedge {}\\{}
 {}\\{}
\quad\quad\quad\quad\quad \tsholcomm{ We are in $\tscon{SYN\_RECEIVED}$ and want to retransmit the SYN,ACK, so we either got here
                    via $\tsunknown{deliver\_in\_1}$ or $\tsunknown{deliver\_in\_2}$. In both cases, $\tsaux{calculate\_buf\_sizes}$ was used to
                    set $\tsvar{cb}.\tsunknown{t\_maxseg}$ to the correct value (as per \wasverb{tcp\textunderscore{}mss()} in BSD), however, we need
                    to use the old values in retransmitting the SYN,ACK, as per \wasverb{tcp\textunderscore{}mssopt()} in BSD.
                    $\tsaux{make\_syn\_ack\_segment}$ therefore uses the value stored in $\tsvar{cb}.\tsunknown{t\_advmss}$ to set the
                    same mss option in the segment, so we do not need to do anything special here. }{}\\{}
\quad\quad\quad\quad\quad \tsvar{oflgs} = \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mtrue ; \tsvar{FIN} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{odata} = [\,] \Mwedge {}\\{}
\quad\quad\quad\quad\quad \exists  \tsvar{S}_{0} \;\tsvar{s} \;\tsvar{s}'. \tsvar{SS} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})] \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{S}' = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')] \Mwedge {}\\{}
 {}\\{}
\quad\quad\quad\quad\quad \tsholcomm{ We need to remember to add the length of the segment data (i.e. 1 for a SYN) back onto
                    $\tsunknown{snd\_nxt}$ in the $\tsvar{cb}$, since this is what $\tsaux{tcp\_output\_really}$ does for normal retransmits. If
                    we do not do this, then we'll end up trying to send the first lot of data with a $\tsunknown{seq}$ of
                    $\tsunknown{iss}$, rather than $\tsunknown{iss} + 1$ }{}\\{}
\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}' \Mmagicrrec ) \Mmagicrrec {}\\{}
\quad\quad\quad ){}\\{}
\quad \Melse  \;\Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{LISTEN} \;\Mthen   \tsholcomm{ BSD LISTEN bug:
                    in BSD it is possible to transition a socket to the LISTEN state without
                    cancelling the rexmt timer.  In this case, segments are emitted with
                    no flags set. }{}\\{}
\quad\quad\quad\quad\quad \tsunknown{bsd\_arch} \;\tsvar{h}.\tsvar{arch} \Mwedge {}\\{}
\quad\quad\quad\quad\quad (\exists \tsvar{i}_{1} \;\tsvar{i}_{2} \;\tsvar{p}_{1} \;\tsvar{p}_{2}.{}\\{}
\quad\quad\quad\quad\quad\quad\quad (\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{is}_{2}, \tsvar{sock}.\tsvar{ps}_{1}, \tsvar{sock}.\tsvar{ps}_{2}) = (\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{p}_{2}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}.\tsvar{cantsndmore} \implies  \tsvar{oflgs}.\tsvar{FIN} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{oflgs} = \tsvar{oflgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{odata} = [\,] \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \exists  \tsvar{S}_{0} \;\tsvar{s} \;\tsvar{s}'. \tsvar{SS} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})] \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{S}' = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')] \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ Retransmission only continues if $\tsvar{FIN}$ is set in the outgoing segment (really!) }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}{}\\{}
  \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}' \Mmagicrrec  ) \Mmagicrrec ){}\\{}
\quad\quad\quad \Melse  \tsholcomm{  $\tscon{ESTABLISHED}, \tscon{FIN\_WAIT\_1}, \tscon{CLOSING}, \tscon{LAST\_ACK}$ }{}\\{}
\quad\quad\quad\quad\quad \tsholcomm{ i.e., cannot be $\tscon{CLOSED}, \tscon{LISTEN}, \tscon{SYN\_SENT}, \tscon{CLOSE\_WAIT}, \tscon{FIN\_WAIT\_2}, \tscon{TIME\_WAIT}$ }{}\\{}
\quad\quad\quad\quad\quad \tsaux{FIXMEstream\_tcp\_output\_really}{}\\{}
\quad\quad\quad\quad\quad (\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}' \Mmagicrrec ) \Mmagicrrec  ){}\\{}
\quad\quad\quad\quad\quad (\tsvar{sock}',\tsvar{oflgs}.\tsvar{FIN})  \tsholcomm{ always emits exactly one segment } \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{oflgs} = \tsvar{oflgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{odata} = [\,] \Mwedge {}\\{}
\quad\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad\quad \Mlet  (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) = \tsaux{quad\_of} \;\tsvar{sock} \;\Min {}\\{}
\quad\quad\quad\quad\quad \exists  \tsvar{S}_{0} \;\tsvar{s} \;\tsvar{s}'. \tsvar{SS} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})] \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{S}' = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')]{}\\{}
\quad ){}\\{}
 {}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsaux{FIXMEstream\_enqueue\_or\_fail} \;\Mtrue  \;\tsvar{h}.\tsvar{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} (\tsvar{sock}'.\tsvar{is}_{1},\tsvar{sock}'.\tsvar{is}_{2}) \tsunknown{tcp\_sock'}.\tsvar{cb} \;\tsvar{cb}'' \Mwedge {}\\{}
 \tsvar{sock}'' = \tsvar{sock}' \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}'' \Mmagicrrec ) \Mmagicrrec }
{\rrulepad }
}

\newcommand{\timerTttTpersistTI}{\rrulecn{timerTttTpersistTI}{timer\_tt\_persist\_1}{tcp: misc nonurgent}{\tsholcomm{ persist timer expires }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock}'')];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')],\tsvar{M})}
{\tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsvar{sock}'.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) \Mwedge {}\\{}
 \Mlet  \;\tsvar{sock}_{0} = \tsvar{sock} \;\Min {}\\{}
 \tsaux{FIXMEstream\_tcp\_output\_really}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}_{0}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{sock}',\tsvar{oflgs}.\tsvar{FIN}) \Mwedge {}\\{}
 \tsvar{oflgs} = \tsvar{oflgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{odata} = [\,] \Mwedge {}\\{}
\quad \tsholcomm{ guaranteed by $\tsaux{FIXMEstream\_tcp\_output\_really}$ }{}\\{}
\quad (\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2}) = (\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{ps}_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}) \Mwedge {}\\{}
\quad \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
 {}\\{}
 \tsaux{FIXMEstream\_enqueue\_or\_fail\_sock} (\tsunknown{tcp\_sock'}.\tsvar{st} \;\in  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT}\}) \tsvar{h}.\tsvar{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Msome  \;\tsvar{i}_{1}, \Msome  \;\tsvar{i}_{2}) \tsvar{sock}_{0} \;\tsvar{sock}' \;\tsvar{sock}''}
{}
}

\newcommand{\timerTttTkeepTI}{\rrulecn{timerTttTkeepTI}{timer\_tt\_keep\_1}{tcp: network nonurgent}{\tsholcomm{ keepalive timer expires }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{rcvq})))] ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb}',*,\tsvar{sndq},\tsvar{rcvq})))] ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{{}\\{}
 {}\\{}
 \tsholcomm{ Note that in another rule the following needs to be specified:
        if the timer has expired for the last time, then (in another rule):
         (if HAVERCVDSYN (i.e., not $\tscon{CLOSED}/\tscon{LISTEN}/\tscon{SYN\_SENT}$) then
              send a RST
          else
              do not do anything yet) $\Mwedge $
         copy soft error to es $\Mwedge $
         free tcpcb, saving RTT
     }{}\\{}
 {}\\{}
 \tsvar{cb}.\tsfield{tt\_keep} = \Msome  (\Mtimed{()}{\tsvar{d}}) \Mwedge {}\\{}
 \tsunknown{timer\_expires} \;\tsvar{d} \Mwedge {}\\{}
 {}\\{}
 \tsvar{cb}' = \tsvar{cb} \; \Mmagiclrec  \tsfield{tt\_keep} \Mass  \Msome  (\Mtimed{()}{\tsunknown{slow\_timer} \;\tsunknown{TCPTV\_KEEPINTVL}})  {}\\{}
 \Mmagicbolrrec }
{}
}

\newcommand{\timerTttTIImslTI}{\rrulecn{timerTttTIImslTI}{timer\_tt\_2msl\_1}{tcp: misc nonurgent}{\tsholcomm{ 2*MSL timer expires }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock}')] \Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{{}\\{}
 \tsholcomm{ \textbf{Summary:}
   When the 2MSL $\tscon{TIME\_WAIT}$ period expires, the socket is closed.
   }{}\\{}
 {}\\{}
 {}\\{}
 \Mif  \;\tsaux{exists\_quad\_of} \;\tsvar{sock} \;\Mthen {}\\{}
 \tsaux{destroy} (\tsaux{quad\_of} \;\tsvar{sock}) \tsvar{SS} \;\tsvar{S}'{}\\{}
 \Melse {}\\{}
 {}\\{}
 \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsvar{sock}' = \tsaux{tcp\_close} \;\tsvar{h}.\tsvar{arch} \;\tsvar{sock}}
{}
}

\newcommand{\timerTttTdelackTI}{\rrulecc{timerTttTdelackTI}{timer\_tt\_delack\_1}{tcp: misc nonurgent}{\tsholcomm{ delayed-ACK timer expires }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})],\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock}'')];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')],\tsvar{M})}
{\tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsvar{sock}'.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) \Mwedge {}\\{}
 \Mlet  \;\tsvar{sock}_{0} = \tsvar{sock} \;\Min {}\\{}
 \tsaux{FIXMEstream\_tcp\_output\_really} \;\tsvar{sock}_{0} (\tsvar{sock}',\tsvar{oflgs}.\tsvar{FIN}) \Mwedge {}\\{}
 \tsvar{oflgs} = \tsvar{oflgs} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{odata} = [\,] \Mwedge {}\\{}
 (\Msome  \;\tsvar{i}_{1}, \Msome  \;\tsvar{p}_{1}, \Msome  \;\tsvar{i}_{2}, \Msome  \;\tsvar{p}_{2}) = (\tsvar{sock}_{0}.\tsvar{is}_{1},\tsvar{sock}_{0}.\tsvar{ps}_{1},\tsvar{sock}_{0}.\tsvar{is}_{2},\tsvar{sock}_{0}.\tsvar{ps}_{2}) \Mwedge {}\\{}
 \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
 \tsaux{FIXMEstream\_enqueue\_or\_fail\_sock} (\tsunknown{tcp\_sock'}.\tsvar{st} \;\in  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT}\}) \tsvar{h}.\tsvar{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{sock}_{0}.\tsvar{is}_{1},\tsvar{sock}_{0}.\tsvar{is}_{2}) \tsvar{sock}_{0} \;\tsvar{sock}' \;\tsvar{sock}''}
{\rulesubsection{Description}

   This overlaps with $\tsunknown{deliver\_out\_1}$.  This is a bit odd, but is a consequence of our liberal nondeterministic TCP output.

\rrulepad }
}

\newcommand{\timerTttTconnTestTI}{\rrulecc{timerTttTconnTestTI}{timer\_tt\_conn\_est\_1}{tcp: misc nonurgent}{\tsholcomm{ connection establishment timer expires }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock}')];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{\tsholcomm{
   \textbf{Summary:}
   If the connection-establishment timer goes off, drop the connection
   (possibly $\tsvar{RST}$ing the other end). }{}\\{}
 {}\\{}
 \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsaux{tcp\_drop\_and\_close} \;\tsvar{h}.\tsvar{arch} (\Msome  \;\tsunknown{ETIMEDOUT}) \tsvar{sock} (\tsvar{sock}',(\tsvar{oflgs},\tsvar{odata})) \Mwedge {}\\{}
 \tsholcomm{ Note it should be the case that the socket is in $\tscon{SYN\_SENT}$, and so $\tsunknown{outsegs}$ will be empty, but that is not definite. }{}\\{}
 {}\\{}
 \tsholcomm{ write to stream if possible. FIXME perhaps an invariant guarantees quad is some }{}\\{}
 \Mif  \;\tsaux{exists\_quad\_of} \;\tsvar{sock} \;\Mthen {}\\{}
\quad \Mlet  (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) = \tsaux{quad\_of} \;\tsvar{sock} \;\Min {}\\{}
\quad \exists  \tsvar{S}_{0} \;\tsvar{s} \;\tsvar{s}'. \tsvar{SS} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})] \Mwedge {}\\{}
\quad \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
\quad \tsvar{S}' = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')]{}\\{}
 \Melse {}\\{}
\quad \tsvar{S}' = \tsvar{SS}}
{\rulesubsection{Description}
   POSIX: says, in the \emph{INFORMATIVE} section \emph{APPLICATION USAGE},
   that the state of the socket is unspecified if \wasverb{connect()} fails.
   We could (in the POSIX "architecture") model this accurately.


\rrulepad }
}

\newcommand{\timerTttTfinTwaitTIITI}{\rrulecc{timerTttTfinTwaitTIITI}{timer\_tt\_fin\_wait\_2\_1}{tcp: misc nonurgent}{\tsholcomm{ $\tscon{FIN\_WAIT\_2}$ timer expires }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec ,{}\\{}
 \tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock}')] \Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{\tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsvar{sock}' = \tsaux{tcp\_close} \;\tsvar{h}.\tsvar{arch} \;\tsvar{sock} \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 \Mif  \;\tsaux{exists\_quad\_of} \;\tsvar{sock} \;\Mthen {}\\{}
 \tsaux{destroy} (\tsaux{quad\_of} \;\tsvar{sock}) \tsvar{SS} \;\tsvar{S}'{}\\{}
 \Melse {}\\{}
 \tsvar{S}' = \tsvar{SS}}
{\rulesubsection{Description}
   This stops the timer and closes the socket.

   Unlike BSD, we take steps to ensure that this timer only fires when it is really time to close
   the socket.  Specifically, we reset it every time we receive a segment while in $\tscon{FIN\_WAIT\_2}$,
   to $\tsunknown{TCPTV\_MAXIDLE}$.  This means we do not need any guarding conditions here; we just do it.

   This means that we do not directly model the BSD behaviour of "sleep for 10 minutes, then check
   every 75 seconds to see if the connection has been idle for 10 minutes".


\rrulepad }
}

\newcommand{\chapcommudpTinputTprocessing}{\chaptersection{ Host LTS: UDP Input Processing}
\label{udp_input_processing}%
\chapcomm{}
}

\newcommand{\seccommudpTinputTprocessingTsection}{\clustersection{(UDP only)}{Input Processing}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{deliver\_in\_udp\_1}$
& \textbf{udp: network nonurgent}
&  Get UDP datagram from host's in-queue and deliver it to a matching socket \\
$\tsrule{deliver\_in\_udp\_2}$
& \textbf{udp: network nonurgent}
&  Get UDP datagram from host's in-queue but generate ICMP, as no matching socket \\
$\tsrule{deliver\_in\_udp\_3}$
& \textbf{udp: network nonurgent}
&  Get UDP datagram from host's in-queue and drop as from a martian address \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\deliverTinTudpTI}{\rrulecc{deliverTinTudpTI}{deliver\_in\_udp\_1}{udp: network nonurgent}{\tsholcomm{ Get UDP datagram from host's in-queue and deliver it to a matching socket }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h}_{0} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}';{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \;\tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}'))] \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \;\tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}))] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{rcvq}' = \Mappend{\tsvar{rcvq}}{[\tscon{Dgram\_msg}(\Mmagiclrec  \tsvar{data} \Mass  \tsvar{data}; \tsunknown{is} \Mass  \Msome  \;\tsvar{i}_{3}; \tsunknown{ps} \Mass  \tsvar{ps}_{3} \Mmagicrrec )]} \Mwedge {}\\{}
 \tsunknown{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tsunknown{UDP}(\Mmagiclrec  \tsvar{is}_{1} \Mass  \Msome  \;\tsvar{i}_{3}; \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i}_{4}; \tsvar{ps}_{1} \Mass  \tsvar{ps}_{3}; \tsvar{ps}_{2} \Mass  \tsvar{ps}_{4}; \tsvar{data} \Mass  \tsvar{data} \Mmagicrrec ))) \Mwedge {}\\{}
 (\exists  (\tsunknown{ifid},\tsunknown{ifd}) \Mcons  (\tsvar{h}_{0}.\tsvar{ifds}). \tsvar{i}_{4} \;\in  \;\tsunknown{ifd}.\tsunknown{ipset} ) \Mwedge {}\\{}
 \tsvar{sid} \;\in  \;\tsaux{lookup\_udp} \;\tsvar{h}_{0}.\tsvar{socks} (\tsvar{i}_{3},\tsvar{ps}_{3},\tsvar{i}_{4},\tsvar{ps}_{4}) \tsvar{h}_{0}.\tsvar{bound} \;\tsvar{h}_{0}.\tsvar{arch} \Mwedge {}\\{}
 \Mtrue  \Mwedge   \tsholcomm{ placeholder for  "not a link-layer multicast or broadcast" }{}\\{}
 \neg{}(\tsunknown{is\_broadormulticast} \;\tsvar{h}_{0}.\tsvar{ifds} \;\tsvar{i}_{4}) \Mwedge   \tsholcomm{ seems unlikely, since $\tsvar{i}_{1} \;\in  \;\tsunknown{local\_ips} \;\tsvar{h}.\tsvar{ifds}$ }{}\\{}
 \neg{}(\tsunknown{is\_broadormulticast} \;\tsvar{h}_{0}.\tsvar{ifds} \;\tsvar{i}_{3})}
{\rulesubsection{Description}

     At the head of the host's in-queue is a UDP datagram with source address $(\Msome  \;\tsvar{i}_{3},\tsvar{ps}_{3})$,
     destination address $(\Msome  \;\tsvar{i}_{4},\tsvar{ps}_{4})$, and data $\tsvar{data}$. The destination IP address, $\tsvar{i}_{4}$,
     is an IP address for one of the host's interfaces and is not an IP- or link-layer broadcast or
     multicast address and neither is the source IP address, $\tsvar{i}_{3}$.

     The UDP socket $\tsvar{sid}$ matches the address quad of the datagram (see \ltslink{lookupTudp}{$\tsaux{lookup\_udp}$} for
     details). A $\MLhtau $ transition is made. The datagram is removed from the host's in-queue,
     $\tsvar{iq}$, and appended to the tail of the socket's receive queue, $\tsvar{rcvq}'$, leaving the host
     with in-queue $\tsvar{iq}'$ and the socket with receive queue $\tsvar{rcvq}'$.


\rrulepad }
}

\newcommand{\deliverTinTudpTII}{\rrulecc{deliverTinTudpTII}{deliver\_in\_udp\_2}{udp: network nonurgent}{\tsholcomm{ Get UDP datagram from host's in-queue but generate ICMP, as no matching socket }}
{(\tsvar{h} \; \;\tsvar{iq} \Mass  \tsvar{iq},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}'; \tsvar{oq} \Mass  \Mif  \;\tsunknown{icmp\_to\_go} \;\Mthen  \;\tsvar{oq}' \;\Melse  \;\tsvar{h}.\tsvar{oq} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tsunknown{UDP}(\Mmagiclrec  \tsvar{is}_{1} \Mass  \Msome  \;\tsvar{i}_{3}; \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i}_{4}; \tsvar{ps}_{1} \Mass  \tsvar{ps}_{3};{}\\{}
 \tsvar{ps}_{2} \Mass  \tsvar{ps}_{4}; \tsvar{data} \Mass  \tsvar{data} \Mmagicrrec ))) \Mwedge {}\\{}
 \tsaux{lookup\_udp} \;\tsvar{h}.\tsvar{socks} (\tsvar{i}_{3},\tsvar{ps}_{3},\tsvar{i}_{4},\tsvar{ps}_{4}) \tsvar{h}.\tsvar{bound} \;\tsvar{h}.\tsvar{arch} = \emptyset  \Mwedge {}\\{}
 \tsvar{icmp} = \tsunknown{ICMP}(\Mmagiclrec  \tsvar{is}_{1} \Mass  \Msome  \;\tsvar{i}_{4}; \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i}_{3}; \tsunknown{is3} \Mass  \Msome  \;\tsvar{i}_{3}; \tsunknown{is4} \Mass  \Msome  \;\tsvar{i}_{4};{}\\{}
 \tsvar{ps}_{3} \Mass  \tsvar{ps}_{3}; \tsvar{ps}_{4} \Mass  \tsvar{ps}_{4}; \tsunknown{proto} \Mass  \tsunknown{PROTO\_UDP}; \tsunknown{seq} \Mass  *;{}\\{}
 \tsunknown{t} \Mass  \tsunknown{ICMP\_UNREACH}(\tsunknown{PORT}) \Mmagicrrec ) \Mwedge {}\\{}
 (\tsunknown{enqueue\_oq}(\tsvar{h}.\tsvar{oq},\tsvar{icmp},\tsvar{oq}',\Mtrue ) \Mvee  \tsunknown{icmp\_to\_go} = \Mfalse ) \tsholcomm{ non-deterministic ICMP generation } \Mwedge {}\\{}
 \tsvar{i}_{4} \;\in  \;\tsunknown{local\_ips} \;\tsvar{h}.\tsvar{ifds} \Mwedge {}\\{}
 \Mtrue  \Mwedge   \tsholcomm{ placeholder for  "not a link-layer multicast or broadcast" }{}\\{}
 \neg{}(\tsunknown{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{4}) \Mwedge   \tsholcomm{ seems unlikely, since $\tsvar{i}_{1} \;\in  \;\tsunknown{local\_ips} \;\tsvar{h}.\tsvar{ifds}$ }{}\\{}
 \neg{}(\tsunknown{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{3})}
{\rulesubsection{Description}

     At the head of the host's in-queue, $\tsvar{iq}$, is a UDP datagram with source address $(\Msome
\tsvar{i}_{3},\tsvar{ps}_{3})$, destination address $(\Msome  \;\tsvar{i}_{4},\tsvar{ps}_{4})$, and data $\tsvar{data}$. The destination IP
     address, $\tsvar{i}_{4}$, is an IP address for one of the host's interfaces and is neither a broadcast
     or multicast address; the source IP address, $\tsvar{i}_{3}$, is also not a broadcast or multicast
     address. None of the sockets in the host's finite map of sockets, $\tsvar{h}.\tsvar{socks}$, match the
     datagram (see \ltslink{lookupTudp}{$\tsaux{lookup\_udp}$} for details).

     A $\MLhtau $ transition is made. The datagram is removed from the host's in-queue, leaving it
     with in-queue $\tsvar{iq}'$. An ICMP Port-unreachable message may be generated and appended to the
     tail of the host's out-queue in response to the datagram.

\rrulepad }
}

\newcommand{\deliverTinTudpTIII}{\rrulecc{deliverTinTudpTIII}{deliver\_in\_udp\_3}{udp: network nonurgent}{\tsholcomm{ Get UDP datagram from host's in-queue and drop as from a martian address }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tsunknown{UDP} \;\tsvar{dgram})) \Mwedge {}\\{}
 \tsvar{dgram}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge {}\\{}
 \tsvar{is}_{1} = \tsvar{dgram}.\tsvar{is}_{1} \Mwedge {}\\{}
 \tsvar{i}_{2} \;\in  \;\tsunknown{local\_ips}(\tsvar{h}.\tsvar{ifds}) \Mwedge {}\\{}
 (\Mfalse  \Mvee                   {}\\{}
 \neg{}(\Mtrue  \Mwedge   {}\\{}
\quad \neg{}(\tsunknown{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{2}) \Mwedge   \tsholcomm{ seems unlikely, since $\tsvar{i}_{1} \;\in  \;\tsunknown{local\_ips} \;\tsvar{h}.\tsvar{ifds}$ }{}\\{}
\quad \neg{}(\tsvar{is}_{1} = *) \Mwedge {}\\{}
\quad \neg{}\tsunknown{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} (\tsholop{THE} \;\tsvar{is}_{1}){}\\{}
 ){}\\{}
 )}
{\rulesubsection{Description}

    At the head of the host's in-queue, $\tsvar{iq}$, is a UDP datagram with destination IP address $\Msome
\tsvar{i}_{2}$ which is an IP address for one of the host's interfaces. Either $\tsvar{i}_{2}$ is an IP-layer
    broadcast or multicast address, or the source IP address, $\tsvar{is}_{1}$, is not set or is an IP-layer
    broadcast or multicast address.

    A $\MLhtau $ transition is made. The datagram is dropped from the host's in-queue, leaving it
    with in-queue $\tsvar{iq}'$.

\rrulepad }
}

\newcommand{\chapcommicmpTinputTprocessing}{\chaptersection{ Host LTS: ICMP Input Processing}
\label{icmp_input_processing}%
\chapcomm{}
}

\newcommand{\seccommicmpTinputTprocessingTsection}{\clustersection{(ICMP only)}{Input Processing}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{deliver\_in\_icmp\_1}$
& \textbf{all: network nonurgent}
&  Receive $\tsunknown{ICMP\_UNREACH\_NET}$ etc for known socket \\
$\tsrule{deliver\_in\_icmp\_2}$
& \textbf{all: network nonurgent}
&  Receive $\tsunknown{ICMP\_UNREACH\_NEEDFRAG}$ for known socket \\
$\tsrule{deliver\_in\_icmp\_3}$
& \textbf{all: network nonurgent}
&  Receive $\tsunknown{ICMP\_UNREACH\_PORT}$ etc for known socket \\
$\tsrule{deliver\_in\_icmp\_4}$
& \textbf{all: network nonurgent}
&  Receive $\tsunknown{ICMP\_PARAMPROB}$ etc for known socket \\
$\tsrule{deliver\_in\_icmp\_5}$
& \textbf{all: network nonurgent}
&  Receive $\tsunknown{ICMP\_SOURCE\_QUENCH}$ for known socket \\
$\tsrule{deliver\_in\_icmp\_6}$
& \textbf{all: network nonurgent}
&  Receive and ignore other ICMP \\
$\tsrule{deliver\_in\_icmp\_7}$
& \textbf{all: network nonurgent}
&  Receive and ignore invalid or unmatched ICMP \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\deliverTinTicmpTI}{\rrulecc{deliverTinTicmpTI}{deliver\_in\_icmp\_1}{all: network nonurgent}{\tsholcomm{ Receive $\tsunknown{ICMP\_UNREACH\_NET}$ etc for known socket }}
{(\tsvar{h}_{0},\tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}';{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec  \Mwedge {}\\{}
 \tsunknown{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tsunknown{ICMP} \;\tsvar{icmp})) \Mwedge {}\\{}
 \tsvar{icmp}.\tsunknown{t} \;\in  \{ \tsunknown{ICMP\_UNREACH} \;\tsunknown{c} \mid {}\\{}
\quad\quad\quad\quad\quad\quad \tsunknown{c} \;\in  \{\tsunknown{NET}; \tsunknown{HOST}; \tsunknown{SRCFAIL}; \tsunknown{NET\_UNKNOWN}; \tsunknown{HOST\_UNKNOWN}; \tsunknown{ISOLATED};{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{TOSNET}; \tsunknown{TOSHOST}; \tsunknown{PREC\_VIOLATION}; \tsunknown{PREC\_CUTOFF}\}\} \Mwedge {}\\{}
 \tsvar{icmp}.\tsunknown{is3} = \Msome  \;\tsvar{i}_{3} \Mwedge {}\\{}
 \tsvar{i}_{3} \;\notin  \;\tsunknown{IN\_MULTICAST} \Mwedge {}\\{}
 \tsvar{sid} \;\in  \;\tsaux{lookup\_icmp} \;\tsvar{h}_{0}.\tsvar{socks} \;\tsvar{icmp} \;\tsvar{h}_{0}.\tsvar{arch} \;\tsvar{h}_{0}.\tsvar{bound} \Mwedge {}\\{}
 (\Mcase  \;\tsvar{sock}.\tsvar{pr} \;\Mof {}\\{}
\quad \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mtotype {}\\{}
\quad\quad (\exists \tsunknown{icmp\_seq}. \tsvar{icmp}.\tsunknown{seq} = \Msome  \;\tsunknown{icmp\_seq} \Mwedge {}\\{}
\quad\quad \exists  \tsunknown{snd\_una\_le\_icmp\_seq} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
\quad\quad \exists  \tsunknown{icmp\_seq\_lt\_snd\_max} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
\quad\quad \exists  \tsvar{cond} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
\quad\quad (\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{t\_softerror} = * \implies  \tsvar{cond} = \Mfalse ) \Mwedge {}\\{}
\quad\quad \Mif  \;\tsunknown{snd\_una\_le\_icmp\_seq} \Mwedge  \tsunknown{icmp\_seq\_lt\_snd\_max} \;\Mthen  {}\\{}
\quad\quad\quad\quad \Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{ESTABLISHED} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge   \tsholcomm{ ignore transient error while connected }{}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{oq}' = \tsvar{oq} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{S}' = \tsvar{SS}{}\\{}
\quad\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT};\tscon{SYN\_RECEIVED}\} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cond} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad \exists  \tsvar{oflgs} \;\tsvar{odata}. \tsaux{tcp\_drop\_and\_close} \;\tsvar{h}.\tsvar{arch} (\Msome  \;\tsunknown{EHOSTUNREACH}) \tsvar{sock} (\tsvar{sock}',(\tsvar{oflgs},\tsvar{odata})) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \Mif  \;\tsaux{exists\_quad\_of} \;\tsvar{sock} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Mlet  (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) = \tsaux{quad\_of} \;\tsvar{sock} \;\Min {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \exists  \tsvar{S}_{0} \;\tsvar{s} \;\tsvar{s}'. \tsvar{S}_{0} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})] \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSED} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{S}' = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')]{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{destroy} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')]) \tsvar{S}'{}\\{}
\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{S}' = \tsvar{SS}{}\\{}
\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{cb} \Mass  \tsunknown{tcp\_sock}.\tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsfield{t\_softerror} \Mass  \Msome  \;\tsunknown{EHOSTUNREACH} \Mmagicrrec  \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{oq}' = \tsvar{oq} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{S}' = \tsvar{SS}{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsholcomm{ Note the case where it is a syncache entry is not dealt with here: a \wasverb{syncache\textunderscore{}unreach()} should be done instead }{}\\{}
\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge {}\\{}
\quad\quad\quad\quad \tsvar{oq}' = \tsvar{oq} \Mwedge {}\\{}
\quad\quad\quad\quad \tsvar{S}' = \tsvar{SS} ) \Mdpipe {}\\{}
\quad \tscon{UDP\_PROTO}(\tsunknown{udp\_sock}) \Mtotype {}\\{}
\quad\quad\quad \Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsunknown{udp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{rcvq} \Mass  \Mappend{\tsunknown{udp\_sock}.\tsvar{rcvq}}{[(\tscon{Dgram\_error}(\Mmagiclrec  \tsunknown{e} \Mass  \tsunknown{ECONNRESET} \Mmagicrrec ))]} \Mmagicrrec ) \Mmagicrrec  \Mwedge  \tsvar{oq}' = \tsvar{oq}{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{es} \;\Mupdby  \;\Msome  \;\tsunknown{ECONNREFUSED}{}\\{}
 \tsholop{onlywhen} ((\tsvar{sock}.\tsvar{is}_{2} \neq  *) \Mvee  \neg{}(\tscon{SO\_BSDCOMPAT} \;\in  \;\tsvar{sock}.\tsvar{sf}.\tsunknown{b})) \Mmagicrrec  \Mwedge  \tsvar{oq}' = \tsvar{oq})}
{\rulesubsection{Description}
   Corresponds to FreeBSD 4.6-RELEASE's PRC\_UNREACH\_NET.

\rrulepad }
}

\newcommand{\deliverTinTicmpTII}{\rrulecc{deliverTinTicmpTII}{deliver\_in\_icmp\_2}{all: network nonurgent}{\tsholcomm{ Receive $\tsunknown{ICMP\_UNREACH\_NEEDFRAG}$ for known socket }}
{(\tsvar{h}_{0},\tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}';{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec  \Mwedge {}\\{}
 \tsunknown{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tsunknown{ICMP} \;\tsvar{icmp})) \Mwedge {}\\{}
 \tsvar{icmp}.\tsunknown{t} = \tsunknown{ICMP\_UNREACH} (\tsunknown{NEEDFRAG} \;\tsvar{icmpmtu}) \Mwedge {}\\{}
 (\tsvar{icmp}.\tsunknown{is3} = * \Mvee  \tsholop{THE} \;\tsvar{icmp}.\tsunknown{is3} \;\notin  \;\tsunknown{IN\_MULTICAST}) \Mwedge {}\\{}
 \tsvar{sid} \;\in  \;\tsaux{lookup\_icmp} \;\tsvar{h}_{0}.\tsvar{socks} \;\tsvar{icmp} \;\tsvar{h}_{0}.\tsvar{arch} \;\tsvar{h}_{0}.\tsvar{bound} \Mwedge {}\\{}
 \Mlet  \;\tsunknown{nextmtu} = \Mif  \;\Mfalse  \Mwedge  \tsholcomm{ Note this is a placeholder for "there is a host (not net) route for icmp.is4" }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Mfalse  \;\Mthen  \tsholcomm{ Note this is a placeholder for "\wasverb{rmx.mtu} not locked" }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mlet  \;\tsunknown{curmtu} = 1492 \;\Min  \tsholcomm{ Note this value should be taken from \wasverb{rmx.mtu} }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mlet  \;\tsunknown{nextmtu} = \Mcase  \;\tsvar{icmpmtu} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  \;\tsunknown{mtu} \Mtotype  \tsholop{w2n} \;\tsunknown{mtu}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mdpipe  *     \Mtotype  \tsaux{next\_smaller} (\tsaux{mtu\_tab} \;\tsvar{h}_{0}.\tsvar{arch}) \tsunknown{curmtu} \;\Min {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mif  \;\tsunknown{nextmtu} < 296 \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ Note this should lock curmtu in rmxcache; and not change rmxcache MTU from curmtu }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  \;\tsunknown{curmtu}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ Note here, $\tsunknown{nextmtu}$ should be stored in rmxcache }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  \;\tsunknown{nextmtu}{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad * \;\Min {}\\{}
 (\Mcase  \;\tsvar{sock}.\tsvar{pr} \;\Mof {}\\{}
\quad\quad \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mtotype {}\\{}
\quad\quad\quad (\exists \tsunknown{icmp\_seq}. \tsvar{icmp}.\tsunknown{seq} = \Msome  \;\tsunknown{icmp\_seq} \Mwedge {}\\{}
\quad\quad\quad \Mif  \;\tsholop{IS\_SOME} \;\tsvar{icmp}.\tsunknown{is3} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \exists  \tsvar{cond} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
\quad\quad\quad\quad\quad (\Mif  \;\tsvar{cond} \;\Mthen  {}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mif  \;\tsunknown{nextmtu} = * \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{oq}' = \tsvar{oq} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{S}' = \tsvar{SS}{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \exists  \tsunknown{tf\_doing\_tstmp} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mlet  \;\tsunknown{mss} = \tsholop{MIN} (\tsvar{sock}.\tsvar{sf}.\tsunknown{n}(\tscon{SO\_SNDBUF})){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsunknown{rounddown} \;\tsunknown{MCLBYTES}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsholop{THE} \;\tsunknown{nextmtu} - 40 - (\Mif  \;\tsunknown{tf\_doing\_tstmp} \;\Mthen  \;12 \;\Melse  \;0))) \Min {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ BSD: TS, plus NOOP for alignment }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \exists  \tsvar{cond}' \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mif  \;\tsvar{cond}' \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mlet  \;\tsvar{sock}'' = \tsvar{sock} \;\Min {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \exists \tsvar{sock}''' \;\tsvar{FINs} \;\tsunknown{tcp\_sock'''}.{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}'''.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'''}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{FIXMEstream\_tcp\_output\_perhaps} \;\tsvar{sock}'' (\tsvar{sock}''',\tsvar{FINs}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{FIXMEstream\_enqueue\_or\_fail\_sock} (\tsunknown{tcp\_sock'''}.\tsvar{st} \;\notin  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT}\}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{h}.\tsvar{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} (\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{is}_{2}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}'' \;\tsvar{sock}''' \;\tsvar{sock}' \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mcase  \;\tsvar{FINs} \;\Mof  \;* \Mtotype  \tsvar{S}' = \tsvar{SS}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mdpipe  \Msome  \;\tsvar{FIN} \Mtotype {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mlet  \;\tsunknown{oflgs} = \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{FIN} \Mass  \tsvar{FIN}; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Min {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mlet  (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) = \tsaux{quad\_of} \;\tsvar{sock} \;\Min {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \exists  \tsvar{S}_{0} \;\tsvar{s} \;\tsvar{s}'. \tsvar{SS} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})] \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsunknown{oflgs},[\,]) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{S}' = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')]{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge  \tsvar{oq}' = \tsvar{oq} \Mwedge  \tsvar{S}' = \tsvar{SS}{}\\{}
\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsholcomm{ Note the case where it is a syncache entry is not dealt with here: a \wasverb{syncache\textunderscore{}unreach()} should be done instead }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge  \tsvar{oq}' = \tsvar{oq} \Mwedge  \tsvar{S}' = \tsvar{SS}){}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge  \tsvar{oq}' = \tsvar{oq} \Mwedge  \tsvar{S}' = \tsvar{SS}) \Mdpipe {}\\{}
\quad\quad \tscon{UDP\_PROTO}(\tsunknown{udp\_sock}) \Mtotype {}\\{}
\quad\quad \Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsunknown{udp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{rcvq} \Mass  \Mappend{\tsunknown{udp\_sock}.\tsvar{rcvq}}{[(\tscon{Dgram\_error}(\Mmagiclrec  \tsunknown{e} \Mass  \tsunknown{EMSGSIZE} \Mmagicrrec ))]} \Mmagicrrec ) \Mmagicrrec  \Mwedge  \tsvar{oq}' = \tsvar{oq}{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsunknown{EMSGSIZE} \Mmagicrrec  \Mwedge  \tsvar{oq}' = \tsvar{oq})}
{\rulesubsection{Description}
   Corresponds to FreeBSD 4.6-RELEASE's PRC\_MSGSIZE.

\rrulepad }
}

\newcommand{\deliverTinTicmpTIII}{\rrulecc{deliverTinTicmpTIII}{deliver\_in\_icmp\_3}{all: network nonurgent}{\tsholcomm{ Receive $\tsunknown{ICMP\_UNREACH\_PORT}$ etc for known socket }}
{(\tsvar{h}_{0},\tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}';{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec  \Mwedge {}\\{}
 \tsunknown{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tsunknown{ICMP} \;\tsvar{icmp})) \Mwedge {}\\{}
 \tsvar{icmp}.\tsunknown{t} \;\in  \{ \tsunknown{ICMP\_UNREACH} \;\tsunknown{c} \mid {}\\{}
\quad\quad\quad\quad\quad\quad \tsunknown{c} \;\in  \{\tsunknown{PROTOCOL}; \tsunknown{PORT}; \tsunknown{NET\_PROHIB}; \tsunknown{HOST\_PROHIB}; \tsunknown{FILTER\_PROHIB}\}\} \Mwedge {}\\{}
 \tsvar{icmp}.\tsunknown{is3} = \Msome  \;\tsvar{i}_{3} \Mwedge {}\\{}
 \tsvar{i}_{3} \;\notin  \;\tsunknown{IN\_MULTICAST} \Mwedge {}\\{}
 \tsvar{sid} \;\in  \;\tsaux{lookup\_icmp} \;\tsvar{h}_{0}.\tsvar{socks} \;\tsvar{icmp} \;\tsvar{h}_{0}.\tsvar{arch} \;\tsvar{h}_{0}.\tsvar{bound} \Mwedge {}\\{}
 (\Mcase  \;\tsvar{sock}.\tsvar{pr} \;\Mof {}\\{}
\quad\quad \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mtotype {}\\{}
\quad\quad\quad (\exists \tsunknown{icmp\_seq}. \tsvar{icmp}.\tsunknown{seq} = \Msome  \;\tsunknown{icmp\_seq} \Mwedge {}\\{}
\quad\quad\quad \exists  \tsvar{cond} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
\quad\quad\quad \Mif  \;\tsvar{cond} \;\Mthen  {}\\{}
\quad\quad\quad\quad\quad \Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_SENT} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \exists  \tsvar{oflgsodata}.{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{tcp\_drop\_and\_close} \;\tsvar{h}.\tsvar{arch} (\Msome  \;\tsunknown{ECONNREFUSED}) \tsvar{sock} (\tsvar{sock}',\tsvar{oflgsodata}) \Mwedge   \tsholcomm{ know from definition of $\tsaux{tcp\_drop\_and\_close}$ that no segs will be emitted }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{null\_flgs\_data} \;\tsvar{oflgsodata} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mif  \;\tsaux{exists\_quad\_of} \;\tsvar{sock} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{destroy} (\tsaux{quad\_of} \;\tsvar{sock}) \tsvar{SS} \;\tsvar{S}'{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{S}' = \tsvar{SS}{}\\{}
\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge  \tsvar{oq}' = \tsvar{oq} \Mwedge  \tsvar{S}' = \tsvar{SS}{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsholcomm{ Note the case where it is a syncache entry is not dealt with here: a \wasverb{syncache\textunderscore{}unreach()} should be done instead }{}\\{}
\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge  \tsvar{oq}' = \tsvar{oq} \Mwedge  \tsvar{S}' = \tsvar{SS} ) \Mdpipe {}\\{}
\quad\quad \tscon{UDP\_PROTO}(\tsunknown{udp\_sock}) \Mtotype {}\\{}
\quad\quad\quad\quad (\Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsunknown{udp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{rcvq} \Mass  \Mappend{\tsunknown{udp\_sock}.\tsvar{rcvq}}{[(\tscon{Dgram\_error}(\Mmagiclrec  \tsunknown{e} \Mass  \tsunknown{ECONNRESET} \Mmagicrrec ))]} \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{oq}' = \tsvar{oq}{}\\{}
\quad\quad\quad\quad\quad \Melse  {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{es} \;\Mupdby  \;\Msome  (\tsunknown{ECONNREFUSED}){}\\{}
 \tsholop{onlywhen} ((\tsvar{sock}.\tsvar{is}_{2} \neq  *) \Mvee  \neg{}(\tscon{SO\_BSDCOMPAT} \;\in  \;\tsvar{sock}.\tsvar{sf}.\tsunknown{b})) \Mmagicrrec  \Mwedge  \tsvar{oq}' = \tsvar{oq}))}
{\rulesubsection{Description}
   Corresponds to FreeBSD 4.6-RELEASE's PRC\_UNREACH\_PORT and PRC\_UNREACH\_ADMIN\_PROHIB.

\rrulepad }
}

\newcommand{\deliverTinTicmpTIV}{\rrulecc{deliverTinTicmpTIV}{deliver\_in\_icmp\_4}{all: network nonurgent}{\tsholcomm{ Receive $\tsunknown{ICMP\_PARAMPROB}$ etc for known socket }}
{(\tsvar{h}_{0},\tsvar{SS},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}';{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S}',\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec  \Mwedge {}\\{}
 \tsunknown{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tsunknown{ICMP} \;\tsvar{icmp})) \Mwedge {}\\{}
 \tsvar{icmp}.\tsunknown{t} \;\in  \{ \tsunknown{ICMP\_PARAMPROB} \;\tsunknown{c} \mid {}\\{}
\quad\quad\quad\quad\quad\quad \tsunknown{c} \;\in  \{\tsunknown{BADHDR}; \tsunknown{NEEDOPT}\}\} \Mwedge {}\\{}
 \tsvar{icmp}.\tsunknown{is3} = \Msome  \;\tsvar{i}_{3} \Mwedge {}\\{}
 \tsvar{i}_{3} \;\notin  \;\tsunknown{IN\_MULTICAST} \Mwedge {}\\{}
 \tsvar{sid} \;\in  \;\tsaux{lookup\_icmp} \;\tsvar{h}_{0}.\tsvar{socks} \;\tsvar{icmp} \;\tsvar{h}_{0}.\tsvar{arch} \;\tsvar{h}_{0}.\tsvar{bound} \Mwedge {}\\{}
 (\Mcase  \;\tsvar{sock}.\tsvar{pr} \;\Mof {}\\{}
\quad\quad \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mtotype {}\\{}
\quad\quad\quad (\exists \tsunknown{icmp\_seq}. \tsvar{icmp}.\tsunknown{seq} = \Msome  \;\tsunknown{icmp\_seq} \Mwedge {}\\{}
\quad\quad\quad \exists  \tsvar{cond} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
\quad\quad\quad \Mif  \;\tsvar{cond} \;\Mthen  {}\\{}
\quad\quad\quad\quad\quad \exists  \tsvar{cond}' \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
\quad\quad\quad\quad\quad \tsvar{cond}' \implies  \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{t\_softerror} \neq  * \Mwedge {}\\{}
\quad\quad\quad\quad\quad \Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT};\tscon{SYN\_RECEIVED}\} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{cond}' \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \exists  \tsvar{oflgs} \;\tsvar{odata}.{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{tcp\_drop\_and\_close} \;\tsvar{h}.\tsvar{arch} (\Msome  \;\tsunknown{ENOPROTOOPT}) \tsvar{sock} (\tsvar{sock}',(\tsvar{oflgs},\tsvar{odata})) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mif  \;\tsaux{exists\_quad\_of} \;\tsvar{sock} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Mlet  (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) = \tsaux{quad\_of} \;\tsvar{sock} \;\Min {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \exists  \tsvar{S}_{0} \;\tsvar{s} \;\tsvar{s}'. \tsvar{SS} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s})] \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{oflgs},\tsvar{odata}) \tsvar{s} \;\tsvar{s}' \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSED} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{S}' = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')]{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{destroy} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}),\tsvar{s}')]) \tsvar{S}'{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{S}' = \tsvar{SS}{}\\{}
\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{cb} \Mass  \tsunknown{tcp\_sock}.\tsvar{cb} \; \Mmagiclrec  \tsfield{t\_softerror} \Mass  \Msome  \;\tsunknown{ENOPROTOOPT} \Mmagicrrec  \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{oq}' = \tsvar{oq} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{S}' = \tsvar{SS}{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge  \tsvar{oq}' = \tsvar{oq} \Mwedge  \tsvar{S}' = \tsvar{SS}) \Mdpipe {}\\{}
\quad\quad \tscon{UDP\_PROTO}(\tsunknown{udp\_sock}) \Mtotype {}\\{}
\quad\quad\quad\quad (\Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsunknown{udp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{rcvq} \Mass  \Mappend{\tsunknown{udp\_sock}.\tsvar{rcvq}}{[(\tscon{Dgram\_error}(\Mmagiclrec  \tsunknown{e} \Mass  \tsunknown{ENOPROTOOPT} \Mmagicrrec ))]} \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{oq}' = \tsvar{oq}{}\\{}
\quad\quad\quad\quad\quad \Melse  {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  (\tsunknown{ENOPROTOOPT}) \Mmagicrrec  \Mwedge  \tsvar{oq}' = \tsvar{oq}))}
{\rulesubsection{Description}
   Corresponds to FreeBSD 4.6-RELEASE's PRC\_PARAMPROB.

\rrulepad }
}

\newcommand{\deliverTinTicmpTV}{\rrulecc{deliverTinTicmpTV}{deliver\_in\_icmp\_5}{all: network nonurgent}{\tsholcomm{ Receive $\tsunknown{ICMP\_SOURCE\_QUENCH}$ for known socket }}
{(\tsvar{h}_{0},\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec  \Mwedge {}\\{}
 \tsunknown{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tsunknown{ICMP} \;\tsvar{icmp})) \Mwedge {}\\{}
 \tsvar{icmp}.\tsunknown{t} = \tsunknown{ICMP\_SOURCE\_QUENCH} \;\tsunknown{QUENCH} \Mwedge {}\\{}
 \tsvar{icmp}.\tsunknown{is3} = \Msome  \;\tsvar{i}_{3} \Mwedge {}\\{}
 \tsvar{i}_{3} \;\notin  \;\tsunknown{IN\_MULTICAST} \Mwedge {}\\{}
 \tsvar{sid} \;\in  \;\tsaux{lookup\_icmp} \;\tsvar{h}_{0}.\tsvar{socks} \;\tsvar{icmp} \;\tsvar{h}_{0}.\tsvar{arch} \;\tsvar{h}_{0}.\tsvar{bound} \Mwedge {}\\{}
 (\Mcase  \;\tsvar{sock}.\tsvar{pr} \;\Mof {}\\{}
\quad\quad \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mtotype {}\\{}
\quad\quad\quad (\exists \tsunknown{icmp\_seq}. \tsvar{icmp}.\tsunknown{seq} = \Msome  \;\tsunknown{icmp\_seq} \Mwedge {}\\{}
\quad\quad\quad \exists  \tsvar{cond} \Mcons  \{\Mtrue ;\Mfalse \}.{}\\{}
\quad\quad\quad \Mif  \;\tsvar{cond} \;\Mthen  {}\\{}
\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock}{}\\{}
\quad\quad\quad \tsholcomm{ Note the state of the TCP socket should be checked here. }{}\\{}
\quad\quad\quad \tsholcomm{ Note it might be necessary to make an allowance for local/remote connection? }{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsholcomm{ Note the case where it is a syncache entry is not dealt with here: a \wasverb{syncache\textunderscore{}unreach()} should be done instead }{}\\{}
\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} ) \Mdpipe {}\\{}
\quad\quad \tscon{UDP\_PROTO}(\tsunknown{udp\_sock}) \Mtotype {}\\{}
\quad\quad\quad\quad (\Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsunknown{udp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{rcvq} \Mass  \Mappend{\tsunknown{udp\_sock}.\tsvar{rcvq}}{[(\tscon{Dgram\_error}(\Mmagiclrec  \tsunknown{e} \Mass  \tsunknown{EHOSTUNREACH} \Mmagicrrec ))]} \Mmagicrrec ) \Mmagicrrec {}\\{}
\quad\quad\quad\quad\quad \Melse  {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  (\tsunknown{EHOSTUNREACH}) \Mmagicrrec ))}
{\rulesubsection{Description}
   Corresponds to FreeBSD 4.6-RELEASE's PRC\_QUENCH.

\rrulepad }
}

\newcommand{\deliverTinTicmpTVI}{\rrulecc{deliverTinTicmpTVI}{deliver\_in\_icmp\_6}{all: network nonurgent}{\tsholcomm{ Receive and ignore other ICMP }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tsunknown{ICMP} \;\tsvar{icmp})) \Mwedge {}\\{}
 (\tsvar{icmp}.\tsunknown{t} \;\in  \{ \tsunknown{ICMP\_TIME\_EXCEEDED} \;\tsunknown{INTRANS}; \tsunknown{ICMP\_TIME\_EXCEEDED} \;\tsunknown{REASS} \} \Mvee {}\\{}
 \tsvar{icmp}.\tsunknown{t} \;\in  \{ \tsunknown{ICMP\_UNREACH}       (\tsunknown{OTHER} \;\tsunknown{x}) \mid  \tsunknown{x} \;\in  \;\tsunknown{UNIV} \} \Mvee {}\\{}
 \tsvar{icmp}.\tsunknown{t} \;\in  \{ \tsunknown{ICMP\_SOURCE\_QUENCH} (\tsunknown{OTHER} \;\tsunknown{x}) \mid  \tsunknown{x} \;\in  \;\tsunknown{UNIV} \} \Mvee {}\\{}
 \tsvar{icmp}.\tsunknown{t} \;\in  \{ \tsunknown{ICMP\_TIME\_EXCEEDED} (\tsunknown{OTHER} \;\tsunknown{x}) \mid  \tsunknown{x} \;\in  \;\tsunknown{UNIV} \} \Mvee {}\\{}
 \tsvar{icmp}.\tsunknown{t} \;\in  \{ \tsunknown{ICMP\_PARAMPROB}     (\tsunknown{OTHER} \;\tsunknown{x}) \mid  \tsunknown{x} \;\in  \;\tsunknown{UNIV} \})}
{\rulesubsection{Description}
   If ICMP\_TIME\_EXCEEDED (either INTRANS or REASS), or if a bad code is received, then ignore
   silently.

\rrulepad }
}

\newcommand{\deliverTinTicmpTVII}{\rrulecc{deliverTinTicmpTVII}{deliver\_in\_icmp\_7}{all: network nonurgent}{\tsholcomm{ Receive and ignore invalid or unmatched ICMP }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \MLhtau  }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsunknown{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tsunknown{ICMP} \;\tsvar{icmp})) \Mwedge {}\\{}
 (\tsvar{icmp}.\tsunknown{t} \;\in  \{ \tsunknown{ICMP\_UNREACH} \;\tsunknown{c} \mid  \neg{}\exists \tsvar{x}. \tsunknown{c} = \tsunknown{OTHER} \;\tsvar{x} \} \Mvee {}\\{}
 \tsvar{icmp}.\tsunknown{t} \;\in  \{ \tsunknown{ICMP\_PARAMPROB} \;\tsunknown{c} \mid  \tsunknown{c} \;\in  \{\tsunknown{BADHDR}; \tsunknown{NEEDOPT}\} \} \Mvee {}\\{}
 \tsvar{icmp}.\tsunknown{t} = \tsunknown{ICMP\_SOURCE\_QUENCH} \;\tsunknown{QUENCH}) \Mwedge {}\\{}
 (\Mif  \exists \tsvar{icmpmtu}. \tsvar{icmp}.\tsunknown{t} = \tsunknown{ICMP\_UNREACH} (\tsunknown{NEEDFRAG} \;\tsvar{icmpmtu}) \Mthen {}\\{}
\quad\quad \exists \tsvar{i}_{3}. \tsvar{icmp}.\tsunknown{is3} = \Msome  \;\tsvar{i}_{3} \Mwedge  \tsvar{i}_{3} \;\in  \;\tsunknown{IN\_MULTICAST}{}\\{}
 \Melse {}\\{}
\quad\quad (\tsvar{icmp}.\tsunknown{is3} = * \Mvee {}\\{}
\quad\quad\quad \tsholop{THE} \;\tsvar{icmp}.\tsunknown{is3} \;\in  \;\tsunknown{IN\_MULTICAST} \Mvee {}\\{}
\quad\quad\quad \neg{}(\exists (\tsunknown{sid},\tsunknown{s}) \Mcons  (\tsvar{h}.\tsvar{socks}).{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{1} = \tsvar{icmp}.\tsunknown{is3} \Mwedge  \tsunknown{s}.\tsvar{is}_{2} = \tsvar{icmp}.\tsunknown{is4} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsunknown{s}.\tsvar{ps}_{1} = \tsvar{icmp}.\tsunknown{ps3} \Mwedge  \tsunknown{s}.\tsvar{ps}_{2} = \tsvar{icmp}.\tsunknown{ps4} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{proto\_of} \;\tsunknown{s}.\tsvar{pr} = \tsvar{icmp}.\tsunknown{proto})))}
{\rulesubsection{Description}
   If the ICMP is a type we handle, but the source IP is $\tsunknown{IP} \;0 \;0 \;0
0$ or a multicast address, or there's no matching socket, then
   drop silently.  $\tsunknown{ICMP\_UNREACH} \;\tsunknown{NEEDFRAG}$ is handled specially,
   since we do not care if it's $\tsunknown{IP} \;0 \;0 \;0 \;0$, only if it's multicast.

\rrulepad }
}

\newcommand{\chapcommnetworkTinputTandToutput}{\chaptersection{ Host LTS: Network Input and Output}
\label{network_input_and_output}%
\chapcomm{}
}

\newcommand{\seccommnetworkTinputTandToutputTsection}{\clustersection{(Network only)}{Input and Output}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{deliver\_in\_99}$
& \textbf{all: network nonurgent}
&  Really receive things \\
$\tsrule{deliver\_in\_99a}$
& \textbf{all: network nonurgent}
&  Ignore things not for us \\
$\tsrule{deliver\_out\_99}$
& \textbf{all: network nonurgent}
&  Really send things \\
$\tsrule{deliver\_loop\_99}$
& \textbf{all: network nonurgent}
&  Loop back a loopback message \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\deliverTinTXCIX}{\rrulecc{deliverTinTXCIX}{deliver\_in\_99}{all: network nonurgent}{\tsholcomm{ Really receive things }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \tsvar{lbl} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec ,\tsvar{S},\tsvar{M}')}
{( \tsvar{lbl} = \MLhtau  \Mwedge  {}\\{}
\quad \tsvar{M}' = \tsvar{M} \Mwedge {}\\{}
\quad (\exists  \tsvar{q} \;\tsvar{d} \;\tsvar{q}' \;\tsvar{d}' \;\tsunknown{tcp\_segment}.{}\\{}
\quad\quad \tsvar{iq} = \Mtimed{\tsvar{q}}{\tsvar{d}} \Mwedge {}\\{}
\quad\quad \tsvar{iq}' = \Mtimed{\tsvar{q}}{\tsvar{d}'} \Mwedge  {}\\{}
\quad\quad \tsunknown{enqueue\_iq}(\tsvar{iq},\tsunknown{TCP} \;\tsunknown{tcp\_segment},\Mtimed{\tsvar{q}'}{\tsvar{d}'},\tsvar{queued}))){}\\{}
 \Mvee {}\\{}
 ( \tsvar{lbl} = \MLhrecvdatagram{\tsvar{msg}} \Mwedge {}\\{}
\quad \tsvar{M} = \tsunknown{BAG\_INSERT} \;\tsvar{msg} \;\tsvar{M}' \Mwedge {}\\{}
\quad \tsunknown{sane\_msg} \;\tsvar{msg} \Mwedge {}\\{}
\quad \Msome  \;\tsvar{i}_{1} = \tsvar{msg}.\tsvar{is}_{2} \Mwedge {}\\{}
\quad \tsvar{i}_{1} \;\in  \;\tsunknown{local\_ips}(\tsvar{h}.\tsvar{ifds}) \Mwedge {}\\{}
\quad \tsunknown{enqueue\_iq}(\tsvar{iq},\tsvar{msg},\tsvar{iq}',\tsvar{queued}))}
{\rulesubsection{Description}
     Actually receive a message from the wire into the input queue.
     Note that if it cannot be queued (because the queue is full), it is
     silently dropped.

     We only accept messages that are for this host.  We also assert that any message we receive is
     well-formed (this excludes elements of type $\tsvar{msg}$ that have no physical realisation).

     Note the delay in in-queuing the datagram is not modelled here.

\rrulepad }
}

\newcommand{\deliverTinTXCIXa}{\rrulecc{deliverTinTXCIXa}{deliver\_in\_99a}{all: network nonurgent}{\tsholcomm{ Ignore things not for us }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec ,\tsvar{S},\tsunknown{BAG\_INSERT} \;\tsvar{msg} \;\tsvar{M})}
{\Mtransition{ \MLhrecvdatagram{\tsvar{msg}} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec ,\tsvar{S},\tsunknown{BAG\_INSERT} \;\tsvar{msg} \;\tsvar{M})}
{\Msome  \;\tsvar{i}_{1} = \tsvar{msg}.\tsvar{is}_{2} \Mwedge {}\\{}
 \tsvar{i}_{1} \;\notin  \;\tsunknown{local\_ips}(\tsvar{h}.\tsvar{ifds}) \Mwedge {}\\{}
 \tsvar{iq} = \tsvar{iq}'}
{\rulesubsection{Description}
     Do not accept messages that are not for this host.


\rrulepad }
}

\newcommand{\deliverToutTXCIX}{\rrulecc{deliverToutTXCIX}{deliver\_out\_99}{all: network nonurgent}{\tsholcomm{ Really send things }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \tsvar{lbl} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,\tsvar{S},\tsvar{M}')}
{( \tsvar{lbl} = \MLhtau  \Mwedge  {}\\{}
\quad \tsvar{M}' = \tsvar{M} \Mwedge {}\\{}
\quad {}\\{}
\quad (\exists  \tsvar{q} \;\tsvar{d} \;\tsunknown{tcp\_segment}.{}\\{}
\quad\quad \tsvar{oq} = \Mtimed{\tsvar{q}}{\tsvar{d}} \Mwedge {}\\{}
\quad\quad \tsunknown{dequeue\_oq}(\Mtimed{\tsunknown{TCP} \;\tsunknown{tcp\_segment}\Mcons \tsvar{q}}{\tsvar{d}},\tsvar{oq}',\Msome  (\tsunknown{TCP} \;\tsunknown{tcp\_segment})))){}\\{}
 \Mvee {}\\{}
 ( \tsvar{lbl} = \MLhsenddatagram{\tsvar{msg}} \Mwedge {}\\{}
\quad \tsvar{M}' = \tsunknown{BAG\_INSERT} \;\tsvar{msg} \;\tsvar{M} \Mwedge {}\\{}
\quad \tsunknown{dequeue\_oq}(\tsvar{oq},\tsvar{oq}',\Msome  \;\tsvar{msg}) \Mwedge {}\\{}
\quad (\exists \tsvar{i}_{2}. \tsvar{msg}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{i}_{2} \;\notin  \;\tsunknown{local\_ips} \;\tsvar{h}.\tsvar{ifds}))}
{\rulesubsection{Description}
     Actually emit a segment from the output queue.

     Note the delay in dequeuing the datagram is not modelled here.


\rrulepad }
}

\newcommand{\deliverTloopTXCIX}{\rrulecc{deliverTloopTXCIX}{deliver\_loop\_99}{all: network nonurgent}{\tsholcomm{ Loop back a loopback message }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{\Mtransition{ \tsvar{lbl} }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}';{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec ,{}\\{}
 \tsvar{S},\tsvar{M})}
{( \tsvar{lbl} = \MLhtau  \Mwedge  {}\\{}
\quad {}\\{}
\quad (\exists  \tsvar{q} \;\tsvar{d} \;\tsunknown{tcp\_segment}.{}\\{}
\quad\quad \tsvar{oq} = \Mtimed{\tsvar{q}}{\tsvar{d}} \Mwedge {}\\{}
\quad\quad \tsunknown{dequeue\_oq}(\Mtimed{\tsunknown{TCP} \;\tsunknown{tcp\_segment}\Mcons \tsvar{q}}{\tsvar{d}},\tsvar{oq}',\Msome  (\tsunknown{TCP} \;\tsunknown{tcp\_segment}))) \Mwedge {}\\{}
\quad {}\\{}
\quad (\exists  \tsvar{q} \;\tsvar{d} \;\tsvar{q}' \;\tsvar{d}' \;\tsunknown{tcp\_segment}.{}\\{}
\quad\quad \tsvar{iq} = \Mtimed{\tsvar{q}}{\tsvar{d}} \Mwedge {}\\{}
\quad\quad \tsvar{iq}' = \Mtimed{\tsvar{q}}{\tsvar{d}'} \Mwedge  {}\\{}
\quad\quad \tsunknown{enqueue\_iq}(\tsvar{iq},\tsunknown{TCP} \;\tsunknown{tcp\_segment},\Mtimed{\tsvar{q}'}{\tsvar{d}'},\tsvar{queued}))){}\\{}
 \Mvee {}\\{}
 ( \tsunknown{dequeue\_oq}(\tsvar{oq},\tsvar{oq}',\Msome  \;\tsvar{msg}) \Mwedge {}\\{}
\quad (\exists \tsvar{i}_{2}. \tsvar{msg}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{i}_{2} \;\in  \;\tsunknown{local\_ips} \;\tsvar{h}.\tsvar{ifds}) \Mwedge {}\\{}
\quad (\tsvar{lbl} = \Mif  \;\tsunknown{windows\_arch} \;\tsvar{h}.\tsvar{arch} \;\Mthen  \;\MLhtau {}\\{}
\quad\quad\quad\quad \Melse  \MLhloopdatagram{\tsvar{msg}}) \Mwedge {}\\{}
\quad \tsunknown{enqueue\_iq}(\tsvar{iq},\tsvar{msg},\tsvar{iq}',\tsvar{queued}))}
{\rulesubsection{Description}
     Deliver a loopback message (for loopback address, or any of our
     addresses) from the outqueue to the inqueue.  (if we tagged each
     message in the outqueue with its interface, we'd just pick
     loopback-interface segments, but we do not, so we just discriminate
     on IP addresses).


\rrulepad }
}

\newcommand{\chapcommtraceTandTinterface}{\chaptersection{ Host LTS:  BSD Trace Records and Interface State Changes}
\label{trace_and_interface}%
\chapcomm{}
}

\newcommand{\seccommtraceTandTinterfaceTsection}{\clustersection{(BSD only)}{Trace Records and Interface State Changes}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{trace\_1}$
& \textbf{all: misc nonurgent}
&  Trace TCPCB state, $\tscon{ESTABLISHED}$ or later \\
$\tsrule{trace\_2}$
& \textbf{all: misc nonurgent}
&  Trace TCPCB state, pre-$\tscon{ESTABLISHED}$ \\
$\tsrule{interface\_1}$
& \textbf{all: misc nonurgent}
&  Change connectivity \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\traceTI}{\rrulecc{traceTI}{trace\_1}{all: misc nonurgent}{\tsholcomm{ Trace TCPCB state, $\tscon{ESTABLISHED}$ or later }}
{(\tsvar{h},\tsvar{S},\tsvar{M})}
{\Mtransition{ \tscon{Lh\_trace} \;\tsvar{tr} }{1}}
{(\tsvar{h},\tsvar{S},\tsvar{M})}
{\tsvar{sid} \;\in  \Mfdom{\tsvar{h}.\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{tr} = (\tsvar{flav},\tsvar{sid},\tsvar{quad},\tsvar{st},\tsvar{cb}) \Mwedge {}\\{}
 \tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}; \tscon{CLOSING};{}\\{}
\quad\quad\quad \tscon{CLOSE\_WAIT}; \tscon{LAST\_ACK}; \tscon{TIME\_WAIT}\} \Mwedge {}\\{}
 \tsaux{tracesock\_eq} \;\tsvar{tr} \;\tsvar{sid} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}})}
{\rulesubsection{Description}
     This rule exposes certain of the fields of the socket and TCPCB, to
     allow open-box testing.

     Note that although the label carries an entire TCPCB, only certain
     selected fields are constrained to be equal to the actual TCPCB.
     See \ltslink{tracesockTeq}{$\tsaux{tracesock\_eq}$} and \ltslink{tracecbTeq}{$\tsaux{tracecb\_eq}$} for
     details.

     Checking trace equality is problematic as BSD generates trace records that
     fall logically inbetween the atomic transitions in this model. This happens
     frequently when in a state before $\tscon{ESTABLISHED}$. We only check for equality
     when we are in $ \tscon{ESTABLISHED}$ or later states.


\rrulepad }
}

\newcommand{\traceTII}{\rrulecn{traceTII}{trace\_2}{all: misc nonurgent}{\tsholcomm{ Trace TCPCB state, pre-$\tscon{ESTABLISHED}$ }}
{(\tsvar{h},\tsvar{S},\tsvar{M})}
{\Mtransition{ \tscon{Lh\_trace} \;\tsvar{tr} }{1}}
{(\tsvar{h},\tsvar{S},\tsvar{M})}
{\tsvar{sid} \;\in  \Mfdom{\tsvar{h}.\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{tr} = (\tsvar{flav},\tsvar{sid},\tsvar{quad},\tsvar{st},\tsvar{cb}) \Mwedge {}\\{}
 \tsvar{st} \;\notin  \{\tscon{ESTABLISHED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}; \tscon{CLOSING};{}\\{}
\quad\quad\quad\quad\quad \tscon{CLOSE\_WAIT}; \tscon{LAST\_ACK}; \tscon{TIME\_WAIT}\} \Mwedge {}\\{}
 (\tsvar{st} = \tscon{CLOSED} \Mvee   \tsholcomm{ BSD emits one of these each time a tcpcb is created, eg at end of 3WHS }{}\\{}
 ((\exists \tsvar{sock} \;\tsunknown{tcp\_sock}.{}\\{}
\quad \tsvar{sock} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}) \Mwedge {}\\{}
\quad \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tsunknown{PROTO\_TCP} \Mwedge {}\\{}
\quad \tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsvar{sock} \Mwedge {}\\{}
\quad (\Mcase  \;\tsvar{quad} \;\Mof {}\\{}
\quad\quad \Msome  (\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}) \Mtotype  \Mif  \;\tsvar{flav} = \tscon{TA\_DROP} \Mvee  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSED} \;\Mthen  \;\Mtrue {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{is}_{1} = \tsvar{sock}.\tsvar{is}_{1} \Mwedge  \tsvar{ps}_{1} = \tsvar{sock}.\tsvar{ps}_{1} \Mwedge  \tsvar{is}_{2} = \tsvar{sock}.\tsvar{is}_{2} \Mwedge  \tsvar{ps}_{2} = \tsvar{sock}.\tsvar{ps}_{2} \Mdpipe {}\\{}
\quad\quad *                   \Mtotype  \Mtrue ) \Mwedge {}\\{}
\quad (\tsvar{st}  = \tsunknown{tcp\_sock}.\tsvar{st} \Mvee  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSED}))))}
{}
}

\newcommand{\interfaceTI}{\rrulecc{interfaceTI}{interface\_1}{all: misc nonurgent}{\tsholcomm{ Change connectivity }}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ifds} \Mass  \tsvar{ifds} \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\Mtransition{ \tscon{Lh\_interface} (\tsvar{ifid},\tsvar{up}) }{1}}
{(\tsvar{h} \; \Mmagiclrec  \tsvar{ifds} \Mass  \tsvar{ifds}' \Mmagicrrec ,\tsvar{S},\tsvar{M})}
{\tsvar{ifid} \;\in  \Mfdom{\tsvar{ifds}} \Mwedge {}\\{}
 \tsvar{ifds}' = \tsvar{ifds} \oplus  (\tsvar{ifid}, (\tsvar{ifds} \Mfapply{}{\tsvar{ifid}})  \Mmagiclrec  \tsvar{up} \Mass  \tsvar{up} \Mmagicrrec )}
{\rulesubsection{Description}
     Allow interfaces to be externally brought up or taken down.


\rrulepad }
}

\newcommand{\chapcommtimeTpassage}{\chaptersection{ Host LTS:  Time Passage}
\label{time_passage}%
\chapcomm{}
}

\newcommand{\seccommtimeTpassageTauxsTsection}{\clustersection{(TCP and UDP)}{Time Passage auxiliaries}
\seccomm{
   Time passage is a \emph{function}, completely deterministic.
   Any nondeterminism must occur as a result of a tau
   (or other) transition.

   In the present semantics, time passage merely:
     \begin{enumerate}
     \item decrements all timers uniformly

     \item prevents time passage if a timer reaches zero

     \item prevents time passage if an urgent action is
        enabled.
     \end{enumerate}
   We model the first two points with functions $\tsunknown{Time\_Pass\_}*$, for various types
   $*$.  These functions return an option type: if the result is NONE then
   time may not pass for the given duration.  Essentially they pick out everything in a host state of type $\tsunknown{'a} \;\tsunknown{timed}$, and do something with it.

   We treat the last point in the rule \ltslink{epsilonTI}{$\tsunknown{epsilon\_1}$} itself, below.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{Time\_Pass\_timedoption}$
&
&  time passes for an $\tsunknown{'a} \;\tsunknown{timed} \;\;\tstype{option}$ value \\
$\tsrule{Time\_Pass\_tcpcb}$
&
&  time passes for a tcp control block \\
$\tsrule{Time\_Pass\_socket}$
&
&  time passes for a socket \\
$\tsrule{fmap\_every}$
&
&  apply $\tsunknown{f}$ to range of finite map, and succeed if each application succeeds \\
$\tsrule{fmap\_every\_pred}$
&
&  apply $\tsunknown{f}$ to range of finite map, and succeed if each application succeeds \\
$\tsrule{Time\_Pass\_host}$
&
&  time passes for a host \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnTimeTPassTtimedoption}{\ddefnn{TimeTPassTtimedoption}{\iA{Time\_Pass\_timedoption}}{\subddefnA[{ time passes for an $\tsunknown{'a} \;\tsunknown{timed} \;\;\tstype{option}$ value }]{Time\_Pass\_timedoption}{(\tsaux{Time\_Pass\_timedoption} : \tsunknown{duration} \Mtotype  \tsunknown{'a} \;\tsunknown{timed} \;\;\tstype{option} \Mtotype  \tsunknown{'a} \;\tsunknown{timed} \;\;\tstype{option} \;\;\tstype{option}){}\\{}
 \tsunknown{dur} \;\tsunknown{x0}{}\\{}
 = \Mcase  \;\tsunknown{x0} \;\Mof {}\\{}
\quad *   \Mtotype  \Msome  \;* \Mdpipe {}\\{}
\quad \Msome  \;\tsunknown{x} \Mtotype  (\Mcase  \;\tsunknown{Time\_Pass\_timed} \;\tsunknown{dur} \;\tsunknown{x} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad * \Mtotype  * \Mdpipe {}\\{}
\quad\quad\quad\quad\quad\quad\quad \Msome  \;\tsunknown{x0'} \Mtotype  \Msome  (\Msome  \;\tsunknown{x0'}))}
}
{}
}

\newcommand{\defnTimeTPassTtcpcb}{\ddefnn{TimeTPassTtcpcb}{\iA{Time\_Pass\_tcpcb}}{\subddefnA[{ time passes for a tcp control block }]{Time\_Pass\_tcpcb}{(\tsaux{Time\_Pass\_tcpcb} : \tsunknown{duration} \Mtotype  \tstype{tcpcb} \Mtotype  \tstype{tcpcb} \;\tstype{set} \;\;\tstype{option})  \tscomm{ recall: 'a set == 'a -\textgreater{} bool }{}\\{}
 \tsunknown{dur} \;\tsvar{cb}{}\\{}
 = \Mlet  \;\tsunknown{tt\_keep'}      = \tsaux{Time\_Pass\_timedoption} \;\tsunknown{dur} \;\tsvar{cb}.\tsfield{tt\_keep}{}\\{}
 \Min {}\\{}
 \Mif  \;\tsholop{IS\_SOME} \;\tsunknown{tt\_keep'}{}\\{}
 \Mthen {}\\{}
\quad \Msome  (\lambda \tsvar{cb}'.{}\\{}
\quad\quad\quad\quad \tsvar{cb}' ={}\\{}
\quad\quad\quad\quad \tsvar{cb} \; \Mmagiclrec  \tscomm{ not going to list everything here; too much! }{}\\{}
 \tsfield{tt\_keep}       \Mass  \tsholop{THE} \;\tsunknown{tt\_keep'}{}\\{}
 \Mmagicbolrrec ){}\\{}
 \Melse {}\\{}
\quad *}
}
{}
}

\newcommand{\defnTimeTPassTsocket}{\ddefnn{TimeTPassTsocket}{\iA{Time\_Pass\_socket}}{\subddefnA[{ time passes for a socket }]{Time\_Pass\_socket}{(\tsaux{Time\_Pass\_socket} : \tsunknown{duration} \Mtotype  \tstype{socket} \Mtotype  \tstype{socket} \;\tstype{set} \;\;\tstype{option}){}\\{}
 \tsunknown{dur} \;\tsunknown{s}{}\\{}
 = \Mcase  \;\tsunknown{s}.\tsvar{pr} \;\Mof  \;\tscon{UDP\_PROTO}(\tsunknown{udp}) \Mtotype  \Msome  \{ \tsunknown{s} \}{}\\{}
 \Mdpipe  \tscon{TCP\_PROTO}(\tsunknown{tcp\_s}) \Mtotype {}\\{}
\quad \Mlet  \;\tsunknown{cb's} = \tsaux{Time\_Pass\_tcpcb} \;\tsunknown{dur} \;\tsunknown{tcp\_s}.\tsvar{cb}{}\\{}
\quad \Min {}\\{}
\quad \Mif  \;\tsholop{IS\_SOME} \;\tsunknown{cb's}{}\\{}
\quad \Mthen {}\\{}
\quad\quad \Msome  (\lambda \tsvar{s}'.{}\\{}
\quad\quad\quad\quad\quad \tsholop{choose} \;\tsvar{cb}' \Mcons  \tsholop{THE} \;\tsunknown{cb's}.{}\\{}
\quad\quad\quad\quad\quad \tsvar{s}' ={}\\{}
\quad\quad\quad\quad\quad \tsunknown{s} \; \Mmagiclrec  \tscomm{ fid unchanged }{}\\{}
 \tscomm{ sf unchanged }{}\\{}
 \tscomm{ is1,ps1,is2,ps2 unchanged }{}\\{}
 \tscomm{ es unchanged }{}\\{}
 \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_s} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}' \Mmagicrrec ){}\\{}
 \Mmagicbolrrec ){}\\{}
\quad \Melse {}\\{}
\quad\quad *}
}
{}
}

\newcommand{\defnfmapTevery}{\ddefnn{fmapTevery}{\iA{fmap\_every}}{\subddefnA[{ apply $\tsunknown{f}$ to range of finite map, and succeed if each application succeeds }]{fmap\_every}{(\tsaux{fmap\_every} : (\tsunknown{'a} \Mtotype  \tsunknown{'b} \;\;\tstype{option}) \Mtotype  (\tsunknown{'c} \mapsto  \tsunknown{'a}) \Mtotype  (\tsunknown{'c} \mapsto  \tsunknown{'b}) \;\tstype{option}){}\\{}
\quad\quad\quad\quad \tsunknown{f} \;\tsunknown{fm} ={}\\{}
 \Mlet  \;\tsunknown{fm'} = \tsunknown{f} \;\tsunknown{o\_f} \;\tsunknown{fm}{}\\{}
 \Min {}\\{}
 \Mif  \;* \;\in  \Mfrange{\tsunknown{fm'}}{}\\{}
 \Mthen  \;*{}\\{}
 \Melse  \;\Msome  (\tsholop{THE} \;\tsunknown{o\_f} \;\tsunknown{fm'})}
}
{}
}

\newcommand{\defnfmapTeveryTpred}{\ddefnn{fmapTeveryTpred}{\iA{fmap\_every\_pred}}{\subddefnA[{ apply $\tsunknown{f}$ to range of finite map, and succeed if each application succeeds }]{fmap\_every\_pred}{(\tsaux{fmap\_every\_pred} : (\tsunknown{'a} \Mtotype  \tsunknown{'b} \;\tstype{set} \;\;\tstype{option}) \Mtotype  (\tsunknown{'c} \mapsto  \tsunknown{'a}) \Mtotype  (\tsunknown{'c} \mapsto  \tsunknown{'b}) \tstype{set} \;\;\tstype{option}){}\\{}
\quad\quad\quad\quad \tsunknown{f} \;\tsunknown{fm} ={}\\{}
 \Mif  \exists \tsvar{y}. \tsvar{y} \;\in  \Mfrange{\tsunknown{fm}} \Mwedge  \tsunknown{f} \;\tsvar{y} = * \;\Mthen {}\\{}
\quad *{}\\{}
 \Melse {}\\{}
\quad \Msome  \{ \tsunknown{fm'} \mid  \Mfdom{\tsunknown{fm}} = \Mfdom{\tsunknown{fm'}} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \forall \tsvar{x}. \tsvar{x} \;\in  \Mfdom{\tsunknown{fm}} \implies  \tsunknown{fm'} \Mfapply{}{\tsvar{x}} \in  (\tsholop{THE} (\tsunknown{f} (\tsunknown{fm} \Mfapply{}{\tsvar{x}}))) \}}
}
{}
}

\newcommand{\defnTimeTPassThost}{\ddefnn{TimeTPassThost}{\iA{Time\_Pass\_host}}{\subddefnA[{ time passes for a host }]{Time\_Pass\_host}{(\tsaux{Time\_Pass\_host} : \tsunknown{duration} \Mtotype  \tstype{host} \Mtotype  \tstype{host} \;\tstype{set} \;\;\tstype{option}){}\\{}
 \tsunknown{dur} \;\tsunknown{h}{}\\{}
 = \Mlet  \;\tsvar{ts}'     = \tsaux{fmap\_every} (\tsunknown{Time\_Pass\_timed} \;\tsunknown{dur}) \tsunknown{h}.\tsvar{ts}{}\\{}
 \Mand  \;\tsunknown{socks's} = \tsaux{fmap\_every\_pred} (\tsaux{Time\_Pass\_socket} \;\tsunknown{dur}) \tsunknown{h}.\tsvar{socks}{}\\{}
 \Mand  \;\tsvar{iq}'     = \tsunknown{Time\_Pass\_timed} \;\tsunknown{dur} \;\tsunknown{h}.\tsvar{iq}{}\\{}
 \Mand  \;\tsvar{oq}'     = \tsunknown{Time\_Pass\_timed} \;\tsunknown{dur} \;\tsunknown{h}.\tsvar{oq}{}\\{}
 \Mand  \;\tsunknown{ticks's} = \tsunknown{Time\_Pass\_ticker} \;\tsunknown{dur} \;\tsunknown{h}.\tsvar{ticks}{}\\{}
 \Min {}\\{}
 \Mif  \;\tsholop{IS\_SOME} \;\tsvar{ts}' \Mwedge {}\\{}
\quad \tsholop{IS\_SOME} \;\tsunknown{socks's} \Mwedge {}\\{}
\quad \tsholop{IS\_SOME} \;\tsvar{iq}' \Mwedge {}\\{}
\quad \tsholop{IS\_SOME} \;\tsvar{oq}'{}\\{}
 \Mthen {}\\{}
\quad \Msome  (\lambda \tsvar{h}'.{}\\{}
\quad\quad\quad\quad \tsholop{choose} \;\tsvar{socks}' \Mcons  \tsholop{THE} \;\tsunknown{socks's}.{}\\{}
\quad\quad\quad\quad \tsholop{choose} \;\tsvar{ticks}' \Mcons  \tsunknown{ticks's}.{}\\{}
\quad\quad\quad\quad \tsvar{h}' ={}\\{}
\quad\quad\quad\quad \tsunknown{h} \; \Mmagiclrec  \tscomm{ arch unchanged }{}\\{}
 \tscomm{ ifds unchanged }{}\\{}
 \tsvar{ts} \Mass  \tsholop{THE} \;\tsvar{ts}';{}\\{}
 \tscomm{ files unchanged }{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks}';{}\\{}
 \tscomm{ listen unchanged }{}\\{}
 \tscomm{ bound unchanged }{}\\{}
 \tsvar{iq} \Mass  \tsholop{THE} \;\tsvar{iq}';{}\\{}
 \tsvar{oq} \Mass  \tsholop{THE} \;\tsvar{oq}';{}\\{}
 \tsvar{ticks} \Mass  \tsvar{ticks}'{}\\{}
 \tscomm{ fds unchanged }{}\\{}
 \Mmagicbolrrec ){}\\{}
 \Melse {}\\{}
\quad *}
}
{}
}

\newcommand{\seccommtimeTpassageTsection}{\clustersection{(TCP and UDP)}{Host transitions with time}
\seccomm{
We now build the relation $\Mtransition{ }{2XXXXX\Mtransitionerr{--=>}}$, which includes time transitions, from the relation $\Mtransition{ }{1XXXXX\Mtransitionerr{-->}}$,
which is instantaneous.  This avoids circularity (or at best inductiveness) in the definition of
the transition relation.


}\clustersubsection{Rules}
~}

\newcommand{\dumpallrules}{
\showrule{\chapcommprelimChapFIXME}
\showrule{\seccommpreliminaryFIXME}
\showrule{\defnsoreadable}
\showrule{\defnsowriteable}
\showrule{\chapcommsocketTcalls}
\showrule{\seccommaccept}
\showrule{\acceptTI}
\showrule{\acceptTII}
\showrule{\acceptTIII}
\showrule{\acceptTIV}
\showrule{\acceptTV}
\showrule{\acceptTVI}
\showrule{\acceptTVII}
\showrule{\seccommbind}
\showrule{\bindTI}
\showrule{\bindTII}
\showrule{\bindTIII}
\showrule{\bindTV}
\showrule{\bindTVII}
\showrule{\bindTIX}
\showrule{\seccommclose}
\showrule{\closeTI}
\showrule{\closeTII}
\showrule{\closeTIII}
\showrule{\closeTIV}
\showrule{\closeTV}
\showrule{\closeTVI}
\showrule{\closeTVII}
\showrule{\closeTVIII}
\showrule{\closeTX}
\showrule{\seccommconnect}
\showrule{\connectTI}
\showrule{\connectTIa}
\showrule{\connectTII}
\showrule{\connectTIII}
\showrule{\connectTIV}
\showrule{\connectTIVa}
\showrule{\connectTV}
\showrule{\connectTVa}
\showrule{\connectTVb}
\showrule{\connectTVc}
\showrule{\connectTVd}
\showrule{\connectTVI}
\showrule{\connectTVII}
\showrule{\connectTVIII}
\showrule{\connectTIX}
\showrule{\connectTX}
\showrule{\seccommdisconnect}
\showrule{\disconnectTIV}
\showrule{\disconnectTV}
\showrule{\disconnectTI}
\showrule{\disconnectTII}
\showrule{\disconnectTIII}
\showrule{\seccommdup}
\showrule{\dupTI}
\showrule{\dupTII}
\showrule{\seccommdupfd}
\showrule{\dupfdTI}
\showrule{\dupfdTIII}
\showrule{\dupfdTIV}
\showrule{\seccommgetfileflags}
\showrule{\getfileflagsTI}
\showrule{\seccommgetifaddrs}
\showrule{\getifaddrsTI}
\showrule{\seccommgetpeername}
\showrule{\getpeernameTI}
\showrule{\getpeernameTII}
\showrule{\seccommgetsockbopt}
\showrule{\getsockboptTI}
\showrule{\getsockboptTII}
\showrule{\seccommgetsockerr}
\showrule{\getsockerrTI}
\showrule{\getsockerrTII}
\showrule{\seccommgetsocklistening}
\showrule{\getsocklisteningTI}
\showrule{\getsocklisteningTIII}
\showrule{\getsocklisteningTII}
\showrule{\seccommgetsockname}
\showrule{\getsocknameTI}
\showrule{\getsocknameTII}
\showrule{\getsocknameTIII}
\showrule{\seccommgetsocknopt}
\showrule{\getsocknoptTI}
\showrule{\getsocknoptTIV}
\showrule{\seccommgetsocktopt}
\showrule{\getsocktoptTI}
\showrule{\getsocktoptTIV}
\showrule{\seccommlisten}
\showrule{\listenTI}
\showrule{\listenTIb}
\showrule{\listenTIc}
\showrule{\listenTII}
\showrule{\listenTIII}
\showrule{\listenTIV}
\showrule{\listenTV}
\showrule{\listenTVII}
\showrule{\seccommtcpTrecv}
\showrule{\recvTI}
\showrule{\recvTII}
\showrule{\recvTIII}
\showrule{\recvTIV}
\showrule{\recvTVII}
\showrule{\recvTVIII}
\showrule{\recvTVIIIa}
\showrule{\recvTIX}
\showrule{\seccommudpTrecv}
\showrule{\recvTXI}
\showrule{\recvTXII}
\showrule{\recvTXIII}
\showrule{\recvTXIV}
\showrule{\recvTXV}
\showrule{\recvTXVI}
\showrule{\recvTXVII}
\showrule{\recvTXX}
\showrule{\recvTXXI}
\showrule{\recvTXXII}
\showrule{\recvTXXIII}
\showrule{\recvTXXIV}
\showrule{\seccommtcpTsend}
\showrule{\sendTI}
\showrule{\sendTII}
\showrule{\sendTIII}
\showrule{\sendTIIIa}
\showrule{\sendTIV}
\showrule{\sendTV}
\showrule{\sendTVa}
\showrule{\sendTVI}
\showrule{\sendTVII}
\showrule{\sendTVIII}
\showrule{\seccommudpTsend}
\showrule{\sendTIX}
\showrule{\sendTX}
\showrule{\sendTXI}
\showrule{\sendTXII}
\showrule{\sendTXIII}
\showrule{\sendTXIV}
\showrule{\sendTXV}
\showrule{\sendTXVI}
\showrule{\sendTXVII}
\showrule{\sendTXVIII}
\showrule{\sendTXIX}
\showrule{\sendTXXI}
\showrule{\sendTXXII}
\showrule{\sendTXXIII}
\showrule{\seccommsetfileflags}
\showrule{\setfileflagsTI}
\showrule{\seccommsetsockbopt}
\showrule{\setsockboptTI}
\showrule{\setsockboptTII}
\showrule{\seccommsetsocknopt}
\showrule{\setsocknoptTI}
\showrule{\setsocknoptTII}
\showrule{\setsocknoptTIV}
\showrule{\seccommsetsocktopt}
\showrule{\setsocktoptTI}
\showrule{\setsocktoptTIV}
\showrule{\setsocktoptTV}
\showrule{\seccommshutdown}
\showrule{\shutdownTI}
\showrule{\shutdownTII}
\showrule{\shutdownTIII}
\showrule{\shutdownTIV}
\showrule{\seccommsocket}
\showrule{\socketTI}
\showrule{\socketTII}
\showrule{\seccommmisc}
\showrule{\returnTI}
\showrule{\badfTI}
\showrule{\notsockTI}
\showrule{\intrTI}
\showrule{\resourcefailTI}
\showrule{\resourcefailTII}
\showrule{\chapcommtcpTinputTprocessing}
\showrule{\seccommtcpTinputTprocessing}
\showrule{\deliverTinTI}
\showrule{\deliverTinTII}
\showrule{\deliverTinTIII}
\showrule{\defndiIIITtopstuff}
\showrule{\defndiIIITnewackstuff}
\showrule{\defndiIIITackstuff}
\showrule{\defndiIIITdatastuff}
\showrule{\defnT}
\showrule{\defndiIIITsocksTupdate}
\showrule{\deliverTinTIIIb}
\showrule{\deliverTinTIV}
\showrule{\deliverTinTV}
\showrule{\deliverTinTVII}
\showrule{\deliverTinTVIIa}
\showrule{\deliverTinTVIIb}
\showrule{\deliverTinTVIIc}
\showrule{\deliverTinTVIId}
\showrule{\deliverTinTVIII}
\showrule{\deliverTinTIX}
\showrule{\chapcommtcpToutput}
\showrule{\seccommtcpToutputTsection}
\showrule{\deliverToutTI}
\showrule{\chapcommtcpTtimers}
\showrule{\seccommtcpTtimersTsection}
\showrule{\timerTttTrexmtsynTI}
\showrule{\timerTttTrexmtTI}
\showrule{\timerTttTpersistTI}
\showrule{\timerTttTkeepTI}
\showrule{\timerTttTIImslTI}
\showrule{\timerTttTdelackTI}
\showrule{\timerTttTconnTestTI}
\showrule{\timerTttTfinTwaitTIITI}
\showrule{\chapcommudpTinputTprocessing}
\showrule{\seccommudpTinputTprocessingTsection}
\showrule{\deliverTinTudpTI}
\showrule{\deliverTinTudpTII}
\showrule{\deliverTinTudpTIII}
\showrule{\chapcommicmpTinputTprocessing}
\showrule{\seccommicmpTinputTprocessingTsection}
\showrule{\deliverTinTicmpTI}
\showrule{\deliverTinTicmpTII}
\showrule{\deliverTinTicmpTIII}
\showrule{\deliverTinTicmpTIV}
\showrule{\deliverTinTicmpTV}
\showrule{\deliverTinTicmpTVI}
\showrule{\deliverTinTicmpTVII}
\showrule{\chapcommnetworkTinputTandToutput}
\showrule{\seccommnetworkTinputTandToutputTsection}
\showrule{\deliverTinTXCIX}
\showrule{\deliverTinTXCIXa}
\showrule{\deliverToutTXCIX}
\showrule{\deliverTloopTXCIX}
\showrule{\chapcommtraceTandTinterface}
\showrule{\seccommtraceTandTinterfaceTsection}
\showrule{\traceTI}
\showrule{\traceTII}
\showrule{\interfaceTI}
\showrule{\chapcommtimeTpassage}
\showrule{\seccommtimeTpassageTauxsTsection}
\showrule{\defnTimeTPassTtimedoption}
\showrule{\defnTimeTPassTtcpcb}
\showrule{\defnTimeTPassTsocket}
\showrule{\defnfmapTevery}
\showrule{\defnfmapTeveryTpred}
\showrule{\defnTimeTPassThost}
\showrule{\seccommtimeTpassageTsection}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP3\protect\textunderscore stream

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: Spec3_alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPITstream}{\chaptersection{ Stream}
\label{TCP1_stream}%
\chapcomm{
This file defines streams. FIXME


}
}

\newcommand{\seccommTCPITstreamTinitial}{\clustersection{(TCP and UDP)}{FIXMe}
\seccomm{
Definitions for default starting values for previously defined types.

TODO3

}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{initial\_streamFlags}$
&
& \\
$\tsrule{initial\_stream}$
&
& \\
$\tsrule{initial\_streams}$
&
& \\
$\tsrule{streamid\_of\_quad}$
&
& \\
$\tsrule{null\_flgs\_data}$
&
& \\
$\tsrule{make\_syn\_flgs\_data}$
&
& \\
$\tsrule{make\_syn\_ack\_flgs\_data}$
&
& \\
$\tsrule{sync\_streams}$
&
& \\
$\tsrule{write}$
&
&  write flags and data to a stream \\
$\tsrule{read}$
&
& \\
$\tsrule{read'}$
&
& \\
$\tsrule{both\_streams\_destroyed}$
&
& \\
$\tsrule{remove\_destroyed\_streams}$
&
& \\
$\tsrule{destroy}$
&
& \\
$\tsrule{destroy\_quads}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defninitialTstreamFlags}{\ddefnn{initialTstreamFlags}{\iA{initial\_streamFlags}}{\subddefnA{initial\_streamFlags}{\tsaux{initial\_streamFlags} = \Mmagiclrec {}\\{}
 \tsvar{SYN} \Mass  \Mfalse ;{}\\{}
 \tsvar{SYNACK} \Mass  \Mfalse ;{}\\{}
 \tsvar{FIN} \Mass  \Mfalse ;{}\\{}
 \tsvar{RST} \Mass  \Mfalse {}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defninitialTstream}{\ddefnn{initialTstream}{\iA{initial\_stream}}{\subddefnA{initial\_stream}{\tsaux{initial\_stream} (\tsvar{i},\tsvar{p}) \tsvar{destroyed} = \Mmagiclrec {}\\{}
 \tsvar{i} \Mass  \tsvar{i};{}\\{}
 \tsvar{p} \Mass  \tsvar{p};{}\\{}
 \tsvar{flgs} \Mass  \tsaux{initial\_streamFlags};{}\\{}
 \tsvar{data} \Mass  [\,];{}\\{}
 \tsvar{destroyed} \Mass  \tsvar{destroyed}{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defninitialTstreams}{\ddefnn{initialTstreams}{\iA{initial\_streams}}{\subddefnA{initial\_streams}{\tsaux{initial\_streams} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) = ({}\\{}
\quad \tscomm{ in stream is initially destroyed because other host knows nothing of the connection attempt }{}\\{}
\quad \Mlet  \;\tsunknown{in\_} = \tsaux{initial\_stream} (\tsvar{i}_{2},\tsvar{p}_{2}) \Mtrue  \;\Min {}\\{}
\quad \Mlet  \;\tsunknown{out} = \tsaux{initial\_stream} (\tsvar{i}_{1},\tsvar{p}_{1}) \Mfalse  \;\Min {}\\{}
\quad \Mmagiclrec  \tsvar{streams} \Mass  \{\tsunknown{in\_};\tsunknown{out}\} \Mmagicrrec )}
}
{}
}

\newcommand{\defnstreamidTofTquad}{\ddefnn{streamidTofTquad}{\iA{streamid\_of\_quad}}{\subddefnA{streamid\_of\_quad}{\tsaux{streamid\_of\_quad} ((\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}):\tsunknown{ip}\#\tsunknown{port}\#\tsunknown{ip}\#\tsunknown{port}) = \{(\tsvar{i}_{1},\tsvar{p}_{1});(\tsvar{i}_{2},\tsvar{p}_{2})\}}
}
{}
}

\newcommand{\defnnullTflgsTdata}{\ddefnn{nullTflgsTdata}{\iA{null\_flgs\_data}}{\subddefnA{null\_flgs\_data}{\tsaux{null\_flgs\_data} (\tsvar{flgs},\tsvar{data}) = ({}\\{}
\quad \tsvar{flgs} = \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{FIN} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Mwedge {}\\{}
\quad \tsvar{data} = [\,])}
}
{}
}

\newcommand{\defnmakeTsynTflgsTdata}{\ddefnn{makeTsynTflgsTdata}{\iA{make\_syn\_flgs\_data}}{\subddefnA{make\_syn\_flgs\_data}{\tsaux{make\_syn\_flgs\_data} (\tsvar{flgs},\tsvar{data}:\tsunknown{char} \;\tstype{list}) = ({}\\{}
\quad \tsvar{flgs} = \Mmagiclrec  \tsvar{SYN} \Mass  \Mtrue ; \tsvar{SYNACK} \Mass  \Mfalse ; \tsvar{FIN} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Mwedge {}\\{}
\quad \tsvar{data} = [\,] \tscomm{ FIXME invariant assume SYNs wellformed via sockets API- otherwise use this only for sending SYN, receive data elsewhere })}
}
{}
}

\newcommand{\defnmakeTsynTackTflgsTdata}{\ddefnn{makeTsynTackTflgsTdata}{\iA{make\_syn\_ack\_flgs\_data}}{\subddefnA{make\_syn\_ack\_flgs\_data}{\tsaux{make\_syn\_ack\_flgs\_data} (\tsvar{flgs},\tsvar{data}:\tsunknown{char} \;\tstype{list}) = ({}\\{}
\quad \tsvar{flgs} = \Mmagiclrec  \tsvar{SYN} \Mass  \Mfalse ; \tsvar{SYNACK} \Mass  \Mtrue ; \tsvar{FIN} \Mass  \Mfalse ; \tsvar{RST} \Mass  \Mfalse  \Mmagicrrec  \Mwedge {}\\{}
\quad \tsvar{data} = [\,] ){}\\{}
 {}\\{}
 \tscomm{ FIXME invariant assume SYNACKs wellformed via sockets API- otherwise use this only for sending SYNACK, receive data elsewhere }}
}
{}
}

\newcommand{\defnsyncTstreams}{\ddefnn{syncTstreams}{\iA{sync\_streams}}{\subddefnA{sync\_streams}{\tsaux{sync\_streams} (\tsvar{i}_{1}:\tsunknown{ip},\tsvar{p}_{1}:\tsunknown{port},\tsvar{i}_{2}:\tsunknown{ip},\tsvar{p}_{2}:\tsunknown{port}) (\tsunknown{s}:\tstype{tcpStreams}) (\tsunknown{in\_},\tsunknown{out}) = ({}\\{}
\quad\quad \tsunknown{s}.\tsvar{streams} = \{\tsunknown{in\_}; \tsunknown{out}\} \Mwedge {}\\{}
\quad\quad (\tsunknown{in\_}.\tsvar{i},\tsunknown{in\_}.\tsvar{p}) = (\tsvar{i}_{2},\tsvar{p}_{2}) \Mwedge {}\\{}
\quad\quad (\tsunknown{out}.\tsvar{i},\tsunknown{out}.\tsvar{p}) = (\tsvar{i}_{1},\tsvar{p}_{1}) ){}\\{}
 {}\\{}
 \tscomm{ i1 p1 are local, i2 p2 are foreign }}
}
{}
}

\newcommand{\defnwrite}{\ddefnn{write}{\iA{write}}{\subddefnA[{ write flags and data to a stream }]{write}{\tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{flgs},\tsvar{data}) \tsunknown{s} \;\tsunknown{s'} = ({}\\{}
\quad \exists  \tsunknown{in\_} \;\tsvar{out} \;\tsvar{in}' \;\tsvar{out}'.{}\\{}
\quad \tsaux{sync\_streams} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsunknown{s} (\tsunknown{in\_},\tsvar{out}) \Mwedge {}\\{}
\quad \tsaux{sync\_streams} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsunknown{s'} (\tsvar{in}',\tsvar{out}') \Mwedge {}\\{}
\quad \tsvar{in}' = \tsunknown{in\_} \Mwedge {}\\{}
\quad \tsvar{out}'.\tsvar{flgs} ={}\\{}
\quad \Mmagiclrec   \tsvar{SYN} \Mass  (\tsvar{out}.\tsvar{flgs}.\tsvar{SYN} \Mvee  \tsvar{flgs}.\tsvar{SYN});{}\\{}
 \tsvar{SYNACK} \Mass  (\tsvar{out}.\tsvar{flgs}.\tsvar{SYNACK} \Mvee  \tsvar{flgs}.\tsvar{SYNACK});{}\\{}
 \tsvar{FIN} \Mass  (\tsvar{out}.\tsvar{flgs}.\tsvar{FIN} \Mvee  \tsvar{flgs}.\tsvar{FIN});{}\\{}
 \tsvar{RST} \Mass  (\tsvar{out}.\tsvar{flgs}.\tsvar{RST} \Mvee  \tsvar{flgs}.\tsvar{RST}){}\\{}
 \Mmagicbolrrec  \Mwedge {}\\{}
\quad \tsvar{out}'.\tsvar{data} = (\tsvar{out}.\tsvar{data} ++ \tsvar{data}))}
}
{}
}

\newcommand{\defnread}{\ddefnn{read}{\iA{read}}{\subddefnA{read}{\tsaux{read} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsunknown{peek}:\tstype{bool}) (\tsunknown{inline}:\tstype{bool}) (\tsvar{flgs}:\tstype{streamFlags},\tsvar{data}:\tsunknown{char} \;\tstype{list}) \tsunknown{s} \;\tsunknown{s'} = ({}\\{}
\quad \exists  \tsunknown{in\_} \;\tsvar{out} \;\tsvar{in}' \;\tsvar{out}'.{}\\{}
\quad \tsaux{sync\_streams} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsunknown{s} (\tsunknown{in\_},\tsvar{out}) \Mwedge {}\\{}
\quad \tsaux{sync\_streams} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsunknown{s'} (\tsvar{in}',\tsvar{out}') \Mwedge {}\\{}
\quad \tsvar{out}' = \tsvar{out} \Mwedge {}\\{}
 {}\\{}
\quad (\Mcase  \;\tsvar{flgs}.\tsvar{SYN} \;\Mof  \;\Mtrue  \Mtotype  \tsvar{in}'.\tsvar{flgs}.\tsvar{SYN} = \Mfalse  \Mwedge  \tsunknown{in\_}.\tsvar{flgs}.\tsvar{SYN} = \Mtrue  \Mdpipe  \Mfalse  \Mtotype  \tsvar{in}'.\tsvar{flgs}.\tsvar{SYN} = \tsunknown{in\_}.\tsvar{flgs}.\tsvar{SYN}) \Mwedge {}\\{}
\quad (\Mcase  \;\tsvar{flgs}.\tsvar{SYNACK} \;\Mof  \;\Mtrue  \Mtotype  \tsvar{in}'.\tsvar{flgs}.\tsvar{SYNACK} = \Mfalse  \Mwedge  \tsunknown{in\_}.\tsvar{flgs}.\tsvar{SYNACK} = \Mtrue  \Mdpipe  \Mfalse  \Mtotype  \tsvar{in}'.\tsvar{flgs}.\tsvar{SYNACK} = \tsunknown{in\_}.\tsvar{flgs}.\tsvar{SYNACK}) \Mwedge {}\\{}
\quad (\Mcase  \;\tsvar{flgs}.\tsvar{FIN} \;\Mof  \;\Mtrue  \Mtotype  \tsvar{in}'.\tsvar{flgs}.\tsvar{FIN} = \Mfalse  \Mwedge  \tsunknown{in\_}.\tsvar{flgs}.\tsvar{FIN} = \Mtrue  \Mdpipe  \Mfalse  \Mtotype  \tsvar{in}'.\tsvar{flgs}.\tsvar{FIN} = \tsunknown{in\_}.\tsvar{flgs}.\tsvar{FIN}) \Mwedge {}\\{}
\quad (\Mcase  \;\tsvar{flgs}.\tsvar{RST} \;\Mof  \;\Mtrue  \Mtotype  \tsvar{in}'.\tsvar{flgs}.\tsvar{RST} = \Mfalse  \Mwedge  \tsunknown{in\_}.\tsvar{flgs}.\tsvar{RST} = \Mtrue  \Mdpipe  \Mfalse  \Mtotype  \tsvar{in}'.\tsvar{flgs}.\tsvar{RST} = \tsunknown{in\_}.\tsvar{flgs}.\tsvar{RST}) \Mwedge {}\\{}
 {}\\{}
\quad (\exists  \tsvar{pre} \;\tsvar{post}.{}\\{}
\quad\quad\quad ((\tsvar{pre} ++ \tsvar{data} ++ \tsvar{post}) = \tsunknown{in\_}.\tsvar{data}) \Mwedge {}\\{}
\quad\quad\quad (\tsunknown{inline} \implies  \tsvar{pre} = [\,]) \Mwedge {}\\{}
\quad\quad\quad \Mif  \;\tsunknown{peek} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \tsvar{in}'.\tsvar{data} = \tsunknown{in\_}.\tsvar{data}{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsvar{in}'.\tsvar{data} = (\tsvar{pre} ++ \tsvar{post})))}
}
{}
}

\newcommand{\defnreadT}{\ddefnn{readT}{\iA{read'}}{\subddefnA{read'}{\tsaux{read'} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsunknown{peek}:\tstype{bool}) (\tsvar{flgs}:\tstype{streamFlags},\tsvar{data}:\tsunknown{char} \;\tstype{list}) \tsunknown{s} \;\tsunknown{s'} = ({}\\{}
\quad \exists  \tsunknown{in\_} \;\tsvar{out} \;\tsvar{in}' \;\tsvar{out}'.{}\\{}
\quad \tsaux{sync\_streams} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsunknown{s} (\tsunknown{in\_},\tsvar{out}) \Mwedge {}\\{}
\quad \tsaux{sync\_streams} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsunknown{s'} (\tsvar{in}',\tsvar{out}') \Mwedge {}\\{}
\quad \tsvar{out}' = \tsvar{out} \Mwedge {}\\{}
 {}\\{}
\quad (\Mcase  \;\tsvar{flgs}.\tsvar{SYN} \;\Mof  \;\Mtrue  \Mtotype  \tsvar{in}'.\tsvar{flgs}.\tsvar{SYN} = \Mfalse  \Mwedge  \tsunknown{in\_}.\tsvar{flgs}.\tsvar{SYN} = \Mtrue  \Mdpipe  \Mfalse  \Mtotype  \tsvar{in}'.\tsvar{flgs}.\tsvar{SYN} = \tsunknown{in\_}.\tsvar{flgs}.\tsvar{SYN}) \Mwedge {}\\{}
\quad (\Mcase  \;\tsvar{flgs}.\tsvar{SYNACK} \;\Mof  \;\Mtrue  \Mtotype  \tsvar{in}'.\tsvar{flgs}.\tsvar{SYNACK} = \Mfalse  \Mwedge  \tsunknown{in\_}.\tsvar{flgs}.\tsvar{SYNACK} = \Mtrue  \Mdpipe  \Mfalse  \Mtotype  \tsvar{in}'.\tsvar{flgs}.\tsvar{SYNACK} = \tsunknown{in\_}.\tsvar{flgs}.\tsvar{SYNACK}) \Mwedge {}\\{}
\quad (\Mcase  \;\tsvar{flgs}.\tsvar{FIN} \;\Mof  \;\Mtrue  \Mtotype  \tsvar{in}'.\tsvar{flgs}.\tsvar{FIN} = \Mfalse  \Mwedge  \tsunknown{in\_}.\tsvar{flgs}.\tsvar{FIN} = \Mtrue  \Mdpipe  \Mfalse  \Mtotype  \tsvar{in}'.\tsvar{flgs}.\tsvar{FIN} = \tsunknown{in\_}.\tsvar{flgs}.\tsvar{FIN}) \Mwedge {}\\{}
\quad (\Mcase  \;\tsvar{flgs}.\tsvar{RST} \;\Mof  \;\Mtrue  \Mtotype  \tsvar{in}'.\tsvar{flgs}.\tsvar{RST} = \Mfalse  \Mwedge  \tsunknown{in\_}.\tsvar{flgs}.\tsvar{RST} = \Mtrue  \Mdpipe  \Mfalse  \Mtotype  \tsvar{in}'.\tsvar{flgs}.\tsvar{RST} = \tsunknown{in\_}.\tsvar{flgs}.\tsvar{RST}) \Mwedge {}\\{}
 {}\\{}
\quad \exists  \tsvar{post}.{}\\{}
\quad \tsunknown{in\_}.\tsvar{data} = (\tsvar{data} ++ \tsvar{post}) \Mwedge {}\\{}
\quad \tsvar{in}'.\tsvar{data} = ((\Mif  \;\tsunknown{peek} \;\Mthen  \;\tsvar{data} \;\Melse  [\,]) ++ \tsvar{post}))}
}
{}
}

\newcommand{\defnbothTstreamsTdestroyed}{\ddefnn{bothTstreamsTdestroyed}{\iA{both\_streams\_destroyed}}{\subddefnA{both\_streams\_destroyed}{\tsaux{both\_streams\_destroyed} \;\tsunknown{ss} = \forall  \tsvar{s} \;\tsvar{t}. \tsunknown{ss}.\tsvar{streams} = \{\tsvar{s};\tsvar{t}\} \implies  \tsvar{s}.\tsvar{destroyed} \Mwedge  \tsvar{t}.\tsvar{destroyed}}
}
{}
}

\newcommand{\defnremoveTdestroyedTstreams}{\ddefnn{removeTdestroyedTstreams}{\iA{remove\_destroyed\_streams}}{\subddefnA{remove\_destroyed\_streams}{\tsaux{remove\_destroyed\_streams} (\tsunknown{SS}:\tsunknown{streamid} \mapsto  \tstype{tcpStreams}) = ({}\\{}
\quad \Mlet  \;\tsunknown{alive} = \{\tsunknown{stid} \mid  \neg{} \tsaux{both\_streams\_destroyed} (\tsunknown{SS} \Mfapply{}{\tsunknown{stid}})\} \Min {}\\{}
\quad \Mdrestrict{\tsunknown{SS}}{\tsunknown{alive}})}
}
{}
}

\newcommand{\defndestroy}{\ddefnn{destroy}{\iA{destroy}}{\subddefnA{destroy}{\tsaux{destroy} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsunknown{SS} \;\tsunknown{S''} = ({}\\{}
\quad \exists  \tsvar{S}_{0} \;\tsvar{s} \;\tsunknown{in\_} \;\tsvar{out} \;\tsvar{s}' \;\tsvar{S}'.{}\\{}
\quad \tsunknown{SS} = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s})] \Mwedge {}\\{}
\quad \tsaux{sync\_streams} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsvar{s} (\tsunknown{in\_},\tsvar{out}) \Mwedge {}\\{}
\quad \tsvar{s}' = \Mmagiclrec  \tsvar{streams} \Mass  \{\tsunknown{in\_}; \tsvar{out} \; \Mmagiclrec  \tsvar{destroyed} \Mass  \Mtrue  \Mmagicrrec \} \Mmagicrrec  \Mwedge {}\\{}
\quad \tsvar{S}' = \tsvar{S}_{0} \oplus  [(\tsaux{streamid\_of\_quad} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}), \tsvar{s}')] \Mwedge {}\\{}
\quad \tsunknown{S''} = \tsaux{remove\_destroyed\_streams} \;\tsvar{S}')}
}
{}
}

\newcommand{\defndestroyTquads}{\ddefnn{destroyTquads}{\iA{destroy\_quads}}{\subddefnA{destroy\_quads}{\tsaux{destroy\_quads} \;\tsunknown{quads} (\tsunknown{SS}:\tsunknown{streamid} \mapsto  \tstype{tcpStreams}) \tsunknown{S''} = ({}\\{}
\quad \exists  \tsvar{S}'. \Mfdom{\tsvar{S}'} = \Mfdom{\tsunknown{SS}} \Mwedge {}\\{}
\quad (\forall  \tsvar{stid}. \tsvar{stid} \;\in  (\Mfdom{\tsunknown{SS}}) \implies {}\\{}
\quad\quad\quad \exists  \tsunknown{in\_} \;\tsvar{out} \;\tsvar{in}' \;\tsvar{out}'.{}\\{}
\quad\quad\quad (\tsunknown{SS} \Mfapply{}{\tsvar{stid}}).\tsvar{streams} = \{\tsunknown{in\_};\tsvar{out}\} \Mwedge {}\\{}
\quad\quad\quad \tsvar{in}' = \tsunknown{in\_} \;  \Mmagiclrec  \tsvar{destroyed} \;\Mupdby  \;\Mtrue  \;\tsholop{onlywhen} ((\tsunknown{in\_}.\tsvar{i},\tsunknown{in\_}.\tsvar{p},\tsvar{out}.\tsvar{i},\tsvar{out}.\tsvar{p}) \in  \;\tsunknown{quads}) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad \tsvar{out}' = \tsvar{out} \; \Mmagiclrec  \tsvar{destroyed} \;\Mupdby  \;\Mtrue  \;\tsholop{onlywhen} ((\tsvar{out}.\tsvar{i},\tsvar{out}.\tsvar{p},\tsunknown{in\_}.\tsvar{i},\tsunknown{in\_}.\tsvar{p}) \in  \;\tsunknown{quads}) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad (\tsvar{S}' \Mfapply{}{\tsvar{stid}}).\tsvar{streams} = \{\tsvar{in}';\tsvar{out}'\}) \Mwedge {}\\{}
\quad \tsunknown{S''} = \tsaux{remove\_destroyed\_streams} \;\tsvar{S}')}
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPITstream}
\showrule{\seccommTCPITstreamTinitial}
\showrule{\defninitialTstreamFlags}
\showrule{\defninitialTstream}
\showrule{\defninitialTstreams}
\showrule{\defnstreamidTofTquad}
\showrule{\defnnullTflgsTdata}
\showrule{\defnmakeTsynTflgsTdata}
\showrule{\defnmakeTsynTackTflgsTdata}
\showrule{\defnsyncTstreams}
\showrule{\defnwrite}
\showrule{\defnread}
\showrule{\defnreadT}
\showrule{\defnbothTstreamsTdestroyed}
\showrule{\defnremoveTdestroyedTstreams}
\showrule{\defndestroy}
\showrule{\defndestroyTquads}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP3\protect\textunderscore net

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\newcommand{\chapcommnetTLTS}{\chaptersection{ Net LTS: some other}
\label{net_LTS}%
\chapcomm{
some text


}
}

\newcommand{\seccommnetTLTS}{\clustersection{(TCP only)}{Net LTS}
\seccomm{
some text


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{type\_abbrev\_hosts}$
&
& \\
$\tsrule{type\_abbrev\_streams}$
&
& \\
$\tsrule{type\_abbrev\_msgs}$
&
& \\
$\tsrule{type\_abbrev\_net}$
&
& \\
$\tsrule{Lnet0}$
&
&  Net transition labels \\
$\tsrule{tlang\_typing}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntypeTabbrevThosts}{\ddefnn{typeTabbrevThosts}{\iA{type\_abbrev\_hosts}}{\subddefnA{type\_abbrev\_hosts}{\tsholop{type\_abbrev} \;\tsunknown{hosts} :\tsunknown{hostid} \mapsto  \tstype{host}}
}
{}
}

\newcommand{\defntypeTabbrevTstreams}{\ddefnn{typeTabbrevTstreams}{\iA{type\_abbrev\_streams}}{\subddefnA{type\_abbrev\_streams}{\tsholop{type\_abbrev} \;\tsvar{streams} :\tsunknown{streamid} \mapsto  \tstype{tcpStreams}}
}
{}
}

\newcommand{\defntypeTabbrevTmsgs}{\ddefnn{typeTabbrevTmsgs}{\iA{type\_abbrev\_msgs}}{\subddefnA{type\_abbrev\_msgs}{\tsholop{type\_abbrev} \;\tsunknown{msgs} :\tsunknown{msg} \;\tsunknown{multiset}}
}
{}
}

\newcommand{\defntypeTabbrevTnet}{\ddefnn{typeTabbrevTnet}{\iA{type\_abbrev\_net}}{\subddefnA{type\_abbrev\_net}{\tsholop{type\_abbrev} \;\tsunknown{net} :\tsunknown{hosts} \# \tsvar{streams} \# \tsunknown{msgs}}
}
{}
}

\newcommand{\defnLnetZ}{\ddefnn{LnetZ}{\iA{Lnet0}}{\subddefnA[{ Net transition labels }]{Lnet0}{\tstype{Lnet0} ={}\\{}
\quad\quad \tscomm{ library interface }{}\\{}
\quad\quad\quad \tscon{Ln\_call} \;\Mof  \;\tsunknown{hostid} \# \tsunknown{tid} \# \tsunknown{LIB\_interface}                      {}\\{}
\quad\quad \mid  \tscon{Ln\_return} \;\Mof  \;\tsunknown{hostid} \# \tsunknown{tid} \# \tsunknown{TLang}                            {}\\{}
 {}\\{}
\quad\quad \tscomm{ connectivity changes FIXME }{}\\{}
\quad\quad \mid  \tscon{Ln\_interface} \;\Mof  \;\tsunknown{hostid} \# \tsunknown{ifid} \# \tstype{bool}                         {}\\{}
 {}\\{}
\quad\quad \tscomm{ miscellaneous }{}\\{}
\quad\quad \mid  \tscon{Ln\_tau}                                              {}\\{}
\quad\quad \mid  \tscon{Ln\_epsilon} \;\Mof  \;\tsunknown{duration}                              {}\\{}
 \tscomm{         | Ln\textunderscore{}trace of tracerecord                             (*[ MODE 0 ]*) }}
}
{}
}

\newcommand{\defntlangTtyping}{\ddefnn{tlangTtyping}{\iA{tlang\_typing}}{\subddefnA{tlang\_typing}{(\forall  \tsvar{hs} \;\tsvar{hid} \;\tsvar{h} \;\tsvar{h}' \;\tsvar{tid} \;\tsvar{c}{}\\{}
 \tsvar{rn} \;\tsvar{rp} \;\tsvar{rc}{}\\{}
 \tsvar{S} \;\tsvar{S}' \;\tsvar{M} \;\tsvar{M}'.{}\\{}
 {}\\{}
 (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ (\tsvar{h},\tsvar{S},\tsvar{M}) \Mtransition{\MLhcall{\tsvar{tid}}{\tsvar{c}}}{1XXXXX\Mtransitionerr{-->}} (\tsvar{h}',\tsvar{S}',\tsvar{M}')){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net\_redn}{}\\{}
 ((\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}),\tsvar{S},\tsvar{M}):\tsunknown{net}){}\\{}
 (\tscon{Ln\_call}(\tsvar{hid},\tsvar{tid},\tsvar{c})){}\\{}
 (\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}'),\tsvar{S}',\tsvar{M}'){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ A thread $\tsvar{tid}$ on host $\tsvar{h}$ executes a sockets call $\tsvar{c}$ which does not sync with the streams. }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{hs} \;\tsvar{hid} \;\tsvar{h} \;\tsvar{h}' \;\tsvar{tid} \;\tsvar{v}{}\\{}
 \tsvar{rn} \;\tsvar{rp} \;\tsvar{rc}{}\\{}
 \tsvar{S} \;\tsvar{S}' \;\tsvar{M} \;\tsvar{M}'.{}\\{}
 {}\\{}
 (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ (\tsvar{h},\tsvar{S},\tsvar{M}) \Mtransition{\MLhreturn{\tsvar{tid}}{\tsvar{v}}}{1XXXXX\Mtransitionerr{-->}} (\tsvar{h}',\tsvar{S}',\tsvar{M}')){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net\_redn}{}\\{}
 ((\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}),\tsvar{S},\tsvar{M}):\tsunknown{net}){}\\{}
 (\tscon{Ln\_return}(\tsvar{hid},\tsvar{tid},\tsvar{v})){}\\{}
 (\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}'),\tsvar{S}',\tsvar{M}'){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ A thread $\tsvar{tid}$ on host $\tsvar{h}$ returns from a sockets call. }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{hs} \;\tsvar{S} \;\tsvar{M}.{}\\{}
 {}\\{}
 \tslongcomm{ FIXME Lh\textunderscore{}senddatagram: there should be a tau at the spec3
    level, but what should this correspond to at the host level?
    Nothing, because we have already mapped sends and receives to taus
    in TCP1\textunderscore{}net1.Lnet1\textunderscore{}to\textunderscore{}Lnet0, and GroundConflate. Do we want to
    split the senddatagram rule in Spec1 so that there is a 1-1
    correspondence with transitions at spec3 level? }{}\\{}
 {}\\{}
 \tsunknown{net\_redn}{}\\{}
 ((\tsvar{hs},\tsvar{S},\tsvar{M}):\tsunknown{net}){}\\{}
 (\tscon{Ln\_tau}){}\\{}
 (\tsvar{hs},\tsvar{S},\tsvar{M}){}\\{}
 {}\\{}
 \tsholcomm{ This tau action at the network level corresponds to the hosts
    doing a $(\MLhsenddatagram{\tsunknown{msg}})$ or a $(\MLhrecvdatagram{\tsunknown{msg}})$. }{}\\{}
 {}\\{}
 \tslongcomm{ FIXME we currently treat only sends and receives of TCP
    msgs. For other messages we want a send and receive visible at the
    Spec3 level }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{hid} \;\tsvar{rn} \;\tsvar{rp} \;\tsvar{rc} \;\tsvar{h} \;\tsvar{hs} \;\tsvar{h}'{}\\{}
 \tsvar{ifid} \;\tsvar{up}{}\\{}
 \tsvar{S} \;\tsvar{S}' \;\tsvar{M} \;\tsvar{M}'.{}\\{}
 {}\\{}
 (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ (\tsvar{h},\tsvar{S},\tsvar{M}) \Mtransition{\tscon{Lh\_interface}(\tsvar{ifid},\tsvar{up})}{1XXXXX\Mtransitionerr{-->}} (\tsvar{h}',\tsvar{S}',\tsvar{M}')){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net\_redn}{}\\{}
 ((\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}),\tsvar{S},\tsvar{M}):\tsunknown{net}){}\\{}
 (\tscon{Ln\_interface} (\tsvar{hid},\tsvar{ifid},\tsvar{up})){}\\{}
 (\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}'),\tsvar{S}',\tsvar{M}'){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Network interface change  }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{hid} \;\tsvar{rn} \;\tsvar{rp} \;\tsvar{rc} \;\tsvar{h} \;\tsvar{hs} \;\tsvar{h}'{}\\{}
 \tsvar{S} \;\tsvar{S}' \;\tsvar{M} \;\tsvar{M}'.{}\\{}
 {}\\{}
 (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ (\tsvar{h},\tsvar{S},\tsvar{M}) \Mtransition{\MLhtau }{1XXXXX\Mtransitionerr{-->}} (\tsvar{h}',\tsvar{S}',\tsvar{M}')){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net\_redn}{}\\{}
 ((\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}),\tsvar{S},\tsvar{M}):\tsunknown{net}){}\\{}
 \tscon{Ln\_tau}{}\\{}
 (\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}'),\tsvar{S}',\tsvar{M}'){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Allow a host to do a $\MLhtau $ transition }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{hs} \;\tsvar{hs}' \;\tsvar{hs}'' \;\tsvar{dur}{}\\{}
 \tsvar{S} \;\tsvar{M}.{}\\{}
 {}\\{}
 (\forall  \tsvar{h}. \tsvar{h} \;\in  \Mfrange{\tsvar{hs}} \implies  \neg{}(\exists \tsvar{rn} \;\tsvar{rp} \;\tsvar{rc} \;\tsvar{lbl} \;\tsvar{h}' \;\tsvar{S}' \;\tsvar{M}'.{}\\{}
\quad\quad\quad \tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ (\tsvar{h},\tsvar{S},\tsvar{M}) \Mtransition{\tsvar{lbl}}{1XXXXX\Mtransitionerr{-->}} (\tsvar{h}',\tsvar{S}',\tsvar{M}') \Mwedge  \tsunknown{is\_urgent} \;\tsvar{rc})) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Time passes for the hosts. }{}\\{}
 \tsvar{hs}' = (\tsaux{Time\_Pass\_host} \;\tsvar{dur}) \tsunknown{o\_f} \;\tsvar{hs} \Mwedge {}\\{}
 \neg{} (* \;\in  \Mfrange{\tsvar{hs}'}) \Mwedge {}\\{}
 {}\\{}
 \Mfdom{\tsvar{hs}''} = \Mfdom{\tsvar{hs}} \Mwedge {}\\{}
 (\forall  \tsvar{hid}. \tsvar{hid} \;\in  \Mfdom{\tsvar{hs}} \implies  \tsvar{hs}'' \Mfapply{}{\tsvar{hid}} \in  (\tsholop{THE} (\tsvar{hs}' \Mfapply{}{\tsvar{hid}}))){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net\_redn}{}\\{}
 ((\tsvar{hs},\tsvar{S},\tsvar{M}):\tsunknown{net}){}\\{}
 (\tscon{Ln\_epsilon} \;\tsvar{dur}){}\\{}
 (\tsvar{hs}'',\tsvar{S},\tsvar{M}){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Allow time to pass for hosts }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{hid} \;\tsvar{rn} \;\tsvar{rp} \;\tsvar{rc} \;\tsvar{h} \;\tsvar{hs} \;\tsvar{h}' \;\tsvar{tr} \;\tsvar{S} \;\tsvar{M} \;\tsvar{S}' \;\tsvar{M}'.{}\\{}
 {}\\{}
 \tsvar{hid} \;\notin  \Mfdom{\tsvar{hs}} \Mwedge {}\\{}
 {}\\{}
 (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ (\tsvar{h},\tsvar{S},\tsvar{M}) \Mtransition{\tscon{Lh\_trace} \;\tsvar{tr}}{1XXXXX\Mtransitionerr{-->}} (\tsvar{h}',\tsvar{S}',\tsvar{M}')){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net\_redn}{}\\{}
 ((\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}),\tsvar{S},\tsvar{M}):\tsunknown{net}){}\\{}
 (\tscon{Ln\_tau}) \tscomm{(Ln\textunderscore{}trace tr) traces were previously visible at net level }{}\\{}
 (\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}'),\tsvar{S}',\tsvar{M}'){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Trace records }{}\\{}
 {}\\{}
 )}
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommnetTLTS}
\showrule{\seccommnetTLTS}
\showrule{\defntypeTabbrevThosts}
\showrule{\defntypeTabbrevTstreams}
\showrule{\defntypeTabbrevTmsgs}
\showrule{\defntypeTabbrevTnet}
\showrule{\defnLnetZ}
\showrule{\defntlangTtyping}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP3\protect\textunderscore absFun

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\newcommand{\defntcpcbITtoTIII}{\ddefnn{tcpcbITtoTIII}{\iA{tcpcb1\_to\_3}}{\subddefnA{tcpcb1\_to\_3}{(\tsaux{tcpcb1\_to\_3}:\tsunknown{TCP1\_hostTypes}\;\tsunknown{\$tcpcb}\Mtotype \tsunknown{TCP3\_hostTypes}\;\tsunknown{\$tcpcb}) \tsvar{cb} = ({}\\{}
\quad\quad \Mmagiclrec   \tsfield{tt\_keep} \Mass  \tsvar{cb}.\tsfield{tt\_keep};{}\\{}
 \tsfield{t\_softerror} \Mass  \tsvar{cb}.\tsfield{t\_softerror}{}\\{}
 \Mmagicbolrrec )}
}
{}
}

\newcommand{\defntcpTsocketITtoTIII}{\ddefnn{tcpTsocketITtoTIII}{\iA{tcp\_socket1\_to\_3}}{\subddefnA{tcp\_socket1\_to\_3}{(\tsaux{tcp\_socket1\_to\_3}:\tsunknown{TCP1\_hostTypes}\;\tsunknown{\$tcp\_socket}\Mtotype \tsunknown{TCP3\_hostTypes}\;\tsunknown{\$tcp\_socket}) \tsunknown{s} = ({}\\{}
\quad\quad \Mmagiclrec   \tsvar{st} \Mass  \tsunknown{s}.\tsvar{st};{}\\{}
 \tsvar{cb} \Mass  \tsaux{tcpcb1\_to\_3} \;\tsunknown{s}.\tsvar{cb};{}\\{}
 \tsvar{lis} \Mass  \tsunknown{s}.\tsvar{lis};{}\\{}
 \tsvar{sndq} \Mass  \tsunknown{s}.\tsvar{sndq};{}\\{}
 \tsvar{rcvq} \Mass  \tsunknown{s}.\tsvar{rcvq}{}\\{}
 \Mmagicbolrrec )}
}
{}
}

\newcommand{\defnsocketITtoTIII}{\ddefnn{socketITtoTIII}{\iA{socket1\_to\_3}}{\subddefnA{socket1\_to\_3}{(\tsaux{socket1\_to\_3}:\tsunknown{TCP1\_hostTypes}\;\tsunknown{\$socket}\Mtotype \tsunknown{TCP3\_hostTypes}\;\tsunknown{\$socket}) \tsunknown{s} = ({}\\{}
\quad\quad \Mmagiclrec   \tsvar{fid} \Mass  \tsunknown{s}.\tsvar{fid};{}\\{}
 \tsvar{sf} \Mass  \tsunknown{s}.\tsvar{sf};{}\\{}
 \tsvar{is}_{1} \Mass  \tsunknown{s}.\tsvar{is}_{1};{}\\{}
 \tsvar{ps}_{1} \Mass  \tsunknown{s}.\tsvar{ps}_{1};{}\\{}
 \tsvar{is}_{2} \Mass  \tsunknown{s}.\tsvar{is}_{2};{}\\{}
 \tsvar{ps}_{2} \Mass  \tsunknown{s}.\tsvar{ps}_{2};{}\\{}
 \tsvar{es} \Mass  \tsunknown{s}.\tsvar{es};{}\\{}
 \tsvar{cantsndmore} \Mass  \tsunknown{s}.\tsvar{cantsndmore};{}\\{}
 \tsvar{cantrcvmore} \Mass  \tsunknown{s}.\tsvar{cantrcvmore};{}\\{}
 \tsvar{pr} \Mass  (\Mcase  \;\tsunknown{s}.\tsvar{pr} \;\Mof  \;\tscon{TCP\_PROTO} \;\tsunknown{tcp\_sock} \Mtotype  \tscon{TCP\_PROTO} (\tsaux{tcp\_socket1\_to\_3} \;\tsunknown{tcp\_sock}){}\\{}
 \Mdpipe   \tscon{UDP\_PROTO} \;\tsunknown{udp\_sock} \Mtotype  \tscon{UDP\_PROTO} \;\tsunknown{udp\_sock}){}\\{}
 \Mmagicbolrrec )}
}
{}
}

\newcommand{\defnhostITtoTIII}{\ddefnn{hostITtoTIII}{\iA{host1\_to\_3}}{\subddefnA{host1\_to\_3}{(\tsaux{host1\_to\_3}:\tsunknown{TCP1\_hostTypes}\;\tsunknown{\$host}\Mtotype \tsunknown{TCP3\_hostTypes}\;\tsunknown{\$host}) \tsunknown{h} = ({}\\{}
\quad\quad \Mlet  \;\tsunknown{filter\_non\_TCP\_msgs} ={}\\{}
\quad\quad\quad \lambda  \tsvar{q}. \Mcase  \;\tsvar{q} \;\Mof  \Mtimed{\tsunknown{msgs}}{\tsunknown{d}} \Mtotype  \Mtimed{\tsholop{FILTER} (\lambda  \tsvar{msg}. \Mcase  \;\tsvar{msg} \;\Mof  \;\tsunknown{TCP} \;\tsunknown{\_1} \Mtotype  \Mfalse  \Mdpipe  \tsunknown{\_2} \Mtotype  \Mtrue ) \tsunknown{msgs}}{\tsunknown{d}}{}\\{}
\quad\quad \Min {}\\{}
\quad\quad \Mmagiclrec   \tsvar{arch} \Mass  \tsunknown{h}.\tsvar{arch};{}\\{}
 \tsvar{privs} \Mass  \tsunknown{h}.\tsvar{privs};{}\\{}
 \tsvar{ifds} \Mass  \tsunknown{h}.\tsvar{ifds};{}\\{}
 \tsvar{rttab} \Mass  \tsunknown{h}.\tsvar{rttab};{}\\{}
 \tsvar{ts} \Mass  \tsunknown{h}.\tsvar{ts};{}\\{}
 \tsvar{files} \Mass  \tsunknown{h}.\tsvar{files};{}\\{}
 \tsvar{socks} \Mass  \tsaux{socket1\_to\_3} \;\tsunknown{o\_f} \;\tsunknown{h}.\tsvar{socks};{}\\{}
 \tsvar{listen} \Mass  \tsunknown{h}.\tsvar{listen};{}\\{}
 \tsvar{bound} \Mass  \tsunknown{h}.\tsvar{bound};{}\\{}
 \tsvar{iq} \Mass  \tsunknown{filter\_non\_TCP\_msgs} \;\tsunknown{h}.\tsvar{iq};{}\\{}
 \tsvar{oq} \Mass  \tsunknown{filter\_non\_TCP\_msgs} \;\tsunknown{h}.\tsvar{oq};{}\\{}
 \tsvar{bndlm} \Mass  \tsunknown{h}.\tsvar{bndlm};{}\\{}
 \tsvar{ticks} \Mass  \tsunknown{h}.\tsvar{ticks};{}\\{}
 \tsvar{fds} \Mass  \tsunknown{h}.\tsvar{fds};{}\\{}
 \tsvar{params} \Mass  \tsunknown{h}.\tsvar{params}{}\\{}
 \Mmagicbolrrec )}
}
{}
}

\newcommand{\defnstreamTreass}{\ddefnn{streamTreass}{\iA{stream\_reass}}{\subddefnA{stream\_reass}{\tsaux{stream\_reass} (\tsunknown{seq}:\tsunknown{tcpLocal} \;\tsunknown{seq32} \tscomm{ FIXME really want word32 }) (\tsunknown{segs}: \tsunknown{tcpSegment} \;\tstype{set}) = ({}\\{}
\quad \tscomm{ FIXME what to do about flags? (we ignore URP) }{}\\{}
\quad \Mlet  \;\tsunknown{myrel} = \{ (\tsvar{i},\tsvar{c}) \mid {}\\{}
\quad\quad\quad\quad\quad \exists  \tsvar{seg}. \tsvar{seg} \;\in  \;\tsunknown{segs} \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsholop{Num} (\tsvar{i} - \tsvar{seg}.\tsunknown{seq}) < \tsholop{LENGTH} \;\tsvar{seg}.\tsvar{data} \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{c} = \tsunknown{EL} (\tsholop{Num} (\tsvar{i} - \tsvar{seg}.\tsunknown{seq})) \tsvar{seg}.\tsvar{data} \} \Min {}\\{}
\quad \Mlet  \;\tsunknown{cs} = \{ (\tsunknown{cs}:\tstype{byte} \;\tstype{list}) \mid {}\\{}
\quad\quad\quad\quad\quad (\forall  \tsvar{n}:\tsvar{num}. \tsvar{n} < \tsholop{LENGTH} \;\tsunknown{cs} \implies  \tsunknown{myrel} (\tsunknown{seq} + \tsvar{n}, \tsunknown{EL} \;\tsvar{n} \;\tsunknown{cs})) \Mwedge {}\\{}
\quad\quad\quad\quad\quad (\neg{}\exists \tsvar{c}. (\tsunknown{seq}+(\tsholop{LENGTH} \;\tsunknown{cs}),\tsvar{c}) \in  \;\tsunknown{myrel}) \} \Min {}\\{}
\quad \tsunknown{CHOICE} \;\tsunknown{cs}){}\\{}
 {}\\{}
 \tslongcomm{ We do this in order to remain functional. Indeed, it is expected that the segments are
    consistent, so that cs is a singleton set. We may need to revisit this assumption- shouldn't be
    too difficult to make the following relational. }}
}
{}
}

\newcommand{\defnERROR}{\ddefnn{ERROR}{\iA{ERROR}}{\subddefnA{ERROR}{\tsunknown{ERROR} (\tsunknown{a}:\tsunknown{'a}) = (\tsunknown{ARB}:\tsunknown{'b})}
}
{}
}

\newcommand{\defnabsThostsToneTsided}{\ddefnn{absThostsToneTsided}{\iA{abs\_hosts\_one\_sided}}{\subddefnA[{ unidirectional abstraction function }]{abs\_hosts\_one\_sided}{\tsaux{abs\_hosts\_one\_sided} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsunknown{h},\tsunknown{msgs},\tsvar{i}) = ({}\\{}
 {}\\{}
\quad \tsholcomm{ get the messages that we are interested in, including those in $\tsvar{oq}$ and $\tsvar{iq}$ }{}\\{}
\quad \Mlet  (\tsunknown{hoq},\tsunknown{iiq}) ={}\\{}
\quad\quad\quad \Mcase  (\tsunknown{h}.\tsvar{oq},\tsvar{i}.\tsvar{iq}) \Mof  (\Mtimed{\tsunknown{msgs}}{\tsunknown{\_1}}, \Mtimed{\tsunknown{msgs'}}{\tsunknown{\_2}}) \Mtotype  (\tsunknown{msgs},\tsunknown{msgs'}) \Min {}\\{}
\quad \Mlet  \;\tsunknown{msgs} = \tsholop{LIST\_TO\_SET} \;\tsunknown{hoq} \;\cup  \;\tsunknown{msgs} \;\cup  (\tsholop{LIST\_TO\_SET} \;\tsunknown{iiq}) \Min {}\\{}
\quad \tsholcomm{ only consider TCP messages \ldots }{}\\{}
\quad \Mlet  \;\tsunknown{msgs} = \{\tsvar{msg} \mid  \tsunknown{TCP} \;\tsvar{msg} \;\in  \;\tsunknown{msgs}\} \Min {}\\{}
\quad \tsholcomm{ \ldots that match the quad }{}\\{}
\quad \Mlet  \;\tsunknown{msgs} = \tsunknown{msgs} \;\cap {}\\{}
\quad\quad\quad \{\tsvar{msg} \mid  \tsvar{msg} = \tsvar{msg} \; \Mmagiclrec  \tsvar{is}_{1} \Mass  \Msome  \;\tsvar{i}_{1}; \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}_{1}; \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i}_{2}; \tsvar{ps}_{2} \Mass  \Msome  \;\tsvar{p}_{2} \Mmagicrrec  \} \Min {}\\{}
 {}\\{}
\quad \tsholcomm{ pick out the send and receive sockets }{}\\{}
\quad \Mlet  \;\tsunknown{smatch} \;\tsvar{i}_{1} \;\tsvar{p}_{1} \;\tsvar{i}_{2} \;\tsvar{p}_{2} \;\tsunknown{s} = ((\tsunknown{s}.\tsvar{is}_{1},\tsunknown{s}.\tsvar{ps}_{1},\tsunknown{s}.\tsvar{is}_{2},\tsunknown{s}.\tsvar{ps}_{2}) = (\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})) \Min {}\\{}
\quad \Mlet  \;\tsunknown{snd\_sock} = \tsunknown{Punique\_range} (\tsunknown{smatch} \;\tsvar{i}_{1} \;\tsvar{p}_{1} \;\tsvar{i}_{2} \;\tsvar{p}_{2}) \tsunknown{h}.\tsvar{socks} \;\Min {}\\{}
\quad \Mlet  \;\tsunknown{rcv\_sock} = \tsunknown{Punique\_range} (\tsunknown{smatch} \;\tsvar{i}_{2} \;\tsvar{p}_{2} \;\tsvar{i}_{1} \;\tsvar{p}_{1}) \tsvar{i}.\tsvar{socks} \;\Min {}\\{}
 {}\\{}
\quad \Mlet  \;\tsunknown{tcpsock\_of} \;\tsunknown{sock} = \Mcase  \;\tsunknown{sock}.\tsvar{pr} \;\Mof {}\\{}
\quad\quad\quad \tsunknown{TCP1\_hostTypes}\;\tsunknown{\$TCP\_PROTO} \;\tsunknown{tcpsock} \Mtotype  \tsunknown{tcpsock}{}\\{}
\quad\quad \Mdpipe  \tsunknown{\_3} \Mtotype  \tsunknown{ERROR} \text{``abs\textunderscore{}hosts\textunderscore{}one\textunderscore{}sided:tcpsock\textunderscore{}of''}{}\\{}
\quad \Min {}\\{}
 {}\\{}
\quad \tsholcomm{ the difficult part of the abstraction function is to compute $\tsvar{data}$ }{}\\{}
\quad \Mlet  (\tsvar{data}:\tstype{byte} \;\tstype{list}) = \Mcase  (\tsunknown{snd\_sock},\tsunknown{rcv\_sock}) \Mof {}\\{}
\quad\quad\quad (\Msome  (\tsunknown{\_8},\tsunknown{hsock}),\Msome (\tsunknown{\_9},\tsunknown{isock})) \Mtotype  ({}\\{}
\quad\quad\quad\quad\quad \Mlet  \;\tsunknown{htcpsock} = \tsunknown{tcpsock\_of} \;\tsunknown{hsock} \;\Min {}\\{}
\quad\quad\quad\quad\quad \Mlet  \;\tsunknown{itcpsock} = \tsunknown{tcpsock\_of} \;\tsunknown{isock} \;\Min {}\\{}
\quad\quad\quad\quad\quad \Mlet  (\tsunknown{snd\_una}, \tsvar{sndq}) = (\tsunknown{htcpsock}.\tsvar{cb}.\tsunknown{snd\_una}, \tsunknown{htcpsock}.\tsvar{sndq}) \Min {}\\{}
\quad\quad\quad\quad\quad \Mlet  (\tsunknown{rcv\_nxt}, \tsvar{rcvq}) = (\tsunknown{itcpsock}.\tsvar{cb}.\tsunknown{rcv\_nxt}, \tsunknown{itcpsock}.\tsvar{rcvq}) \Min {}\\{}
\quad\quad\quad\quad\quad \Mlet  \;\tsunknown{rcv\_nxt} = \tsunknown{tcp\_seq\_flip\_sense} \;\tsunknown{rcv\_nxt} \;\Min {}\\{}
\quad\quad\quad\quad\quad \Mlet  \;\tsvar{sndq}' = \tsunknown{DROP} ((\tsholop{Num} (\tsunknown{rcv\_nxt} - \tsunknown{snd\_una}))) \tsvar{sndq} \;\Min {}\\{}
\quad\quad\quad\quad\quad \tsvar{rcvq} ++ \tsvar{sndq}'){}\\{}
 {}\\{}
\quad\quad \Mdpipe  (\Msome  (\tsunknown{\_8},\tsunknown{hsock}),*) \Mtotype  ({}\\{}
\quad\quad\quad\quad\quad \Mlet  \;\tsunknown{htcpsock} = \tsunknown{tcpsock\_of} \;\tsunknown{hsock} \;\Min {}\\{}
\quad\quad\quad\quad\quad \tsunknown{htcpsock}.\tsvar{sndq}){}\\{}
 {}\\{}
\quad\quad \Mdpipe  (*,\Msome (\tsunknown{\_9},\tsunknown{isock})) \Mtotype  ({}\\{}
\quad\quad\quad\quad\quad \Mlet  \;\tsunknown{itcpsock} = \tsunknown{tcpsock\_of} \;\tsunknown{isock} \;\Min {}\\{}
\quad\quad\quad\quad\quad \Mlet  (\tsunknown{rcv\_nxt}:\tsunknown{tcpLocal} \;\tsunknown{seq32},\tsvar{rcvq}:\tstype{byte} \;\tstype{list}) ={}\\{}
\quad\quad\quad\quad\quad\quad\quad (\tsunknown{tcp\_seq\_flip\_sense} (\tsunknown{itcpsock}.\tsvar{cb}.\tsunknown{rcv\_nxt}),\tsunknown{itcpsock}.\tsvar{rcvq}) \Min {}\\{}
\quad\quad\quad\quad\quad \tsvar{rcvq} ++ (\tsaux{stream\_reass} \;\tsunknown{rcv\_nxt} \;\tsunknown{msgs})){}\\{}
 {}\\{}
\quad\quad \Mdpipe  (*,*) \Mtotype  \tsunknown{ERROR} \text{``abs\textunderscore{}hosts\textunderscore{}one\textunderscore{}sided:data''}{}\\{}
\quad \Min {}\\{}
\quad \Mmagiclrec   \tsvar{i} \Mass  \tsvar{i}_{1};{}\\{}
 \tsvar{p} \Mass  \tsvar{p}_{1};{}\\{}
 \tsvar{flgs} \Mass {}\\{}
 \Mmagiclrec   \tsvar{SYN}    \Mass  (\exists  \tsvar{msg}. \tsvar{msg} \;\in  \;\tsunknown{msgs} \Mwedge  \tsvar{msg} = \tsvar{msg} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mtrue ; \tsunknown{ACK} \Mass  \Mfalse \Mmagicrrec );{}\\{}
 \tsvar{SYNACK} \Mass  (\exists  \tsvar{msg}. \tsvar{msg} \;\in  \;\tsunknown{msgs} \Mwedge  \tsvar{msg} = \tsvar{msg} \; \Mmagiclrec  \tsvar{SYN} \Mass  \Mtrue ; \tsunknown{ACK} \Mass  \Mtrue \Mmagicrrec );{}\\{}
 \tsvar{FIN}    \Mass  (\exists  \tsvar{msg}. \tsvar{msg} \;\in  \;\tsunknown{msgs} \Mwedge  \tsvar{msg} = \tsvar{msg} \; \Mmagiclrec  \tsvar{FIN} \Mass  \Mtrue \Mmagicrrec );{}\\{}
 \tsvar{RST}    \Mass  (\exists  \tsvar{msg}. \tsvar{msg} \;\in  \;\tsunknown{msgs} \Mwedge  \tsvar{msg} = \tsvar{msg} \; \Mmagiclrec  \tsvar{RST} \Mass  \Mtrue \Mmagicrrec ){}\\{}
 \Mmagicbolrrec ;{}\\{}
 \tsvar{data} \Mass  \tsvar{data};{}\\{}
 \tsvar{destroyed} \Mass  (\Mcase  \;\tsunknown{snd\_sock} \;\Mof {}\\{}
 \Msome  (\tsunknown{sid},\tsunknown{hsock}) \Mtotype  ((\tsunknown{tcpsock\_of} \;\tsunknown{hsock}).\tsvar{st} = \tscon{CLOSED}){}\\{}
 \Mdpipe  * \Mtotype  \Mtrue ){}\\{}
 \Mmagicbolrrec )}
}
{}
}

\newcommand{\defnabsThosts}{\ddefnn{absThosts}{\iA{abs\_hosts}}{\subddefnA{abs\_hosts}{\tsaux{abs\_hosts} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsunknown{h1},\tsunknown{msgs},\tsunknown{h2}) = ({}\\{}
\quad \Mlet  \;\tsunknown{n1} = \tsaux{host1\_to\_3} \;\tsunknown{h1} \;\Min {}\\{}
\quad \Mlet  \;\tsunknown{n2} = \tsaux{host1\_to\_3} \;\tsunknown{h2} \;\Min {}\\{}
\quad \Mlet  (\tsvar{streams}:\tstype{tcpStreams} \;\;\tstype{option}) ={}\\{}
\quad\quad\quad \Mlet  \;\tsunknown{s12} = \tsaux{abs\_hosts\_one\_sided} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsunknown{h1},\tsunknown{msgs},\tsunknown{h2}) \Min {}\\{}
\quad\quad\quad \Mlet  \;\tsunknown{s21} = \tsaux{abs\_hosts\_one\_sided} (\tsvar{i}_{2},\tsvar{p}_{2},\tsvar{i}_{1},\tsvar{p}_{1}) (\tsunknown{h2},\tsunknown{msgs},\tsunknown{h1}) \Min {}\\{}
\quad\quad\quad (\Mcase  \;\tsunknown{s12}.\tsvar{destroyed} \Mwedge  \tsunknown{s21}.\tsvar{destroyed} \;\Mof {}\\{}
\quad\quad\quad\quad\quad \Mtrue  \Mtotype  *{}\\{}
\quad\quad\quad\quad \Mdpipe  \Mfalse  \Mtotype  \Msome  \Mmagiclrec  \tsvar{streams} \Mass  \{\tsunknown{s12};\tsunknown{s21}\} \Mmagicrrec ){}\\{}
\quad \Min {}\\{}
\quad (\tsunknown{n1},\tsvar{streams},\tsunknown{n2}))}
}
{}
}

\newcommand{\defnabsTlbl}{\ddefnn{absTlbl}{\iA{abs\_lbl}}{\subddefnA{abs\_lbl}{\tsaux{abs\_lbl} \;\tsunknown{lbl} = (\Mcase  \;\tsunknown{lbl} \;\Mof {}\\{}
\quad \tsunknown{Ln0\_call} (\tsunknown{hid}, \tsunknown{tid}, \tsunknown{lib}) \Mtotype  \tscon{Ln\_call} (\tsunknown{hid}, \tsunknown{tid}, \tsunknown{lib}){}\\{}
 \Mdpipe  \tsunknown{Ln0\_return} (\tsunknown{hid}, \tsunknown{tid}, \tsunknown{tlang}) \Mtotype  \tscon{Ln\_return} (\tsunknown{hid},\tsunknown{tid},\tsunknown{tlang}){}\\{}
 \Mdpipe  \tsunknown{Ln0\_interface} (\tsunknown{hid},\tsunknown{ifid},\tsunknown{up}) \Mtotype  \tsunknown{ARB} \text{``absfn: Ln0\textunderscore{}interface''} \tscomm{ FIXME not handled at moment }{}\\{}
 \Mdpipe  \tsunknown{Ln0\_tau} \Mtotype  \tscon{Ln\_tau}{}\\{}
 \Mdpipe  \tsunknown{Ln0\_epsilon} \;\tsunknown{dur} \Mtotype  \tscon{Ln\_epsilon} \;\tsunknown{dur}{}\\{}
 \Mdpipe  \tsunknown{Ln0\_trace} \;\tsunknown{tr} \Mtotype  \tscon{Ln\_tau}){}\\{}
 {}\\{}
 \tscomm{ assume hid = h, FIXME ignore tid for time being? 20061130 what does this mean? }}
}
{}
}

\newcommand{\defnabsTtrans}{\ddefnn{absTtrans}{\iA{abs\_trans}}{\subddefnA{abs\_trans}{\tsaux{abs\_trans} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsunknown{h1},\tsunknown{msgs},\tsunknown{h2}) \tsunknown{lbl} (\tsunknown{h1'},\tsunknown{msgs'},\tsunknown{h2'}) = ({}\\{}
\quad \Mlet  \;\tsunknown{n} = \tsaux{abs\_hosts} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsunknown{h1},\tsunknown{msgs},\tsunknown{h2}) \Min {}\\{}
\quad \Mlet  \;\tsunknown{n'} = \tsaux{abs\_hosts} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsunknown{h1'},\tsunknown{msgs'},\tsunknown{h2'}) \Min {}\\{}
\quad \Mlet  \;\tsunknown{nlbl} = \tsaux{abs\_lbl} \;\tsunknown{lbl} \;\Min {}\\{}
\quad (\tsunknown{n},\tsunknown{nlbl},\tsunknown{n'}))}
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\defntcpcbITtoTIII}
\showrule{\defntcpTsocketITtoTIII}
\showrule{\defnsocketITtoTIII}
\showrule{\defnhostITtoTIII}
\showrule{\defnstreamTreass}
\showrule{\defnERROR}
\showrule{\defnabsThostsToneTsided}
\showrule{\defnabsThosts}
\showrule{\defnabsTlbl}
\showrule{\defnabsTtrans}
}

%%%% END %%%%
\let\dumpallrules\relax

\def\rulesrcsid{}

