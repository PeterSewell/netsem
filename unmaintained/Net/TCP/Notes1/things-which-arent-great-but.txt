-- DO NOT EDIT THIS FILE: all its contents should have been moved to
   the companion .mng file. --

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=- Things which seem like bad design -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

We are invariably asked at the end of our talk whether we found any
bugs, and if so what they were.  Of course, "bugs" doesn't make sense
in this context, but we certainly came across things that seem like
bad design, that we "could [in principle] do better".  So we list them
here, for ammunition.

Of course, a few things do look like bugs.

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=- TCP -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Issue: Behaviour of multiple connects when blocking mode changed
Platforms: BSD, Linux
Description:

Issue: Self-connect support
Platforms: BSD, others?
Description:


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=- UDP -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=- Sockets Layer -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=- Old File Contents -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

UDP:

(lots of stuff from the past, and:)

- race between bind() and connect(); would like to set whole 4-tuple
  at once.

- BUG: in Linux it is possible to send a packet out with a zero
  destination port; can't do anything with it though.



TCP:

- I have a note (2002-07-02) that Per Brand (of the PEPITO project)
  encountered lots of weird undocumented errors when using TCP.  We
  should ask him for more weirdnesses.


Bugs identified by Stevens in 1995 (TCPv2) but still lurking in FreeBSD 4.6:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TCPv2p822: needless initialisation of global constant every 500msec:
netinet/tcp_timer.c:134.

TCPv2p879: subtle bug in urgent pointer logic (truncation to short):
netinet/tcp_output.c:725.


Things which seem like bugs in FreeBSD 4.6-RELEASE:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Whether ACK is set or not appears rather late, and it's not clear how
observable this is.  There certainly are some things (if ACK not set
but ack has a sensible value, the datagram is silently dropped,
whereas if ACK not set and ack is stupid, a RST is sent).  (Header
prediction only fires if ACK is set).


Things spotted in the wild:
~~~~~~~~~~~~~~~~~~~~~~~~~~~

*****

Message-id: <gnfZ8.2$075.1606@paloalto-snr1.gtei.net>
Subject: Re: transmitter address is broadcast
From: Barry Margolin <barmar@genuity.net>
Date: Wed, 17 Jul 2002 14:42:21 GMT (15:42 BST)
Newsgroups: comp.protocols.tcp-ip

	(text/plain)
In article <e90dfe5e.0207162242.3bf0eb8e@posting.google.com>,
Frank Lam <frank_yylam@yahoo.com> wrote:
>I saw some packet in the sniffer capture with alarm " transmitter
>address is broadcast". It look strange to me, how can the
>transmitter's address be broadcast address? Appreciated if any
>information can be provided?

It could be due to someone forging invalid source addresses.  There may
also be some buggy ICMP implementations that don't do the right thing when
responding to a broadcast ICMP Echo: the ICMP specification says that when
responding, you're supposed to swap the source and destination addresses,
but it should be obvious that this doesn't apply if the destination address
was a broadcast address; but some implementations might have followed the
spec literally.

--
Barry Margolin, barmar@genuity.net
Genuity, Woburn, MA
*** DON'T SEND TECHNICAL QUESTIONS DIRECTLY TO ME, post them to newsgroups.
Please DON'T copy followups to me -- I'll assume it wasn't posted to the group.

*****

Interesting thread about urgent data and the brokenness of
not-OOBINLINE in BSD, in comp.protocols.tcp-ip, starting at
Message-ID: <H1JE6J.1vI1@Watt.COM>.

*****

Interesting corner case worth checking: recv of zero bytes should
block until data arrives.  comp.protocols.tcp-ip, particularly
Message-ID: <3D7513F4.8277C186@webmaster.com> and Message-ID:
<al4iac$15b$3@news1.xs4all.nl>, thread starting at Message-ID:
<b399d6ce.0209030928.249a6d50@posting.google.com>.

*****

Discussion of weird Winsock2 behaviour: thread starting at Message-ID:
<a7458e5b.0210220838.3d098e8a@posting.google.com>.

*****

Another interesting TCP/IP bug (from the Bugtraq database) can be
found here:

http://msgs.securepoint.com/cgi-bin/get/bugtraq0210/228.html

This describes the behaviour of some TCP/IP stack implementations
under TCP flag abuse, e.g., Linux 2.4.19 kernels will allow the
establishment of a new connection from a segment that has SYN|RST set.

*****

In comp.protocols.tcpip,
Message-ID: <3df5b40f$0$11751$e4fe514c@news.xs4all.nl>, talking about
data+FIN:

  Solaris 2.6 has a bug in that it will not ack the FIN but will require
  the peer to retransmit it after it has acked all data.
  (We've also found that some systems do not retransmit the FIN)

  This issue is fixed in Solaris 9 and patch all the way back to
  Solaris 2.6.  (bug 4330074, 4083814 may also be relevant)

  Casper

*****

Not a bug, but interesting: there's a suggestion that HPUX uses the
text field in a RST segment per the RFC's suggestion:

Newsgroups: comp.protocols.tcp-ip
Message-ID: <at8ron$qg3$1@web1.cup.hp.com>

  [...] different stuff in RST segments is known - for example
  the text that is in the "data" portion of a RST from an HP-UX 11
  system... but I can attest that the UX stack does not look for those
  text fields when it receives a RST...

*****

Wierd IIS behaviour, from /. :
(this explanation may be bogus...)

http://grotto11.com/blog/slash.html?+1039831658

Many very stupid companies have tried to come up with overly clever
ways to speed up TCP/IP. TCP, by its nature, is a stateful and
bidirectional protocol that requires all data packets to be
acknowledged; this makes the data flow reliable, by providing a
mechanism for dropped packets to be retransmitted; but this also makes
for a more strictly regimented flow structure involving more packets
transmitted over the wire than in simpler, non-reliable protocols like
UDP-- and therefore it's slower. One company that thought itself a lot
smarter than it really was, called RunTCP, came up with the idea of
"pre-acking" TCP packets; it would send out the acknowledgments for a
whole pile of data packets in advance, thus freeing them from the
onerous necessity of double-checking that each packet actually got
there properly. And it worked great, speeding up TCP flows by a
significant margin-- in the lab, under ideal test conditions. The
minute you put RunTCP's products out onto the real Internet,
everything stopped working. Which stands to reason-- their "solution"
was to tear out all the infrastructure that made TCP work reliably,
under competing load and in adverse conditions, in the first
place. Dumbasses.

So then there's this thing we discovered in the lab. We noticed that
when you entered a URL in Internet Explorer 5, its sequence of startup
packets didn't look like the one shown above. Instead, it looked like
this:

Client Server
1. Request ->
Uh... what? Dunno what the hell this is. I'll ignore it, or RST.
2. Oh, you're a standard server. Okay: SYN ->
3. <- SYN/ACK
4. ACK ->
5. Request ->


In other words, instead of sending a SYN packet like every other
TCP/IP application in the world, IE would send out the request packet
first of all. Just to check. Just in case the HTTP server was, oh,
say, a Microsoft IIS server. Because IIS' HTTP teardown sequence
looked like this:

Client Server
1. <- FIN
2. ACK ->

...And that's it. The client doesn't FIN, and the server doesn't
ACK. In other words, the connection is kept "half-open" on the server
end. The reason for this? Why, to make subsequent connections from IE
clients faster. If the connection isn't torn down all the way, all IE
has to do is send an HTTP request, with no preamble-- and the server
will immediately respond. Ingenious!

They probably called it "Microsoft Active Web AccelerationX



******

TCP fingerprinting:

  http://www.insecure.org/nmap/nmap-fingerprinting-article.html

******

Why it's a good idea to set socket buffers to at least 3*MSS: Stevens,
UNPv1p192, and Message-ID: <3e1f9c72_2@omega.dimensional.com> on
comp.protocols.tcp-ip.

******

Different behaviour in NetBSD re bind():

> SECURITY CONSIDERATIONS
>
> bind() was changed in NetBSD 1.4 to prevent the binding of a socket to
> the same port as an existing socket when all of the following is true:
>    +   either of the existing or new addresses is INADDR_ANY,
>    +   the uid of the new socket is not root, and the uids of the cre-
>        ators of the sockets are different,
>    +   the address is not a multicast address, and
>    +   both sockets are not bound to INADDR_ANY with SO_REUSEPORT set.
>
> This prevents an attack where a user could bind to a port with the
> host's IP address (after setting SO_REUSEADDR) and `steal' packets
> destined for a server that bound to the same port with INADDR_ANY.

From: arielgont@softhome.net (Fernando Gont)
Newsgroups: comp.protocols.tcp-ip
Subject: Re: Question regarding port number
Date: Fri, 14 Feb 2003 04:37:37 GMT
Message-ID: <3e4c0cfe.1797845@News.CIS.DFN.DE>

******

Discussion of using connect with AF_UNSPEC to perform disconnect: in
the thread around

From: James Carlson <james.d.carlson@sun.com>
Newsgroups: comp.protocols.tcp-ip
Subject: Re: How do I reconnect using connected UDP?
Date: 02 Apr 2003 09:59:17 -0500
Message-ID: <xoav65pxeyii.fsf@sun.com>

******

Difference in shutdown/close between Win and Unix: thread around

From: Barry Margolin <barry.margolin@level3.com>
Newsgroups: comp.protocols.tcp-ip
Subject: Re: 'connection reset by peer' errors?
Message-ID: <hYVka.1$HL5.44@paloalto-snr1.gtei.net>
Date: Wed, 09 Apr 2003 14:17:49 GMT

******

select() considered inefficient; use something native instead:

http://tangentsoft.net/wskfaq/articles/io-strategies.html  (see
Heuristic 3 in particular)

******

Difference in behaviour of accept()ed socket:

Thread around

  From: Michael Kerrisk <michael.kerrisk@freenet.de>
  Newsgroups: comp.protocols.tcp-ip
  Subject: Re: accept() socket state
  Date: Fri, 25 Apr 2003 07:09:36 +0200
  Message-ID: <gmghavs250gpvfrpjdetsr9kdb1qjdhun6@4ax.com>

  On Thu, 24 Apr 2003 17:45:06 +0200, "Gisle Vanem"
  <gvanem@broadpark.no> wrote:

  >If a non-blocking listen socket is used in accept(), should the
  >created socket also be non-blocking?
  >
  >My HP-UX man-page says:
  > "...  accept() extracts the first connection on the queue of pending
  >  connections, creates a new socket with the
  > same properties as s, and returns a new file descriptor..."
  >
  >The clue here is "same properties". So my gut feeling is
  >yes, but I'm not sure. What is the BSD way?

  There is variation across implementations.  BSDs inherit O_NONBLOCK
  across accept.  Linux does not.

  Cheers

  Michael

Further:

  Newsgroups: comp.protocols.tcp-ip
  From: alun@texis.com (Alun Jones)
  Subject: Re: accept() socket state
  Message-ID: <Ekbqa.1328$j41.745623651@newssvr30.news.prodigy.com>
  Date: Fri, 25 Apr 2003 14:09:40 GMT

  In case it matters to anyone, Winsock requires that blocking / non-blocking
  status be carried over from listener to accepted child socket.  Otherwise it
  wouldn't be able to achieve the effect of carrying over the WSAAsyncSelect /
  WSAEventSelect mappings, which are a requirement.

******

Keepalives automatically enabled in close():

  From: Rick Jones <foo@bar.baz.invalid>
  Subject: Re: FIN_WAIT socket killer
  Newsgroups: comp.protocols.tcp-ip
  Message-ID: <3vbqb.8481$aE5.4507@news.cpqcorp.net>
  Date: Wed, 05 Nov 2003 18:41:03 GMT

  Another way to deal with that is for the application to enable TCP
  keepalives. Those will (generally?) remain active in FIN_WAIT_2 and
  can thus "cull" orphaned FIN_WAIT_2 connections.  Some stacks (HP-UX
  11, perhaps others) will automagically enable TCP keepalives when an
  application calls close().

******

Message-ID: <e22e96da.0404140953.5a3f4432@posting.google.com>
Thread:
  http://groups.google.com/groups?hl=en&lr=&ie=UTF-8&oe=UTF-8&threadm=1257464%40news1.IPSWITCHS.CMM

Partial ACKs don't reset the rexmt counter on some OS.

******


API design issues
~~~~~~~~~~~~~~~~~

Design-for-test for protocols: if one has a protocol spec and an
implementation that more-or-less necessarily follows it in detail, as
we do for TCP, the API should make it possible to see any endpoint
state and any state transitions, to make it possible to do what we're
doing much more easily.

The sockets API for TCP does not (P reckons) reveal enough about its
network state estimators: for prompt application adjustment in the
face of congestion, partition, or crash, the application would like to
know eg how the RTT is changing.

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=- End of File -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
