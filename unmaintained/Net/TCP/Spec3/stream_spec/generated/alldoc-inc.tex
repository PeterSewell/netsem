% auto-generated file; do not edit
\RequirePackage{ltsmunge}
\RequirePackage{tcp}

\let\mignore\relax
\newcommand{\mignore}[1]{}

\def\rulesrcsid{}

% load as late as possible
\RequirePackage[pdfpagelabels,linktocpage,colorlinks,linkcolor=blue,pagecolor=blue]{hyperref}
% Ugh, get rid of annoying warnings.  We will hope that the substitutions
% hyperref does to get a PDF-safe string for the various anchors are OK.
\makeatletter
\def\HyPsd@CatcodeWarning#1{}
\makeatother

\let\dumpallrules\relax
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore utils

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPITutils}{\chaptersection{ Utility functions}
\label{TCP1_utils}%
\chapcomm{
This file contains various utility functions and definitions, for functions, lists, and numeric types, that are
used throughout the specification.


}
}

\newcommand{\seccommutilTstuff}{\clustersection{}{Basic utilities}
\seccomm{
Basic utilities for functions, numbers, maps, and records.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{funupd}$
&
&  update one point of a function\\
$\tsrule{funupd\_list}$
&
&  update multiple points of a function\\
$\tsrule{clip\_int\_to\_num}$
&
&  clip $\tstype{int}$ to $\tstype{num}$ \\
$\tsrule{left\_shift\_num}$
&
&  left shift, written $\ll $ \\
$\tsrule{right\_shift\_num}$
&
&  right shift, written $\gg $ \\
$\tsrule{rounddown}$
&
&  round $\tsunknown{v}$ down to multiple of $\tsunknown{bs}$, unless $\tsunknown{v} < \tsunknown{bs}$ already \\
$\tsrule{roundup}$
&
&  round $\tsunknown{v}$ up to next multiple of $\tsunknown{bs}$; if $\tsunknown{v} = \tsunknown{k}*\tsunknown{bs}$ then no change \\
$\tsrule{real\_of\_int}$
&
&  inject $\tstype{int}$ into $\tsunknown{real}$ \\
$\tsrule{num\_floor}$
&
&  $\tstype{num}$ floor of $\tsunknown{real}$ \\
$\tsrule{num\_floor\_and\_frac}$
&
&  $\tstype{num}$ floor and fractional part of $\tsunknown{real}$ \\
$\tsrule{fm\_exists}$
&
&  finite map exists, written $\exists (\tsunknown{k},\tsunknown{v}) \Mcons  \tsunknown{fm} . \tsunknown{P} (\tsunknown{k},\tsunknown{v})$ \\
$\tsrule{onlywhen}$
&
&  used for conditional record updates \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnfunupd}{\ddefnc{funupd}{\iA{funupd}}{\subddefnA[{ update one point of a function}]{funupd}{\Mfupdate{\tsunknown{f}}{\tsunknown{x}}{\tsunknown{y}} = \lambda \tsvar{x}'. \Mif  \;\tsvar{x}'=\tsunknown{x} \;\Mthen  \;\tsunknown{y} \;\Melse  \;\tsunknown{f} \;\tsvar{x}'}
}
{}
}

\newcommand{\defnfunupdTlist}{\ddefnc{funupdTlist}{\iA{funupd\_list}}{\subddefnA[{ update multiple points of a function}]{funupd\_list}{\tsaux{funupd\_list} \;\tsvar{f} \;\tsunknown{xys} = \tsholop{FOLDL} (\lambda \tsvar{f} (\tsunknown{x},\tsunknown{y}). \Mfupdate{\tsvar{f}}{\tsunknown{x}}{\tsunknown{y}}) \tsvar{f} \;\tsunknown{xys}}
}
{}
}

\newcommand{\defnclipTintTtoTnum}{\ddefnc{clipTintTtoTnum}{\iA{clip\_int\_to\_num}}{\subddefnA[{ clip $\tstype{int}$ to $\tstype{num}$ }]{clip\_int\_to\_num}{\tsaux{clip\_int\_to\_num} (\tsunknown{i}:\tstype{int}) = \Mif  \;\tsunknown{i} < 0 \;\Mthen  \;0 \;\Melse  \;\tsholop{Num} \;\tsunknown{i}}
}
{}
}

\newcommand{\defnleftTshiftTnum}{\ddefnc{leftTshiftTnum}{\iA{left\_shift\_num}}{\subddefnA[{ left shift, written $\ll $ }]{left\_shift\_num}{\tsaux{left\_shift\_num} (\tsvar{n}:\tstype{num}) (\tsunknown{i}:\tstype{num}) = \tsvar{n} * 2 \;\Mexp  \;\tsunknown{i}}
}
{}
}

\newcommand{\defnrightTshiftTnum}{\ddefnc{rightTshiftTnum}{\iA{right\_shift\_num}}{\subddefnA[{ right shift, written $\gg $ }]{right\_shift\_num}{\tsaux{right\_shift\_num} (\tsvar{n}:\tstype{num}) (\tsunknown{i}:\tstype{num}) = \tsvar{n} \;\tsholop{DIV} \;2 \;\Mexp  \;\tsunknown{i}}
}
{}
}

\newcommand{\defnrounddown}{\ddefnc{rounddown}{\iA{rounddown}}{\subddefnA[{ round $\tsunknown{v}$ down to multiple of $\tsunknown{bs}$, unless $\tsunknown{v} < \tsunknown{bs}$ already }]{rounddown}{\tsaux{rounddown} \;\tsunknown{bs} \;\tsunknown{v} = \Mif  \;\tsunknown{v} < \tsunknown{bs} \;\Mthen  \;\tsunknown{v} \;\Melse  (\tsunknown{v} \;\tsholop{DIV} \;\tsunknown{bs}) * \tsunknown{bs}}
}
{}
}

\newcommand{\defnroundup}{\ddefnc{roundup}{\iA{roundup}}{\subddefnA[{ round $\tsunknown{v}$ up to next multiple of $\tsunknown{bs}$; if $\tsunknown{v} = \tsunknown{k}*\tsunknown{bs}$ then no change }]{roundup}{\tsaux{roundup}   \;\tsunknown{bs} \;\tsunknown{v} = ((\tsunknown{v} + (\tsunknown{bs} - 1)) \tsholop{DIV} \;\tsunknown{bs}) * \tsunknown{bs}}
}
{}
}

\newcommand{\defnrealTofTint}{\ddefnc{realTofTint}{\iA{real\_of\_int}}{\subddefnA[{ inject $\tstype{int}$ into $\tsunknown{real}$ }]{real\_of\_int}{\tsaux{real\_of\_int} (\tsunknown{i}:\tstype{int}) = \Mif  \;\tsunknown{i} < 0 \;\Mthen  \neg{}(\tsholop{real\_of\_num} (\tsholop{Num} \neg{}\tsunknown{i})){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsholop{real\_of\_num} (\tsholop{Num} \;\tsunknown{i})}
}
{}
}

\newcommand{\defnnumTfloor}{\ddefnc{numTfloor}{\iA{num\_floor}}{\subddefnA[{ $\tstype{num}$ floor of $\tsunknown{real}$ }]{num\_floor}{\tsaux{num\_floor} (\tsunknown{x}:\tsunknown{real}) = \tsholop{LEAST} (\tsvar{n}:\tstype{num}). \tsholop{real\_of\_num} (\tsvar{n}+1) > \tsunknown{x}}
}
{}
}

\newcommand{\defnnumTfloorTandTfrac}{\ddefnc{numTfloorTandTfrac}{\iA{num\_floor\_and\_frac}}{\subddefnA[{ $\tstype{num}$ floor and fractional part of $\tsunknown{real}$ }]{num\_floor\_and\_frac}{\tsaux{num\_floor\_and\_frac} (\tsunknown{x}:\tsunknown{real}){}\\{}
 = \Mlet  \;\tsvar{n} = \tsholop{LEAST} (\tsvar{n}:\tstype{num}). \tsholop{real\_of\_num} (\tsvar{n}+1) > \tsunknown{x}{}\\{}
 \Min {}\\{}
 (\tsvar{n},\tsunknown{x} - \tsholop{real\_of\_num} \;\tsvar{n})}
}
{}
}

\newcommand{\defnfmTexists}{\ddefnc{fmTexists}{\iA{fm\_exists}}{\subddefnA[{ finite map exists, written $\exists (\tsunknown{k},\tsunknown{v}) \Mcons  \tsunknown{fm} . \tsunknown{P} (\tsunknown{k},\tsunknown{v})$ }]{fm\_exists}{\tsaux{fm\_exists} \;\tsunknown{fm} \;\tsunknown{P} = \exists \tsvar{k}. \tsvar{k} \;\in  \Mfdom{\tsunknown{fm}} \Mwedge  \tsunknown{P} (\tsvar{k}, \tsunknown{fm} \Mfapply{}{\tsvar{k}})}
}
{}
}

\newcommand{\defnonlywhen}{\ddefnc{onlywhen}{\iA{onlywhen}}{\subddefnA[{ used for conditional record updates }]{onlywhen}{(\tsunknown{x} \;\tsholop{onlywhen} \;\tsvar{b}) = \Mif  \;\tsvar{b} \;\Mthen  \;\tsunknown{K} \;\tsunknown{x} \;\Melse  \;\MI }
}
{\rrulepad }
}

\newcommand{\seccommutilTlists}{\clustersection{}{List utilities}
\seccomm{This section contains a number of basic functions for manipulating lists.

}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{SPLIT\_REV\_0}$
&
&  split worker function\\
$\tsrule{SPLIT\_REV}$
&
&  split a list after $\tsvar{n}$ elements, returning the reversed prefix
and the remainder\\
$\tsrule{SPLIT}$
&
&  split a list after $\tsvar{n}$ elements, returning the prefix and the remainder\\
$\tsrule{TAKE}$
&
&  take the first $\tsvar{n}$ elements of a list\\
$\tsrule{DROP}$
&
&  drop the first $\tsvar{n}$ elements of a list\\
$\tsrule{TAKEWHILE\_REV}$
&
&  split a list at first element not satisfying $\tsunknown{p}$, returning reversed prefix and remainder\\
$\tsrule{TAKEWHILE}$
&
&  split a list at first element not satisfying $\tsunknown{p}$, returning prefix and remainder\\
$\tsrule{REPLICATE}$
&
&  make a list of $\tsvar{n}$ copies of $\tsunknown{x}$\\
$\tsrule{decr\_list}$
&
&  decrement a list of nums by a num, dropping any that count below zero\\
$\tsrule{NOTIN'}$
&
&  not in \\
$\tsrule{MAP\_OPTIONAL}$
&
&  map with optional result\\
$\tsrule{CONCAT\_OPTIONAL}$
&
&  concatentation of option list that drops all $*$s\\
$\tsrule{ORDERINGS}$
&
&  the set of all orderings of a set \\
$\tsrule{INSERT\_ORDERED}$
&
&  insert ordered\end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnSPLITTREVTZ}{\ddefnc{SPLITTREVTZ}{\iA{SPLIT\_REV\_0}}{\subddefnA[{ split worker function}]{SPLIT\_REV\_0}{(\tsaux{SPLIT\_REV\_0}      \;0  \;\tsunknown{ls}     \;\tsunknown{rs}  = (\tsunknown{ls},\tsunknown{rs})) \Mwedge {}\\{}
 (\tsaux{SPLIT\_REV\_0} (\tsunknown{SUC} \;\tsvar{n}) \tsunknown{ls} (\tsunknown{r}\Mcons \tsunknown{rs}) = \tsaux{SPLIT\_REV\_0} \;\tsvar{n} (\tsunknown{r}\Mcons \tsunknown{ls}) \tsunknown{rs}) \Mwedge {}\\{}
 (\tsaux{SPLIT\_REV\_0} (\tsunknown{SUC} \;\tsvar{n}) \tsunknown{ls}     [\,]  = (\tsunknown{ls},[\,]))}
}
{}
}

\newcommand{\defnSPLITTREV}{\ddefnc{SPLITTREV}{\iA{SPLIT\_REV}}{\subddefnA[{ split a list after $\tsvar{n}$ elements, returning the reversed prefix
and the remainder}]{SPLIT\_REV}{\tsaux{SPLIT\_REV} \;\tsvar{n} \;\tsunknown{rs} = \tsaux{SPLIT\_REV\_0} \;\tsvar{n} [\,] \tsunknown{rs}}
}
{}
}

\newcommand{\defnSPLIT}{\ddefnc{SPLIT}{\iA{SPLIT}}{\subddefnA[{ split a list after $\tsvar{n}$ elements, returning the prefix and the remainder}]{SPLIT}{\tsaux{SPLIT} \;\tsvar{n} \;\tsunknown{rs} = \Mlet  (\tsunknown{ls},\tsunknown{rs}) = \tsaux{SPLIT\_REV} \;\tsvar{n} \;\tsunknown{rs} \;\Min  (\tsunknown{REVERSE} \;\tsunknown{ls},\tsunknown{rs})}
}
{}
}

\newcommand{\defnTAKE}{\ddefnc{TAKE}{\iA{TAKE}}{\subddefnA[{ take the first $\tsvar{n}$ elements of a list}]{TAKE}{\tsaux{TAKE} \;\tsvar{n} \;\tsunknown{rs} = \Mlet  (\tsunknown{ls},\tsunknown{rs}) = \tsaux{SPLIT\_REV} \;\tsvar{n} \;\tsunknown{rs} \;\Min  \;\tsunknown{REVERSE} \;\tsunknown{ls}}
}
{}
}

\newcommand{\defnDROP}{\ddefnc{DROP}{\iA{DROP}}{\subddefnA[{ drop the first $\tsvar{n}$ elements of a list}]{DROP}{\tsaux{DROP} \;\tsvar{n} \;\tsunknown{rs} = \Mlet  (\tsunknown{ls},\tsunknown{rs}) = \tsaux{SPLIT\_REV} \;\tsvar{n} \;\tsunknown{rs} \;\Min  \;\tsunknown{rs}}
}
{}
}

\newcommand{\defnTAKEWHILETREV}{\ddefnc{TAKEWHILETREV}{\iA{TAKEWHILE\_REV}}{\subddefnA[{ split a list at first element not satisfying $\tsunknown{p}$, returning reversed prefix and remainder}]{TAKEWHILE\_REV}{\tsaux{TAKEWHILE\_REV} \;\tsunknown{p} \;\tsunknown{ls} (\tsunknown{r}\Mcons \tsunknown{rs}) = \tsaux{TAKEWHILE\_REV} \;\tsunknown{p} (\Mif  \;\tsunknown{p} \;\tsunknown{r} \;\Mthen  (\tsunknown{r}\Mcons \tsunknown{ls}) \Melse  \;\tsunknown{ls}) \tsunknown{rs} \Mwedge {}\\{}
 \tsaux{TAKEWHILE\_REV} \;\tsunknown{p} \;\tsunknown{ls}     [\,]  = \tsunknown{ls}}
}
{}
}

\newcommand{\defnTAKEWHILE}{\ddefnc{TAKEWHILE}{\iA{TAKEWHILE}}{\subddefnA[{ split a list at first element not satisfying $\tsunknown{p}$, returning prefix and remainder}]{TAKEWHILE}{\tsaux{TAKEWHILE} \;\tsunknown{p} \;\tsunknown{rs} = \tsunknown{REVERSE} (\tsaux{TAKEWHILE\_REV} \;\tsunknown{p} [\,] \tsunknown{rs})}
}
{}
}

\newcommand{\defnREPLICATE}{\ddefnc{REPLICATE}{\iA{REPLICATE}}{\subddefnA[{ make a list of $\tsvar{n}$ copies of $\tsunknown{x}$}]{REPLICATE}{(\tsaux{REPLICATE}      \;0  \;\tsunknown{x} = [\,]) \Mwedge {}\\{}
 (\tsaux{REPLICATE} (\tsunknown{SUC} \;\tsvar{n}) \tsunknown{x} = \tsunknown{x} \Mcons  \tsaux{REPLICATE} \;\tsvar{n} \;\tsunknown{x})}
}
{}
}

\newcommand{\defndecrTlist}{\ddefnc{decrTlist}{\iA{decr\_list}}{\subddefnA[{ decrement a list of nums by a num, dropping any that count below zero}]{decr\_list}{((\tsaux{decr\_list} : \tstype{num} \Mtotype  \tstype{num} \;\tstype{list} \Mtotype  \tstype{num} \;\tstype{list}){}\\{}
\quad\quad\quad\quad \tsunknown{d} [\,] = [\,]) \Mwedge {}\\{}
 (\tsaux{decr\_list} \;\tsunknown{d} (\tsvar{n}\Mcons \tsunknown{ns}) = (\Mif  \;\tsvar{n} < \tsunknown{d} \;\Mthen  \;\MI  \;\Melse  \;\tsunknown{CONS} (\tsvar{n}-\tsunknown{d})) (\tsaux{decr\_list} \;\tsunknown{d} \;\tsunknown{ns}))}
}
{}
}

\newcommand{\defnNOTINT}{\ddefnc{NOTINT}{\iA{NOTIN'}}{\subddefnA[{ not in }]{NOTIN'}{(\tsunknown{x} \;\notin  \;\tsunknown{y}) = \neg{}(\tsholop{MEM}\Mspii{\tsunknown{x}}{\tsunknown{y}})}
}
{}
}

\newcommand{\defnMAPTOPTIONAL}{\ddefnc{MAPTOPTIONAL}{\iA{MAP\_OPTIONAL}}{\subddefnA[{ map with optional result}]{MAP\_OPTIONAL}{\tsaux{MAP\_OPTIONAL} \;\tsunknown{f} (\tsunknown{x}\Mcons \tsunknown{xs}) = % TCP1_utilsScript.sml:311:46-312:-1:WARNING: curry parse failed: APPEND ==> \Mappend 7: line break not allowed in non-multiline curried op.
\tsholop{APPEND} (\Mcase  \;\tsunknown{f} \;\tsunknown{x} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad * \Mtotype  [\,]{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mdpipe  \Msome  \;\tsunknown{y} \Mtotype  [\tsunknown{y}]){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsaux{MAP\_OPTIONAL} \;\tsunknown{f} \;\tsunknown{xs}) \Mwedge {}\\{}
 \tsaux{MAP\_OPTIONAL} \;\tsunknown{f} [\,]      = [\,]}
}
{}
}

\newcommand{\defnCONCATTOPTIONAL}{\ddefnc{CONCATTOPTIONAL}{\iA{CONCAT\_OPTIONAL}}{\subddefnA[{ concatentation of option list that drops all $*$s}]{CONCAT\_OPTIONAL}{\tsaux{CONCAT\_OPTIONAL} \;\tsunknown{xs} = \tsaux{MAP\_OPTIONAL} \;\MI  \;\tsunknown{xs}}
}
{}
}

\newcommand{\defnORDERINGS}{\ddefnc{ORDERINGS}{\iA{ORDERINGS}}{\subddefnA[{ the set of all orderings of a set }]{ORDERINGS}{\tsaux{ORDERINGS} \;\tsunknown{s} \;\tsunknown{l} = (\tsholop{LIST\_TO\_SET} \;\tsunknown{l} = \tsunknown{s} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsholop{LENGTH} \;\tsunknown{l}      = \tsholop{CARD} \;\tsunknown{s})}
}
{}
}

\newcommand{\defnINSERTTORDERED}{\ddefnn{INSERTTORDERED}{\iA{INSERT\_ORDERED}}{\subddefnA[{ insert ordered}]{INSERT\_ORDERED}{\tsaux{INSERT\_ORDERED} \;\tsunknown{new} \;\tsunknown{old} \;\tsunknown{bad} ={}\\{}
 \tsholop{FILTER} (\lambda \tsvar{fd}. \tsvar{fd} \;\in  \;\tsunknown{new} \Mvee  \tsvar{fd} \;\in  \;\tsunknown{bad}) \tsunknown{old}}
}
{}
}

\newcommand{\seccommutilTassertions}{\clustersection{}{Assertions}
\seccomm{This definition is an alias for false, which induces the checker to
emit a special message indicating an assertion failure.

}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{ASSERTION\_FAILURE}$
&
&  assertion failure (causes checker to halt) \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnASSERTIONTFAILURE}{\ddefnn{ASSERTIONTFAILURE}{\iA{ASSERTION\_FAILURE}}{\subddefnA[{ assertion failure (causes checker to halt) }]{ASSERTION\_FAILURE}{\tsaux{ASSERTION\_FAILURE} (\tsunknown{s}:\tstype{string}) = \Mfalse }
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPITutils}
\showrule{\seccommutilTstuff}
\showrule{\defnfunupd}
\showrule{\defnfunupdTlist}
\showrule{\defnclipTintTtoTnum}
\showrule{\defnleftTshiftTnum}
\showrule{\defnrightTshiftTnum}
\showrule{\defnrounddown}
\showrule{\defnroundup}
\showrule{\defnrealTofTint}
\showrule{\defnnumTfloor}
\showrule{\defnnumTfloorTandTfrac}
\showrule{\defnfmTexists}
\showrule{\defnonlywhen}
\showrule{\seccommutilTlists}
\showrule{\defnSPLITTREVTZ}
\showrule{\defnSPLITTREV}
\showrule{\defnSPLIT}
\showrule{\defnTAKE}
\showrule{\defnDROP}
\showrule{\defnTAKEWHILETREV}
\showrule{\defnTAKEWHILE}
\showrule{\defnREPLICATE}
\showrule{\defndecrTlist}
\showrule{\defnNOTINT}
\showrule{\defnMAPTOPTIONAL}
\showrule{\defnCONCATTOPTIONAL}
\showrule{\defnORDERINGS}
\showrule{\defnINSERTTORDERED}
\showrule{\seccommutilTassertions}
\showrule{\defnASSERTIONTFAILURE}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore errors

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPITerrors}{\chaptersection{ Error codes}
\label{TCP1_errors}%
\chapcomm{
This file contains the datatype of all possible error codes.  The
names are generally the common Unix ones; in the case of Winsock, the
obvious mapping is used.  Not all error codes are used in the body of the specification; those that are are described in the `Errors' section of each socket call.



}
}

\newcommand{\seccommerrorsTerror}{\clustersection{}{The type of errors}
\seccomm{
The union of all (relevant) errors on the supported architectures.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{error}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnerror}{\ddefnn{error}{\iA{error}}{\subddefnA{error}{\tstype{error} ={}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscon{E2BIG}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EACCES}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EADDRINUSE}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EADDRNOTAVAIL}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EAFNOSUPPORT}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EAGAIN}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EWOULDBLOCK} \tsholcomm{ only used if $\tscon{EWOULDBLOCK} \neq  \tscon{EAGAIN}$ }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EALREADY}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EBADF}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EBADMSG}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EBUSY}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ECANCELED}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ECHILD}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ECONNABORTED}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ECONNREFUSED}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ECONNRESET}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EDEADLK}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EDESTADDRREQ}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EDOM}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EDQUOT}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EEXIST}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EFAULT}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EFBIG}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EHOSTUNREACH}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EIDRM}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EILSEQ}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EINPROGRESS}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EINTR}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EINVAL}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EIO}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EISCONN}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EISDIR}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ELOOP}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EMFILE}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EMLINK}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EMSGSIZE}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EMULTIHOP}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENAMETOOLONG}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENETDOWN}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENETRESET}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENETUNREACH}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENFILE}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOBUFS}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENODATA}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENODEV}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOENT}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOEXEC}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOLCK}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOLINK}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOMEM}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOMSG}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOPROTOOPT}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOSPC}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOSR}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOSTR}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOSYS}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOTCONN}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOTDIR}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOTEMPTY}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOTSOCK}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOTSUP}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENOTTY}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ENXIO}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EOPNOTSUPP}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EOVERFLOW}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EPERM}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EPIPE}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EPROTO}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EPROTONOSUPPORT}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EPROTOTYPE}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ERANGE}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EROFS}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ESPIPE}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ESRCH}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ESTALE}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ETIME}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ETIMEDOUT}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ETXTBSY}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EXDEV}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{ESHUTDOWN}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{EHOSTDOWN}}
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPITerrors}
\showrule{\seccommerrorsTerror}
\showrule{\defnerror}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore signals

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPITsignals}{\chaptersection{ Signal names}
\label{TCP1_signals}%
\chapcomm{
This file contains the datatype of signal names, with all the signals
known to POSIX, Linux, and BSD.  The specification does not model signal behaviour in detail, however: it treats them very nondeterministically.


}
}

\newcommand{\seccommsignalsTsignal}{\clustersection{}{The type of signals}
\seccomm{
The union of the signals suported by the target architectures.  Names
based on POSIX.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{signal}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnsignal}{\ddefnn{signal}{\iA{signal}}{\subddefnA{signal}{\tstype{signal} = \tscon{SIGABRT}{}\\{}
\quad\quad \mid  \tscon{SIGALRM}{}\\{}
\quad\quad \mid  \tscon{SIGBUS}{}\\{}
\quad\quad \mid  \tscon{SIGCHLD}{}\\{}
\quad\quad \mid  \tscon{SIGCONT}{}\\{}
\quad\quad \mid  \tscon{SIGFPE}{}\\{}
\quad\quad \mid  \tscon{SIGHUP}{}\\{}
\quad\quad \mid  \tscon{SIGILL}{}\\{}
\quad\quad \mid  \tscon{SIGINT}{}\\{}
\quad\quad \mid  \tscon{SIGKILL}{}\\{}
\quad\quad \mid  \tscon{SIGPIPE}{}\\{}
\quad\quad \mid  \tscon{SIGQUIT}{}\\{}
\quad\quad \mid  \tscon{SIGSEGV}{}\\{}
\quad\quad \mid  \tscon{SIGSTOP}{}\\{}
\quad\quad \mid  \tscon{SIGTERM}{}\\{}
\quad\quad \mid  \tscon{SIGTSTP}{}\\{}
\quad\quad \mid  \tscon{SIGTTIN}{}\\{}
\quad\quad \mid  \tscon{SIGTTOU}{}\\{}
\quad\quad \mid  \tscon{SIGUSR1}{}\\{}
\quad\quad \mid  \tscon{SIGUSR2}{}\\{}
\quad\quad \mid  \tscon{SIGPOLL}    \tscomm{ XSI only }{}\\{}
\quad\quad \mid  \tscon{SIGPROF}    \tscomm{ XSI only }{}\\{}
\quad\quad \mid  \tscon{SIGSYS}     \tscomm{ XSI only }{}\\{}
\quad\quad \mid  \tscon{SIGTRAP}    \tscomm{ XSI only }{}\\{}
\quad\quad \mid  \tscon{SIGURG}{}\\{}
\quad\quad \mid  \tscon{SIGVTALRM}  \tscomm{ XSI only }{}\\{}
\quad\quad \mid  \tscon{SIGXCPU}    \tscomm{ XSI only }{}\\{}
\quad\quad \mid  \tscon{SIGXFSZ}    \tscomm{ XSI only }}
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPITsignals}
\showrule{\seccommsignalsTsignal}
\showrule{\defnsignal}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore baseTypes

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
% TCP1_baseTypesScript.sml:404:61-71:         WARNING: Ignoring ``...`` item possibly tagged by constructors_of
\def\rulesrcsid{\$Id: alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPITbaseTypes}{\chaptersection{ Base types}
\label{TCP1_baseTypes}%
\chapcomm{
This file defines basic types used throughout the specification.
%including
%types for ports, IP addresses, and file descriptors; types of file and socket flags used in the sockets API;
%
%
%the language types and the time and duration
%types.


}
}

\newcommand{\seccommbaseTos}{\clustersection{(TCP and UDP)}{Network and OS-related types}
\seccomm{
The specification distinguishes between the types $\tstype{port}$ and $\tstype{ip}$,
for which we do not use the zero values, and option types $\tstype{port} \;\;\tstype{option}$ and
$\tstype{ip} \;\;\tstype{option}$, with values $*$ (modelling the zero values) and $\Msome  \;\tsunknown{p}$ and $\Msome  \;\tsunknown{i}$, modelling the non-zero values.
Zero values are used as wildcards in some places and are forbidden in others;
this typing lets that be captured explicitly.

}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{port}$
&
& \\
$\tsrule{ip}$
&
& \\
$\tsrule{ifid}$
&
& \\
$\tsrule{netmask}$
&
& \\
$\tsrule{fd}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnport}{\ddefnc{port}{\iA{port}}{\subddefnA{port}{\tstype{port} = \tscon{Port} \;\Mof  \;\tstype{num} \tsholcomm{ really 16 bits, non-zero }}
}
{\rulesubsection{Description}
TCP or UDP port number, non-zero.

\rrulepad }
}

\newcommand{\defnip}{\ddefnc{ip}{\iA{ip}}{\subddefnA{ip}{\tstype{ip}   = \tstype{ip} \;\Mof  \;\tstype{num} \tsholcomm{ really 32 bits, non-zero }}
}
{\rulesubsection{Description}
IPv4 address, non-zero.

\rrulepad }
}

\newcommand{\defnifid}{\ddefnc{ifid}{\iA{ifid}}{\subddefnA{ifid}{\tsvar{ifid} = \tscon{LO} \mid  \tscon{ETH} \;\Mof  \;\tstype{num}}
}
{\rulesubsection{Description}
Interface ID: either the loopback interface, or a numbered Ethernet interface.

\rrulepad }
}

\newcommand{\defnnetmask}{\ddefnc{netmask}{\iA{netmask}}{\subddefnA{netmask}{\tsvar{netmask} = \tscon{NETMASK} \;\Mof  \;\tstype{num}}
}
{\rulesubsection{Description}
Network mask, represented as the number of 1 bits (as in a CIDR /nn
suffix).

\rrulepad }
}

\newcommand{\defnfd}{\ddefnc{fd}{\iA{fd}}{\subddefnA{fd}{\tstype{fd} = \tscon{FD} \;\Mof  \;\tstype{num}}
}
{\rulesubsection{Description}
File descriptor.  On Unix-like systems this is a small nonnegative
integer; on Windows it is an arbitrary handle.

\rrulepad }
}

\newcommand{\seccommbaseTflags}{\clustersection{(TCP and UDP)}{File and socket flags}
\seccomm{
This defines the types of various flags used in the sockets API: file flags, socket flags, message flags (used in $\tslib{send}$ and $\tslib{recv}$ calls), and socket types (used in $\tslib{socket}$ calls).  The socket flags are partitioned into those with boolean, natural-number and time-valued arguments.

}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{filebflag}$
&
& \\
$\tsrule{sockbflag}$
&
& \\
$\tsrule{socknflag}$
&
& \\
$\tsrule{socktflag}$
&
& \\
$\tsrule{msgbflag}$
&
& \\
$\tsrule{socktype}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnfilebflag}{\ddefnc{filebflag}{\iA{filebflag}}{\subddefnA{filebflag}{\tstype{filebflag} = \tscon{O\_NONBLOCK}{}\\{}
\quad\quad\quad\quad \mid  \tscon{O\_ASYNC}}
}
{\rulesubsection{Description}
Boolean flags affecting the behaviour of an open file (or socket).

$\tscon{O\_NONBLOCK}$ makes all operations on this file (or socket) nonblocking.

$\tscon{O\_ASYNC}$ specifies whether signal driven I/O is enabled.


\rrulepad }
}

\newcommand{\defnsockbflag}{\ddefnc{sockbflag}{\iA{sockbflag}}{\subddefnA{sockbflag}{\tstype{sockbflag} = \tscon{SO\_BSDCOMPAT} \tscomm{ Linux only }{}\\{}
\quad\quad\quad\quad \mid  \tscon{SO\_REUSEADDR}{}\\{}
\quad\quad\quad\quad \mid  \tscon{SO\_KEEPALIVE}{}\\{}
\quad\quad\quad\quad \mid  \tscon{SO\_OOBINLINE} \tscomm{ ? }{}\\{}
\quad\quad\quad\quad \mid  \tscon{SO\_DONTROUTE}}
}
{\rulesubsection{Description}
Boolean flags affecting the behaviour of a socket.

     $\tscon{SO\_BSDCOMPAT}$ Specifies whether the BSD semantics for delivery of ICMPs to UDP sockets
     with no peer address set is enabled.

     $\tscon{SO\_DONTROUTE}$ Requests that outgoing messages bypass the standard routing
     facilities. The destination shall be on a directly-connected network, and messages are directed
     to the appropriate network interface according to the destination address.

    $\tscon{SO\_KEEPALIVE}$ Keeps connections active by enabling the periodic transmission of
     messages, if this is supported by the protocol.

     $\tscon{SO\_OOBINLINE}$ Leaves received out-of-band data (data marked urgent) inline.

     $\tscon{SO\_REUSEADDR}$ Specifies that the rules used in validating addresses supplied to
     $\tslib{bind}()$ should allow reuse of local ports, if this is supported by the protocol.


\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
& The flag $\tscon{SO\_BSDCOMPAT}$ is Linux-only.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\defnsocknflag}{\ddefnc{socknflag}{\iA{socknflag}}{\subddefnA{socknflag}{\tstype{socknflag} = \tscon{SO\_SNDBUF}{}\\{}
\quad\quad\quad\quad \mid  \tscon{SO\_RCVBUF}{}\\{}
\quad\quad\quad\quad \mid  \tscon{SO\_SNDLOWAT}{}\\{}
\quad\quad\quad\quad \mid  \tscon{SO\_RCVLOWAT}}
}
{\rulesubsection{Description}
Natural-number flags affecting the behaviour of a socket.

     $\tscon{SO\_SNDBUF}$ Specifies the send buffer size.

     $\tscon{SO\_RCVBUF}$ Specifies the receive buffer size.

     $\tscon{SO\_SNDLOWAT}$ Specifies the minimum number of bytes to process for socket output
      operations.

     $\tscon{SO\_RCVLOWAT}$ Specifies the minimum number of bytes to process for socket input
     operations.

\rrulepad }
}

\newcommand{\defnsocktflag}{\ddefnc{socktflag}{\iA{socktflag}}{\subddefnA{socktflag}{\tstype{socktflag} = \tscon{SO\_LINGER}{}\\{}
\quad\quad\quad\quad \mid  \tscon{SO\_SNDTIMEO}{}\\{}
\quad\quad\quad\quad \mid  \tscon{SO\_RCVTIMEO}}
}
{\rulesubsection{Description}
Time-valued flags affecting the behaviour of a socket.

   $\tscon{SO\_LINGER}$  specifies a maximum duration
    that a $\tslib{close}(\tstype{fd})$ call is permitted to block.

     $\tscon{SO\_RCVTIMEO}$ specifies the timeout value for input operations.

     $\tscon{SO\_SNDTIMEO}$ specifies the timeout value for an output function blocking because flow
     control prevents data from being sent.



\rrulepad }
}

\newcommand{\defnmsgbflag}{\ddefnc{msgbflag}{\iA{msgbflag}}{\subddefnA{msgbflag}{\tstype{msgbflag} = \tscon{MSG\_PEEK}      \tscomm{ recv only, [in] }{}\\{}
\quad\quad\quad \mid  \tscon{MSG\_OOB}       \tscomm{ recv and send, [in] }{}\\{}
\quad\quad\quad \mid  \tscon{MSG\_WAITALL}   \tscomm{ recv only, [in] }{}\\{}
\quad\quad\quad \mid  \tscon{MSG\_DONTWAIT}  \tscomm{ recv and send, [in] }}
}
{\rulesubsection{Description}
Boolean flags affecting the behaviour of a $\tslib{send}$ or $\tslib{recv}$ call.

 $\tscon{MSG\_DONTWAIT}$: Do not block if there is no data available.

 $\tscon{MSG\_OOB}$: Return out-of-band data.

 $\tscon{MSG\_PEEK}$: Read data but do not remove it from the socket's receive queue.

 $\tscon{MSG\_WAITALL}$: Block untill all $\tsvar{n}$ bytes of data are available.


\rrulepad }
}

\newcommand{\defnsocktype}{\ddefnc{socktype}{\iA{socktype}}{\subddefnA{socktype}{\tstype{socktype} = \tscon{SOCK\_STREAM}{}\\{}
\quad\quad\quad\quad \mid  \tscon{SOCK\_DGRAM}}
}
{\rulesubsection{Description}
The two different flavours of socket, as passed to the $\tslib{socket}$ call,
  $\tscon{SOCK\_STREAM}$ for TCP and $\tscon{SOCK\_DGRAM}$ for UDP.


\rrulepad }
}

\newcommand{\seccommbaseTlanginter}{\clustersection{}{Language interaction types}
\seccomm{
The specification makes almost no assumptions on the programming language used to drive sockets calls.  It supposes that calls are made by threads, with thread IDs of type $\tstype{tid}$, and that calls return values of the $\tstype{err}$ types indicating success or failure.
Our \textsf{OCaml} binding maps the latter to exceptions.

Values occuring as arguments or results of sockets calls are typed.
There is a HOL type $\tstype{TLang\_type}$ of the names of these types and a
HOL type $\tstype{TLang}$ which is a disjoint union of all of their values.
An inductive definition defines a typing relation between the two.




}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{tid}$
&
& \\
$\tsrule{err}$
&
& \\
$\tsrule{TLang\_type}$
&
& \\
$\tsrule{TLang}$
&
& \\
$\tsrule{tlang\_typing}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntid}{\ddefnc{tid}{\iA{tid}}{\subddefnA{tid}{\tstype{tid} = \tscon{TID} \;\Mof  \;\tstype{num}}
}
{\rulesubsection{Description}
Thread IDs.

\rrulepad }
}

\newcommand{\defnerr}{\ddefnc{err}{\iA{err}}{\subddefnA{err}{\tstype{err} = \tscon{OK} \;\Mof  \;\tsunknown{'a} \mid  \tscon{FAIL}\;{\Mof } \tstype{error}}
}
{\rulesubsection{Description}
Each library call returns either success ($\tscon{OK} \;\tsunknown{v}$) or failure ($\tscon{FAIL}\;{\tstype{err}}$).


\rrulepad }
}

\newcommand{\defnTLangTtype}{\ddefnc{TLangTtype}{\iA{TLang\_type}}{\subddefnA{TLang\_type}{\tstype{TLang\_type} = \tscon{TLty\_int}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_bool}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_string}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_one}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_pair} \;\Mof  (\tstype{TLang\_type} \# \tstype{TLang\_type}){}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_list} \;\Mof  \;\tstype{TLang\_type}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_lift} \;\Mof  \;\tstype{TLang\_type}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_err} \;\Mof  \;\tstype{TLang\_type}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_fd}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_ip}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_port}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_error}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_netmask}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_ifid}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_filebflag}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_sockbflag}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_socknflag}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_socktflag}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_socktype}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_tid}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TLty\_signal}}
}
{\rulesubsection{Description}
Type names for language types that are used in the sockets API.

\rrulepad }
}

\newcommand{\defnTLang}{\ddefnc{TLang}{\iA{TLang}}{\subddefnA{TLang}{\tstype{TLang} = \tscon{TL\_int} \;\Mof  \;\tstype{int}{}\\{}
\quad\quad \mid  \tscon{TL\_bool} \;\Mof  \;\tstype{bool}{}\\{}
\quad\quad \mid  \tscon{TL\_string} \;\Mof  \;\tstype{string}{}\\{}
\quad\quad \mid  \tscon{TL\_one} \;\Mof  \;(){}\\{}
\quad\quad \mid  \tscon{TL\_pair} \;\Mof  \;\tstype{TLang} \# \tstype{TLang}{}\\{}
\quad\quad \mid  \tscon{TL\_list} \;\Mof  \;\tstype{TLang} \;\tstype{list}{}\\{}
\quad\quad \mid  \tscon{TL\_option} \;\Mof  \;\tstype{TLang} \;\;\tstype{option}{}\\{}
\quad\quad \mid  \tscon{TL\_err} \;\Mof  \;\tstype{TLang} \;\tstype{err}{}\\{}
\quad\quad \mid  \tscon{TL\_fd} \;\Mof  \;\tstype{fd}{}\\{}
\quad\quad \mid  \tscon{TL\_ip} \;\Mof  \;\tstype{ip}{}\\{}
\quad\quad \mid  \tscon{TL\_port} \;\Mof  \;\tstype{port}{}\\{}
\quad\quad \mid  \tscon{TL\_error} \;\Mof  \;\tstype{error}{}\\{}
\quad\quad \mid  \tscon{TL\_netmask} \;\Mof  \;\tsvar{netmask}{}\\{}
\quad\quad \mid  \tscon{TL\_ifid} \;\Mof  \;\tsvar{ifid}{}\\{}
\quad\quad \mid  \tscon{TL\_filebflag} \;\Mof  \;\tstype{filebflag}{}\\{}
\quad\quad \mid  \tscon{TL\_sockbflag} \;\Mof  \;\tstype{sockbflag}{}\\{}
\quad\quad \mid  \tscon{TL\_socknflag} \;\Mof  \;\tstype{socknflag}{}\\{}
\quad\quad \mid  \tscon{TL\_socktflag} \;\Mof  \;\tstype{socktflag}{}\\{}
\quad\quad \mid  \tscon{TL\_socktype} \;\Mof  \;\tstype{socktype}{}\\{}
\quad\quad \mid  \tscon{TL\_tid} \;\Mof  \;\tstype{tid}{}\\{}
\quad\quad \mid  \tscon{TL\_signal} \;\Mof  \;\tstype{signal}}
}
{\rulesubsection{Description}
Language values.


\rrulepad }
}

\newcommand{\defntlangTtyping}{\ddefnn{tlangTtyping}{\iA{tlang\_typing}}{\subddefnA{tlang\_typing}{(\forall \tsvar{i}. \tsunknown{tlang\_typing} (\tscon{TL\_int} \;\tsvar{i}) \tscon{TLty\_int}) \Mwedge {}\\{}
 {}\\{}
\quad (\forall \tsvar{b}. \tsunknown{tlang\_typing} (\tscon{TL\_bool} \;\tsvar{b}) \tscon{TLty\_bool}) \Mwedge {}\\{}
 {}\\{}
\quad (\forall \tsvar{s}. \tsunknown{tlang\_typing} (\tscon{TL\_string} \;\tsvar{s}) \tscon{TLty\_string}) \Mwedge {}\\{}
 {}\\{}
\quad \tsunknown{tlang\_typing} (\tscon{TL\_one} \;()) \tscon{TLty\_one} \Mwedge {}\\{}
 {}\\{}
\quad (\forall \tsvar{p}_{1} \;\tsvar{p}_{2} \;\tsvar{ty}_{1} \;\tsvar{ty}_{2}.{}\\{}
\quad\quad\quad \tsunknown{tlang\_typing} \;\tsvar{p}_{1} \;\tsvar{ty}_{1} \Mwedge  \tsunknown{tlang\_typing} \;\tsvar{p}_{2} \;\tsvar{ty}_{2} \implies {}\\{}
\quad\quad\quad \tsunknown{tlang\_typing} (\tscon{TL\_pair}(\tsvar{p}_{1},\tsvar{p}_{2})) (\tscon{TLty\_pair}(\tsvar{ty}_{1},\tsvar{ty}_{2}))) \Mwedge {}\\{}
 {}\\{}
\quad (\forall \tsvar{tl} \;\tsvar{ty}. (\forall \tsvar{e}. \tsholop{MEM}\Mspii{\tsvar{e}}{\tsvar{tl}} \implies  \tsunknown{tlang\_typing} \;\tsvar{e} \;\tsvar{ty}) \implies {}\\{}
\quad\quad\quad\quad\quad \tsunknown{tlang\_typing} (\tscon{TL\_list} \;\tsvar{tl}) (\tscon{TLty\_list} \;\tsvar{ty})) \Mwedge {}\\{}
 {}\\{}
\quad (\forall \tsvar{p} \;\tsvar{ty}. \tsunknown{tlang\_typing} \;\tsvar{p} \;\tsvar{ty} \implies {}\\{}
\quad\quad\quad\quad\quad \tsunknown{tlang\_typing} (\tscon{TL\_option} (\Msome  \;\tsvar{p})) (\tscon{TLty\_lift} \;\tsvar{ty})) \Mwedge {}\\{}
\quad (\forall \tsvar{ty}. \tsunknown{tlang\_typing} (\tscon{TL\_option} \;*) (\tscon{TLty\_lift} \;\tsvar{ty})) \Mwedge {}\\{}
 {}\\{}
\quad (\forall \tsvar{e} \;\tsvar{ty}. \tsunknown{tlang\_typing} (\tscon{TL\_err} (\tscon{FAIL}\;{\tsvar{e}})) (\tscon{TLty\_err} \;\tsvar{ty})) \Mwedge {}\\{}
\quad (\forall \tsvar{p} \;\tsvar{ty}. \tsunknown{tlang\_typing} \;\tsvar{p} \;\tsvar{ty} \implies {}\\{}
\quad\quad\quad\quad\quad \tsunknown{tlang\_typing} (\tscon{TL\_err} (\tscon{OK} \;\tsvar{p})) (\tscon{TLty\_err} \;\tsvar{ty})) \Mwedge {}\\{}
 {}\\{}
\quad (\forall \tsvar{fd}. \tsunknown{tlang\_typing} (\tscon{TL\_fd} \;\tsvar{fd}) \tscon{TLty\_fd}) \Mwedge {}\\{}
 {}\\{}
\quad (\forall \tsvar{i}. \tsunknown{tlang\_typing} (\tscon{TL\_ip} \;\tsvar{i}) \tscon{TLty\_ip}) \Mwedge {}\\{}
\quad (\forall \tsvar{p}. \tsunknown{tlang\_typing} (\tscon{TL\_port} \;\tsvar{p}) \tscon{TLty\_port}) \Mwedge {}\\{}
\quad (\forall \tsvar{e}. \tsunknown{tlang\_typing} (\tscon{TL\_error} \;\tsvar{e}) \tscon{TLty\_error}) \Mwedge {}\\{}
\quad (\forall \tsvar{nm}. \tsunknown{tlang\_typing} (\tscon{TL\_netmask} \;\tsvar{nm}) \tscon{TLty\_netmask}) \Mwedge {}\\{}
\quad (\forall \tsvar{ifid}. \tsunknown{tlang\_typing} (\tscon{TL\_ifid} \;\tsvar{ifid}) \tscon{TLty\_ifid}) \Mwedge {}\\{}
\quad (\forall \tsvar{ff}. \tsunknown{tlang\_typing} (\tscon{TL\_filebflag} \;\tsvar{ff}) \tscon{TLty\_filebflag}) \Mwedge {}\\{}
\quad (\forall \tsvar{sf}. \tsunknown{tlang\_typing} (\tscon{TL\_sockbflag} \;\tsvar{sf}) \tscon{TLty\_sockbflag}) \Mwedge {}\\{}
\quad (\forall \tsvar{sf}. \tsunknown{tlang\_typing} (\tscon{TL\_socknflag} \;\tsvar{sf}) \tscon{TLty\_socknflag}) \Mwedge {}\\{}
\quad (\forall \tsvar{sf}. \tsunknown{tlang\_typing} (\tscon{TL\_socktflag} \;\tsvar{sf}) \tscon{TLty\_socktflag}) \Mwedge {}\\{}
\quad (\forall \tsvar{st}. \tsunknown{tlang\_typing} (\tscon{TL\_socktype} \;\tsvar{st}) \tscon{TLty\_socktype}) \Mwedge {}\\{}
\quad (\forall \tsvar{tid}. \tsunknown{tlang\_typing} (\tscon{TL\_tid} \;\tsvar{tid}) \tscon{TLty\_tid}) \Mwedge {}\\{}
 \tscomm{       (!l ty. tlang\textunderscore{}typing (TL\textunderscore{}ref (Loc (ty,l))) (TLty\textunderscore{}ref ty)) /\textbackslash{} }{}\\{}
 \tscomm{       (!ex. tlang\textunderscore{}typing (TL\textunderscore{}exn ex) TLty\textunderscore{}exn ) /\textbackslash{} }{}\\{}
 \tscomm{       (!p ty.  tlang\textunderscore{}typing p ty ==\textgreater{}                    }{}\\{}
 \tscomm{                tlang\textunderscore{}typing (TL\textunderscore{}except (EOK p)) (TLty\textunderscore{}except ty)) /\textbackslash{} }{}\\{}
 \tscomm{        (!ex ty.  tlang\textunderscore{}typing (TL\textunderscore{}exn ex) TLty\textunderscore{}exn ==\textgreater{} }{}\\{}
 \tscomm{                 tlang\textunderscore{}typing (TL\textunderscore{}except (EEX ex)) (TLty\textunderscore{}except ty)) /\textbackslash{} }{}\\{}
\quad (\forall \tsvar{s}. \tsunknown{tlang\_typing} (\tscon{TL\_signal} \;\tsvar{s}) \tscon{TLty\_signal})}
}
{}
}

\newcommand{\seccommbaseTtime}{\clustersection{}{Time types}
\seccomm{
Time and duration are defined as type synonyms.  Time must be
non-negative and may be infinite; duration must be positive and
finite.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{time}$
&
& \\
$\tsrule{type\_abbrev\_duration}$
&
& \\
$\tsrule{time\_lt}$
&
&  written $<$ \\
$\tsrule{time\_lte}$
&
&  written $\leq $ \\
$\tsrule{time\_gt}$
&
&  written $>$ \\
$\tsrule{time\_gte}$
&
&  written $\geq $ \\
$\tsrule{time\_min}$
&
&  written $\tsholop{MIN} \;\tsunknown{x} \;\tsunknown{y}$ \\
$\tsrule{time\_max}$
&
&  written $\tsholop{MAX} \;\tsunknown{x} \;\tsunknown{y}$ \\
$\tsrule{time\_plus\_dur}$
&
&  written $+$ \\
$\tsrule{time\_minus\_dur}$
&
&  written $-$ \\
$\tsrule{real\_mult\_time}$
&
&  written $*$ \\
$\tsrule{time\_zero}$
&
& \\
$\tsrule{duration}$
&
& \\
$\tsrule{abstime}$
&
& \\
$\tsrule{realopt\_of\_time}$
&
& \\
$\tsrule{the\_time}$
&
&  written $\tsholop{THE}$ \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntime}{\ddefnn{time}{\iA{time}}{\subddefnA{time}{\tstype{time} = \infty \mid  \tstype{time} \;\Mof  \;\tsunknown{real}}
}
{}
}

\newcommand{\defntypeTabbrevTduration}{\ddefnn{typeTabbrevTduration}{\iA{type\_abbrev\_duration}}{\subddefnA{type\_abbrev\_duration}{\tsholop{type\_abbrev} \;\tsaux{duration} :\tsunknown{real}}
}
{}
}

\newcommand{\defntimeTlt}{\ddefnc{timeTlt}{\iA{time\_lt}}{\subddefnA[{ written $<$ }]{time\_lt}{((\tsaux{time\_lt}:\tstype{time} \Mtotype  \tstype{time} \Mtotype  \tstype{bool}) (\tstype{time} \;\tsunknown{x}) (\tstype{time} \;\tsunknown{y}) = \tsunknown{x} < \tsunknown{y}){}\\{}
 \Mwedge  (\tsaux{time\_lt}  \;\infty     \;\tsunknown{ys}      = \Mfalse ){}\\{}
 \Mwedge  (\tsaux{time\_lt} \;\tsunknown{xs}        \;\infty    = \Mtrue )}
}
{}
}

\newcommand{\defntimeTlte}{\ddefnc{timeTlte}{\iA{time\_lte}}{\subddefnA[{ written $\leq $ }]{time\_lte}{\tsaux{time\_lte} (\tstype{time} \;\tsunknown{x}) (\tstype{time} \;\tsunknown{y}) = \tsunknown{x} \leq  \tsunknown{y} \Mwedge {}\\{}
 \tsaux{time\_lte} \;\tsvar{t} \;\infty = \Mtrue  \Mwedge {}\\{}
 \tsaux{time\_lte} \;\infty \;\tsvar{t} = (\tsvar{t} = \infty)}
}
{}
}

\newcommand{\defntimeTgt}{\ddefnc{timeTgt}{\iA{time\_gt}}{\subddefnA[{ written $>$ }]{time\_gt}{\tsaux{time\_gt}  \;\tsunknown{xs} \;\tsunknown{ys} = \tsaux{time\_lt} \;\tsunknown{ys} \;\tsunknown{xs}}
}
{}
}

\newcommand{\defntimeTgte}{\ddefnn{timeTgte}{\iA{time\_gte}}{\subddefnA[{ written $\geq $ }]{time\_gte}{\tsaux{time\_gte} \;\tsunknown{xs} \;\tsunknown{ys} = \tsaux{time\_lte} \;\tsunknown{ys} \;\tsunknown{xs}}
}
{}
}

\newcommand{\defntimeTmin}{\ddefnc{timeTmin}{\iA{time\_min}}{\subddefnA[{ written $\tsholop{MIN} \;\tsunknown{x} \;\tsunknown{y}$ }]{time\_min}{\tsaux{time\_min} (\tstype{time} \;\tsunknown{x}) (\tstype{time} \;\tsunknown{y}) = \tstype{time} (\tsholop{MIN} \;\tsunknown{x} \;\tsunknown{y}) \Mwedge {}\\{}
 \tsaux{time\_min} (\tstype{time} \;\tsunknown{x}) \infty = \tstype{time} \;\tsunknown{x} \Mwedge {}\\{}
 \tsaux{time\_min} \;\infty (\tstype{time} \;\tsunknown{x}) = \tstype{time} \;\tsunknown{x} \Mwedge {}\\{}
 \tsaux{time\_min} \;\infty \;\infty = \infty}
}
{}
}

\newcommand{\defntimeTmax}{\ddefnc{timeTmax}{\iA{time\_max}}{\subddefnA[{ written $\tsholop{MAX} \;\tsunknown{x} \;\tsunknown{y}$ }]{time\_max}{\tsaux{time\_max} (\tstype{time} \;\tsunknown{x}) (\tstype{time} \;\tsunknown{y}) = \tstype{time} (\tsholop{MAX} \;\tsunknown{x} \;\tsunknown{y}) \Mwedge {}\\{}
 \tsaux{time\_max} \;\infty (\tstype{time} \;\tsunknown{x}) = \infty \Mwedge {}\\{}
 \tsaux{time\_max} (\tstype{time} \;\tsunknown{x}) \infty = \infty \Mwedge {}\\{}
 \tsaux{time\_max} \;\infty \;\infty = \infty}
}
{}
}

\newcommand{\defntimeTplusTdur}{\ddefnc{timeTplusTdur}{\iA{time\_plus\_dur}}{\subddefnA[{ written $+$ }]{time\_plus\_dur}{((\tsaux{time\_plus\_dur}:\tstype{time} \Mtotype  \tsaux{duration} \Mtotype  \tstype{time}){}\\{}
\quad\quad\quad\quad\quad\quad\quad (\tstype{time} \;\tsunknown{x}) \tsunknown{y} = \tstype{time} (\tsunknown{x}+\tsunknown{y})) \Mwedge {}\\{}
 (\tsaux{time\_plus\_dur}  \;\infty    \;\tsunknown{y} = \infty)}
}
{}
}

\newcommand{\defntimeTminusTdur}{\ddefnc{timeTminusTdur}{\iA{time\_minus\_dur}}{\subddefnA[{ written $-$ }]{time\_minus\_dur}{((\tsaux{time\_minus\_dur}:\tstype{time} \Mtotype  \tsaux{duration} \Mtotype  \tstype{time}){}\\{}
\quad\quad\quad\quad\quad\quad\quad (\tstype{time} \;\tsunknown{x})      \tsunknown{y} = \tstype{time} (\tsunknown{x}-\tsunknown{y})) \Mwedge {}\\{}
 (\tsaux{time\_minus\_dur}  \;\infty    \;\tsunknown{y} = \infty)}
}
{}
}

\newcommand{\defnrealTmultTtime}{\ddefnn{realTmultTtime}{\iA{real\_mult\_time}}{\subddefnA[{ written $*$ }]{real\_mult\_time}{(\tsaux{real\_mult\_time}:\tsunknown{real} \Mtotype  \tstype{time} \Mtotype  \tstype{time}){}\\{}
\quad\quad\quad\quad\quad\quad \tsunknown{x}  (\tstype{time} \;\tsunknown{y})      = \tstype{time} (\tsunknown{x}*\tsunknown{y}) \Mwedge {}\\{}
 \tsaux{real\_mult\_time} \;\tsunknown{x}  \;\infty    = \infty}
}
{}
}

\newcommand{\defntimeTzero}{\ddefnn{timeTzero}{\iA{time\_zero}}{\subddefnA{time\_zero}{(0 : \tstype{time}) = \tstype{time} \;0}
}
{}
}

\newcommand{\defnduration}{\ddefnc{duration}{\iA{duration}}{\subddefnA{duration}{(\tsaux{duration} : \tstype{num} \Mtotype  \tstype{num} \Mtotype  \tsaux{duration}) \tsunknown{sec} \;\tsunknown{usec} = \$\&\tsunknown{sec} + \$\&\tsunknown{usec} / 1000000}
}
{\rulesubsection{Description}
Some durations may be represented as $\tsaux{duration} \;\tsunknown{sec} \;\tsunknown{usec}$, where $\tsunknown{sec}$
and $\tsunknown{usec}$ are both natural numbers.

\rrulepad }
}

\newcommand{\defnabstime}{\ddefnc{abstime}{\iA{abstime}}{\subddefnA{abstime}{(\tsaux{abstime} : \tstype{num} \Mtotype  \tstype{num} \Mtotype  \tsaux{duration}) \tsunknown{sec} \;\tsunknown{usec} =  \$\&\tsunknown{sec} + \$\&\tsunknown{usec} / 1000000}
}
{\rulesubsection{Description}
Some times may be represented as $\tsaux{duration} \;\tsunknown{sec} \;\tsunknown{usec}$, where $\tsunknown{sec}$
and $\tsunknown{usec}$ are both natural numbers.

\rrulepad }
}

\newcommand{\defnrealoptTofTtime}{\ddefnc{realoptTofTtime}{\iA{realopt\_of\_time}}{\subddefnA{realopt\_of\_time}{(\tsaux{realopt\_of\_time} : \tstype{time} \Mtotype  \tsunknown{real} \;\;\tstype{option}) (\tstype{time} \;\tsunknown{x}) = \Msome  \;\tsunknown{x} \Mwedge {}\\{}
 \tsaux{realopt\_of\_time} \;\infty = *}
}
{}
}

\newcommand{\defntheTtime}{\ddefnn{theTtime}{\iA{the\_time}}{\subddefnA[{ written $\tsholop{THE}$ }]{the\_time}{\tsaux{the\_time} (\tstype{time} \;\tsunknown{x}) = \tsunknown{x}}
}
{}
}

\newcommand{\seccommbaseTnet}{\clustersection{(TCP only)}{Basic network types: sequence numbers}
\seccomm{
We have several flavours of TCP sequence numbers, all represented by
32-bit values: local sequence numbers, foreign sequence numbers, and
timestamps.  This helps prevent confusion.  We also define
$\tsunknown{tcp\_seq\_flip\_sense}$, which converts a local to a foreign sequence
number and vice versa.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{type\_abbrev\_byte}$
&
& \\
$\tsrule{seq32}$
&
& \\
$\tsrule{seq32\_plus}$
&
&  written $+$ \\
$\tsrule{seq32\_minus}$
&
&  written $-$ \\
$\tsrule{seq32\_plus'}$
&
&  written $+$ \\
$\tsrule{seq32\_minus'}$
&
&  written $-$ \\
$\tsrule{seq32\_diff}$
&
&  written $-$ \\
$\tsrule{seq32\_lt}$
&
&  written $<$ \\
$\tsrule{seq32\_leq}$
&
&  written $\leq $ \\
$\tsrule{seq32\_gt}$
&
&  written $>$ \\
$\tsrule{seq32\_geq}$
&
&  written $\geq $ \\
$\tsrule{seq32\_fromto}$
&
& \\
$\tsrule{seq32\_coerce}$
&
& \\
$\tsrule{seq32\_min}$
&
&  written $\tsholop{MIN} \;\tsunknown{x} \;\tsunknown{y}$ \\
$\tsrule{seq32\_max}$
&
&  written $\tsholop{MAX} \;\tsunknown{x} \;\tsunknown{y}$ \\
$\tsrule{tcpLocal}$
&
& \\
$\tsrule{tcpForeign}$
&
& \\
$\tsrule{type\_abbrev\_tcp\_seq\_local}$
&
& \\
$\tsrule{type\_abbrev\_tcp\_seq\_foreign}$
&
& \\
$\tsrule{tcp\_seq\_local}$
&
& \\
$\tsrule{tcp\_seq\_foreign}$
&
& \\
$\tsrule{tcp\_seq\_local\_to\_foreign}$
&
& \\
$\tsrule{tcp\_seq\_foreign\_to\_local}$
&
& \\
$\tsrule{tstamp}$
&
& \\
$\tsrule{type\_abbrev\_ts\_seq}$
&
& \\
$\tsrule{ts\_seq}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntypeTabbrevTbyte}{\ddefnn{typeTabbrevTbyte}{\iA{type\_abbrev\_byte}}{\subddefnA{type\_abbrev\_byte}{\tsholop{type\_abbrev} \;\tstype{byte} :\tsunknown{char}}
}
{}
}

\newcommand{\defnseqXXXII}{\ddefnc{seqXXXII}{\iA{seq32}}{\subddefnA{seq32}{\tsvar{seq}_{32} = \tscon{SEQ32} \;\Mof  \;\tsunknown{'a} => \tsunknown{word32}}
}
{\rulesubsection{Description}
32-bit wraparound sequence numbers, as used in TCP, along with their special arithmetic.

\rrulepad }
}

\newcommand{\defnseqXXXIITplus}{\ddefnc{seqXXXIITplus}{\iA{seq32\_plus}}{\subddefnA[{ written $+$ }]{seq32\_plus}{\tsaux{seq32\_plus}   (\tscon{SEQ32} \;\tsunknown{a} \;\tsvar{n}) (\tsunknown{m}:\tstype{num}) = \tscon{SEQ32} \;\tsunknown{a} (\tsvar{n} + \tsholop{n2w} \;\tsunknown{m})}
}
{}
}

\newcommand{\defnseqXXXIITminus}{\ddefnc{seqXXXIITminus}{\iA{seq32\_minus}}{\subddefnA[{ written $-$ }]{seq32\_minus}{\tsaux{seq32\_minus}  (\tscon{SEQ32} \;\tsunknown{a} \;\tsvar{n}) (\tsunknown{m}:\tstype{num}) = \tscon{SEQ32} \;\tsunknown{a} (\tsvar{n} - \tsholop{n2w} \;\tsunknown{m})}
}
{}
}

\newcommand{\defnseqXXXIITplusT}{\ddefnc{seqXXXIITplusT}{\iA{seq32\_plus'}}{\subddefnA[{ written $+$ }]{seq32\_plus'}{\tsaux{seq32\_plus'}  (\tscon{SEQ32} \;\tsunknown{a} \;\tsvar{n}) (\tsunknown{m}:\tstype{int}) = \tscon{SEQ32} \;\tsunknown{a} (\tsvar{n} + \tsunknown{i2w} \;\tsunknown{m})}
}
{}
}

\newcommand{\defnseqXXXIITminusT}{\ddefnc{seqXXXIITminusT}{\iA{seq32\_minus'}}{\subddefnA[{ written $-$ }]{seq32\_minus'}{\tsaux{seq32\_minus'} (\tscon{SEQ32} \;\tsunknown{a} \;\tsvar{n}) (\tsunknown{m}:\tstype{int}) = \tscon{SEQ32} \;\tsunknown{a} (\tsvar{n} - \tsunknown{i2w} \;\tsunknown{m})}
}
{}
}

\newcommand{\defnseqXXXIITdiff}{\ddefnc{seqXXXIITdiff}{\iA{seq32\_diff}}{\subddefnA[{ written $-$ }]{seq32\_diff}{\tsaux{seq32\_diff} (\tscon{SEQ32} (\tsunknown{a}:\tsunknown{'a}) \tsvar{n}) (\tscon{SEQ32} (\tsvar{b}:\tsunknown{'a}) \tsunknown{m}) = \tsunknown{w2i} (\tsvar{n} - \tsunknown{m})}
}
{}
}

\newcommand{\defnseqXXXIITlt}{\ddefnc{seqXXXIITlt}{\iA{seq32\_lt}}{\subddefnA[{ written $<$ }]{seq32\_lt}{\tsaux{seq32\_lt}  (\tsvar{n}:\tsunknown{'a} \;\tsvar{seq}_{32}) (\tsunknown{m}:\tsunknown{'a} \;\tsvar{seq}_{32}) = ( (\tsvar{n} - \tsunknown{m}) : \tstype{int} ) < 0}
}
{}
}

\newcommand{\defnseqXXXIITleq}{\ddefnc{seqXXXIITleq}{\iA{seq32\_leq}}{\subddefnA[{ written $\leq $ }]{seq32\_leq}{\tsaux{seq32\_leq} (\tsvar{n}:\tsunknown{'a} \;\tsvar{seq}_{32}) (\tsunknown{m}:\tsunknown{'a} \;\tsvar{seq}_{32}) = ( (\tsvar{n} - \tsunknown{m}) : \tstype{int} ) \leq  0}
}
{}
}

\newcommand{\defnseqXXXIITgt}{\ddefnc{seqXXXIITgt}{\iA{seq32\_gt}}{\subddefnA[{ written $>$ }]{seq32\_gt}{\tsaux{seq32\_gt}  (\tsvar{n}:\tsunknown{'a} \;\tsvar{seq}_{32}) (\tsunknown{m}:\tsunknown{'a} \;\tsvar{seq}_{32}) = ( (\tsvar{n} - \tsunknown{m}) : \tstype{int} ) > 0}
}
{}
}

\newcommand{\defnseqXXXIITgeq}{\ddefnc{seqXXXIITgeq}{\iA{seq32\_geq}}{\subddefnA[{ written $\geq $ }]{seq32\_geq}{\tsaux{seq32\_geq} (\tsvar{n}:\tsunknown{'a} \;\tsvar{seq}_{32}) (\tsunknown{m}:\tsunknown{'a} \;\tsvar{seq}_{32}) = ( (\tsvar{n} - \tsunknown{m}) : \tstype{int} ) \geq  0}
}
{}
}

\newcommand{\defnseqXXXIITfromto}{\ddefnc{seqXXXIITfromto}{\iA{seq32\_fromto}}{\subddefnA{seq32\_fromto}{\tsaux{seq32\_fromto} (\tsunknown{a}:\tsunknown{'a}) \tsvar{b} (\tscon{SEQ32} (\tsunknown{c}:\tsunknown{'a}) \tsvar{n}) = \tscon{SEQ32} \;\tsvar{b} \;\tsvar{n}}
}
{}
}

\newcommand{\defnseqXXXIITcoerce}{\ddefnc{seqXXXIITcoerce}{\iA{seq32\_coerce}}{\subddefnA{seq32\_coerce}{\tsaux{seq32\_coerce} (\tscon{SEQ32} \;\tsunknown{a} \;\tsvar{n}) = \tscon{SEQ32} \;\tsunknown{ARB} \;\tsvar{n}}
}
{}
}

\newcommand{\defnseqXXXIITmin}{\ddefnc{seqXXXIITmin}{\iA{seq32\_min}}{\subddefnA[{ written $\tsholop{MIN} \;\tsunknown{x} \;\tsunknown{y}$ }]{seq32\_min}{\tsaux{seq32\_min} (\tsvar{n}:\tsunknown{'a} \;\tsvar{seq}_{32}) (\tsunknown{m}:\tsunknown{'a} \;\tsvar{seq}_{32}) = \Mif  \;\tsvar{n} < \tsunknown{m} \;\Mthen  \;\tsvar{n} \;\Melse  \;\tsunknown{m}}
}
{}
}

\newcommand{\defnseqXXXIITmax}{\ddefnn{seqXXXIITmax}{\iA{seq32\_max}}{\subddefnA[{ written $\tsholop{MAX} \;\tsunknown{x} \;\tsunknown{y}$ }]{seq32\_max}{\tsaux{seq32\_max} (\tsvar{n}:\tsunknown{'a} \;\tsvar{seq}_{32}) (\tsunknown{m}:\tsunknown{'a} \;\tsvar{seq}_{32}) = \Mif  \;\tsvar{n} < \tsunknown{m} \;\Mthen  \;\tsunknown{m} \;\Melse  \;\tsvar{n}}
}
{}
}

\newcommand{\defntcpLocal}{\ddefnn{tcpLocal}{\iA{tcpLocal}}{\subddefnA{tcpLocal}{\tstype{tcpLocal}   = \tscon{TcpLocal}}
}
{}
}

\newcommand{\defntcpForeign}{\ddefnn{tcpForeign}{\iA{tcpForeign}}{\subddefnA{tcpForeign}{\tstype{tcpForeign} = \tscon{TcpForeign}}
}
{}
}

\newcommand{\defntypeTabbrevTtcpTseqTlocal}{\ddefnn{typeTabbrevTtcpTseqTlocal}{\iA{type\_abbrev\_tcp\_seq\_local}}{\subddefnA{type\_abbrev\_tcp\_seq\_local}{\tsholop{type\_abbrev} \;\tsaux{tcp\_seq\_local} :\tstype{tcpLocal}   \;\tsvar{seq}_{32}}
}
{}
}

\newcommand{\defntypeTabbrevTtcpTseqTforeign}{\ddefnn{typeTabbrevTtcpTseqTforeign}{\iA{type\_abbrev\_tcp\_seq\_foreign}}{\subddefnA{type\_abbrev\_tcp\_seq\_foreign}{\tsholop{type\_abbrev} \;\tsaux{tcp\_seq\_foreign} :\tstype{tcpForeign} \;\tsvar{seq}_{32}}
}
{}
}

\newcommand{\defntcpTseqTlocal}{\ddefnc{tcpTseqTlocal}{\iA{tcp\_seq\_local}}{\subddefnA{tcp\_seq\_local}{\tsaux{tcp\_seq\_local}   (\tsvar{n}:\tsunknown{word32}) = \tscon{SEQ32} \;\tscon{TcpLocal}   \;\tsvar{n}}
}
{}
}

\newcommand{\defntcpTseqTforeign}{\ddefnc{tcpTseqTforeign}{\iA{tcp\_seq\_foreign}}{\subddefnA{tcp\_seq\_foreign}{\tsaux{tcp\_seq\_foreign} (\tsvar{n}:\tsunknown{word32}) = \tscon{SEQ32} \;\tscon{TcpForeign} \;\tsvar{n}}
}
{}
}

\newcommand{\defntcpTseqTlocalTtoTforeign}{\ddefnc{tcpTseqTlocalTtoTforeign}{\iA{tcp\_seq\_local\_to\_foreign}}{\subddefnA{tcp\_seq\_local\_to\_foreign}{\tsaux{tcp\_seq\_local\_to\_foreign} = \tsaux{seq32\_coerce}:\tsaux{tcp\_seq\_local} \Mtotype  \tsaux{tcp\_seq\_foreign}}
}
{}
}

\newcommand{\defntcpTseqTforeignTtoTlocal}{\ddefnn{tcpTseqTforeignTtoTlocal}{\iA{tcp\_seq\_foreign\_to\_local}}{\subddefnA{tcp\_seq\_foreign\_to\_local}{\tsaux{tcp\_seq\_foreign\_to\_local} = \tsaux{seq32\_coerce}:\tsaux{tcp\_seq\_foreign} \Mtotype  \tsaux{tcp\_seq\_local}}
}
{}
}

\newcommand{\defntstamp}{\ddefnn{tstamp}{\iA{tstamp}}{\subddefnA{tstamp}{\tstype{tstamp} = \tscon{Tstamp}}
}
{}
}

\newcommand{\defntypeTabbrevTtsTseq}{\ddefnn{typeTabbrevTtsTseq}{\iA{type\_abbrev\_ts\_seq}}{\subddefnA{type\_abbrev\_ts\_seq}{\tsholop{type\_abbrev} \;\tsaux{ts\_seq} :\tstype{tstamp} \;\tsvar{seq}_{32}}
}
{}
}

\newcommand{\defntsTseq}{\ddefnn{tsTseq}{\iA{ts\_seq}}{\subddefnA{ts\_seq}{\tsaux{ts\_seq} (\tsvar{n}:\tsunknown{word32}) = \tscon{SEQ32} \;\tscon{Tstamp} \;\tsvar{n}}
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPITbaseTypes}
\showrule{\seccommbaseTos}
\showrule{\defnport}
\showrule{\defnip}
\showrule{\defnifid}
\showrule{\defnnetmask}
\showrule{\defnfd}
\showrule{\seccommbaseTflags}
\showrule{\defnfilebflag}
\showrule{\defnsockbflag}
\showrule{\defnsocknflag}
\showrule{\defnsocktflag}
\showrule{\defnmsgbflag}
\showrule{\defnsocktype}
\showrule{\seccommbaseTlanginter}
\showrule{\defntid}
\showrule{\defnerr}
\showrule{\defnTLangTtype}
\showrule{\defnTLang}
\showrule{\defntlangTtyping}
\showrule{\seccommbaseTtime}
\showrule{\defntime}
\showrule{\defntypeTabbrevTduration}
\showrule{\defntimeTlt}
\showrule{\defntimeTlte}
\showrule{\defntimeTgt}
\showrule{\defntimeTgte}
\showrule{\defntimeTmin}
\showrule{\defntimeTmax}
\showrule{\defntimeTplusTdur}
\showrule{\defntimeTminusTdur}
\showrule{\defnrealTmultTtime}
\showrule{\defntimeTzero}
\showrule{\defnduration}
\showrule{\defnabstime}
\showrule{\defnrealoptTofTtime}
\showrule{\defntheTtime}
\showrule{\seccommbaseTnet}
\showrule{\defntypeTabbrevTbyte}
\showrule{\defnseqXXXII}
\showrule{\defnseqXXXIITplus}
\showrule{\defnseqXXXIITminus}
\showrule{\defnseqXXXIITplusT}
\showrule{\defnseqXXXIITminusT}
\showrule{\defnseqXXXIITdiff}
\showrule{\defnseqXXXIITlt}
\showrule{\defnseqXXXIITleq}
\showrule{\defnseqXXXIITgt}
\showrule{\defnseqXXXIITgeq}
\showrule{\defnseqXXXIITfromto}
\showrule{\defnseqXXXIITcoerce}
\showrule{\defnseqXXXIITmin}
\showrule{\defnseqXXXIITmax}
\showrule{\defntcpLocal}
\showrule{\defntcpForeign}
\showrule{\defntypeTabbrevTtcpTseqTlocal}
\showrule{\defntypeTabbrevTtcpTseqTforeign}
\showrule{\defntcpTseqTlocal}
\showrule{\defntcpTseqTforeign}
\showrule{\defntcpTseqTlocalTtoTforeign}
\showrule{\defntcpTseqTforeignTtoTlocal}
\showrule{\defntstamp}
\showrule{\defntypeTabbrevTtsTseq}
\showrule{\defntsTseq}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore netTypes

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPITnetTypes}{\chaptersection{ Network datagram types}
\label{TCP1_netTypes}%
\chapcomm{
This file defines the types of the datagrams that appear on the
network, with an IP message being either a TCP segment, a UDP
datagram, or an ICMP datagram.

These types abstract from most fields of the IP header: version, header
length, type of service, identification, DF, MF, and fragment offset,
time to live, header checksum, and IP options.
%
They faithfully model the IP header fields: protocol (TCP, UDP,
or ICMP), total length, source address, and destination address.
%
The $\tstype{tcpSegment}$ type abstracts from the TCP checksum, reserved, and
padding fields of the TCP header, from the ordering of TCP options,
and from ill-formed TCP options.
It faithfully models all other fields.
%
The $\tstype{udpDatagram}$ type abstracts from the UDP checksum but
faithfully models all other fields.
%
Lengths are represented by allowing simple lists of data bytes rather
than explicit length fields.
%
All these types collapse the encapsulation of TCP/UDP/ICMP within IP,
flattening them into single records, to reduce syntactic noise
throughout the specification.

For ease of comparison we reproduce the RFC 791/793/768 header formats below.

\begin{alltt}
\input{inetheaders.inc}
\end{alltt}



}
}

\newcommand{\seccommnettyTtcp}{\clustersection{(TCP only)}{TCP segments}
\seccomm{
TCP segments (really \emph{datagrams}, since we include the IP data)
are modelled as follows.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{tcpSegment}$
&
&  TCP datagram type \\
$\tsrule{sane\_seg}$
&
&
segment well-formedness test (physical constraints imposed by format)
\end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntcpSegment}{\ddefnc{tcpSegment}{\iA{tcpSegment}}{\subddefnA[{ TCP datagram type }]{tcpSegment}{\tstype{tcpSegment}{}\\{}
 = \Mmagiclrec  \tsvar{is}_{1} : \tstype{ip} \;\;\tstype{option} ;      \tscomm{ source IP }{}\\{}
 \tsvar{is}_{2} : \tstype{ip} \;\;\tstype{option} ;      \tscomm{ destination IP }{}\\{}
 \tsvar{ps}_{1} : \tstype{port} \;\;\tstype{option};     \tscomm{ source port }{}\\{}
 \tsvar{ps}_{2} : \tstype{port} \;\;\tstype{option};     \tscomm{ destination port }{}\\{}
 \tsvar{seq} : \tsaux{tcp\_seq\_local};   \tscomm{ sequence number       }{}\\{}
 \tsvar{ack} : \tsaux{tcp\_seq\_foreign}; \tscomm{ acknowledgment number }{}\\{}
 \tsvar{URG} : \tstype{bool};{}\\{}
 \tsvar{ACK} : \tstype{bool};{}\\{}
 \tsvar{PSH} : \tstype{bool};{}\\{}
 \tsvar{RST} : \tstype{bool};{}\\{}
 \tsvar{SYN} : \tstype{bool};{}\\{}
 \tsvar{FIN} : \tstype{bool};{}\\{}
 \tsvar{win} : \tsunknown{word16};        \tscomm{ window size (unsigned) }{}\\{}
 \tsvar{ws}  : \tstype{byte} \;\;\tstype{option};   \tscomm{ TCP option: window scaling; typically 0..14 }{}\\{}
 \tsvar{urp} : \tsunknown{word16};        \tscomm{ urgent pointer (unsigned) }{}\\{}
 \tsvar{mss} : \tsunknown{word16} \;\;\tstype{option};             \tscomm{ TCP option: maximum segment size (unsigned) }{}\\{}
 \tsvar{ts}  : (\tsaux{ts\_seq} \# \tsaux{ts\_seq}) \;\tstype{option};  \tscomm{ TCP option: RFC1323 timestamp value and echo-reply }{}\\{}
 \tsvar{data} : \tstype{byte} \;\tstype{list}{}\\{}
 \Mmagicbolrrec }
}
{\rulesubsection{Description}
The use of "local" and "foreign" here is with respect to the \emph{sending} TCP.


\rrulepad }
}

\newcommand{\defnsaneTseg}{\ddefnn{saneTseg}{\iA{sane\_seg}}{\subddefnA[{
segment well-formedness test (physical constraints imposed by format)
}]{sane\_seg}{\tsaux{sane\_seg} \;\tsunknown{seg} = \tsholop{LENGTH} \;\tsunknown{seg}.\tsvar{data} < (65536 - 40)}
}
{}
}

\newcommand{\seccommnettyTudp}{\clustersection{(UDP only)}{UDP datagrams}
\seccomm{
UDP datagrams are very simple.  They are modelled as follows.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{udpDatagram}$
&
&  UDP datagram type \\
$\tsrule{sane\_udpdgm}$
&
&
message well-formedness test (physical constraints imposed by format)
\end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnudpDatagram}{\ddefnn{udpDatagram}{\iA{udpDatagram}}{\subddefnA[{ UDP datagram type }]{udpDatagram}{\tstype{udpDatagram}{}\\{}
 = \Mmagiclrec  \tsvar{is}_{1} : \tstype{ip} \;\;\tstype{option} ;      \tscomm{ source IP }{}\\{}
 \tsvar{is}_{2} : \tstype{ip} \;\;\tstype{option} ;      \tscomm{ destination IP }{}\\{}
 \tsvar{ps}_{1} : \tstype{port} \;\;\tstype{option};     \tscomm{ source port }{}\\{}
 \tsvar{ps}_{2} : \tstype{port} \;\;\tstype{option};     \tscomm{ destination port }{}\\{}
 \tsvar{data} : \tstype{byte} \;\tstype{list}{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defnsaneTudpdgm}{\ddefnn{saneTudpdgm}{\iA{sane\_udpdgm}}{\subddefnA[{
message well-formedness test (physical constraints imposed by format)
}]{sane\_udpdgm}{\tsaux{sane\_udpdgm} \;\tsunknown{dgm} = \tsholop{LENGTH} \;\tsunknown{dgm}.\tsvar{data} < (65536-20-8)}
}
{}
}

\newcommand{\seccommnettyTicmp}{\clustersection{(TCP and UDP)}{ICMP datagrams}
\seccomm{
ICMP messages have \emph{type} and \emph{code} fields, both 8 bits wide.
The specification deals only with some of these types, as
characterised in the HOL type $\tstype{icmpType}$ below.  For each type we
identify some or all of the codes that have conventional symbolic
representations, but to ensure the model can faithfully represent
arbitrary codes each code (HOL type) also has an $\tscon{OTHER}$ constructor
carrying a byte.  The values carried are assumed not to overlap with
the symbolically-represented values.

In retrospect, there seems to be no reason not to have types
and codes simply particular byte constants.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{protocol}$
&
&
protocol type for use in ICMP messages
\\
$\tsrule{icmp\_unreach\_code}$
&
& \\
$\tsrule{icmp\_source\_quench\_code}$
&
& \\
$\tsrule{icmp\_redirect\_code}$
&
& \\
$\tsrule{icmp\_time\_exceeded\_code}$
&
& \\
$\tsrule{icmp\_paramprob\_code}$
&
& \\
$\tsrule{icmpType}$
&
& \\
$\tsrule{icmpDatagram}$
&
&  ICMP datagram type \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnprotocol}{\ddefnn{protocol}{\iA{protocol}}{\subddefnA[{
protocol type for use in ICMP messages
}]{protocol}{\tstype{protocol} = \tscon{PROTO\_TCP} \mid  \tscon{PROTO\_UDP}}
}
{}
}

\newcommand{\defnicmpTunreachTcode}{\ddefnn{icmpTunreachTcode}{\iA{icmp\_unreach\_code}}{\subddefnA{icmp\_unreach\_code}{\tstype{icmp\_unreach\_code} ={}\\{}
 \tscon{NET}{}\\{}
 \mid  \tscon{HOST}{}\\{}
 \mid  \tscon{PROTOCOL}{}\\{}
 \mid  \tscon{PORT}{}\\{}
 \mid  \tscon{SRCFAIL}{}\\{}
 \mid  \tscon{NEEDFRAG} \;\Mof  \;\tsunknown{word16} \;\;\tstype{option}{}\\{}
 \mid  \tscon{NET\_UNKNOWN}{}\\{}
 \mid  \tscon{HOST\_UNKNOWN}{}\\{}
 \mid  \tscon{ISOLATED}{}\\{}
 \mid  \tscon{NET\_PROHIB}{}\\{}
 \mid  \tscon{HOST\_PROHIB}{}\\{}
 \mid  \tscon{TOSNET}{}\\{}
 \mid  \tscon{TOSHOST}{}\\{}
 \mid  \tscon{FILTER\_PROHIB}{}\\{}
 \mid  \tscon{PREC\_VIOLATION}{}\\{}
 \mid  \tscon{PREC\_CUTOFF}{}\\{}
 \mid  \tscon{OTHER} \;\Mof  \;\tstype{byte} \# \tsunknown{word32}  \tscomm{ really want this not to overlap }}
}
{}
}

\newcommand{\defnicmpTsourceTquenchTcode}{\ddefnn{icmpTsourceTquenchTcode}{\iA{icmp\_source\_quench\_code}}{\subddefnA{icmp\_source\_quench\_code}{\tstype{icmp\_source\_quench\_code} ={}\\{}
 \tscon{QUENCH}{}\\{}
 \mid  \tscon{SQ\_OTHER} \;\Mof  \;\tstype{byte} \# \tsunknown{word32} \tsholcomm{ writen $\tscon{OTHER}$ }}
}
{}
}

\newcommand{\defnicmpTredirectTcode}{\ddefnn{icmpTredirectTcode}{\iA{icmp\_redirect\_code}}{\subddefnA{icmp\_redirect\_code}{\tstype{icmp\_redirect\_code} ={}\\{}
 \tscon{RD\_NET}                     \tsholcomm{ written $\tscon{NET}$ }{}\\{}
 \mid  \tscon{RD\_HOST}                    \tsholcomm{ written $\tscon{HOST}$ }{}\\{}
 \mid  \tscon{RD\_TOSNET}                  \tsholcomm{ written $\tscon{TOSNET}$ }{}\\{}
 \mid  \tscon{RD\_TOSHOST}                 \tsholcomm{ written $\tscon{TOSHOST}$ }{}\\{}
 \mid  \tscon{RD\_OTHER} \;\Mof  \;\tstype{byte} \# \tsunknown{word32}  \tsholcomm{ written $\tscon{OTHER}$ }}
}
{}
}

\newcommand{\defnicmpTtimeTexceededTcode}{\ddefnn{icmpTtimeTexceededTcode}{\iA{icmp\_time\_exceeded\_code}}{\subddefnA{icmp\_time\_exceeded\_code}{\tstype{icmp\_time\_exceeded\_code} ={}\\{}
 \tscon{INTRANS}{}\\{}
 \mid  \tscon{REASS}{}\\{}
 \mid  \tscon{TX\_OTHER} \;\Mof  \;\tstype{byte} \# \tsunknown{word32}  \tsholcomm{ written $\tscon{OTHER}$ }}
}
{}
}

\newcommand{\defnicmpTparamprobTcode}{\ddefnn{icmpTparamprobTcode}{\iA{icmp\_paramprob\_code}}{\subddefnA{icmp\_paramprob\_code}{\tstype{icmp\_paramprob\_code} ={}\\{}
 \tscon{BADHDR}{}\\{}
 \mid  \tscon{NEEDOPT}{}\\{}
 \mid  \tscon{PP\_OTHER} \;\Mof  \;\tstype{byte} \# \tsunknown{word32}  \tsholcomm{ written $\tscon{OTHER}$ }}
}
{}
}

\newcommand{\defnicmpType}{\ddefnn{icmpType}{\iA{icmpType}}{\subddefnA{icmpType}{\tstype{icmpType} ={}\\{}
 \tscon{ICMP\_UNREACH}       \;\Mof  \;\tstype{icmp\_unreach\_code}{}\\{}
 \mid  \tscon{ICMP\_SOURCE\_QUENCH} \;\Mof  \;\tstype{icmp\_source\_quench\_code}{}\\{}
 \mid  \tscon{ICMP\_REDIRECT}      \;\Mof  \;\tstype{icmp\_redirect\_code}{}\\{}
 \mid  \tscon{ICMP\_TIME\_EXCEEDED} \;\Mof  \;\tstype{icmp\_time\_exceeded\_code}{}\\{}
 \mid  \tscon{ICMP\_PARAMPROB}     \;\Mof  \;\tstype{icmp\_paramprob\_code}{}\\{}
 \tscomm{ FreeBSD 4.6-RELEASE also does: ICMP\textunderscore{}ECHO, ICMP\textunderscore{}TSTMP, ICMP\textunderscore{}MASKREQ }}
}
{}
}

\newcommand{\defnicmpDatagram}{\ddefnn{icmpDatagram}{\iA{icmpDatagram}}{\subddefnA[{ ICMP datagram type }]{icmpDatagram}{\tstype{icmpDatagram}{}\\{}
 = \Mmagiclrec  \tsvar{is}_{1} : \tstype{ip} \;\;\tstype{option} ;     \tscomm{ this is the sender of this ICMP }{}\\{}
 \tsvar{is}_{2} : \tstype{ip} \;\;\tstype{option} ;     \tscomm{ this is the intended receiver of this ICMP }{}\\{}
 {}\\{}
 \tslongcomm{ we assume the enclosed IP always has at least 8 bytes of data, i.e., enough
          for all the fields below }{}\\{}
 \tsvar{is}_{3} : \tstype{ip} \;\;\tstype{option} ;     \tscomm{ source of enclosed IP datagram }{}\\{}
 \tsvar{is}_{4} : \tstype{ip} \;\;\tstype{option} ;     \tscomm{ destination of enclosed IP datagram }{}\\{}
 \tsvar{ps}_{3} : \tstype{port} \;\;\tstype{option};    \tscomm{ source port }{}\\{}
 \tsvar{ps}_{4} : \tstype{port} \;\;\tstype{option};    \tscomm{ destination port }{}\\{}
 \tsvar{proto} : \tstype{protocol};     \tscomm{ protocol }{}\\{}
 \tsvar{seq} : \tsaux{tcp\_seq\_local} \;\;\tstype{option};  \tscomm{ seq }{}\\{}
 \tsvar{t}   : \tstype{icmpType}{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\seccommnettyTip}{\clustersection{(TCP and UDP)}{IP messages}
\seccomm{
  An IP datagram is (for our purposes) either a TCP segment, an ICMP
  datagram, or a UDP datagram.  We use the type $\tstype{msg}$ for IP
  datagrams.  IP datagrams may be checked for sanity, and may have
  their $\tsvar{is}_{1}$ and $\tsvar{is}_{2}$ fields inspected.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{msg}$
&
&  IP message type \\
$\tsrule{sane\_msg}$
&
&  message well-formedness test (physical constraints imposed by format) \\
$\tsrule{msg\_is1}$
&
&  source IP of a message, written $\tsunknown{x}.\tsvar{is}_{1}$ \\
$\tsrule{msg\_is2}$
&
&  destination IP of a message, written $\tsunknown{x}.\tsvar{is}_{2}$ \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnmsg}{\ddefnn{msg}{\iA{msg}}{\subddefnA[{ IP message type }]{msg}{\tstype{msg} = \tscon{TCP} \;\Mof  \;\tstype{tcpSegment} \mid  \tscon{ICMP} \;\Mof  \;\tstype{icmpDatagram} \mid  \tscon{UDP} \;\Mof  \;\tstype{udpDatagram}}
}
{}
}

\newcommand{\defnsaneTmsg}{\ddefnn{saneTmsg}{\iA{sane\_msg}}{\subddefnA[{ message well-formedness test (physical constraints imposed by format) }]{sane\_msg}{\tsaux{sane\_msg} (\tscon{TCP} \;\tsunknown{seg}) = \tsaux{sane\_seg} \;\tsunknown{seg} \Mwedge {}\\{}
 \tsaux{sane\_msg} (\tscon{ICMP} \;\tsunknown{dgm}) = \Mtrue  \Mwedge {}\\{}
 \tsaux{sane\_msg} (\tscon{UDP} \;\tsunknown{dgm'}) = \tsaux{sane\_udpdgm} \;\tsunknown{dgm'}}
}
{}
}

\newcommand{\defnmsgTisI}{\ddefnc{msgTisI}{\iA{msg\_is1}}{\subddefnA[{ source IP of a message, written $\tsunknown{x}.\tsvar{is}_{1}$ }]{msg\_is1}{\tsaux{msg\_is1} (\tscon{TCP} \;\tsunknown{seg})  = \tsunknown{seg}.\tsvar{is}_{1} \Mwedge {}\\{}
 \tsaux{msg\_is1} (\tscon{ICMP} \;\tsunknown{dgm}) = \tsunknown{dgm}.\tsvar{is}_{1} \Mwedge {}\\{}
 \tsaux{msg\_is1} (\tscon{UDP} \;\tsunknown{dgm'}) = \tsunknown{dgm'}.\tsvar{is}_{1}}
}
{}
}

\newcommand{\defnmsgTisII}{\ddefnn{msgTisII}{\iA{msg\_is2}}{\subddefnA[{ destination IP of a message, written $\tsunknown{x}.\tsvar{is}_{2}$ }]{msg\_is2}{\tsaux{msg\_is2} (\tscon{TCP} \;\tsunknown{seg})  = \tsunknown{seg}.\tsvar{is}_{2} \Mwedge {}\\{}
 \tsaux{msg\_is2} (\tscon{ICMP} \;\tsunknown{dgm}) = \tsunknown{dgm}.\tsvar{is}_{2} \Mwedge {}\\{}
 \tsaux{msg\_is2} (\tscon{UDP} \;\tsunknown{dgm'}) = \tsunknown{dgm'}.\tsvar{is}_{2}}
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPITnetTypes}
\showrule{\seccommnettyTtcp}
\showrule{\defntcpSegment}
\showrule{\defnsaneTseg}
\showrule{\seccommnettyTudp}
\showrule{\defnudpDatagram}
\showrule{\defnsaneTudpdgm}
\showrule{\seccommnettyTicmp}
\showrule{\defnprotocol}
\showrule{\defnicmpTunreachTcode}
\showrule{\defnicmpTsourceTquenchTcode}
\showrule{\defnicmpTredirectTcode}
\showrule{\defnicmpTtimeTexceededTcode}
\showrule{\defnicmpTparamprobTcode}
\showrule{\defnicmpType}
\showrule{\defnicmpDatagram}
\showrule{\seccommnettyTip}
\showrule{\defnmsg}
\showrule{\defnsaneTmsg}
\showrule{\defnmsgTisI}
\showrule{\defnmsgTisII}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore LIBinterface

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPITLIBinterface}{\chaptersection{ System call types}
\label{TCP1_LIBinterface}%
\chapcomm{
This file gives the system call API that is modelled by the
specification.

}
}

\newcommand{\seccommlibTinterface}{\clustersection{(TCP and UDP)}{The interface}
\seccomm{
The Sockets API is modelled by the library interface below.  As
discussed in volume 1, we refine the C interface slightly:
\begin{itemize}

\item We use ML-style datatypes, abstracting from pointers and length
parameters.

\item Where the C API provides multiple entry points to a single
operation (such as \wasverb{send}/\wasverb{sendto}/\wasverb{sendmsg}/\wasverb{write}, or
\wasverb{pselect}/\wasverb{select}) we combine them all into a single general
function.

\item Certain special cases of general functions (such as \wasverb{getsockopt}
with \wasverb{SO\textunderscore{}ERROR}, \wasverb{ioctl} with \wasverb{SIOCATMARK}, and \wasverb{fcntl} with
\wasverb{F\textunderscore{}GETFL}) have been pulled out into separate functions
($\tslib{getsockerr}$, $\tslib{sockatmark}$ (following POSIX), and
$\tslib{getfileflags}$ respectively).

\item Features not relevant to TCP or UDP (e.g. Unix domain sockets), or
historical artifacts (such as the address family / protocol family
distinction in \wasverb{socket}) are elided.
\end{itemize}

The HOL type $\tstype{LIB\_interface}$ defines the calls. It
takes their arguments to be the relevant HOL types (rather than values
of $\tstype{TLang}$) so that HOL typechecking ensures consistency.  The return
types of the calls cannot be embedded so neatly within the HOL type
system, so an additional $\tsaux{retType}$ function defines these (and HOL
typechecking does not check this data at present).


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{LIB\_interface}$
&
& \\
$\tsrule{retType}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnLIBTinterface}{\ddefnc{LIBTinterface}{\iA{LIB\_interface}}{\subddefnA{LIB\_interface}{\tstype{LIB\_interface} ={}\\{}
\quad \tslib{accept}       \;\Mof  \;\tstype{fd}{}\\{}
 \mid  \tslib{bind}         \;\Mof  (\tstype{fd} \# \tstype{ip} \;\;\tstype{option} \# \tstype{port} \;\;\tstype{option}){}\\{}
 \mid  \tslib{close}        \;\Mof  \;\tstype{fd}{}\\{}
 \mid  \tslib{connect}      \;\Mof  (\tstype{fd} \# \tstype{ip} \# \tstype{port} \;\;\tstype{option}){}\\{}
 \mid  \tslib{disconnect}   \;\Mof  \;\tstype{fd}{}\\{}
 \mid  \tslib{dup}          \;\Mof  \;\tstype{fd}{}\\{}
 \mid  \tslib{dupfd}        \;\Mof  (\tstype{fd} \# \tstype{int}){}\\{}
 \mid  \tslib{getfileflags} \;\Mof  \;\tstype{fd}{}\\{}
 \mid  \tslib{getifaddrs}   \;\Mof  \;(){}\\{}
 \mid  \tslib{getpeername}  \;\Mof  \;\tstype{fd}{}\\{}
 \mid  \tslib{getsockbopt}  \;\Mof  (\tstype{fd} \# \tstype{sockbflag}){}\\{}
 \mid  \tslib{getsockerr}   \;\Mof  \;\tstype{fd}{}\\{}
 \mid  \tslib{getsocklistening} \;\Mof  \;\tstype{fd}{}\\{}
 \mid  \tslib{getsockname}  \;\Mof  \;\tstype{fd}{}\\{}
 \mid  \tslib{getsocknopt}  \;\Mof  (\tstype{fd} \# \tstype{socknflag}){}\\{}
 \mid  \tslib{getsocktopt}  \;\Mof  (\tstype{fd} \# \tstype{socktflag}){}\\{}
 \mid  \tslib{listen}       \;\Mof  (\tstype{fd} \# \tstype{int}){}\\{}
 \mid  \tslib{pselect}      \;\Mof  (\tstype{fd} \;\tstype{list} \# \tstype{fd} \;\tstype{list} \# \tstype{fd} \;\tstype{list} \# (\tstype{int} \# \tstype{int}) \;\tstype{option} \# \tstype{signal} \;\tstype{list} \;\;\tstype{option}){}\\{}
 \mid  \tslib{recv}         \;\Mof  (\tstype{fd} \# \tstype{int} \# \tstype{msgbflag} \;\tstype{list}){}\\{}
 \mid  \tslib{send}         \;\Mof  (\tstype{fd} \# (\tstype{ip} \# \tstype{port}) \;\tstype{option} \# \tstype{string} \# \tstype{msgbflag} \;\tstype{list}){}\\{}
 \mid  \tslib{setfileflags} \;\Mof  (\tstype{fd} \# \tstype{filebflag} \;\tstype{list}){}\\{}
 \mid  \tslib{setsockbopt}  \;\Mof  (\tstype{fd} \# \tstype{sockbflag} \# \tstype{bool}){}\\{}
 \mid  \tslib{setsocknopt}  \;\Mof  (\tstype{fd} \# \tstype{socknflag} \# \tstype{int}){}\\{}
 \mid  \tslib{setsocktopt}  \;\Mof  (\tstype{fd} \# \tstype{socktflag} \# (\tstype{int} \# \tstype{int}) \;\tstype{option}){}\\{}
 \mid  \tslib{shutdown}     \;\Mof  (\tstype{fd} \# \tstype{bool} \# \tstype{bool}){}\\{}
 \mid  \tslib{sockatmark}   \;\Mof  \;\tstype{fd}{}\\{}
 \mid  \tslib{socket}       \;\Mof  \;\tstype{socktype}}
}
{\rulesubsection{Description}
Sockets calls with their argument types.

\rrulepad }
}

\newcommand{\defnretType}{\ddefnc{retType}{\iA{retType}}{\subddefnA{retType}{\tsaux{retType} (\tslib{accept}      \;\tsunknown{\_}) = \tscon{TLty\_pair}(\tscon{TLty\_fd},\tscon{TLty\_pair}(\tscon{TLty\_ip}, \tscon{TLty\_port})){}\\{}
 \Mwedge  \tsaux{retType} (\tslib{bind}        \;\tsunknown{\_}) = \tscon{TLty\_one}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{close}       \;\tsunknown{\_}) = \tscon{TLty\_one}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{connect}     \;\tsunknown{\_}) = \tscon{TLty\_one}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{disconnect}  \;\tsunknown{\_}) = \tscon{TLty\_one}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{dup}         \;\tsunknown{\_}) = \tscon{TLty\_fd}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{dupfd}       \;\tsunknown{\_}) = \tscon{TLty\_fd}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{getfileflags} \;\tsunknown{\_}) = \tscon{TLty\_list} \;\tscon{TLty\_filebflag}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{getifaddrs}          \;\tsunknown{\_}) = \tscon{TLty\_list}{}\\{}
\quad\quad\quad\quad (\tscon{TLty\_pair}(\tscon{TLty\_ifid},\tscon{TLty\_pair}(\tscon{TLty\_ip},\tscon{TLty\_pair}((\tscon{TLty\_list} \;\tscon{TLty\_ip}),\tscon{TLty\_netmask})))){}\\{}
 \Mwedge  \tsaux{retType} (\tslib{getpeername} \;\tsunknown{\_}) = \tscon{TLty\_pair}(\tscon{TLty\_ip}, \tscon{TLty\_port}){}\\{}
 \Mwedge  \tsaux{retType} (\tslib{getsockbopt} \;\tsunknown{\_}) = \tscon{TLty\_bool}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{getsockerr}  \;\tsunknown{\_}) = \tscon{TLty\_one}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{getsocklistening} \;\tsunknown{\_}) = \tscon{TLty\_bool}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{getsockname} \;\tsunknown{\_}) = \tscon{TLty\_pair}(\tscon{TLty\_lift} \;\tscon{TLty\_ip}, \tscon{TLty\_lift} \;\tscon{TLty\_port}){}\\{}
 \Mwedge  \tsaux{retType} (\tslib{getsocknopt} \;\tsunknown{\_}) = \tscon{TLty\_int}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{getsocktopt} \;\tsunknown{\_}) = \tscon{TLty\_lift} (\tscon{TLty\_pair}(\tscon{TLty\_int},\tscon{TLty\_int})){}\\{}
 \Mwedge  \tsaux{retType} (\tslib{listen}      \;\tsunknown{\_}) = \tscon{TLty\_one}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{pselect}     \;\tsunknown{\_}) = \tscon{TLty\_pair}(\tscon{TLty\_list} \;\tscon{TLty\_fd},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscon{TLty\_pair}(\tscon{TLty\_list} \;\tscon{TLty\_fd},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscon{TLty\_list} \;\tscon{TLty\_fd})){}\\{}
 \Mwedge  \tsaux{retType} (\tslib{recv}        \;\tsunknown{\_}) = \tscon{TLty\_pair} (\tscon{TLty\_string},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscon{TLty\_lift}(\tscon{TLty\_pair}(\tscon{TLty\_pair}(\tscon{TLty\_ip},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscon{TLty\_port}),{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscon{TLty\_bool}))){}\\{}
 \Mwedge  \tsaux{retType} (\tslib{send}        \;\tsunknown{\_}) = \tscon{TLty\_string}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{setfileflags} \;\tsunknown{\_}) = \tscon{TLty\_one}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{setsockbopt} \;\tsunknown{\_}) = \tscon{TLty\_one}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{setsocknopt} \;\tsunknown{\_}) = \tscon{TLty\_one}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{setsocktopt} \;\tsunknown{\_}) = \tscon{TLty\_one}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{shutdown}    \;\tsunknown{\_}) = \tscon{TLty\_one}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{sockatmark}  \;\tsunknown{\_}) = \tscon{TLty\_bool}{}\\{}
 \Mwedge  \tsaux{retType} (\tslib{socket}      \;\tsunknown{\_}) = \tscon{TLty\_fd}}
}
{\rulesubsection{Description}
Return types of sockets calls.

\rrulepad }
}

\newcommand{\seccommlibTgroups}{\clustersection{(TCP and UDP)}{Useful groups of calls}
\seccomm{For some purposes it is useful to group together all the system calls
that expect a single $\tstype{fd}$, and those that expect a socket $\tstype{fd}$.

}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{fd\_op}$
&
& \\
$\tsrule{fd\_sockop}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnfdTop}{\ddefnc{fdTop}{\iA{fd\_op}}{\subddefnA{fd\_op}{\tsaux{fd\_op} \;\tstype{fd} \;\tsunknown{opn} = ({}\\{}
 \tsunknown{opn} = \tslib{accept}(\tstype{fd}) \Mvee {}\\{}
 (\exists \tsvar{is} \;\tsvar{ps}. \tsunknown{opn} = \tslib{bind}(\tstype{fd},\tsvar{is},\tsvar{ps})) \Mvee {}\\{}
 \tsunknown{opn} = \tslib{close}(\tstype{fd}) \Mvee {}\\{}
 (\exists \tsvar{i} \;\tsvar{p}. \tsunknown{opn} = \tslib{connect}(\tstype{fd},\tsvar{i},\tsvar{p})) \Mvee {}\\{}
 \tsunknown{opn} = \tslib{disconnect}(\tstype{fd}) \Mvee {}\\{}
 \tsunknown{opn} = \tslib{dup}(\tstype{fd}) \Mvee {}\\{}
 (\exists \tsvar{fd}'. \tsunknown{opn} = \tslib{dupfd}(\tstype{fd},\tsvar{fd}')) \Mvee {}\\{}
 (\tsunknown{opn} = \tslib{getfileflags}(\tstype{fd})) \Mvee {}\\{}
 (\exists \tsvar{flags}. \tsunknown{opn} = \tslib{setfileflags}(\tstype{fd},\tsvar{flags})) \Mvee {}\\{}
 \tsunknown{opn} = \tslib{getsockname}(\tstype{fd}) \Mvee {}\\{}
 \tsunknown{opn} = \tslib{getpeername}(\tstype{fd}) \Mvee {}\\{}
 (\exists \tsvar{sfb}. \tsunknown{opn} = \tslib{getsockbopt}(\tstype{fd},\tsvar{sfb})) \Mvee {}\\{}
 (\exists \tsvar{sfn}. \tsunknown{opn} = \tslib{getsocknopt}(\tstype{fd},\tsvar{sfn})) \Mvee {}\\{}
 (\exists \tsvar{sft}. \tsunknown{opn} = \tslib{getsocktopt}(\tstype{fd},\tsvar{sft})) \Mvee {}\\{}
 (\exists \tsvar{sfb} \;\tsvar{b}. \tsunknown{opn} = \tslib{setsockbopt}(\tstype{fd},\tsvar{sfb},\tsvar{b})) \Mvee {}\\{}
 (\exists \tsvar{sfn} \;\tsvar{n}. \tsunknown{opn} = \tslib{setsocknopt}(\tstype{fd},\tsvar{sfn},\tsvar{n})) \Mvee {}\\{}
 (\exists \tsvar{sft} \;\tsvar{t}. \tsunknown{opn} = \tslib{setsocktopt}(\tstype{fd},\tsvar{sft},\tsvar{t})) \Mvee {}\\{}
 (\exists \tsvar{n}. \tsunknown{opn} = \tslib{listen}(\tstype{fd},\tsvar{n})) \Mvee {}\\{}
 (\exists \tsvar{n} \;\tsvar{opt}. \tsunknown{opn} = \tslib{recv}(\tstype{fd},\tsvar{n},\tsvar{opt})) \Mvee {}\\{}
 (\exists \tsvar{data} \;\tsvar{opt}. \tsunknown{opn} = \tslib{send}(\tstype{fd},\tsvar{data},\tsvar{opt})) \Mvee {}\\{}
 (\exists \tsvar{r} \;\tsvar{w}. \tsunknown{opn} = \tslib{shutdown}(\tstype{fd},\tsvar{r},\tsvar{w})) \Mvee {}\\{}
 \tsunknown{opn} = \tslib{sockatmark}(\tstype{fd}) \Mvee {}\\{}
 \tsunknown{opn} = \tslib{getsockerr}(\tstype{fd}) \Mvee {}\\{}
 \tsunknown{opn} = \tslib{getsocklistening}(\tstype{fd}){}\\{}
 )}
}
{\rulesubsection{Description}
Calls that expect a (single) fd.

\rrulepad }
}

\newcommand{\defnfdTsockop}{\ddefnc{fdTsockop}{\iA{fd\_sockop}}{\subddefnA{fd\_sockop}{\tsaux{fd\_sockop} \;\tstype{fd} \;\tsunknown{opn} = ({}\\{}
 \tsunknown{opn} = \tslib{accept}(\tstype{fd}) \Mvee {}\\{}
 (\exists \tsvar{is} \;\tsvar{ps}. \tsunknown{opn} = \tslib{bind}(\tstype{fd},\tsvar{is},\tsvar{ps})) \Mvee {}\\{}
 (\exists \tsvar{i} \;\tsvar{p}. \tsunknown{opn} = \tslib{connect}(\tstype{fd},\tsvar{i},\tsvar{p})) \Mvee {}\\{}
 \tsunknown{opn} = \tslib{disconnect}(\tstype{fd}) \Mvee {}\\{}
 \tsunknown{opn} = \tslib{getsockname}(\tstype{fd}) \Mvee {}\\{}
 \tsunknown{opn} = \tslib{getpeername}(\tstype{fd}) \Mvee {}\\{}
 (\exists \tsvar{sfb}. \tsunknown{opn} = \tslib{getsockbopt}(\tstype{fd},\tsvar{sfb})) \Mvee {}\\{}
 (\exists \tsvar{sfn}. \tsunknown{opn} = \tslib{getsocknopt}(\tstype{fd},\tsvar{sfn})) \Mvee {}\\{}
 (\exists \tsvar{sft}. \tsunknown{opn} = \tslib{getsocktopt}(\tstype{fd},\tsvar{sft})) \Mvee {}\\{}
 (\exists \tsvar{sfb} \;\tsvar{b}. \tsunknown{opn} = \tslib{setsockbopt}(\tstype{fd},\tsvar{sfb},\tsvar{b})) \Mvee {}\\{}
 (\exists \tsvar{sfn} \;\tsvar{n}. \tsunknown{opn} = \tslib{setsocknopt}(\tstype{fd},\tsvar{sfn},\tsvar{n})) \Mvee {}\\{}
 (\exists \tsvar{sft} \;\tsvar{t}. \tsunknown{opn} = \tslib{setsocktopt}(\tstype{fd},\tsvar{sft},\tsvar{t})) \Mvee {}\\{}
 (\exists \tsvar{n}. \tsunknown{opn} = \tslib{listen}(\tstype{fd},\tsvar{n})) \Mvee {}\\{}
 (\exists \tsvar{n} \;\tsvar{opt}. \tsunknown{opn} = \tslib{recv}(\tstype{fd},\tsvar{n},\tsvar{opt})) \Mvee {}\\{}
 (\exists \tsvar{data} \;\tsvar{opt}. \tsunknown{opn} = \tslib{send}(\tstype{fd},\tsvar{data},\tsvar{opt})) \Mvee {}\\{}
 (\exists \tsvar{r} \;\tsvar{w}. \tsunknown{opn} = \tslib{shutdown}(\tstype{fd},\tsvar{r},\tsvar{w})) \Mvee {}\\{}
 \tsunknown{opn} = \tslib{sockatmark}(\tstype{fd}) \Mvee {}\\{}
 \tsunknown{opn} = \tslib{getsockerr}(\tstype{fd}) \Mvee {}\\{}
 \tsunknown{opn} = \tslib{getsocklistening}(\tstype{fd}){}\\{}
 )}
}
{\rulesubsection{Description}
Calls that expect a (single) socket fd.

\rrulepad }
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPITLIBinterface}
\showrule{\seccommlibTinterface}
\showrule{\defnLIBTinterface}
\showrule{\defnretType}
\showrule{\seccommlibTgroups}
\showrule{\defnfdTop}
\showrule{\defnfdTsockop}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore host0

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPIThostZ}{\chaptersection{ Host LTS labels and rule categories}
\label{TCP1_host0}%
\chapcomm{
This file defines the labels for the host labelled transition system,
characterising the possible interactions between a host and its environment.
It also defines various categories for the host LTS rules.


}
}

\newcommand{\seccommhostZTlabels}{\clustersection{(TCP and UDP)}{Transition labels}
\seccomm{
Host transition labels.

}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{Lhost0}$
&
&  Host transition labels \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnLhostZ}{\ddefnn{LhostZ}{\iA{Lhost0}}{\subddefnA[{ Host transition labels }]{Lhost0}{\tstype{Lhost0} ={}\\{}
\quad\quad \tscomm{ library interface }{}\\{}
\quad\quad\quad \tscon{Lh\_call} \Mof  \;\tstype{tid} \# \tstype{LIB\_interface}                        \tsholcomm{ invocation of LIB call, written e.g.~$\MLhcall{\tstype{tid}}{(\tslib{socket} (\tstype{socktype}))}$ } {}\\{}
\quad\quad \mid  \tscon{Lh\_return} \Mof  \;\tstype{tid} \# \tstype{TLang}                              \tsholcomm{ return result of LIB call, written $\MLhreturn{\tstype{tid}}{\tsunknown{v}} $ } {}\\{}
 {}\\{}
\quad\quad \tscomm{ message transmission and receipt }{}\\{}
\quad\quad \mid  \tscon{Lh\_senddatagram} \Mof  \;\tstype{msg}                               \tsholcomm{ output of message to the network, written $\MLhsenddatagram{\tstype{msg}}$ } {}\\{}
\quad\quad \mid  \tscon{Lh\_recvdatagram} \Mof  \;\tstype{msg}                              \tsholcomm{ input of message from the network, written $\MLhrecvdatagram{\tstype{msg}}$  } {}\\{}
\quad\quad \mid  \tscon{Lh\_loopdatagram} \Mof  \;\tstype{msg}                               \tsholcomm{ loopback output/input, written $\MLhloopdatagram{\tstype{msg}}$ } {}\\{}
 {}\\{}
\quad\quad \tscomm{ connectivity changes }{}\\{}
\quad\quad \mid  \tscon{Lh\_interface} \Mof  \;\tstype{ifid} \# \tstype{bool}                         \tsholcomm{ set interface status to boolean $\tsvar{up}$, written $\tscon{Lh\_interface} (\tsvar{ifid},\tsvar{up})$ } {}\\{}
 {}\\{}
\quad\quad \tscomm{ miscellaneous }{}\\{}
\quad\quad \mid  \MLhtau                                               \tsholcomm{ internal transition, written $\MLhtau $ } {}\\{}
\quad\quad \mid  \tscon{Lh\_epsilon} \Mof  \;\tsaux{duration}                              \tsholcomm{ time passage, written $\Meps{\tsunknown{dur}}$ } {}\\{}
\quad\quad \mid  \tscon{Lh\_trace} \Mof  \;\tsunknown{tracerecord}                             \tsholcomm{ TCP trace record, written $\tscon{Lh\_trace} \;\tsunknown{tr}$ } }
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPIThostZ}
\showrule{\seccommhostZTlabels}
\showrule{\defnLhostZ}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore ruleids

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPITruleids}{\chaptersection{ Rule names}
\label{TCP1_ruleids}%
\chapcomm{
This file defines the names of transition rules in the specification.


}
}

\newcommand{\seccommruleidsTruleids}{\clustersection{(Rule only)}{names}
\seccomm{
We list here the names of all rules in the host LTS.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{rule\_ids}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnruleTids}{\ddefnn{ruleTids}{\iA{rule\_ids}}{\subddefnA{rule\_ids}{\tstype{rule\_ids} = \tsrule{return\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{socket\_1} \mid  \tsrule{socket\_2}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{accept\_1} \mid  \tsrule{accept\_2} \mid  \tsrule{accept\_3} \mid  \tsrule{accept\_4} \mid  \tsrule{accept\_5} \mid  \tsrule{accept\_6} \mid  \tsrule{accept\_7}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{bind\_1} \mid  \tsrule{bind\_2} \mid  \tsrule{bind\_3} \mid  \tsrule{bind\_5} \mid  \tsrule{bind\_7} \mid  \tsrule{bind\_9}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{close\_1} \mid  \tsrule{close\_2} \mid  \tsrule{close\_3} \mid  \tsrule{close\_4} \mid  \tsrule{close\_5}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{close\_6} \mid  \tsrule{close\_7} \mid  \tsrule{close\_8} \mid  \tsrule{close\_10}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{connect\_1} \mid \tsrule{connect\_1a} \tscomm{ FIXME Spec3 only- split Spec1 rule? } \mid  \tsrule{connect\_2} \mid  \tsrule{connect\_3} \mid  \tsrule{connect\_4} \mid  \tsrule{connect\_4a} \mid  \tsrule{connect\_5}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{connect\_5a} \mid  \tsrule{connect\_5b} \mid  \tsrule{connect\_5c} \mid  \tsrule{connect\_5d} \mid  \tsrule{connect\_6}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{connect\_7} \mid  \tsrule{connect\_8} \mid  \tsrule{connect\_9} \mid  \tsrule{connect\_10}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{disconnect\_1} \mid  \tsrule{disconnect\_2} \mid  \tsrule{disconnect\_3} \mid  \tsrule{disconnect\_4} \mid  \tsrule{disconnect\_5}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{dup\_1} \mid  \tsrule{dup\_2}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{dupfd\_1} \mid  \tsrule{dupfd\_3} \mid  \tsrule{dupfd\_4}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{listen\_1} \mid  \tsrule{listen\_1b} \mid  \tsrule{listen\_1c} \mid  \tsrule{listen\_2} \mid  \tsrule{listen\_3} \mid  \tsrule{listen\_4} \mid  \tsrule{listen\_5} \mid  \tsrule{listen\_7}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{getfileflags\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{setfileflags\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{getifaddrs\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{getsockbopt\_1} \mid  \tsrule{getsockbopt\_2}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{setsockbopt\_1} \mid  \tsrule{setsockbopt\_2}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{getsocknopt\_1} \mid  \tsrule{getsocknopt\_4}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{setsocknopt\_1} \mid  \tsrule{setsocknopt\_4} \mid  \tsrule{setsocknopt\_2}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{getsocktopt\_1} \mid  \tsrule{getsocktopt\_4}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{setsocktopt\_1} \mid  \tsrule{setsocktopt\_4} \mid  \tsrule{setsocktopt\_5}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{getsockerr\_1} \mid  \tsrule{getsockerr\_2}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{getsocklistening\_1} \mid  \tsrule{getsocklistening\_2} \mid  \tsrule{getsocklistening\_3}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{shutdown\_1} \mid  \tsrule{shutdown\_2} \mid  \tsrule{shutdown\_3} \mid  \tsrule{shutdown\_4}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{recv\_1} \mid  \tsrule{recv\_2} \mid  \tsrule{recv\_3} \mid  \tsrule{recv\_4} \mid  \tsrule{recv\_5} \mid  \tsrule{recv\_6} \mid  \tsrule{recv\_7} \mid  \tsrule{recv\_8} \mid  \tsrule{recv\_8a} \mid  \tsrule{recv\_9}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{recv\_11} \mid  \tsrule{recv\_12} \mid  \tsrule{recv\_13} \mid  \tsrule{recv\_14} \mid  \tsrule{recv\_15} \mid  \tsrule{recv\_16} \mid  \tsrule{recv\_17} \mid  \tsrule{recv\_20} \mid  \tsrule{recv\_21} \mid  \tsrule{recv\_22}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{recv\_23} \mid  \tsrule{recv\_24}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{send\_1} \mid  \tsrule{send\_2} \mid  \tsrule{send\_3} \mid  \tsrule{send\_3a} \mid  \tsrule{send\_4} \mid  \tsrule{send\_5} \mid  \tsrule{send\_5a}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{send\_6} \mid  \tsrule{send\_7} \mid  \tsrule{send\_8} \mid  \tsrule{send\_9} \mid  \tsrule{send\_10}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{send\_11} \mid  \tsrule{send\_12} \mid  \tsrule{send\_13} \mid  \tsrule{send\_14} \mid  \tsrule{send\_15}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{send\_16} \mid  \tsrule{send\_17} \mid  \tsrule{send\_18} \mid  \tsrule{send\_19} \mid  \tsrule{send\_21} \mid  \tsrule{send\_22} \mid  \tsrule{send\_23}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{sockatmark\_1} \mid  \tsrule{sockatmark\_2}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{pselect\_1} \mid  \tsrule{pselect\_2} \mid  \tsrule{pselect\_3} \mid  \tsrule{pselect\_4} \mid  \tsrule{pselect\_5}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{pselect\_6}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{getsockname\_1} \mid  \tsrule{getsockname\_2} \mid  \tsrule{getsockname\_3}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{getpeername\_1} \mid  \tsrule{getpeername\_2}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{badf\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{notsock\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{intr\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{resourcefail\_1} \mid  \tsrule{resourcefail\_2}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{deliver\_in\_1} \mid  \tsrule{deliver\_in\_1b} \mid  \tsrule{deliver\_in\_2} \mid  \tsrule{deliver\_in\_2a}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{deliver\_in\_3} \mid  \tsrule{deliver\_in\_3a} \mid  \tsrule{deliver\_in\_3b} \mid  \tsrule{deliver\_in\_3c}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{deliver\_in\_4} \mid  \tsrule{deliver\_in\_5} \mid  \tsrule{deliver\_in\_6}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{deliver\_in\_7} \mid  \tsrule{deliver\_in\_7a} \mid  \tsrule{deliver\_in\_7b} \mid  \tsrule{deliver\_in\_7c}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{deliver\_in\_7d} \mid  \tsrule{deliver\_in\_8} \mid  \tsrule{deliver\_in\_9}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{deliver\_in\_icmp\_1} \mid  \tsrule{deliver\_in\_icmp\_2} \mid  \tsrule{deliver\_in\_icmp\_3}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{deliver\_in\_icmp\_4} \mid  \tsrule{deliver\_in\_icmp\_5} \mid  \tsrule{deliver\_in\_icmp\_6}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{deliver\_in\_icmp\_7}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{deliver\_in\_udp\_1} \mid  \tsrule{deliver\_in\_udp\_2} \mid  \tsrule{deliver\_in\_udp\_3}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{deliver\_in\_99} \mid  \tsrule{deliver\_in\_99a}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{timer\_tt\_rexmt\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{timer\_tt\_rexmtsyn\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{timer\_tt\_persist\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{timer\_tt\_2msl\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{timer\_tt\_delack\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{timer\_tt\_conn\_est\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{timer\_tt\_keep\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{timer\_tt\_fin\_wait\_2\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{deliver\_out\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{deliver\_out\_99}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{deliver\_loop\_99}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{trace\_1} \mid  \tsrule{trace\_2}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{interface\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{epsilon\_1}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{epsilon\_2}{}\\{}
\quad\quad\quad\quad\quad \mid  \tsrule{FIXME} \tscomm{ marker for new rules }}
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPITruleids}
\showrule{\seccommruleidsTruleids}
\showrule{\defnruleTids}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore timers

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPITtimers}{\chaptersection{ Timers}
\label{TCP1_timers}%
\chapcomm{
This file defines the various kinds of timer that are used by the host
specification.
%
   Timers are host-state components that are updated by the
   passage of time, in $\Meps{\tsunknown{dur}}$ transitions.
%
   We define four kinds of timer:

\begin{enumerate}
\item the deadline timer ($\tsunknown{'a} \;\tstype{timed}$), which wraps a value in a timer
      that will count towards a (possibly fuzzy) deadline, and stop
      the progress of time when it reaches the maximum deadline.

\item the time-window timer ($\tsunknown{'a} \;\tstype{timewindow}$), which wraps a value in a
      timer just like a deadline timer, except that the value merely
      vanishes when it expires, rather than impeding the progress of
      time.

      These are an optimisation, designed to avoid having an extra
      rule (and consequent $\MLhtau $ transitions) just for processing the
      expiry of such values.

\item the ticker ($\tstype{ticker}$), which contains a $\tsaux{ts\_seq}$ (integral
      wraparound 32-bit type) that is incremented by one for every
      time a certain interval passes.  It also contains the real
      remainder, and the interval size that corresponds to a step.

\item the stopwatch ($\tstype{stopwatch}$), which may be reset at any time
      and counts upwards indefinitely from zero.  Note it may be
      necessary to add some fuzziness to this timer.

\end{enumerate}

   For each timer we define a constructor and a time-passage function.
   The time-passage function takes a duration (positive real) and a
   timer, and returns either the timer, or $*$ if time is not
   permitted by the timer to pass that far (i.e., an urgent instant
   would be passed).  Timers that never need to stop time do not
   return an option type.  Timers that behave nondeterministically are
   defined relationally (taking the "result" as argument and returning
   a bool).

   For all of them, we want the two properties defined by Lynch and
   Vaandrager in Inf. and Comp., 128(1), 1996
   (http://theory.lcs.mit.edu/tds/papers/Lynch/IC96.html) as S1 and S2
   to hold.


}
}

\newcommand{\seccommtimersTprops}{\clustersection{(TCP and UDP)}{Properties}
\seccomm{
Axioms of time, that all timers must satisfy.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{time\_pass\_additive}$
&
& \\
$\tsrule{time\_pass\_trajectory}$
&
& \\
$\tsrule{opttorel}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntimeTpassTadditive}{\ddefnc{timeTpassTadditive}{\iA{time\_pass\_additive}}{\subddefnA{time\_pass\_additive}{(\tsaux{time\_pass\_additive} : (\tsaux{duration} \Mtotype  \tsunknown{'a} \Mtotype  \tsunknown{'a} \Mtotype  \tstype{bool}) \Mtotype  \tstype{bool}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{time\_pass}{}\\{}
 = \forall \tsvar{dur}_{1} \;\tsvar{dur}_{2} \;\tsvar{s}_{0} \;\tsvar{s}_{1} \;\tsvar{s}_{2}.{}\\{}
\quad\quad \tsunknown{time\_pass} \;\tsvar{dur}_{1} \;\tsvar{s}_{0} \;\tsvar{s}_{1} \Mwedge  \tsunknown{time\_pass} \;\tsvar{dur}_{2} \;\tsvar{s}_{1} \;\tsvar{s}_{2} \implies  \tsunknown{time\_pass} (\tsvar{dur}_{1}+\tsvar{dur}_{2}) \tsvar{s}_{0} \;\tsvar{s}_{2}}
}
{\rulesubsection{Description}
Property S1, additivity:
%
    If $\tsunknown{s'} \Mtransition{\Meps{\tsunknown{d}}}{1XXXXX\Mtransitionerr{-->}} \tsunknown{s''}$ and $\tsunknown{s''} \Mtransition{\Meps{\tsunknown{d'}}}{1XXXXX\Mtransitionerr{-->}} \tsunknown{s}$ then $\tsunknown{s'} \Mtransition{\Meps{\tsunknown{d}+\tsunknown{d'}}}{1XXXXX\Mtransitionerr{-->}} \tsunknown{s}$.

\rrulepad }
}

\newcommand{\defntimeTpassTtrajectory}{\ddefnc{timeTpassTtrajectory}{\iA{time\_pass\_trajectory}}{\subddefnA{time\_pass\_trajectory}{(\tsaux{time\_pass\_trajectory} : (\tsaux{duration} \Mtotype  \tsunknown{'a} \Mtotype  \tsunknown{'a} \Mtotype  \tstype{bool}) \Mtotype  \tstype{bool}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{time\_pass}{}\\{}
 = \forall \tsvar{dur} \;\tsvar{s}_{0} \;\tsvar{s}_{1}.{}\\{}
\quad\quad \tsunknown{time\_pass} \;\tsvar{dur} \;\tsvar{s}_{0} \;\tsvar{s}_{1}{}\\{}
\quad\quad \implies {}\\{}
\quad\quad \exists \tsvar{w}.{}\\{}
\quad\quad\quad \tsvar{w} \;0   = \tsvar{s}_{0} \Mwedge {}\\{}
\quad\quad\quad \tsvar{w} \;\tsvar{dur} = \tsvar{s}_{1} \Mwedge {}\\{}
\quad\quad\quad \forall \tsvar{t} \;\tsvar{t}'.{}\\{}
\quad\quad\quad\quad 0 \leq  \tsvar{t}  \Mwedge  \tsvar{t} \leq  \tsvar{dur} \Mwedge {}\\{}
\quad\quad\quad\quad 0 \leq  \tsvar{t}' \Mwedge  \tsvar{t}' \leq  \tsvar{dur} \Mwedge {}\\{}
\quad\quad\quad\quad \tsvar{t} < \tsvar{t}'{}\\{}
\quad\quad\quad\quad \implies {}\\{}
\quad\quad\quad\quad \tsunknown{time\_pass} (\tsvar{t}'-\tsvar{t}) (\tsvar{w} \;\tsvar{t}) (\tsvar{w} \;\tsvar{t}')}
}
{\rulesubsection{Description}
Property S2 is defined as follows:
    Each time passage step $\tsunknown{s'} \Mtransition{\Meps{\tsunknown{d}}}{1XXXXX\Mtransitionerr{-->}} \tsunknown{s}$ has a \emph{trajectory},
  where a trajectory is defined as follows.
  If $I$ is any left-closed interval of $\mathbb{R} \geq 0$ beginning with 0, then
  an $I$-trajectory is a function $w$ from $I$ to $\mathrm{states}(A)$ such that
    $\tsunknown{w}(\tsvar{t}) \Mtransition{\Meps{\tsvar{t}'-\tsvar{t}}}{1XXXXX\Mtransitionerr{-->}} \tsunknown{w}(\tsvar{t}')$ for all $t$,$t'$ in $I$ with $t < t'$.

  Now define $w.\mathrm{fstate} = w(0)$, $w.\mathrm{ltime}$ to be the supremum of $I$, and if
  $I$ is right-closed, $w.\mathrm{lstate} = w(w.\mathrm{ltime})$.  Then a trajectory for a
  step $\tsunknown{s'} \Mtransition{\Meps{\tsunknown{d}}}{1XXXXX\Mtransitionerr{-->}} \tsunknown{s}$ is a $[0,d]$-trajectory with $w.\mathrm{fstate} = s'$ and
  $w.\mathrm{lstate} = s$.

  In our case, S2 (which we call ``trajectory'') may be stated as follows:
     For each time passage step $\tsunknown{s'} \Mtransition{\Meps{\tsunknown{d}}}{1XXXXX\Mtransitionerr{-->}} \tsunknown{s}$, there exists a
     function $w$ from $[0,d]$ to states such that $w(0) = s'$, $w(d) = s$,
     and $\tsunknown{w}(\tsvar{t}) \Mtransition{\Meps{\tsvar{t}'-\tsvar{t}}}{1XXXXX\Mtransitionerr{-->}} \tsunknown{w}(\tsvar{t}')$ for all $t$,$t'$ in $[0,d]$ with $t < t'$.


\rrulepad }
}

\newcommand{\defnopttorel}{\ddefnc{opttorel}{\iA{opttorel}}{\subddefnA{opttorel}{(\tsaux{opttorel} : (\tsaux{duration} \Mtotype  \tsunknown{'a} \Mtotype  \tsunknown{'a} \;\;\tstype{option}) \Mtotype  (\tsaux{duration} \Mtotype  \tsunknown{'a} \Mtotype  \tsunknown{'a} \Mtotype  \tstype{bool})){}\\{}
\quad\quad\quad \tsunknown{tp} \;\tsunknown{dur} \;\tsunknown{x} \;\tsunknown{y}{}\\{}
 = \Mcase  \;\tsunknown{tp} \;\tsunknown{dur} \;\tsunknown{x} \;\Mof {}\\{}
\quad\quad\quad \Msome  \;\tsunknown{x'} \Mtotype  \tsunknown{y} = \tsunknown{x'}{}\\{}
\quad \Mdpipe  *    \Mtotype  \Mfalse }
}
{\rulesubsection{Description}
Impedance-matching coercion.

\rrulepad }
}

\newcommand{\seccommtimersTtimer}{\clustersection{(TCP and UDP)}{Basic timer $\tstype{timer}$}
\seccomm{
The basic timer, $\tstype{timer}$, is a triple of the elapsed time, the
minimum expiry time, and the maximum expiry time.  It may expire at
any time after the minimum expiry time, but time may not progress
beyond the maximum expiry time.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{timer}$
&
& \\
$\tsrule{fuzzy\_timer}$
&
&  timer that goes off in the interval $ [\tsunknown{d}-\tsunknown{eps},\tsunknown{d}+\tsunknown{fuz}] $, like a BSD ticks-based timer \\
$\tsrule{sharp\_timer}$
&
&  timer that goes off at exactly $\tsunknown{d}$ after now \\
$\tsrule{never\_timer}$
&
&  timer that never goes off \\
$\tsrule{upper\_timer}$
&
&  timer that goes off between now and $\tsunknown{d}$ \\
$\tsrule{timer\_expires}$
&
&  true if the timer may expire now \\
$\tsrule{Time\_Pass\_timer}$
&
&  state of timer after time passage \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntimer}{\ddefnn{timer}{\iA{timer}}{\subddefnA{timer}{\tstype{timer} = \tscon{Timer} \;\Mof  \;\tsaux{duration} \# \tstype{time} \# \tstype{time}}
}
{}
}

\newcommand{\defnfuzzyTtimer}{\ddefnn{fuzzyTtimer}{\iA{fuzzy\_timer}}{\subddefnA[{ timer that goes off in the interval $ [\tsunknown{d}-\tsunknown{eps},\tsunknown{d}+\tsunknown{fuz}] $, like a BSD ticks-based timer }]{fuzzy\_timer}{\tsholcomm{ $\tsunknown{fuz}$ is some fuzziness added to mask the atomic nature of the model. }{}\\{}
 {}\\{}
 (\tsaux{fuzzy\_timer} : \tstype{time} \Mtotype  \tsaux{duration} \Mtotype  \tsaux{duration} \Mtotype  \tstype{timer}){}\\{}
\quad\quad\quad\quad\quad \tsunknown{d} \;\tsunknown{eps} \;\tsunknown{fuz} = \tscon{Timer}(0,\tsunknown{d}-\tsunknown{eps},\tsunknown{d}+\tsunknown{fuz})}
}
{}
}

\newcommand{\defnsharpTtimer}{\ddefnc{sharpTtimer}{\iA{sharp\_timer}}{\subddefnA[{ timer that goes off at exactly $\tsunknown{d}$ after now }]{sharp\_timer}{\tsaux{sharp\_timer} \;\tsunknown{d} = \tsaux{fuzzy\_timer} \;\tsunknown{d} \;0 \;0}
}
{}
}

\newcommand{\defnneverTtimer}{\ddefnc{neverTtimer}{\iA{never\_timer}}{\subddefnA[{ timer that never goes off }]{never\_timer}{\tsaux{never\_timer} = \tscon{Timer}(0,\infty,\infty)}
}
{}
}

\newcommand{\defnupperTtimer}{\ddefnn{upperTtimer}{\iA{upper\_timer}}{\subddefnA[{ timer that goes off between now and $\tsunknown{d}$ }]{upper\_timer}{\tsaux{upper\_timer} \;\tsunknown{d} = \tscon{Timer}(0,0,\tsunknown{d})}
}
{}
}

\newcommand{\defntimerTexpires}{\ddefnn{timerTexpires}{\iA{timer\_expires}}{\subddefnA[{ true if the timer may expire now }]{timer\_expires}{\tslongcomm{ NB: we assume below that this is monotonic; if it is once true it
     is always true (at least at any time that can be reached }{}\\{}
 (\tsaux{timer\_expires} : \tstype{timer} \Mtotype  \tstype{bool}) (\tscon{Timer}(\tsvar{e},\tsunknown{deadmin},\tsunknown{deadmax})){}\\{}
 = (\tstype{time} \;\tsvar{e} \geq  \tsunknown{deadmin})}
}
{}
}

\newcommand{\defnTimeTPassTtimer}{\ddefnn{TimeTPassTtimer}{\iA{Time\_Pass\_timer}}{\subddefnA[{ state of timer after time passage }]{Time\_Pass\_timer}{(\tsaux{Time\_Pass\_timer} : \tsaux{duration} \Mtotype  \tstype{timer} \Mtotype  \tstype{timer} \;\;\tstype{option}){}\\{}
 \tsunknown{dur} (\tscon{Timer}(\tsvar{e},\tsunknown{deadmin},\tsunknown{deadmax})){}\\{}
 = \Mlet  \;\tsvar{e}' = \tsvar{e} + \tsunknown{dur}{}\\{}
 \Min {}\\{}
 \Mif  \;\tstype{time} \;\tsvar{e}' \leq  \tsunknown{deadmax}{}\\{}
 \Mthen  \;\Msome  (\tscon{Timer}(\tsvar{e}',\tsunknown{deadmin},\tsunknown{deadmax})){}\\{}
 \Melse  \;*}
}
{}
}

\newcommand{\seccommtimersTtimed}{\clustersection{(TCP and UDP)}{Deadline timer $\tstype{timed}$}
\seccomm{
The deadline timer $\tsunknown{'a} \;\tstype{timed}$ is simply a value $\tsunknown{'a}$ annotated by
a $\tstype{timer}$.  This is a very convenient idiom.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{timed}$
&
& \\
$\tsrule{timed\_val\_of}$
&
& \\
$\tsrule{timed\_timer\_of}$
&
& \\
$\tsrule{timed\_expires}$
&
& \\
$\tsrule{Time\_Pass\_timed}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntimed}{\ddefnn{timed}{\iA{timed}}{\subddefnA{timed}{\tstype{timed} = \tscon{Timed} \Mof  \;\tsunknown{'a} \# \tstype{timer}}
}
{}
}

\newcommand{\defntimedTvalTof}{\ddefnn{timedTvalTof}{\iA{timed\_val\_of}}{\subddefnA{timed\_val\_of}{\tsaux{timed\_val\_of} (\Mtimed{\tsunknown{x}}{\tsunknown{\_}}) = \tsunknown{x}}
}
{}
}

\newcommand{\defntimedTtimerTof}{\ddefnn{timedTtimerTof}{\iA{timed\_timer\_of}}{\subddefnA{timed\_timer\_of}{\tsaux{timed\_timer\_of} (\Mtimed{\tsunknown{x}}{\tsunknown{d}}) = \tsunknown{d}}
}
{}
}

\newcommand{\defntimedTexpires}{\ddefnn{timedTexpires}{\iA{timed\_expires}}{\subddefnA{timed\_expires}{\tsaux{timed\_expires} (\Mtimed{\tsunknown{\_}}{\tsunknown{d}}) = \tsaux{timer\_expires} \;\tsunknown{d}}
}
{}
}

\newcommand{\defnTimeTPassTtimed}{\ddefnn{TimeTPassTtimed}{\iA{Time\_Pass\_timed}}{\subddefnA{Time\_Pass\_timed}{(\tsaux{Time\_Pass\_timed} : \tsaux{duration} \Mtotype  \tsunknown{'a} \;\tstype{timed} \Mtotype  \tsunknown{'a} \;\tstype{timed} \;\;\tstype{option}){}\\{}
 \tsunknown{dur} (\Mtimed{\tsunknown{x}}{\tsunknown{d}}){}\\{}
 = \Mcase  \;\tsaux{Time\_Pass\_timer} \;\tsunknown{dur} \;\tsunknown{d} \;\Mof {}\\{}
\quad \Msome  \;\tsunknown{d'} \Mtotype  \Msome  (\Mtimed{\tsunknown{x}}{\tsunknown{d'}}){}\\{}
 \Mdpipe  *    \Mtotype  *}
}
{}
}

\newcommand{\seccommtimersTtimewindow}{\clustersection{(TCP and UDP)}{Time-window timer $\tstype{timewindow}$}
\seccomm{
The time-window timer $\tsunknown{'a} \;\tstype{timewindow}$, rendered as $\Mtimewindow{\tsunknown{x}}{\tsunknown{d}}$, is like a deadline timer $\tsunknown{'a}
\tstype{timed}$, except that when it expires the value merely evaporates,
rather than causing time to stop.  Thus an $\tsunknown{'a} \;\tstype{timewindow}$ never
induces urgency.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{timewindow}$
&
& \\
$\tsrule{timewindow\_val\_of}$
&
& \\
$\tsrule{timewindow\_open}$
&
& \\
$\tsrule{Time\_Pass\_timewindow}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntimewindow}{\ddefnn{timewindow}{\iA{timewindow}}{\subddefnA{timewindow}{\tstype{timewindow} = \tscon{TimeWindow} \Mof  \;\tsunknown{'a} \# \tstype{timer} \mid  \tscon{TimeWindowClosed}}
}
{}
}

\newcommand{\defntimewindowTvalTof}{\ddefnn{timewindowTvalTof}{\iA{timewindow\_val\_of}}{\subddefnA{timewindow\_val\_of}{\tsaux{timewindow\_val\_of} (\Mtimewindow{\tsunknown{x}}{\tsunknown{\_}}) = \Msome  \;\tsunknown{x} \Mwedge {}\\{}
 \tsaux{timewindow\_val\_of}  \;\tscon{TimeWindowClosed} = *}
}
{}
}

\newcommand{\defntimewindowTopen}{\ddefnn{timewindowTopen}{\iA{timewindow\_open}}{\subddefnA{timewindow\_open}{\tsaux{timewindow\_open} (\Mtimewindow{\tsunknown{\_}}{\tsunknown{\_}}) = \Mtrue  \Mwedge {}\\{}
 \tsaux{timewindow\_open}  \;\tscon{TimeWindowClosed} = \Mfalse }
}
{}
}

\newcommand{\defnTimeTPassTtimewindow}{\ddefnn{TimeTPassTtimewindow}{\iA{Time\_Pass\_timewindow}}{\subddefnA{Time\_Pass\_timewindow}{(\tsaux{Time\_Pass\_timewindow} : \tsaux{duration} \Mtotype  \tsunknown{'a} \;\tstype{timewindow} \Mtotype  \tsunknown{'a} \;\tstype{timewindow} \Mtotype  \tstype{bool}){}\\{}
 \tsunknown{dur} (\Mtimewindow{\tsunknown{x}}{\tsunknown{d}}) \tsunknown{tw'}{}\\{}
 = (\Mcase  \;\tsaux{Time\_Pass\_timer} \;\tsunknown{dur} \;\tsunknown{d} \;\Mof {}\\{}
\quad\quad *    \Mtotype  \tsunknown{tw'} = \tscon{TimeWindowClosed}{}\\{}
 \Mdpipe  \Msome  \;\tsunknown{d'} \Mtotype  \tsunknown{tw'} = \Mtimewindow{\tsunknown{x}}{\tsunknown{d'}} \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad (\tsaux{timer\_expires} \;\tsunknown{d'} \Mwedge  \tsunknown{tw'} = \tscon{TimeWindowClosed})) \Mwedge {}\\{}
 \tsaux{Time\_Pass\_timewindow} \;\tsunknown{dur} \;\tscon{TimeWindowClosed} \;\tsunknown{tw'} = (\tsunknown{tw'} = \tscon{TimeWindowClosed})}
}
{}
}

\newcommand{\seccommtimersTticker}{\clustersection{(TCP and UDP)}{Ticker $\tstype{ticker}$}
\seccomm{
A ticker $\tstype{ticker}$ models a discrete time counter.  It contains a
counter, a remainder, a minimum duration, and a maximum duration.  The
counter is incremented at least once every maximum duration, and at
most once every minimum duration.  The remainder stores the time since
the last increment.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{ticker}$
&
& \\
$\tsrule{ticks\_of}$
&
& \\
$\tsrule{Time\_Pass\_ticker}$
&
& \\
$\tsrule{ticker\_ok}$
&
& \\
$\tsrule{tick\_imin}$
&
& \\
$\tsrule{tick\_imax}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnticker}{\ddefnn{ticker}{\iA{ticker}}{\subddefnA{ticker}{\tstype{ticker} = \tscon{Ticker} \;\Mof  \;\tsaux{ts\_seq} \# \tsaux{duration}\tscomm{ may be zero } \# \tsaux{duration} \# \tsaux{duration}}
}
{}
}

\newcommand{\defnticksTof}{\ddefnn{ticksTof}{\iA{ticks\_of}}{\subddefnA{ticks\_of}{\tsaux{ticks\_of} (\tscon{Ticker}(\tsvar{ticks},\tsunknown{\_},\tsunknown{\_},\tsunknown{\_})) = \tsvar{ticks}}
}
{}
}

\newcommand{\defnTimeTPassTticker}{\ddefnn{TimeTPassTticker}{\iA{Time\_Pass\_ticker}}{\subddefnA{Time\_Pass\_ticker}{(\tsaux{Time\_Pass\_ticker} : \tsaux{duration} \Mtotype  \tstype{ticker} \Mtotype  \tstype{ticker} \Mtotype  \tstype{bool}){}\\{}
 \tsunknown{dur} (\tscon{Ticker}(\tsvar{ticks},\tsunknown{remdr},\tsunknown{intvlmin},\tsunknown{intvlmax})) \tsvar{t}'{}\\{}
 = \Mlet  \;\tsunknown{d} = \tsunknown{remdr} + \tsunknown{dur}{}\\{}
 \Min {}\\{}
\quad \exists \tsvar{delta} \;\tsvar{remdr}'.{}\\{}
\quad\quad \tsunknown{d} - \tsholop{real\_of\_num} \;\tsvar{delta} * \tsunknown{intvlmax} \leq  \tsvar{remdr}' \Mwedge {}\\{}
\quad\quad \tsvar{remdr}' \leq  \tsunknown{d} - \tsholop{real\_of\_num} \;\tsvar{delta} * \tsunknown{intvlmin} \Mwedge {}\\{}
\quad\quad 0 \leq  \tsvar{remdr}' \Mwedge  \tsvar{remdr}' < \tsunknown{intvlmax} \Mwedge {}\\{}
\quad\quad \tsvar{t}' = \tscon{Ticker}(\tsvar{ticks} + \tsvar{delta}, \tsvar{remdr}', \tsunknown{intvlmin}, \tsunknown{intvlmax})}
}
{}
}

\newcommand{\defntickerTok}{\ddefnn{tickerTok}{\iA{ticker\_ok}}{\subddefnA{ticker\_ok}{\tsaux{ticker\_ok} (\tscon{Ticker}(\tsvar{ticks}, \tsunknown{remdr}, \tsunknown{imin}, \tsunknown{imax})) ={}\\{}
 (0 \leq  \tsunknown{remdr} \Mwedge  \tsunknown{remdr} < \tsunknown{imax} \Mwedge  \tsunknown{imin} \leq  \tsunknown{imax} \Mwedge  0 < \tsunknown{imin})}
}
{}
}

\newcommand{\defntickTimin}{\ddefnn{tickTimin}{\iA{tick\_imin}}{\subddefnA{tick\_imin}{\tsaux{tick\_imin}(\tscon{Ticker}(\tsvar{t},\tsunknown{r},\tsunknown{imin}, \tsunknown{imax})) = \tsunknown{imin}}
}
{}
}

\newcommand{\defntickTimax}{\ddefnn{tickTimax}{\iA{tick\_imax}}{\subddefnA{tick\_imax}{\tsaux{tick\_imax}(\tscon{Ticker}(\tsvar{t},\tsunknown{r},\tsunknown{imin},\tsunknown{imax})) = \tsunknown{imax}}
}
{}
}

\newcommand{\seccommtimersTstopwatch}{\clustersection{(TCP and UDP)}{Stopwatch $\tstype{stopwatch}$}
\seccomm{
The stopwatch $\tstype{stopwatch}$ records the time since it was started,
with fuzziness introduced by means of a minimum and maximum rate
factor applied to the passage of time.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{stopwatch}$
&
& \\
$\tsrule{stopwatch\_val\_of}$
&
& \\
$\tsrule{Time\_Pass\_stopwatch}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnstopwatch}{\ddefnn{stopwatch}{\iA{stopwatch}}{\subddefnA{stopwatch}{\tstype{stopwatch} = \tscon{Stopwatch} \;\Mof  \;\tsaux{duration}\tscomm{ may be zero } \# \tsunknown{real} \# \tsunknown{real}}
}
{}
}

\newcommand{\defnstopwatchTvalTof}{\ddefnn{stopwatchTvalTof}{\iA{stopwatch\_val\_of}}{\subddefnA{stopwatch\_val\_of}{\tsaux{stopwatch\_val\_of} (\tscon{Stopwatch}(\tsunknown{d},\tsunknown{\_},\tsunknown{\_})) = \tsunknown{d}}
}
{}
}

\newcommand{\defnTimeTPassTstopwatch}{\ddefnn{TimeTPassTstopwatch}{\iA{Time\_Pass\_stopwatch}}{\subddefnA{Time\_Pass\_stopwatch}{(\tsaux{Time\_Pass\_stopwatch} : \tsaux{duration} \Mtotype  \tstype{stopwatch} \Mtotype  \tstype{stopwatch} \Mtotype  \tstype{bool}){}\\{}
 \tsunknown{dur} (\tscon{Stopwatch}(\tsunknown{d},\tsunknown{ratemin},\tsunknown{ratemax})) \tsunknown{s'}{}\\{}
 = \exists \tsvar{rate}. \tsunknown{ratemin} \leq  \tsvar{rate} \Mwedge  \tsvar{rate} \leq  \tsunknown{ratemax} \Mwedge {}\\{}
 \tsunknown{s'} = \tscon{Stopwatch}(\tsunknown{d}+(\tsunknown{dur}*\tsvar{rate}),\tsunknown{ratemin},\tsunknown{ratemax})}
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPITtimers}
\showrule{\seccommtimersTprops}
\showrule{\defntimeTpassTadditive}
\showrule{\defntimeTpassTtrajectory}
\showrule{\defnopttorel}
\showrule{\seccommtimersTtimer}
\showrule{\defntimer}
\showrule{\defnfuzzyTtimer}
\showrule{\defnsharpTtimer}
\showrule{\defnneverTtimer}
\showrule{\defnupperTtimer}
\showrule{\defntimerTexpires}
\showrule{\defnTimeTPassTtimer}
\showrule{\seccommtimersTtimed}
\showrule{\defntimed}
\showrule{\defntimedTvalTof}
\showrule{\defntimedTtimerTof}
\showrule{\defntimedTexpires}
\showrule{\defnTimeTPassTtimed}
\showrule{\seccommtimersTtimewindow}
\showrule{\defntimewindow}
\showrule{\defntimewindowTvalTof}
\showrule{\defntimewindowTopen}
\showrule{\defnTimeTPassTtimewindow}
\showrule{\seccommtimersTticker}
\showrule{\defnticker}
\showrule{\defnticksTof}
\showrule{\defnTimeTPassTticker}
\showrule{\defntickerTok}
\showrule{\defntickTimin}
\showrule{\defntickTimax}
\showrule{\seccommtimersTstopwatch}
\showrule{\defnstopwatch}
\showrule{\defnstopwatchTvalTof}
\showrule{\defnTimeTPassTstopwatch}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore preHostTypes

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
% TCP1_preHostTypesScript.sml:228:17-229:23:  WARNING: LDoc tag @description: expected nothing, found  Specifies
\def\rulesrcsid{\$Id: alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\seccommhosttyTtcpstates}{\clustersection{(TCP only)}{TCP states}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{tcpstate}$
&
&  TCP protocol states \\
$\tsrule{socket\_listen}$
&
&  extra info for a listening socket \\
$\tsrule{dgram\_msg}$
&
&  ordinary datagram on UDP receive queue \\
$\tsrule{dgram\_error}$
&
&  error (pseudo-)datagram on UDP receive queue \\
$\tsrule{dgram}$
&
&  receive queue elements for a UDP socket \\
$\tsrule{udp\_socket}$
&
&  details of a UDP socket \\
$\tsrule{ifd}$
&
&  network interface descriptor \\
$\tsrule{routing\_table\_entry}$
&
&  routing table entry \\
$\tsrule{type\_abbrev\_routing\_table}$
&
& \\
$\tsrule{bandlim\_reason}$
&
&  segment category, determining which band limiter to use \\
$\tsrule{type\_abbrev\_bandlim\_state}$
&
& \\
$\tsrule{hostThreadState}$
&
&  state of host wrt a thread \\
$\tsrule{hostParams}$
&
&  other relevant bits of host configuration \\
$\tsrule{traceflavour}$
&
&  trace record flavours \\
$\tsrule{hostid}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntcpstate}{\ddefnc{tcpstate}{\iA{tcpstate}}{\subddefnA[{ TCP protocol states }]{tcpstate}{\tstype{tcpstate} =  \tscon{CLOSED}{}\\{}
\quad\quad\quad\quad \mid  \tscon{LISTEN}{}\\{}
\quad\quad\quad\quad \mid  \tscon{SYN\_SENT}{}\\{}
\quad\quad\quad\quad \mid  \tscon{SYN\_RECEIVED}{}\\{}
\quad\quad\quad\quad \mid  \tscon{ESTABLISHED}{}\\{}
\quad\quad\quad\quad \mid  \tscon{CLOSE\_WAIT}{}\\{}
\quad\quad\quad\quad \mid  \tscon{FIN\_WAIT\_1}{}\\{}
\quad\quad\quad\quad \mid  \tscon{CLOSING}{}\\{}
\quad\quad\quad\quad \mid  \tscon{LAST\_ACK}{}\\{}
\quad\quad\quad\quad \mid  \tscon{FIN\_WAIT\_2}{}\\{}
\quad\quad\quad\quad \mid  \tscon{TIME\_WAIT}}
}
{\rulesubsection{Description}
The states laid down by RFC793, with spelling as in the BSD source.


\rrulepad }
}

\newcommand{\defnsocketTlisten}{\ddefnn{socketTlisten}{\iA{socket\_listen}}{\subddefnA[{ extra info for a listening socket }]{socket\_listen}{\tstype{socket\_listen}{}\\{}
 = \Mmagiclrec  \tsvar{q}_{0} : \tstype{sid} \;\tstype{list}; \tscomm{ incomplete connections queue }{}\\{}
 \tsvar{q}  : \tstype{sid} \;\tstype{list}; \tscomm{ completed connections queue }{}\\{}
 \tsvar{qlimit} : \tstype{int}   \tscomm{ backlog value as passed to listen }{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defndgramTmsg}{\ddefnc{dgramTmsg}{\iA{dgram\_msg}}{\subddefnA[{ ordinary datagram on UDP receive queue }]{dgram\_msg}{\tstype{dgram\_msg}{}\\{}
 = \Mmagiclrec  \tsvar{data} : \tstype{byte} \;\tstype{list};{}\\{}
 \tsvar{is}   : \tstype{ip} \;\;\tstype{option};  \tscomm{ source ip }{}\\{}
 \tsvar{ps}   : \tstype{port} \;\;\tstype{option} \tscomm{ source port }{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defndgramTerror}{\ddefnc{dgramTerror}{\iA{dgram\_error}}{\subddefnA[{ error (pseudo-)datagram on UDP receive queue }]{dgram\_error}{\tstype{dgram\_error}{}\\{}
 = \Mmagiclrec  \tsvar{e} : \tstype{error} \Mmagicrrec }
}
{}
}

\newcommand{\defndgram}{\ddefnc{dgram}{\iA{dgram}}{\subddefnA[{ receive queue elements for a UDP socket }]{dgram}{\tstype{dgram} = \tscon{Dgram\_msg} \;\Mof  \;\tstype{dgram\_msg}{}\\{}
\quad\quad \mid  \tscon{Dgram\_error} \;\Mof  \;\tstype{dgram\_error}}
}
{}
}

\newcommand{\defnudpTsocket}{\ddefnc{udpTsocket}{\iA{udp\_socket}}{\subddefnA[{ details of a UDP socket }]{udp\_socket}{\tstype{udp\_socket}{}\\{}
 = \Mmagiclrec  \tsvar{rcvq} : \tstype{dgram} \;\tstype{list}  \Mmagicrrec }
}
{\rulesubsection{Description}
%
UDP sockets are very simple -- the protocol-specific content is merely
a receive queue.
%
The receive queue of a UDP socket, however, is not just
a queue of bytes as it is for a TCP socket.  Instead, it
is a queue of \emph{messages} and (in some implementations)
\emph{errors}.  Each message contains a block of types and some
ancilliary data.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
On WinXP, errors are returned in order w.r.t.~messages; this is modelled
by placing them in the receive queue.

\\\hline
FreeBSD,Linux
&
On FreeBSD and Linux, only messages are placed in the receive queue,
and errors are treated asynchronously.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\defnifd}{\ddefnn{ifd}{\iA{ifd}}{\subddefnA[{ network interface descriptor }]{ifd}{\tstype{ifd} = \Mmagiclrec  \tsvar{ipset} : \tstype{ip} \;\tstype{set}; \tscomm{ set of IP addresses of this interface }{}\\{}
 \tsvar{primary} : \tstype{ip}; \tscomm{ and the primary IP address }{}\\{}
 \tsvar{netmask} : \tsvar{netmask}; \tscomm{ netmask }{}\\{}
 \tsvar{up} : \tstype{bool}  \tscomm{ status: up (and connected) or not }{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defnroutingTtableTentry}{\ddefnc{routingTtableTentry}{\iA{routing\_table\_entry}}{\subddefnA[{ routing table entry }]{routing\_table\_entry}{\tstype{routing\_table\_entry} = \Mmagiclrec  \tsfield{destination\_ip} : \tstype{ip};{}\\{}
 \tsfield{destination\_netmask} : \tsvar{netmask};{}\\{}
 \tsvar{ifid} : \tsvar{ifid}{}\\{}
 \Mmagicbolrrec }
}
{\rulesubsection{Description}

Note that both routing table entries and interfaces have IP addresses
(plural for interfaces, singular for RTEs) and netmasks; furthermore,
interfaces have a primary IP.  When we do routing, we ignore the IP
addresses and mask of the interface; we only use the address and mask
from the RTE.  The only use of the interface info is to obtain the
primary IP for use by connect().

However, there is one place where all the interface data is used: on
input, the interface IP addresses are consulted to see if we
can receive a packet.

The netmask of the interface is not used in the specification (except
by $\tslib{getifaddrs}()$).  Its function in the implementation relates to
gateways etc., which (as we abstract from IP routing) we do not model.

Note that the model does not represent the routing \emph{cache} here
(i.e., cached routes with gateways, MSS, RTT, etc.), just the routing
\emph{table}.
Cache data is treated nondeterministically.

\rrulepad }
}

\newcommand{\defntypeTabbrevTroutingTtable}{\ddefnn{typeTabbrevTroutingTtable}{\iA{type\_abbrev\_routing\_table}}{\subddefnA{type\_abbrev\_routing\_table}{\tsholop{type\_abbrev} \;\tsunknown{routing\_table} :\tstype{routing\_table\_entry} \;\tstype{list}}
}
{}
}

\newcommand{\defnbandlimTreason}{\ddefnc{bandlimTreason}{\iA{bandlim\_reason}}{\subddefnA[{ segment category, determining which band limiter to use }]{bandlim\_reason}{\tstype{bandlim\_reason} = \tscon{BANDLIM\_UNLIMITED}{}\\{}
\quad\quad\quad\quad\quad\quad \mid  \tscon{BANDLIM\_RST\_CLOSEDPORT}{}\\{}
\quad\quad\quad\quad\quad\quad \mid  \tscon{BANDLIM\_RST\_OPENPORT}}
}
{\rulesubsection{Description}
internal bandlimiter state; intended to be opaque

\rrulepad }
}

\newcommand{\defntypeTabbrevTbandlimTstate}{\ddefnn{typeTabbrevTbandlimTstate}{\iA{type\_abbrev\_bandlim\_state}}{\subddefnA{type\_abbrev\_bandlim\_state}{\tsholop{type\_abbrev} \;\tsunknown{bandlim\_state} :(\tstype{tcpSegment} \# \tsaux{ts\_seq} \# \tstype{bandlim\_reason}) \tstype{list}}
}
{}
}

\newcommand{\defnhostThreadState}{\ddefnc{hostThreadState}{\iA{hostThreadState}}{\subddefnA[{ state of host wrt a thread }]{hostThreadState}{\tstype{hostThreadState} = \tscon{Run}              \tsholcomm{ thread is running }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{Ret} \;\Mof  \;\tstype{TLang}     \tsholcomm{ about to return given value to thread }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{Accept2} \;\Mof  \;\tstype{sid}   \tsholcomm{ blocked in $\tslib{accept}$ }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{Close2} \;\Mof  \;\tstype{sid}    \tsholcomm{ blocked in $\tslib{close}$ }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{Connect2} \;\Mof  \;\tstype{sid}  \tsholcomm{ blocked in $\tslib{connect}$ }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{Recv2} \;\Mof  \;\tstype{sid} \# \tstype{num} \# \tstype{msgbflag} \;\tstype{set}  \tsholcomm{ blocked in $\tslib{recv}$ }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{Send2} \;\Mof  \;\tstype{sid} \# ((\tstype{ip} \# \tstype{port}) \;\tstype{option} \# \tstype{ip} \;\;\tstype{option} \# \tstype{port} \;\;\tstype{option} \# \tstype{ip} \;\;\tstype{option} \# \tstype{port} \;\;\tstype{option}) \;\tstype{option}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \# \tstype{byte} \;\tstype{list} \# \tstype{msgbflag} \;\tstype{set}  \tsholcomm{ blocked in $\tslib{send}$ }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \mid  \tscon{PSelect2} \;\Mof  \;\tstype{fd} \;\tstype{list} \# \tstype{fd} \;\tstype{list} \# \tstype{fd} \;\tstype{list}  \tsholcomm{ blocked in $\tslib{pselect}$ }}
}
{\rulesubsection{Description}
Host threads are either $\tscon{Run}$ning or executing a sockets call.  The latter can either be about to return a value to the thread (state $\tscon{Ret}$) or blocked; the remaining states capture the data required for the unblock processing for each slow call.

\rrulepad }
}

\newcommand{\defnhostParams}{\ddefnc{hostParams}{\iA{hostParams}}{\subddefnA[{ other relevant bits of host configuration }]{hostParams}{\tstype{hostParams} = \Mmagiclrec {}\\{}
 \tsfield{min\_eph\_port}  : \tstype{num};{}\\{}
 \tsfield{max\_eph\_port}  : \tstype{num}{}\\{}
 \Mmagicbolrrec }
}
{\rulesubsection{Description}
ports range, which can vary
from host to host; notably, the Linux kernel picks values for these parameters
based on the amount of available memory.

\rrulepad }
}

\newcommand{\defntraceflavour}{\ddefnc{traceflavour}{\iA{traceflavour}}{\subddefnA[{ trace record flavours }]{traceflavour}{\tstype{traceflavour} = \tscon{TA\_INPUT}{}\\{}
\quad\quad\quad\quad\quad \mid  \tscon{TA\_OUTPUT}{}\\{}
\quad\quad\quad\quad\quad \mid  \tscon{TA\_USER}{}\\{}
\quad\quad\quad\quad\quad \mid  \tscon{TA\_RESPOND}{}\\{}
\quad\quad\quad\quad\quad \mid  \tscon{TA\_DROP}}
}
{\rulesubsection{Description}
Different situations in which a trace may be generated.


\rrulepad }
}

\newcommand{\defnhostid}{\ddefnn{hostid}{\iA{hostid}}{\subddefnA{hostid}{\tstype{hostid} ={}\\{}
\quad \tscon{Test}{}\\{}
 \mid  \tscon{Aux}}
}
{}
}

\newcommand{\seccommhostZTcats}{\clustersection{(TCP and UDP)}{Rule categories}
\seccomm{
A rule carries a number of flags: the protocol it relates to, its
status (success, failure, or `bad' failure), its category (fast or
slow system call, network, etc.), and its urgency (whether it must
fire immediately, or may be delayed).


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{rule\_proto}$
&
& \\
$\tsrule{rule\_status}$
&
& \\
$\tsrule{rule\_cat}$
&
& \\
$\tsrule{urgent}$
&
& \\
$\tsrule{nonurgent}$
&
& \\
$\tsrule{is\_urgent}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnruleTproto}{\ddefnc{ruleTproto}{\iA{rule\_proto}}{\subddefnA{rule\_proto}{\tstype{rule\_proto} = \tscon{rp\_tcp}{}\\{}
\quad\quad\quad\quad \mid  \tscon{rp\_udp}{}\\{}
\quad\quad\quad\quad \mid  \tscon{rp\_all}}
}
{\rulesubsection{Description}
Rules are classified as to whether they relate to TCP, to UDP, or to both.

\rrulepad }
}

\newcommand{\defnruleTstatus}{\ddefnc{ruleTstatus}{\iA{rule\_status}}{\subddefnA{rule\_status}{\tstype{rule\_status} = \tscon{succeed}{}\\{}
\quad\quad\quad\quad \mid  \tscon{fail}{}\\{}
\quad\quad\quad\quad \mid  \tscon{badfail}}
}
{\rulesubsection{Description}
Socket call rules marked $\tscon{succeed}$ construct an $\tscon{OK} \;\tsunknown{v}$ value to be returned to the calling thread, whereas those maked $\tscon{fail}$ or $\tscon{badfail}$ construct a $\tscon{FAIL}\;{\tsvar{e}}$ error to be returned.
The $\tscon{badfail}$ rules are those involving (unusual) lack of resources, e.g.~of ephemeral ports, file descriptors, or kernel memory.  They are distinguished from the $\tscon{fail}$ rules to make it easy to state properties of the form "if no bad failures occur, then...".

\rrulepad }
}

\newcommand{\defnruleTcat}{\ddefnc{ruleTcat}{\iA{rule\_cat}}{\subddefnA{rule\_cat}{\tstype{rule\_cat}  = \tscon{fast}    \;\Mof  \;\tstype{rule\_status}{}\\{}
\quad\quad\quad \mid  \tscon{block}{}\\{}
\quad\quad\quad \mid  \tscon{slow}    \;\Mof  \;\tstype{bool}  => \tstype{rule\_status}{}\\{}
\quad\quad\quad \mid  \tscon{network} \;\Mof  \;\tstype{bool}{}\\{}
\quad\quad\quad \mid  \tscon{misc}    \;\Mof  \;\tstype{bool}}
}
{\rulesubsection{Description}
Socket call rules are either $\tscon{fast}$, immediately constructing a return value or error, $\tscon{block}$, entering a state in which the calling thread is blocked, or $\tscon{slow}$, completing processing for a blocked thread.
$\tscon{fast}$ and $\tscon{slow}$ rules have a $\tstype{rule\_status}$ as above.
The $\tscon{network}$ rules include message send and receive and the internal actions involved in the protocol.
The $\tscon{misc}$ rules cover the remainder:
returning values to threads, timer expiry, TCP tracing, interface status changes, and time passage.
The $\tstype{bool}$ argument to $\tscon{slow}$, $\tscon{network}$, and $\tscon{misc}$ rule categories
indicates whether the rule is \emph{urgent}.  If an urgent rule is enabled then no time may pass.


\rrulepad }
}

\newcommand{\defnurgent}{\ddefnc{urgent}{\iA{urgent}}{\subddefnA{urgent}{\tsaux{urgent} = \Mtrue }
}
{}
}

\newcommand{\defnnonurgent}{\ddefnc{nonurgent}{\iA{nonurgent}}{\subddefnA{nonurgent}{\tsaux{nonurgent} = \Mfalse }
}
{}
}

\newcommand{\defnisTurgent}{\ddefnn{isTurgent}{\iA{is\_urgent}}{\subddefnA{is\_urgent}{\tsaux{is\_urgent} (\tscon{slow}    \;\tsvar{b} \;\tsunknown{\_}) = \tsvar{b} \Mwedge {}\\{}
 \tsaux{is\_urgent} (\tscon{network} \;\tsvar{b}  ) = \tsvar{b} \Mwedge {}\\{}
 \tsaux{is\_urgent} (\tscon{misc}    \;\tsvar{b}  ) = \tsvar{b} \Mwedge {}\\{}
 \tsaux{is\_urgent}  \;\tsunknown{\_}            = \Mfalse }
}
{}
}

\newcommand{\seccommauxTarch}{\clustersection{(TCP and UDP)}{Architecture handling}
\seccomm{
Many aspects of host behaviour differ from one OS to another, and so a
host has an architecture parameter detailing its precise OS and
version (e.g., $\tscon{Linux\_2\_4\_20\_8}$).  Very often, however, we do not
need to be so precise -- a certain behaviour might apply to all Linux,
or even all Unix, OSes.  Below we define predicates for these cases, to allow variant architectures to be easily added later.

}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{windows\_arch}$
&
&  test if host architecture is Windows \\
$\tsrule{bsd\_arch}$
&
&  test if host architecture is BSD \\
$\tsrule{linux\_arch}$
&
&  test if host architecture is Linux \\
$\tsrule{unix\_arch}$
&
&  test if host architecture is Unix \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnwindowsTarch}{\ddefnc{windowsTarch}{\iA{windows\_arch}}{\subddefnA[{ test if host architecture is Windows }]{windows\_arch}{\tsaux{windows\_arch} \;\tstype{arch} = (\tstype{arch} \;\in  \{\tscon{WinXP\_Prof\_SP1}\}                     )}
}
{}
}

\newcommand{\defnbsdTarch}{\ddefnc{bsdTarch}{\iA{bsd\_arch}}{\subddefnA[{ test if host architecture is BSD }]{bsd\_arch}{\tsaux{bsd\_arch}     \;\tstype{arch} = (\tstype{arch} \;\in  \{\tscon{FreeBSD\_4\_6\_RELEASE}\}                )}
}
{}
}

\newcommand{\defnlinuxTarch}{\ddefnc{linuxTarch}{\iA{linux\_arch}}{\subddefnA[{ test if host architecture is Linux }]{linux\_arch}{\tsaux{linux\_arch}   \;\tstype{arch} = (\tstype{arch} \;\in  \{\tscon{Linux\_2\_4\_20\_8}\}                     )}
}
{}
}

\newcommand{\defnunixTarch}{\ddefnn{unixTarch}{\iA{unix\_arch}}{\subddefnA[{ test if host architecture is Unix }]{unix\_arch}{\tsaux{unix\_arch}    \;\tstype{arch} = (\tstype{arch} \;\in  \{\tscon{Linux\_2\_4\_20\_8}; \tscon{FreeBSD\_4\_6\_RELEASE}\})}
}
{}
}

\newcommand{\seccommauxTif}{\clustersection{(TCP and UDP)}{Interfaces and IP addresses}
\seccomm{
Constructors, predicates, and helper functions that deal with
interfaces, IP addresses, and routing.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{mask}$
&
&  apply a netmask to an IP to obtain the network number \\
$\tsrule{mask\_bits}$
&
&  compute network bitmask from netmask \\
$\tsrule{IP}$
&
&  constructor for dotted-decimal IP addresses \\
$\tsrule{IN\_MULTICAST}$
&
&  the set of multicast addresses \\
$\tsrule{INADDR\_BROADCAST}$
&
&  the local broadcast address \\
$\tsrule{LOOPBACK\_ADDRS}$
&
&  the set of loopback addresses \\
$\tsrule{ip\_localhost}$
&
&  the canonical loopback address, aka 'localhost' \\
$\tsrule{in\_loopback}$
&
&  is IP address a loopback address? \\
$\tsrule{in\_local}$
&
&  is IP address a local address? \\
$\tsrule{local\_ips}$
&
&  the set of local IP addresses \\
$\tsrule{local\_primary\_ips}$
&
&  the set of local primary IP addresses \\
$\tsrule{is\_localnet}$
&
&  is IP address on a local subnet of this host? \\
$\tsrule{if\_broadcast}$
&
&  is IP address a broadcast address? \\
$\tsrule{if\_any}$
&
&  the set of addresses in an interface's subnet \\
$\tsrule{is\_broadormulticast}$
&
&  is IP address a broadcast/multicast address? \\
$\tsrule{routeable}$
&
&  compute set of routeable addresses for a routing table entry \\
$\tsrule{outroute\_ifids}$
&
&  determine list of possible sending interfaces \\
$\tsrule{ifid\_up}$
&
&  is the interface up? \\
$\tsrule{outroute}$
&
&  compute interface to use to send to given IP, if any \\
$\tsrule{auto\_outroute}$
&
&  compute source address to use to route to given IP \\
$\tsrule{test\_outroute\_ip}$
&
&  test if we can route to given IP, returning appropriate error if not \\
$\tsrule{test\_outroute}$
&
&  if destination IP specified, do $\tsaux{test\_outroute\_ip}$ \\
$\tsrule{loopback\_on\_wire}$
&
&  check if a message bears a loopback address \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnmask}{\ddefnc{mask}{\iA{mask}}{\subddefnA[{ apply a netmask to an IP to obtain the network number }]{mask}{\tsaux{mask} (\tscon{NETMASK} \;\tsunknown{m}) (\tstype{ip} \;\tsvar{n}) = \tstype{ip} ((\tsvar{n} \;\tsholop{DIV} (2 \;\Mexp  (32 - \tsunknown{m}))) * 2 \;\Mexp  (32 - \tsunknown{m}))}
}
{}
}

\newcommand{\defnmaskTbits}{\ddefnc{maskTbits}{\iA{mask\_bits}}{\subddefnA[{ compute network bitmask from netmask }]{mask\_bits}{\tsaux{mask\_bits} (\tscon{NETMASK} \;\tsunknown{m}) = ((2 \;\Mexp  \;32 - 1) \tsholop{DIV} (2 \;\Mexp  (32 - \tsunknown{m}))) * 2 \;\Mexp  (32 - \tsunknown{m})}
}
{\rulesubsection{Description}
Netmask operations.
Recall netmasks are stored as the number of 1 bits in the mask; thus
255.255.128.0 is modelled by $\tscon{NETMASK} \;17$.

\rrulepad }
}

\newcommand{\defnIP}{\ddefnc{IP}{\iA{IP}}{\subddefnA[{ constructor for dotted-decimal IP addresses }]{IP}{\tsaux{IP} (\tsunknown{a}:\tstype{num}) (\tsvar{b}:\tstype{num}) (\tsunknown{c}:\tstype{num}) (\tsunknown{d}:\tstype{num}) = \tstype{ip} (\tsunknown{a} * 2 \;\Mexp  \;24 + \tsvar{b} * 2 \;\Mexp  \;16 + \tsunknown{c} * 2 \;\Mexp  \;8 + \tsunknown{d})}
}
{}
}

\newcommand{\defnINTMULTICAST}{\ddefnc{INTMULTICAST}{\iA{IN\_MULTICAST}}{\subddefnA[{ the set of multicast addresses }]{IN\_MULTICAST}{\tsaux{IN\_MULTICAST} = \{ \tsunknown{i} \mid  \tsaux{mask} (\tscon{NETMASK} \;4) \tsunknown{i} = \tsaux{IP} \;224 \;0 \;0 \;0 \}}
}
{}
}

\newcommand{\defnINADDRTBROADCAST}{\ddefnc{INADDRTBROADCAST}{\iA{INADDR\_BROADCAST}}{\subddefnA[{ the local broadcast address }]{INADDR\_BROADCAST}{\tsaux{INADDR\_BROADCAST} = \tsaux{IP} \;255 \;255 \;255 \;255}
}
{}
}

\newcommand{\defnLOOPBACKTADDRS}{\ddefnc{LOOPBACKTADDRS}{\iA{LOOPBACK\_ADDRS}}{\subddefnA[{ the set of loopback addresses }]{LOOPBACK\_ADDRS}{\tsaux{LOOPBACK\_ADDRS} = \{ \tsunknown{i} \mid  \tsaux{mask} (\tscon{NETMASK} \;8) \tsunknown{i} = \tsaux{IP} \;127 \;0 \;0 \;0 \}}
}
{}
}

\newcommand{\defnipTlocalhost}{\ddefnc{ipTlocalhost}{\iA{ip\_localhost}}{\subddefnA[{ the canonical loopback address, aka 'localhost' }]{ip\_localhost}{\tsaux{ip\_localhost} = \tsaux{IP} \;127 \;0 \;0 \;1}
}
{}
}

\newcommand{\defninTloopback}{\ddefnc{inTloopback}{\iA{in\_loopback}}{\subddefnA[{ is IP address a loopback address? }]{in\_loopback}{\tsaux{in\_loopback} \;\tsunknown{i} = (\tsunknown{i} \;\in  \;\tsaux{LOOPBACK\_ADDRS})}
}
{}
}

\newcommand{\defninTlocal}{\ddefnc{inTlocal}{\iA{in\_local}}{\subddefnA[{ is IP address a local address? }]{in\_local}{\tsaux{in\_local} (\tsvar{ifds}:\tsvar{ifid} \mapsto  \tstype{ifd}) \tsunknown{i} ={}\\{}
\quad\quad (\tsaux{in\_loopback} \;\tsunknown{i} \Mvee {}\\{}
\quad\quad \tsunknown{i} \;\in  (\tsholop{BIGUNION} \{ \tsunknown{ifd\_}.\tsvar{ipset} \mid  \tsunknown{ifd\_} \;\in  (\Mfrange{\tsvar{ifds}}) \})){}\\{}
 \tsholcomm{ Note: the test "$\tsaux{in\_loopback} \;\tsunknown{i}$" is usually redundant as there
     is almost always a loopback interface in $\tsvar{ifds}$ with $\tsvar{ipset} = \tsaux{LOOPBACK\_ADDRS}$ }}
}
{}
}

\newcommand{\defnlocalTips}{\ddefnc{localTips}{\iA{local\_ips}}{\subddefnA[{ the set of local IP addresses }]{local\_ips}{\tsaux{local\_ips}(\tsvar{ifds}:\tsvar{ifid} \mapsto  \tstype{ifd}) = \tsholop{BIGUNION} \{ \tsunknown{ifd\_}.\tsvar{ipset} \mid  \tsunknown{ifd\_} \;\in  (\Mfrange{\tsvar{ifds}}) \}{}\\{}
 \tslongcomm{ annoying: ifd is a constructor, and \{ | \} has no binder to allow us
   to shadow it }}
}
{}
}

\newcommand{\defnlocalTprimaryTips}{\ddefnc{localTprimaryTips}{\iA{local\_primary\_ips}}{\subddefnA[{ the set of local primary IP addresses }]{local\_primary\_ips}{\tsaux{local\_primary\_ips}(\tsvar{ifds}:\tsvar{ifid} \mapsto  \tstype{ifd}) = \{ \tsunknown{ifd\_}.\tsvar{primary} \mid  \tsunknown{ifd\_} \;\in  (\Mfrange{\tsvar{ifds}}) \}}
}
{}
}

\newcommand{\defnisTlocalnet}{\ddefnc{isTlocalnet}{\iA{is\_localnet}}{\subddefnA[{ is IP address on a local subnet of this host? }]{is\_localnet}{\tsaux{is\_localnet} (\tsvar{ifds}_{0}:\tsvar{ifid} \mapsto  \tsvar{ifd}) \tsunknown{i} ={}\\{}
 (\exists \tsvar{ifd}. \tsvar{ifd} \;\in  (\Mfrange{\tsvar{ifds}_{0}}) \Mwedge   \tsaux{mask} \;\tsvar{ifd}.\tsvar{netmask} \;\tsunknown{i} = \tsaux{mask} \;\tsvar{ifd}.\tsvar{netmask} \;\tsvar{ifd}.\tsvar{primary})}
}
{}
}

\newcommand{\defnifTbroadcast}{\ddefnc{ifTbroadcast}{\iA{if\_broadcast}}{\subddefnA[{ is IP address a broadcast address? }]{if\_broadcast}{\tsaux{if\_broadcast} (\tsunknown{ifd0}:\tstype{ifd}){}\\{}
 = \Mcase  (\tsunknown{ifd0}.\tsvar{netmask}, \tsaux{mask} \;\tsunknown{ifd0}.\tsvar{netmask} \;\tsunknown{ifd0}.\tsvar{primary}) \Mof {}\\{}
\quad\quad (\tscon{NETMASK} \;\tsunknown{m}, \tstype{ip} \;\tsvar{n} \tscomm{ n has been masked by m above }) \Mtotype {}\\{}
\quad\quad\quad \tstype{ip} (\tsvar{n} + 2 \;\Mexp  (32 - \tsunknown{m}) - 1){}\\{}
 \tsholcomm{ Note: would be much easier if IPs were actually $\tsunknown{word32}$ rather than $\tstype{num}$ }{}\\{}
 \tsholcomm{ corresponds to $\tsaux{INADDR\_BROADCAST}$ for the interface }}
}
{}
}

\newcommand{\defnifTany}{\ddefnc{ifTany}{\iA{if\_any}}{\subddefnA[{ the set of addresses in an interface's subnet }]{if\_any}{\tsaux{if\_any} (\tsunknown{ifd0}:\tstype{ifd}){}\\{}
 = \Mcase  (\tsunknown{ifd0}.\tsvar{netmask}, \tsaux{mask} \;\tsunknown{ifd0}.\tsvar{netmask} \;\tsunknown{ifd0}.\tsvar{primary}) \Mof {}\\{}
\quad\quad (\tscon{NETMASK} \;\tsunknown{m}, \tstype{ip} \;\tsvar{n} \tscomm{ n has been masked by m above }) \Mtotype {}\\{}
\quad\quad\quad \tstype{ip} (\tsvar{n}){}\\{}
 \tsholcomm{ Note: would be much easier if IPs were actually $\tsunknown{word32}$ rather than $\tstype{num}$ }}
}
{\rulesubsection{Description}
%
Various distinguished IP addresses and sets of IP addresses.  Some of these are
are dependent on the host's set of interfaces.


\rrulepad }
}

\newcommand{\defnisTbroadormulticast}{\ddefnc{isTbroadormulticast}{\iA{is\_broadormulticast}}{\subddefnA[{ is IP address a broadcast/multicast address? }]{is\_broadormulticast}{\tsaux{is\_broadormulticast} (\tsvar{ifds}_{0}:\tsvar{ifid} \mapsto  \tstype{ifd}) \tsunknown{i} ={}\\{}
 (\tsunknown{i} \;\in  \;\tsaux{IN\_MULTICAST} \Mvee     \tsholcomm{ is $\tsunknown{i}$ a multicast address? }{}\\{}
 \tsunknown{i} = \tsaux{INADDR\_BROADCAST} \Mvee  \tsholcomm{ is $\tsunknown{i}$ the default broadcast address? [CORRECT NAME?] }{}\\{}
 \exists  (\tsunknown{k}, \tsunknown{ifd0}) \Mcons  \tsvar{ifds}_{0}.{}\\{}
\quad\quad \tsunknown{i} \;\in  \{\tsaux{if\_broadcast} \;\tsunknown{ifd0};  \tsholcomm{ is $\tsunknown{i}$ the broadcast addr for any interface? }{}\\{}
\quad\quad\quad\quad\quad \tsaux{if\_any} \;\tsunknown{ifd0}\})       \tsholcomm{ RFC 1122 - should accept an all-0s or all-1s
                                                  broadcast address. all three OSes do }}
}
{\rulesubsection{Description}
 Test if IP address $\tsunknown{i}$ is a broadcast or multicast address, wrt the
   given set of interfaces $\tsvar{ifds}_{0}$.  If no interfaces given
   ($\tsvar{ifds}_{0}=*$), then treat only $\tsaux{INADDR\_BROADCAST}$ as a broadcast
   address.

 These correctly use the interface rather than the routing-table
   entry to check what is a broadcast address and what is in the local net of
   this host.  Whether there is a route allowing a send to that local
   net is another question entirely, although the two data structures
   \emph{should} be consistent.

\rrulepad }
}

\newcommand{\defnrouteable}{\ddefnc{routeable}{\iA{routeable}}{\subddefnA[{ compute set of routeable addresses for a routing table entry }]{routeable}{\tsaux{routeable}(\tsunknown{rte}:\tstype{routing\_table\_entry}) ={}\\{}
 \{ \tsunknown{i} \mid  \tsaux{mask} \;\tsunknown{rte}.\tsfield{destination\_netmask} \;\tsunknown{i} = \tsaux{mask} \;\tsunknown{rte}.\tsfield{destination\_netmask} \;\tsunknown{rte}.\tsfield{destination\_ip} \}}
}
{}
}

\newcommand{\defnoutrouteTifids}{\ddefnc{outrouteTifids}{\iA{outroute\_ifids}}{\subddefnA[{ determine list of possible sending interfaces }]{outroute\_ifids}{\tsaux{outroute\_ifids}(\tsvar{i}_{2},\tsvar{rttab}:\tsunknown{routing\_table}) ={}\\{}
 \tsaux{MAP\_OPTIONAL} (\lambda \tsvar{rte}. \Mif  \;\tsvar{i}_{2} \;\in  \;\tsaux{routeable} \;\tsvar{rte} \;\Mthen  \;\Msome  \;\tsvar{rte}.\tsvar{ifid} \;\Melse  \;*) \tsvar{rttab}}
}
{\rulesubsection{Description}
%
Determine the list of possible interfaces to use in sending to a given
IP, based on the routing table.


\rrulepad }
}

\newcommand{\defnifidTup}{\ddefnc{ifidTup}{\iA{ifid\_up}}{\subddefnA[{ is the interface up? }]{ifid\_up}{\tsaux{ifid\_up} \;\tsvar{ifds} \;\tsvar{ifid} = (\tsvar{ifds} \Mfapply{}{\tsvar{ifid}}).\tsvar{up}}
}
{}
}

\newcommand{\defnoutroute}{\ddefnc{outroute}{\iA{outroute}}{\subddefnA[{ compute interface to use to send to given IP, if any }]{outroute}{\tsaux{outroute}(\tsvar{i}_{2},\tsvar{rttab}:\tsunknown{routing\_table},\tsvar{ifds}:\tsvar{ifid} \mapsto  \tstype{ifd}) ={}\\{}
 \Mcase  \;\tsholop{FILTER} (\tsaux{ifid\_up} \;\tsvar{ifds}) (\tsaux{outroute\_ifids}(\tsvar{i}_{2},\tsvar{rttab})) \Mof {}\\{}
\quad [\,]           \Mtotype  *{}\\{}
 \Mdpipe  (\tsvar{ifid}\Mcons \tsunknown{\_987}) \Mtotype  \Msome  \;\tsvar{ifid}}
}
{\rulesubsection{Description}
%
Determine the interface to use to send to a given IP, if possible.
Returns the first up interface that can route to the destination.


\rrulepad }
}

\newcommand{\defnautoToutroute}{\ddefnc{autoToutroute}{\iA{auto\_outroute}}{\subddefnA[{ compute source address to use to route to given IP }]{auto\_outroute}{\tsaux{auto\_outroute}(\tsunknown{i2'},\Msome  \;\tsvar{i}_{2},\tsvar{rttab},\tsvar{ifds}) = \{\tsvar{i}_{2}\} \Mwedge {}\\{}
 \tsaux{auto\_outroute}(\tsunknown{i2'},*   ,\tsvar{rttab},\tsvar{ifds}) = \Mcase  \;\tsaux{outroute}(\tsunknown{i2'},\tsvar{rttab},\tsvar{ifds}) \Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  \;\tsvar{ifid} \Mtotype  \{ (\tsvar{ifds} \Mfapply{}{\tsvar{ifid}}).\tsvar{primary} \}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mdpipe  *      \Mtotype  \{\}}
}
{\rulesubsection{Description}
%
Compute source address to use to route to a given IP, if any possible.
If the caller provides an address, use that without checking;
otherwise try to find one.  Do not return a specific error code.  Used
for autobinding to a local IP address.


\rrulepad }
}

\newcommand{\defntestToutrouteTip}{\ddefnc{testToutrouteTip}{\iA{test\_outroute\_ip}}{\subddefnA[{ test if we can route to given IP, returning appropriate error if not }]{test\_outroute\_ip}{\tsaux{test\_outroute\_ip}(\tsvar{i}_{2}:\tstype{ip},\tsvar{rttab},\tsvar{ifds},\tstype{arch}){}\\{}
 = \Mlet  \;\tsunknown{ifids} = \tsaux{outroute\_ifids}(\tsvar{i}_{2},\tsvar{rttab}) \Min {}\\{}
\quad\quad \Mif  \;\tsunknown{ifids} = [\,] \Mthen {}\\{}
\quad\quad\quad\quad (\Mif  \;\tsaux{linux\_arch} \;\tstype{arch} \;\Mthen  \;\Msome  \;\tscon{ENETUNREACH}{}\\{}
\quad\quad\quad\quad \Melse  \;\Msome  \;\tscon{EHOSTUNREACH}){}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad\quad \Mif  \;\tsholop{FILTER} (\tsaux{ifid\_up} \;\tsvar{ifds}) \tsunknown{ifids} = [\,] \Mthen {}\\{}
\quad\quad\quad\quad\quad\quad \Msome  \;\tscon{ENETDOWN}{}\\{}
\quad\quad\quad\quad \Melse  \;*}
}
{}
}

\newcommand{\defntestToutroute}{\ddefnc{testToutroute}{\iA{test\_outroute}}{\subddefnA[{ if destination IP specified, do $\tsaux{test\_outroute\_ip}$ }]{test\_outroute}{\tsaux{test\_outroute}(\tstype{msg}:\tstype{msg},\tsvar{rttab},\tsvar{ifds},\tstype{arch}){}\\{}
 = \Mcase  \;\tstype{msg}.\tsvar{is}_{2} \;\Mof {}\\{}
\quad \Msome  \;\tsvar{i}_{2} \Mtotype  \Msome  (\tsaux{test\_outroute\_ip}(\tsvar{i}_{2},\tsvar{rttab},\tsvar{ifds},\tstype{arch})){}\\{}
 \Mdpipe  \tsunknown{\_} \Mtotype  *}
}
{\rulesubsection{Description}
Check that we can route the message out.
%
First check that there is an interface that can route to the destination
address.  If not, $\tscon{EHOSTUNREACH}$.  Then, check that there is one of
these that is up.  If not, $\tscon{ENETDOWN}$.  Otherwise, succeed (indicated by
empty set of possible errors).  The message should have $\tsvar{i}_{2}$
specified.

You might think that we should check that the interface can send from
the source address also, but in fact, in the weak end system model,
they don't need to be the same interface.  We have tested Linux, and
find this behaviour.  Not sure yet about BSD, but suspect it will be
the same.  test 20030204T1525 or so.

$\tsaux{test\_outroute}$ modified to be functional rather than relational, as
   behaviour is purely deterministic.  The result is of type $\tstype{error}
\;\tstype{option} \;\;\tstype{option}$, where the first level of "optionality" indicates
   whether or not the function is even being called on valid input
   (whether or not message has an $\tsvar{is}_{2}$ "field"), and the next level
   indicates errors being raised, or not.

   Note that if we "knew" that this would only be called on messages
   with ok $\tsvar{is}_{2}$ fields, then it would easier still to just use $\tsholop{THE}$,
   ignore the fact that the function had an unspecified result on
   arguments with bad $\tsvar{is}_{2}$ fields, and make the result type $ \tstype{error} \;\;\tstype{option}$.

\rrulepad }
}

\newcommand{\defnloopbackTonTwire}{\ddefnc{loopbackTonTwire}{\iA{loopback\_on\_wire}}{\subddefnA[{ check if a message bears a loopback address }]{loopback\_on\_wire}{\tsaux{loopback\_on\_wire} (\tstype{msg}:\tstype{msg}) (\tsvar{ifds}:\tsvar{ifid} \mapsto  \tstype{ifd}) ={}\\{}
 \Mcase  (\tstype{msg}.\tsvar{is}_{1}, \tstype{msg}.\tsvar{is}_{2}) \Mof {}\\{}
\quad (*, *) \Mtotype  \Mfalse {}\\{}
 \Mdpipe  (*, \Msome  \;\tsunknown{j}) \Mtotype  \Mfalse {}\\{}
 \Mdpipe  (\Msome  \;\tsunknown{i}, *) \Mtotype  \Mfalse {}\\{}
 \Mdpipe  (\Msome  \;\tsunknown{i}, \Msome  \;\tsunknown{j}) \Mtotype  \tsaux{in\_loopback} \;\tsunknown{i} \Mwedge  \neg{}\tsaux{in\_local} \;\tsvar{ifds} \;\tsunknown{j}}
}
{\rulesubsection{Description}
 RFC1122 says loopback addresses must never appear on the wire.  Here we test if
   this segment is in violation.  Ideally, we'd check "(src or dest in
   loopback net) and interface not loopback", but we can't see which
   interface it's going out of in this model.  The condition above is
   possibly the best approximation we can make if one considers the possible
   values of $\tstype{msg}.\tsvar{is}_{1}$ and $\tstype{msg}.\tsvar{is}_{2}$.

\rrulepad }
}

\newcommand{\seccommauxTfiles}{\clustersection{(TCP and UDP)}{Files, file descriptors, and sockets}
\seccomm{
   The open files of a host are modelled by a set of open file
   descriptions, indexed by $\tstype{fid}$.  The open files of a process are
   identified by file descriptor $\tstype{fd}$, which is an index into a
   table of $\tstype{fid}$s.  This table is modelled by a finite map.
   File descriptors are isomorphic to the natural numbers.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{fdlt}$
&
&  $<$ comparison on file descriptors \\
$\tsrule{fdle}$
&
&  $\leq $ comparison on file descriptors \\
$\tsrule{leastfd}$
&
&  least $\tstype{fd}$ satisfying predicate $\tsunknown{P}$ \\
$\tsrule{nextfd}$
&
&  next file descriptor to use \\
$\tsrule{fid\_ref\_count}$
&
&  count references to given $\tstype{fid}$ \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnfdlt}{\ddefnc{fdlt}{\iA{fdlt}}{\subddefnA[{ $<$ comparison on file descriptors }]{fdlt}{\tsaux{fdlt} (\tscon{FD} \;\tsvar{n}) (\tscon{FD} \;\tsunknown{m}) = \tsvar{n} < \tsunknown{m}}
}
{}
}

\newcommand{\defnfdle}{\ddefnc{fdle}{\iA{fdle}}{\subddefnA[{ $\leq $ comparison on file descriptors }]{fdle}{\tsaux{fdle} (\tscon{FD} \;\tsvar{n}) (\tscon{FD} \;\tsunknown{m}) = \tsvar{n} \leq  \tsunknown{m}}
}
{}
}

\newcommand{\defnleastfd}{\ddefnc{leastfd}{\iA{leastfd}}{\subddefnA[{ least $\tstype{fd}$ satisfying predicate $\tsunknown{P}$ }]{leastfd}{\tsaux{leastfd} \;\tsunknown{P} = \tscon{FD} (\tsholop{LEAST} \;\tsvar{n}. \tsunknown{P} (\tscon{FD} \;\tsvar{n}))}
}
{}
}

\newcommand{\defnnextfd}{\ddefnc{nextfd}{\iA{nextfd}}{\subddefnA[{ next file descriptor to use }]{nextfd}{\tsaux{nextfd} \;\tstype{arch} \;\tsvar{fds} \;\tsunknown{fd'} = \Mif  \;\tsaux{windows\_arch} \;\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscomm{ no ordering on Windows fds; they're just handles }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{fd'} \;\notin  \Mfdom{\tsvar{fds}}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscomm{ POSIX architectures allocate in order }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{fd'} = \tsaux{leastfd} \;\tsunknown{fd'}. \tsunknown{fd'} \;\notin  \Mfdom{\tsvar{fds}}}
}
{\rulesubsection{Description}
%
Basic operations on file descriptors.  Normally, when a new file
descriptor is required the least unused one is used.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
On Windows, file descriptors are opaque handles, and have no useful
ordering.  In particular, $\tsaux{nextfd}$ returns an arbitrary unused file
descriptor.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\defnfidTrefTcount}{\ddefnc{fidTrefTcount}{\iA{fid\_ref\_count}}{\subddefnA[{ count references to given $\tstype{fid}$ }]{fid\_ref\_count}{\tsaux{fid\_ref\_count}(\tsvar{fds}:\tstype{fd} \mapsto  \tstype{fid},\tstype{fid}) = \tsholop{CARD} (\Mfdom{(\tsholop{RRESTRICT} \;\tsvar{fds} \{\tstype{fid}\})})}
}
{\rulesubsection{Description}
A file is closed when its reference count drops to zero.  This function determines the
reference count of a file (strictly, a $\tstype{fid}$).
\rrulepad }
}

\newcommand{\seccommauxTtimers}{\clustersection{(TCP and UDP)}{Timers}
\seccomm{
Many TCP protocol events are time-dependent, and time is also
necessary for a useful specification of the behaviour of system calls,
returns, and datagram emission and receipt.  These common
time-dependent behaviours are described using the timers below.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{slow\_timer}$
&
&  TCP slow timer, typically 500ms resolution (for keepalive, MSL, linger, badrxtwin) \\
$\tsrule{fast\_timer}$
&
&  TCP fast timer, typically 200ms resolution (for delack) \\
$\tsrule{kern\_timer}$
&
&  kernel timer, typically 10ms resolution (for timestamp valid, pselect) \\
$\tsrule{sched\_timer}$
&
&  scheduling timer (for OS returns) \\
$\tsrule{inqueue\_timer}$
&
&  in-queue timer (incoming message processing) \\
$\tsrule{outqueue\_timer}$
&
&  out-queue timer (outgoing message emission) \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnslowTtimer}{\ddefnc{slowTtimer}{\iA{slow\_timer}}{\subddefnA[{ TCP slow timer, typically 500ms resolution (for keepalive, MSL, linger, badrxtwin) }]{slow\_timer}{\tsaux{slow\_timer} \;\tsunknown{d} = \tsaux{fuzzy\_timer} \;\tsunknown{d} \;\tsaux{SLOW\_TIMER\_INTVL} \;\tsaux{SLOW\_TIMER\_MODEL\_INTVL}}
}
{}
}

\newcommand{\defnfastTtimer}{\ddefnc{fastTtimer}{\iA{fast\_timer}}{\subddefnA[{ TCP fast timer, typically 200ms resolution (for delack) }]{fast\_timer}{\tsaux{fast\_timer} \;\tsunknown{d} = \tsaux{fuzzy\_timer} \;\tsunknown{d} \;\tsaux{FAST\_TIMER\_INTVL} \;\tsaux{FAST\_TIMER\_MODEL\_INTVL}}
}
{}
}

\newcommand{\defnkernTtimer}{\ddefnc{kernTtimer}{\iA{kern\_timer}}{\subddefnA[{ kernel timer, typically 10ms resolution (for timestamp valid, pselect) }]{kern\_timer}{\tsaux{kern\_timer} \;\tsunknown{d} = \tsaux{fuzzy\_timer} \;\tsunknown{d} \;\tsaux{KERN\_TIMER\_INTVL} \;\tsaux{KERN\_TIMER\_MODEL\_INTVL}}
}
{}
}

\newcommand{\defnschedTtimer}{\ddefnc{schedTtimer}{\iA{sched\_timer}}{\subddefnA[{ scheduling timer (for OS returns) }]{sched\_timer}{\tsaux{sched\_timer}     = \tsaux{upper\_timer} \;\tsaux{dschedmax}}
}
{}
}

\newcommand{\defninqueueTtimer}{\ddefnc{inqueueTtimer}{\iA{inqueue\_timer}}{\subddefnA[{ in-queue timer (incoming message processing) }]{inqueue\_timer}{\tsaux{inqueue\_timer}   = \tsaux{upper\_timer} \;\tsaux{diqmax}}
}
{}
}

\newcommand{\defnoutqueueTtimer}{\ddefnc{outqueueTtimer}{\iA{outqueue\_timer}}{\subddefnA[{ out-queue timer (outgoing message emission) }]{outqueue\_timer}{\tsaux{outqueue\_timer}  = \tsaux{upper\_timer} \;\tsaux{doqmax}}
}
{\rulesubsection{Description}

   Traditionally TCP has been implemented using two timers, a slow
   timer ticking once every 500ms, and a fast timer ticking once every
   200ms.  In addition, the kernel is assumed to maintain a tick
   count, typically incremented every 10ms.

   Measuring intervals with such a timer means an uncertainty in
   duration: the observed interval may be up to one tick less than the
   specified interval, and is on average half a tick less.  We model
   this with a \ltslink{fuzzyTtimer}{$\tsaux{fuzzy\_timer}$}, fuzzy to the left by $\tsunknown{eps}$
   and to the right by $\tsunknown{fuz}$, i.e., $ [\tsunknown{d}-\tsunknown{eps},\tsunknown{d}+\tsunknown{fuz}] $.

    The $\tsunknown{eps}$, one tick, accounts for the fact that we do not know
      where in the clock's period we set the timer.

    The $\tsunknown{fuz}$ (some global fuzziness) is included
    to account for the atomicity of the model.
      For example, an implementation TCP processing step, performed by
  \wasverb{tcp\textunderscore{}output} etc., occupies some time interval, with timers such as
  $\tsfield{tt\_rexmt}$ being reset at various points within that interval.
  The model, on the other hand, has atomic transitions.
  The possible time difference between multiple timer resets in the same step must be accounted for by this fuzziness.

    For example,
   a model rule may
   reset the $\tsfield{tt\_rexmt}$ timer and also leave a segment on the output queue,
   with  time passing before the segment is seen on the wire.
%
%
%
%
% This time
%    passage covers not only the time to emit the packet but the mainly
%    unobservable (except for BSD) TCP processing being performed by the
%    host in [[tcp_output]] and friends. The period of TCP processing that
%    occurs before the rexmt timer is \emph{really} reset must be accounted for
%    by the fuzziness.

The various flavours of \ltslink{upperTtimer}{$\tsaux{upper\_timer}$} -- $\tsaux{sched\_timer}$,
$\tsaux{inqueue\_timer}$, $\tsaux{outqueue\_timer}$ -- fire at any time between now
and $\tsunknown{dmax}$.  These events may occur at any time up to a specified
maximum delay.


\rrulepad }
}

\newcommand{\seccommauxTtimeopt}{\clustersection{(TCP and UDP)}{Time values for socket options}
\seccomm{
   The $\tstype{TLang}$ sockets interface representation of a time is as a pair of integers,
   the first for seconds and the second for nanoseconds.
   It also uses $(\tstype{int}\#\tstype{int}) \;\tstype{option}$ representations, e.g.~in the arguments to $\tslib{setsocktopt}$ and $\tslib{pselect}$ and the result of $\tslib{setsocktopt}$, with the $\tsunknown{None}$ value meaning infinity.
   Internally, time is represented as a $\tstype{time}$ value, either a real or infinity.
   These routines convert between the various types. Note that they allow ill-formed tltimeopts without complaint.

}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{time\_of\_tltime}$
&
&  convert $(\tsunknown{sec},\tsunknown{nsec})$ pair to real time value \\
$\tsrule{time\_of\_tltimeopt}$
&
&  convert optional $(\tsunknown{sec},\tsunknown{nsec})$ pair to real time value (where $*$ mapped to $\infty$) \\
$\tsrule{tltimeopt\_wf}$
&
&  is an optional $(\tsunknown{sec},\tsunknown{nsec})$ pair well-formed? \\
$\tsrule{tltimeopt\_of\_time}$
&
&  convert a $\tstype{time}$ value to an optional $(\tsunknown{sec},\tsunknown{nsec})$ pair \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntimeTofTtltime}{\ddefnc{timeTofTtltime}{\iA{time\_of\_tltime}}{\subddefnA[{ convert $(\tsunknown{sec},\tsunknown{nsec})$ pair to real time value }]{time\_of\_tltime}{(\tsaux{time\_of\_tltime} : \tstype{int} \# \tstype{int} \Mtotype  \tstype{time}){}\\{}
 (\tsunknown{sec},\tsunknown{nsec}) = \tstype{time} (\tsaux{real\_of\_int} \;\tsunknown{sec} + \tsaux{real\_of\_int} \;\tsunknown{nsec} / 1000000000)}
}
{}
}

\newcommand{\defntimeTofTtltimeopt}{\ddefnc{timeTofTtltimeopt}{\iA{time\_of\_tltimeopt}}{\subddefnA[{ convert optional $(\tsunknown{sec},\tsunknown{nsec})$ pair to real time value (where $*$ mapped to $\infty$) }]{time\_of\_tltimeopt}{\tsaux{time\_of\_tltimeopt}  \;*     = \infty \Mwedge {}\\{}
 \tsaux{time\_of\_tltimeopt} (\Msome  \;\tsunknown{sn}) = \tsaux{time\_of\_tltime} \;\tsunknown{sn}}
}
{}
}

\newcommand{\defntltimeoptTwf}{\ddefnc{tltimeoptTwf}{\iA{tltimeopt\_wf}}{\subddefnA[{ is an optional $(\tsunknown{sec},\tsunknown{nsec})$ pair well-formed? }]{tltimeopt\_wf}{(\tsaux{tltimeopt\_wf} : (\tstype{int} \# \tstype{int}) \;\tstype{option} \Mtotype  \tstype{bool}){}\\{}
\quad\quad\quad\quad\quad *             = \Mtrue  \Mwedge {}\\{}
 \tsaux{tltimeopt\_wf} (\Msome  (\tsunknown{sec},\tsunknown{nsec})) = (\tsunknown{sec} \geq  0 \Mwedge  \tsunknown{nsec} \geq  0 \Mwedge  \tsunknown{nsec} < 1000000000)}
}
{}
}

\newcommand{\defntltimeoptTofTtime}{\ddefnc{tltimeoptTofTtime}{\iA{tltimeopt\_of\_time}}{\subddefnA[{ convert a $\tstype{time}$ value to an optional $(\tsunknown{sec},\tsunknown{nsec})$ pair }]{tltimeopt\_of\_time}{(\tsaux{tltimeopt\_of\_time} : \tstype{time} \Mtotype  (\tstype{int} \# \tstype{int}) \;\tstype{option}) \tsvar{t}{}\\{}
 = @\tsvar{x}. \tsaux{tltimeopt\_wf} \;\tsvar{x} \Mwedge  \tsaux{time\_of\_tltimeopt} \;\tsvar{x} = \tsvar{t}  \tsholcomm{ garbage if $\tsvar{t}$ not nonnegative integral number of nsec }}
}
{\rulesubsection{Description}
 A $\tsunknown{tltimeopt}$ is well-formed if $\tsunknown{sec}$ and $\tsunknown{nsec}$ are positive
   and $\tsunknown{nsec}$ is less than $10^9$.

\rrulepad }
}

\newcommand{\seccommauxTqueues}{\clustersection{(TCP and UDP)}{Queues}
\seccomm{
Messages are queued at various points within the implementations,
e.g.~within the network interface hardware and in the kernel.  These
queues can become full, though their "size" is not simple to describe
--- e.g.~in BSD there is some accounting of the number of mbufs used.
We model this with simple queues, for example the host message inqueue and outqueue (see $\tsvar{iq}$ and $\tsvar{oq}$, \ltslink{host}{$\tstype{host}$}) which have lists of messages.
These model the combination of network interface and kernel queues.
We allow them to nondetermistically be full for enqueue operations, to ensure that the specification includes all real-world traces.
This behaviour is guarded by $\tsaux{INFINITE\_RESOURCES}$.

The nondeterminism means that queue operations must be relations, not
functions, and hence that many definitions that use them must also be
relational.

Many queues also associated with timers (see e.g.~\ltslink{inqueueTtimer}{$\tsaux{inqueue\_timer}$}) bounding the times within which they must next be
processed.

One might want additional properties, e.g.~(1) if a queue is empty then at least one message can be enqueued, or more
generally a specified finite lower bound on queue size;
or
(2) if a queue is full then is remains so until a message is dequeued
(perhaps only for enqueue attempts of at least the same size).
At present we see no need for the additional complication.



}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{enqueue}$
&
&  attempt to enqueue a message \\
$\tsrule{enqueue\_iq}$
&
&  attempt to enqueue onto the in-queue \\
$\tsrule{enqueue\_oq}$
&
&  attempt to enqueue onto the out-queue \\
$\tsrule{dequeue}$
&
&  attempt to dequeue a message \\
$\tsrule{dequeue\_iq}$
&
&  attempt to dequeue from the in-queue \\
$\tsrule{dequeue\_oq}$
&
&  attempt to dequeue from the out-queue \\
$\tsrule{route\_and\_enqueue\_oq}$
&
&  attempt to route and then enqueue an outgoing message \\
$\tsrule{enqueue\_list\_qinfo}$
&
&  attempt to enqueue a list of messages \\
$\tsrule{enqueue\_list}$
&
&  attempt to enqueue a list of messages, ignoring success flags \\
$\tsrule{enqueue\_oq\_list\_qinfo}$
&
&  attempt to enqueue a list of messages onto the out-queue \\
$\tsrule{enqueue\_oq\_list}$
&
&  attempt to enqueue a list of messages onto the out-queue, ignoring success flags \\
$\tsrule{accept\_incoming\_q0}$
&
&  should an incoming incomplete connection be accepted? \\
$\tsrule{accept\_incoming\_q}$
&
&  should an incoming completed connection be accepted? \\
$\tsrule{drop\_from\_q0}$
&
&  drop from incomplete-connection queue? \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnenqueue}{\ddefnc{enqueue}{\iA{enqueue}}{\subddefnA[{ attempt to enqueue a message }]{enqueue}{\tsaux{enqueue} \;\tsunknown{dq} (\Mtimed{\tsvar{q}}{\tsunknown{d}},\tstype{msg},\Mtimed{\tsvar{q}'}{\tsunknown{d'}},\tsunknown{queued}){}\\{}
 = ((\tsaux{INFINITE\_RESOURCES} \implies  \tsunknown{queued}) \Mwedge {}\\{}
\quad (\tsvar{q}',\tsunknown{d'}) = (\Mif  \;\tsunknown{queued} \;\Mthen  (\Mappend{\tsvar{q}}{[\tstype{msg}]},\tsunknown{dq}) \Melse  (\tsvar{q},\tsunknown{d})){}\\{}
 )}
}
{\rulesubsection{Description}
This is a relation between an original timed queue $\Mtimed{\tsvar{q}}{\tsunknown{d}}$, a message to enqueue, $\tstype{msg}$, a resulting timed queue $\Mtimed{\tsvar{q}'}{\tsunknown{d'}}$, and a boolean $\tsunknown{queued}$ indicating whether the enqueue was successful or not.  For a successful enqueue the timer on the resulting queue is set to $\tsunknown{dq}$
\rrulepad }
}

\newcommand{\defnenqueueTiq}{\ddefnc{enqueueTiq}{\iA{enqueue\_iq}}{\subddefnA[{ attempt to enqueue onto the in-queue }]{enqueue\_iq}{\tsaux{enqueue\_iq} = \tsaux{enqueue} \;\tsaux{inqueue\_timer}}
}
{}
}

\newcommand{\defnenqueueToq}{\ddefnc{enqueueToq}{\iA{enqueue\_oq}}{\subddefnA[{ attempt to enqueue onto the out-queue }]{enqueue\_oq}{\tsaux{enqueue\_oq} = \tsaux{enqueue} \;\tsaux{outqueue\_timer}}
}
{\rulesubsection{Description}
Add a message to the respective queue, returning the new queue and a flag
   saying whether the message was successfully queued.

\rrulepad }
}

\newcommand{\defndequeue}{\ddefnc{dequeue}{\iA{dequeue}}{\subddefnA[{ attempt to dequeue a message }]{dequeue}{\tsaux{dequeue} \;\tsunknown{dq} (\Mtimed{\tsvar{q}}{\tsunknown{d}},\Mtimed{\tsvar{q}'}{\tsunknown{d'}},\tstype{msg}){}\\{}
 = \Mcase  \;\tsvar{q} \;\Mof {}\\{}
\quad (\tsunknown{msg0}\Mcons \tsvar{q}_{0}) \Mtotype  \tsvar{q}' = \tsvar{q}_{0} \Mwedge  \tstype{msg} = \Msome  \;\tsunknown{msg0} \Mwedge  \tsunknown{d'} = (\Mif  \;\tsvar{q}_{0} = [\,] \Mthen  \;\tsaux{never\_timer} \;\Melse  \;\tsunknown{dq}) \Mdpipe {}\\{}
\quad [\,]         \Mtotype  \tsvar{q}' = \tsvar{q}  \Mwedge  \tstype{msg} = *      \Mwedge  \tsunknown{d'} = \tsunknown{d}}
}
{}
}

\newcommand{\defndequeueTiq}{\ddefnc{dequeueTiq}{\iA{dequeue\_iq}}{\subddefnA[{ attempt to dequeue from the in-queue }]{dequeue\_iq}{\tsaux{dequeue\_iq} = \tsaux{dequeue} \;\tsaux{inqueue\_timer}}
}
{}
}

\newcommand{\defndequeueToq}{\ddefnc{dequeueToq}{\iA{dequeue\_oq}}{\subddefnA[{ attempt to dequeue from the out-queue }]{dequeue\_oq}{\tsaux{dequeue\_oq} = \tsaux{dequeue} \;\tsaux{outqueue\_timer}}
}
{\rulesubsection{Description}
Remove a message from the queue, returning the new queue, and the
   message if there is one.

\rrulepad }
}

\newcommand{\defnrouteTandTenqueueToq}{\ddefnc{routeTandTenqueueToq}{\iA{route\_and\_enqueue\_oq}}{\subddefnA[{ attempt to route and then enqueue an outgoing message }]{route\_and\_enqueue\_oq}{\tsaux{route\_and\_enqueue\_oq} (\tsvar{rttab},\tsvar{ifds},\tsvar{oq},\tstype{msg},\tsvar{oq}',\tsvar{es},\tstype{arch}){}\\{}
 = \Mcase  \;\tsaux{test\_outroute} (\tstype{msg},\tsvar{rttab},\tsvar{ifds},\tstype{arch}) \Mof {}\\{}
\quad\quad * \Mtotype  \Mfalse {}\\{}
 \Mdpipe  \Msome  (\Msome  \;\tsvar{e}) \Mtotype  \tsvar{oq}' = \tsvar{oq} \Mwedge  \tsvar{es} = \Msome  \;\tsvar{e}{}\\{}
 \Mdpipe  \Msome  \;* \Mtotype  \exists \tsvar{queued}.{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{enqueue\_oq} (\tsvar{oq},\tstype{msg},\tsvar{oq}',\tsvar{queued}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{es} = \Mif  \;\tsvar{queued} \;\Mthen  \;* \;\Melse  \;\Msome  \;\tscon{ENOBUFS}}
}
{\rulesubsection{Description}
 This is a relation because $\tsaux{enqueue\_oq}$ can non-deterministically
   decide that the $\tsvar{oq}$ is full.

\rrulepad }
}

\newcommand{\defnenqueueTlistTqinfo}{\ddefnc{enqueueTlistTqinfo}{\iA{enqueue\_list\_qinfo}}{\subddefnA[{ attempt to enqueue a list of messages }]{enqueue\_list\_qinfo}{\tsaux{enqueue\_list\_qinfo} \;\tsunknown{dq} (\tsvar{q},(\tstype{msg},\tsunknown{queued})\Mcons \tsunknown{msgqs},\tsvar{q}'){}\\{}
 = (\exists \tsvar{q}_{0}.{}\\{}
\quad \tsaux{enqueue}            \;\tsunknown{dq} (\tsvar{q} ,\tstype{msg}  ,\tsvar{q}_{0},\tsunknown{queued}) \Mwedge {}\\{}
\quad \tsaux{enqueue\_list\_qinfo} \;\tsunknown{dq} (\tsvar{q}_{0},\tsunknown{msgqs},\tsvar{q}')) \Mwedge {}\\{}
 \tsaux{enqueue\_list\_qinfo} \;\tsunknown{dq} (\tsvar{q},[\,],\tsvar{q}'){}\\{}
 = (\tsvar{q}' = \tsvar{q})}
}
{}
}

\newcommand{\defnenqueueTlist}{\ddefnc{enqueueTlist}{\iA{enqueue\_list}}{\subddefnA[{ attempt to enqueue a list of messages, ignoring success flags }]{enqueue\_list}{\tsaux{enqueue\_list} \;\tsunknown{dq} (\tsvar{q},\tsunknown{msgs},\tsvar{q}',\tsunknown{queued}) ={}\\{}
 (\exists \tsvar{msgqs}.{}\\{}
 \tsaux{enqueue\_list\_qinfo} \;\tsunknown{dq} (\tsvar{q},\tsvar{msgqs},\tsvar{q}') \Mwedge {}\\{}
 \tsunknown{msgs} = \tsholop{MAP} \;\tsholop{FST} \;\tsvar{msgqs} \Mwedge {}\\{}
 \tsunknown{queued} = \tsholop{EVERY} (\lambda \tsvar{x}. \tsholop{SND} \;\tsvar{x} = \Mtrue ) \tsvar{msgqs})}
}
{}
}

\newcommand{\defnenqueueToqTlistTqinfo}{\ddefnc{enqueueToqTlistTqinfo}{\iA{enqueue\_oq\_list\_qinfo}}{\subddefnA[{ attempt to enqueue a list of messages onto the out-queue }]{enqueue\_oq\_list\_qinfo}{\tsaux{enqueue\_oq\_list\_qinfo} = \tsaux{enqueue\_list\_qinfo} \;\tsaux{outqueue\_timer}}
}
{}
}

\newcommand{\defnenqueueToqTlist}{\ddefnc{enqueueToqTlist}{\iA{enqueue\_oq\_list}}{\subddefnA[{ attempt to enqueue a list of messages onto the out-queue, ignoring success flags }]{enqueue\_oq\_list}{\tsaux{enqueue\_oq\_list} = \tsaux{enqueue\_list} \;\tsaux{outqueue\_timer}}
}
{\rulesubsection{Description}
 We sometimes need to enqueue multiple messages at a time.  $\tsaux{enqueue\_list\_qinfo}$
   tries to enqueue a list of messages, pairing each with its
   success boolean.

 Often, we don't care too much about the precise queueing success of
   each message.  $\tsaux{enqueue\_list}$ provides the AND of success of each
   message (though this is of limited use).

\rrulepad }
}

\newcommand{\defnacceptTincomingTqZ}{\ddefnc{acceptTincomingTqZ}{\iA{accept\_incoming\_q0}}{\subddefnA[{ should an incoming incomplete connection be accepted? }]{accept\_incoming\_q0}{\tsaux{accept\_incoming\_q0} (\tsvar{lis}:\tstype{socket\_listen}) (\tsvar{b}:\tstype{bool}){}\\{}
 = (\tsvar{b} = \tsholop{LENGTH} \;\tsvar{lis}.\tsvar{q} < \tsaux{backlog\_fudge} \;\tsvar{lis}.\tsvar{qlimit})}
}
{}
}

\newcommand{\defnacceptTincomingTq}{\ddefnc{acceptTincomingTq}{\iA{accept\_incoming\_q}}{\subddefnA[{ should an incoming completed connection be accepted? }]{accept\_incoming\_q}{\tsaux{accept\_incoming\_q} (\tsvar{lis}:\tstype{socket\_listen}) (\tsvar{b}:\tstype{bool}){}\\{}
 = (\tsvar{b} = \tsholop{LENGTH} \;\tsvar{lis}.\tsvar{q} < 3 * \tsaux{backlog\_fudge} \;\tsvar{lis}.\tsvar{qlimit} \;\tsholop{DIV} \;2)}
}
{}
}

\newcommand{\defndropTfromTqZ}{\ddefnc{dropTfromTqZ}{\iA{drop\_from\_q0}}{\subddefnA[{ drop from incomplete-connection queue? }]{drop\_from\_q0}{\tsaux{drop\_from\_q0} (\tsvar{lis}:\tstype{socket\_listen}) (\tsvar{b}:\tstype{bool}){}\\{}
 = ((\tsholop{LENGTH} \;\tsvar{lis}.\tsvar{q}_{0} \geq  \tsaux{TCP\_Q0MINLIMIT} \Mwedge  \tsvar{b} = \Mtrue ) \Mvee {}\\{}
\quad (\tsholop{LENGTH} \;\tsvar{lis}.\tsvar{q}_{0} <  \tsaux{TCP\_Q0MAXLIMIT} \Mwedge  \tsvar{b} = \Mfalse ))}
}
{\rulesubsection{Description}
%
A listening socket has two queues, the incomplete connections queue
$\tsvar{lis}.\tsvar{q}_{0}$ and the completed connections queue $\tsvar{lis}.\tsvar{q}$.
%
An incoming incomplete (respectively, completed) connection be
accepted onto $\tsvar{lis}.\tsvar{q}_{0}$ (respectively, $\tsvar{lis}.\tsvar{q}$) if the
relevant queue is not full.
%
Intriguingly, for FreeBSD 4.6-RELEASE, this specification  is
correct, but if syncaches were to be turned off, the condition in the
$\tsvar{q}_{0}$ case would be $\tsholop{LENGTH} \;\tsvar{lis}.\tsvar{q} < 3 * \tsvar{lis}.\tsvar{qlimit} / 2$ instead.
%
Existing incomplete connections may dropped from $\tsvar{lis}.\tsvar{q}_{0}$ to make
room if its length is between its minimum and maximum limits.


\rrulepad }
}

\newcommand{\dumpallrules}{
\showrule{\seccommhosttyTtcpstates}
\showrule{\defntcpstate}
\showrule{\defnsocketTlisten}
\showrule{\defndgramTmsg}
\showrule{\defndgramTerror}
\showrule{\defndgram}
\showrule{\defnudpTsocket}
\showrule{\defnifd}
\showrule{\defnroutingTtableTentry}
\showrule{\defntypeTabbrevTroutingTtable}
\showrule{\defnbandlimTreason}
\showrule{\defntypeTabbrevTbandlimTstate}
\showrule{\defnhostThreadState}
\showrule{\defnhostParams}
\showrule{\defntraceflavour}
\showrule{\defnhostid}
\showrule{\seccommhostZTcats}
\showrule{\defnruleTproto}
\showrule{\defnruleTstatus}
\showrule{\defnruleTcat}
\showrule{\defnurgent}
\showrule{\defnnonurgent}
\showrule{\defnisTurgent}
\showrule{\seccommauxTarch}
\showrule{\defnwindowsTarch}
\showrule{\defnbsdTarch}
\showrule{\defnlinuxTarch}
\showrule{\defnunixTarch}
\showrule{\seccommauxTif}
\showrule{\defnmask}
\showrule{\defnmaskTbits}
\showrule{\defnIP}
\showrule{\defnINTMULTICAST}
\showrule{\defnINADDRTBROADCAST}
\showrule{\defnLOOPBACKTADDRS}
\showrule{\defnipTlocalhost}
\showrule{\defninTloopback}
\showrule{\defninTlocal}
\showrule{\defnlocalTips}
\showrule{\defnlocalTprimaryTips}
\showrule{\defnisTlocalnet}
\showrule{\defnifTbroadcast}
\showrule{\defnifTany}
\showrule{\defnisTbroadormulticast}
\showrule{\defnrouteable}
\showrule{\defnoutrouteTifids}
\showrule{\defnifidTup}
\showrule{\defnoutroute}
\showrule{\defnautoToutroute}
\showrule{\defntestToutrouteTip}
\showrule{\defntestToutroute}
\showrule{\defnloopbackTonTwire}
\showrule{\seccommauxTfiles}
\showrule{\defnfdlt}
\showrule{\defnfdle}
\showrule{\defnleastfd}
\showrule{\defnnextfd}
\showrule{\defnfidTrefTcount}
\showrule{\seccommauxTtimers}
\showrule{\defnslowTtimer}
\showrule{\defnfastTtimer}
\showrule{\defnkernTtimer}
\showrule{\defnschedTtimer}
\showrule{\defninqueueTtimer}
\showrule{\defnoutqueueTtimer}
\showrule{\seccommauxTtimeopt}
\showrule{\defntimeTofTtltime}
\showrule{\defntimeTofTtltimeopt}
\showrule{\defntltimeoptTwf}
\showrule{\defntltimeoptTofTtime}
\showrule{\seccommauxTqueues}
\showrule{\defnenqueue}
\showrule{\defnenqueueTiq}
\showrule{\defnenqueueToq}
\showrule{\defndequeue}
\showrule{\defndequeueTiq}
\showrule{\defndequeueToq}
\showrule{\defnrouteTandTenqueueToq}
\showrule{\defnenqueueTlistTqinfo}
\showrule{\defnenqueueTlist}
\showrule{\defnenqueueToqTlistTqinfo}
\showrule{\defnenqueueToqTlist}
\showrule{\defnacceptTincomingTqZ}
\showrule{\defnacceptTincomingTq}
\showrule{\defndropTfromTqZ}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore hostTypes

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPIThostTypes}{\chaptersection{ Host types}
\label{TCP1_hostTypes}%
\chapcomm{
This file defines types for the internal state of the host and its components:
files, TCP control blocks, sockets, interfaces, routing table, thread
states, and so on, culminating in the definition of the $\tstype{host}$ type.
%
It also defines TCP trace records, building on the definition of TCP control blocks.


Broadly following the implementations, each protocol endpoint has a
$\tslib{socket}$ structure which has some common fields (e.g.~the associated
IP addresses and ports), and some protocol-specific information.

For TCP, which involves a great deal of local state, the
protocol-specific information (of type $\tstype{tcp\_socket}$) consists of a
\emph{TCP state} ($\tscon{CLOSED}$, $\tscon{LISTEN}$, etc.), send and receive
queues, and a \emph{TCP control block}, of type $\tstype{tcpcb}$, with many
window parameters, timers, etc.
%
Roughly, the $\tslib{socket}$ structure and $\tstype{tcp\_socket}$ substructure contain all the information required by most sockets rules, whereas the $\tstype{tcpcb}$ contains fields required only by the protocol information.




}
}

\newcommand{\seccommhosttyTtcpcp}{\clustersection{(TCP only)}{The TCP control block}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{tcpReassSegment}$
&
&  segment reassembly queue elements \\
$\tsrule{rexmtmode}$
&
&  retransmission mode \\
$\tsrule{rttinf}$
&
&  round-trip time calculation parameters \\
$\tsrule{tcpcb}$
&
&  the TCP control block \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntcpReassSegment}{\ddefnc{tcpReassSegment}{\iA{tcpReassSegment}}{\subddefnA[{ segment reassembly queue elements }]{tcpReassSegment}{\tstype{tcpReassSegment}{}\\{}
 = \Mmagiclrec  \tsvar{seq} : \tsaux{tcp\_seq\_foreign};{}\\{}
 \tsfield{spliced\_urp} : \tsaux{tcp\_seq\_foreign} \;\;\tstype{option};{}\\{}
 \tsvar{FIN} : \tstype{bool};{}\\{}
 \tsvar{data} : \tstype{byte} \;\tstype{list}{}\\{}
 \Mmagicbolrrec }
}
{\rulesubsection{Description}
The TCP reassembly queue (the $\tsfield{t\_segq}$ component of the TCP control block)
holds information about TCP segments received out of order, pending their reassembly.  It is a list of these $\tstype{tcpReassSegment}$s, recording just the information we need about each.
%
        If a byte of urgent data has been spliced from $\tsvar{data}$ for
       out-of-line delivery, its sequence number is recorded in the $\tsfield{spliced\_urp}$ component here to
       permit correct reassembly.


\rrulepad }
}

\newcommand{\defnrexmtmode}{\ddefnc{rexmtmode}{\iA{rexmtmode}}{\subddefnA[{ retransmission mode }]{rexmtmode}{\tstype{rexmtmode} ={}\\{}
 \tscon{RexmtSyn}{}\\{}
 \mid  \tscon{Rexmt}{}\\{}
 \mid  \tscon{Persist}}
}
{\rulesubsection{Description}
   TCP has three output modes: idle,
   retransmitting, and persisting.  We introduce one more,
   retransmitting-syn, since the behaviour is slightly different.
   These modes all share the same timer, and use this "mode" parameter
   to distinguish.  The idle mode is represented by the timer not
   running.


\rrulepad }
}

\newcommand{\defnrttinf}{\ddefnc{rttinf}{\iA{rttinf}}{\subddefnA[{ round-trip time calculation parameters }]{rttinf}{\tstype{rttinf}{}\\{}
 = \Mmagiclrec  \tsfield{t\_rttupdated} : \tstype{num} ;                \tsholcomm{ number of times rtt sampled }{}\\{}
 \tsfield{tf\_srtt\_valid} : \tstype{bool} ;              \tsholcomm{ estimate is currently believed to be valid }{}\\{}
 \tsfield{t\_srtt}     : \tsaux{duration} ;             \tsholcomm{ smoothed round-trip time }{}\\{}
 \tsfield{t\_rttvar}   : \tsaux{duration} ;             \tsholcomm{ variance in round-trip time }{}\\{}
 \tsfield{t\_rttmin}   : \tsaux{duration} ;             \tsholcomm{ minimum rtt allowed }{}\\{}
 \tsfield{t\_lastrtt}  : \tsaux{duration} ;             \tsholcomm{ most recent instantaneous RTT obtained }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ Note this should really
                                              be an option type which is
                                              set to $*$ if no value
                                              has been obtained. The same
                                              applies to $\tsfield{t\_lastshift}$
                                              below. }{}\\{}
 \tslongcomm{ in BSD, this is the local variable rtt in tcp\textunderscore{}xmit\textunderscore{}timer(); we put it here
             because we don't want to store rxtcur in the tcpcb }{}\\{}
 \tsfield{t\_lastshift} : \tstype{num} ;                 \tsholcomm{ the last retransmission shift used }{}\\{}
 \tsfield{t\_wassyn}    : \tstype{bool}                  \tsholcomm{ whether that shift was $\tscon{RexmtSyn}$ or not }{}\\{}
 \tslongcomm{ these two also are to avoid storing rxtcur in the tcpcb;
             they are somewhat annoying because they are *only*
             required for the tcp\textunderscore{}output test that returns to slow
             start if the connection has been idle for \textgreater{}=1RTO }{}\\{}
 \Mmagicbolrrec }
}
{\rulesubsection{Description}

This collects data used for round-trip time estimation.

$\tsfield{tf\_srtt\_valid}$ is not in BSD; instead, BSD uses $\tsfield{t\_srtt}=0$ to
indicate $\tsfield{t\_srtt}$ invalid, and does horrible hacks in retransmission
calculations to allow the continued use of the old $\tsfield{t\_srtt}$ even
after marking it invalid.  We do it better!

Unlike BSD, we don't store the current retransmission interval
explicitly; instead we recalculate it if it is needed.


\rrulepad }
}

\newcommand{\defntcpcb}{\ddefnn{tcpcb}{\iA{tcpcb}}{\subddefnA[{ the TCP control block }]{tcpcb}{\tstype{tcpcb} = \Mmagiclrec {}\\{}
 {}\\{}
 \tsholcomm{ timers }{}\\{}
 \tsfield{tt\_rexmt}      : (\tstype{rexmtmode} \# \tstype{num}) \tstype{timed} \;\;\tstype{option}; \tsholcomm{ retransmit timer, with mode and shift; $*$ is idle }{}\\{}
 \tsholcomm{ see \wasverb{tcp\textunderscore{}output.c:356ff} for more info. }{}\\{}
 \tsholcomm{ as in BSD, the shift starts at zero, and is incremented each
        time the timer fires.  So it is zero during the first interval,
        1 after the first retransmit, etc. }{}\\{}
 \tsfield{tt\_keep}       : () \;\tstype{timed} \;\;\tstype{option};         \tsholcomm{ keepalive timer }{}\\{}
 \tsfield{tt\_2msl}       : () \;\tstype{timed} \;\;\tstype{option};         \tsholcomm{ $2*\mathit{MSL}$ $\tscon{TIME\_WAIT}$ timer }{}\\{}
 \tsfield{tt\_delack}     : () \;\tstype{timed} \;\;\tstype{option};         \tsholcomm{ delayed $\tsvar{ACK}$ timer }{}\\{}
 \tsfield{tt\_conn\_est}   : () \;\tstype{timed} \;\;\tstype{option};         \tsholcomm{ connection-establishment timer, overlays keep in BSD }{}\\{}
 \tsfield{tt\_fin\_wait\_2} : () \;\tstype{timed} \;\;\tstype{option};         \tsholcomm{ $\tscon{FIN\_WAIT\_2}$ timer, overlays 2msl in BSD }{}\\{}
 \tsfield{t\_idletime} : \tstype{stopwatch} ;                  \tsholcomm{ time since last segment received }{}\\{}
 {}\\{}
 \tsholcomm{ flags, some corresponding to BSD \wasverb{TF\textunderscore{}} flags }{}\\{}
 \tsfield{tf\_needfin}   : \tstype{bool};         \tsholcomm{ send $\tsvar{FIN}$ (implicit state, used for app close while in $\tscon{SYN\_RECEIVED}$) }{}\\{}
 \tsfield{tf\_shouldacknow} : \tstype{bool};      \tsholcomm{ output a segment urgently -- similar to \wasverb{TF\textunderscore{}ACKNOW}, but used less often}{}\\{}
 \tsfield{bsd\_cantconnect} : \tstype{bool};      \tsholcomm{ connection establishment attempt has failed having sent a $\tsvar{SYN}$ -- on BSD this causes further connect() calls to fail }{}\\{}
 {}\\{}
 \tsholcomm{ send variables }{}\\{}
 \tsfield{snd\_una}      : \tsaux{tcp\_seq\_local} ; \tsholcomm{ lowest unacknowledged sequence number }{}\\{}
 \tsfield{snd\_max}      : \tsaux{tcp\_seq\_local} ; \tsholcomm{ highest sequence number sent; used to recognise retransmits }{}\\{}
 \tsfield{snd\_nxt}      : \tsaux{tcp\_seq\_local} ; \tsholcomm{ next sequence number to send }{}\\{}
 \tsfield{snd\_wl1}      : \tsaux{tcp\_seq\_foreign} ; \tsholcomm{ seq number of most recent window update segment }{}\\{}
 \tsfield{snd\_wl2}      : \tsaux{tcp\_seq\_local} ;   \tsholcomm{ ack number of most recent window update segment }{}\\{}
 \tsvar{iss}          : \tsaux{tcp\_seq\_local} ;   \tsholcomm{ initial send sequence number }{}\\{}
 \tsfield{snd\_wnd}      : \tstype{num}  ;        \tsholcomm{ send window size: always between 0 and 65535*2**14 }{}\\{}
 \tsfield{snd\_cwnd}     : \tstype{num}  ;        \tsholcomm{ congestion window }{}\\{}
 \tsfield{snd\_ssthresh} : \tstype{num}  ;        \tsholcomm{ threshold between exponential and linear $\tsfield{snd\_cwnd}$ expansion (for slow start)}{}\\{}
 {}\\{}
 \tsholcomm{ receive variables }{}\\{}
 \tsfield{rcv\_wnd}      : \tstype{num}  ;            \tsholcomm{ receive window size }{}\\{}
 \tsfield{tf\_rxwin0sent} : \tstype{bool} ;           \tsholcomm{ have advertised a zero window to receiver }{}\\{}
 \tsfield{rcv\_nxt}      : \tsaux{tcp\_seq\_foreign} ; \tsholcomm{ lowest sequence number not yet received }{}\\{}
 \tsfield{rcv\_up}       : \tsaux{tcp\_seq\_foreign} ; \tsholcomm{ received urgent pointer if any, else $=\tsfield{rcv\_nxt}$ }{}\\{}
 \tsvar{irs}          : \tsaux{tcp\_seq\_foreign} ; \tsholcomm{ initial receive sequence number }{}\\{}
 \tsfield{rcv\_adv}      : \tsaux{tcp\_seq\_foreign} ; \tsholcomm{ most recently advertised window }{}\\{}
 \tsfield{last\_ack\_sent}     : \tsaux{tcp\_seq\_foreign} ;  \tsholcomm{ last acknowledged sequence number }{}\\{}
 {}\\{}
 \tsholcomm{ connection parameters }{}\\{}
 \tsfield{t\_maxseg}   : \tstype{num} ;           \tsholcomm{ maximum segment size on this connection }{}\\{}
 \tsfield{t\_advmss}   : \tstype{num} \;\;\tstype{option} ;    \tsholcomm{ the mss advertisment sent in our initial SYN }{}\\{}
 \tsfield{tf\_doing\_ws}       : \tstype{bool} ;     \tsholcomm{ doing window scaling on this connection?  (result of negotiation) }{}\\{}
 \tsfield{request\_r\_scale}   : \tstype{num} \;\;\tstype{option}  ;  \tsholcomm{ pending window scaling, if any (used during negotiation) }{}\\{}
 \tsfield{snd\_scale}         : \tstype{num}  ;     \tsholcomm{ window scaling for send window (0..14), applied to received advertisements (RFC1323) }{}\\{}
 \tsfield{rcv\_scale}         : \tstype{num}  ;     \tsholcomm{ window scaling for receive window (0..14), applied when we send advertisements (RFC1323) }{}\\{}
 {}\\{}
 \tsholcomm{ timestamping }{}\\{}
 \tsfield{tf\_doing\_tstmp} : \tstype{bool};       \tsholcomm{ are we doing timestamps on this connection? (result of negotiation) }{}\\{}
 \tsfield{tf\_req\_tstmp} : \tstype{bool};         \tsholcomm{ have/will request(ed) timestamps (used during negotiation) }{}\\{}
 \tsfield{ts\_recent}         : \tsaux{ts\_seq} \;\tstype{timewindow} ;  \tsholcomm{ most recent timestamp received; TimeWindowClosed if invalid.  Timer models the RFC1323 end-\S4.2.3 24-day validity period. }{}\\{}
 {}\\{}
 \tsholcomm{ round-trip time estimation }{}\\{}
 \tsfield{t\_rttseg}   : (\tsaux{ts\_seq} \# \tsaux{tcp\_seq\_local}) \;\tstype{option} ;  \tsholcomm{ start time and sequence number of segment being timed }{}\\{}
 \tsfield{t\_rttinf}   : \tstype{rttinf} ;               \tsholcomm{ round-trip time estimator values }{}\\{}
 {}\\{}
 \tsholcomm{ retransmission }{}\\{}
 \tsfield{t\_dupacks}    : \tstype{num} ;                \tsholcomm{ number of consecutive duplicate acks received (typically 0..3ish; should this wrap at 64K/4G ack burst?) }{}\\{}
 \tsfield{t\_badrxtwin}       : () \;\tstype{timewindow};   \tsholcomm{ deadline for bad-retransmit recovery }{}\\{}
 \tsfield{snd\_cwnd\_prev}     : \tstype{num} ;            \tsholcomm{ $\tsfield{snd\_cwnd}$ prior to retransmit (used in bad-retransmit recovery) }{}\\{}
 \tsfield{snd\_ssthresh\_prev} : \tstype{num} ;            \tsholcomm{ $\tsfield{snd\_ssthresh}$ prior to retransmit (used in bad-retransmit recovery) }{}\\{}
 \tsfield{snd\_recover} : \tsaux{tcp\_seq\_local} ;        \tsholcomm{ highest sequence number sent at time of receipt of partial ack (used in RFC2581/RFC2582 fast recovery) }{}\\{}
 {}\\{}
 \tsholcomm{ other }{}\\{}
 \tsfield{t\_segq} :  \tstype{tcpReassSegment} \;\tstype{list};  \tsholcomm{ segment reassembly queue }{}\\{}
 \tsfield{t\_softerror} : \tstype{error} \;\;\tstype{option}      \tsholcomm{ current transient error; reported only if failure becomes permanent }{}\\{}
 \tsholcomm{ could cut this down to the actually-possible errors? }{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\seccommhosttyTsockets}{\clustersection{(TCP and UDP)}{Sockets}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{iobc}$
&
&  out-of-band data and status \\
$\tsrule{tcp\_socket}$
&
&  details of a TCP socket \\
$\tsrule{protocol\_info}$
&
&  protocol-specific socket data \\
$\tsrule{socket}$
&
&  details of a socket \\
$\tsrule{TCP\_Sock0}$
&
&  helper constructor \\
$\tsrule{TCP\_Sock}$
&
&  helper constructor \\
$\tsrule{UDP\_Sock0}$
&
&  helper constructor \\
$\tsrule{UDP\_Sock}$
&
&  helper constructor \\
$\tsrule{Sock}$
&
&  helper constructor \\
$\tsrule{tcp\_sock\_of}$
&
&  helper accessor (beware ARBitrary behaviour on non-TCP socket) \\
$\tsrule{udp\_sock\_of}$
&
&  helper accessor (beware ARBitrary behaviour on non-UDP socket) \\
$\tsrule{proto\_of}$
&
&  helper accessor \\
$\tsrule{proto\_eq}$
&
&  compare protocol of two protocol info structures \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defniobc}{\ddefnn{iobc}{\iA{iobc}}{\subddefnA[{ out-of-band data and status }]{iobc}{\tsvar{iobc} = \tscon{NO\_OOBDATA}{}\\{}
\quad \mid  \tscon{OOBDATA} \;\Mof  \;\tstype{byte}{}\\{}
\quad \mid  \tscon{HAD\_OOBDATA}}
}
{}
}

\newcommand{\defntcpTsocket}{\ddefnn{tcpTsocket}{\iA{tcp\_socket}}{\subddefnA[{ details of a TCP socket }]{tcp\_socket}{\tstype{tcp\_socket}{}\\{}
 = \Mmagiclrec  \tsvar{st}   : \tstype{tcpstate};  \tsholcomm{ here rather than in $\tstype{tcpcb}$ for convenience as heavily used.  Called \wasverb{t\textunderscore{}state} in BSD }{}\\{}
 \tsvar{cb}   : \tstype{tcpcb};{}\\{}
 \tsvar{lis}  : \tstype{socket\_listen} \;\;\tstype{option}; \tsholcomm{ invariant: $*$ iff not $\tscon{LISTEN}$ }{}\\{}
 \tsvar{sndq} : \tstype{byte} \;\tstype{list};{}\\{}
 \tsvar{sndurp} : \tstype{num} \;\;\tstype{option};{}\\{}
 \tsvar{rcvq} : \tstype{byte} \;\tstype{list};{}\\{}
 \tsvar{rcvurp} : \tstype{num} \;\;\tstype{option};  \tscomm{ was "oobmark" }{}\\{}
 \tsvar{iobc} : \tsvar{iobc}{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defnprotocolTinfo}{\ddefnn{protocolTinfo}{\iA{protocol\_info}}{\subddefnA[{ protocol-specific socket data }]{protocol\_info}{\tstype{protocol\_info} = \tscon{TCP\_PROTO} \;\Mof  \;\tstype{tcp\_socket}{}\\{}
\quad\quad\quad\quad\quad\quad \mid  \tscon{UDP\_PROTO} \;\Mof  \;\tstype{udp\_socket}}
}
{}
}

\newcommand{\defnsocket}{\ddefnn{socket}{\iA{socket}}{\subddefnA[{ details of a socket }]{socket}{\tslib{socket}{}\\{}
 = \Mmagiclrec  \tstype{fid}  : \tstype{fid} \;\;\tstype{option};    \tsholcomm{ associated open file description if any }{}\\{}
 \tsvar{sf}   : \tstype{sockflags};     \tsholcomm{ socket flags }{}\\{}
 \tsvar{is}_{1}  : \tstype{ip} \;\;\tstype{option};     \tsholcomm{ local IP address if any }{}\\{}
 \tsvar{ps}_{1}  : \tstype{port} \;\;\tstype{option};   \tsholcomm{ local port if any }{}\\{}
 \tsvar{is}_{2}  : \tstype{ip} \;\;\tstype{option};     \tsholcomm{ remote IP address if any }{}\\{}
 \tsvar{ps}_{2}  : \tstype{port} \;\;\tstype{option};   \tsholcomm{ remote port if any }{}\\{}
 \tsvar{es}   : \tstype{error} \;\;\tstype{option};  \tsholcomm{ pending error if any }{}\\{}
 \tsvar{cantsndmore} : \tstype{bool};   \tsholcomm{ output stream ends at end of send queue }{}\\{}
 \tsvar{cantrcvmore} : \tstype{bool};   \tsholcomm{ input stream ends at end of receive queue }{}\\{}
 \tsvar{pr}   : \tstype{protocol\_info}  \tsholcomm{ protocol-specific information }{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defnTCPTSockZ}{\ddefnc{TCPTSockZ}{\iA{TCP\_Sock0}}{\subddefnA[{ helper constructor }]{TCP\_Sock0}{\tsaux{TCP\_Sock0}(\tsvar{st}, \tsvar{cb}, \tsvar{lis}, \tsvar{sndq}, \tsvar{sndurp}, \tsvar{rcvq}, \tsvar{rcvurp}, \tsvar{iobc}){}\\{}
 = \Mmagiclrec  \tsvar{st}\Mass \tsvar{st}; \tsvar{cb}\Mass \tsvar{cb}; \tsvar{lis}\Mass \tsvar{lis}; \tsvar{sndq}\Mass \tsvar{sndq};{}\\{}
 \tsvar{sndurp}\Mass \tsvar{sndurp}; \tsvar{rcvq}\Mass \tsvar{rcvq}; \tsvar{rcvurp}\Mass \tsvar{rcvurp}; \tsvar{iobc}\Mass \tsvar{iobc} \Mmagicrrec }
}
{}
}

\newcommand{\defnTCPTSock}{\ddefnc{TCPTSock}{\iA{TCP\_Sock}}{\subddefnA[{ helper constructor }]{TCP\_Sock}{\tsaux{TCP\_Sock} \;\tsunknown{v} = \tscon{TCP\_PROTO}(\tsaux{TCP\_Sock0} \;\tsunknown{v})}
}
{}
}

\newcommand{\defnUDPTSockZ}{\ddefnc{UDPTSockZ}{\iA{UDP\_Sock0}}{\subddefnA[{ helper constructor }]{UDP\_Sock0}{(\tsaux{UDP\_Sock0}:\tstype{dgram} \;\tstype{list}\Mtotype \tstype{udp\_socket}) \tsvar{rcvq} = \Mmagiclrec  \tsvar{rcvq}\Mass \tsvar{rcvq} \Mmagicrrec }
}
{}
}

\newcommand{\defnUDPTSock}{\ddefnc{UDPTSock}{\iA{UDP\_Sock}}{\subddefnA[{ helper constructor }]{UDP\_Sock}{\tsaux{UDP\_Sock} \;\tsunknown{v} = \tscon{UDP\_PROTO}(\tsaux{UDP\_Sock0} \;\tsunknown{v})}
}
{}
}

\newcommand{\defnSock}{\ddefnc{Sock}{\iA{Sock}}{\subddefnA[{ helper constructor }]{Sock}{\tscon{Sock}(\tstype{fid}, \tsvar{sf}, \tsvar{is}_{1}, \tsvar{ps}_{1}, \tsvar{is}_{2}, \tsvar{ps}_{2}, \tsvar{es}, \tsunknown{csm}, \tsunknown{crm}, \tsvar{pr}){}\\{}
 = \Mmagiclrec  \tstype{fid}\Mass \tstype{fid}; \tsvar{sf}\Mass \tsvar{sf}; \tsvar{is}_{1}\Mass \tsvar{is}_{1}; \tsvar{ps}_{1}\Mass \tsvar{ps}_{1}; \tsvar{is}_{2}\Mass \tsvar{is}_{2}; \tsvar{ps}_{2}\Mass \tsvar{ps}_{2};{}\\{}
 \tsvar{es}\Mass \tsvar{es}; \tsvar{cantsndmore} \Mass  \tsunknown{csm}; \tsvar{cantrcvmore} \Mass  \tsunknown{crm}; \tsvar{pr}\Mass \tsvar{pr} \Mmagicrrec }
}
{}
}

\newcommand{\defntcpTsockTof}{\ddefnc{tcpTsockTof}{\iA{tcp\_sock\_of}}{\subddefnA[{ helper accessor (beware ARBitrary behaviour on non-TCP socket) }]{tcp\_sock\_of}{\tsaux{tcp\_sock\_of} \;\tsunknown{sock} = \Mcase  \;\tsunknown{sock}.\tsvar{pr} \;\Mof  \;\tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mtotype  \tsunknown{tcp\_sock} \Mdpipe  \tsunknown{\_} \Mtotype  \tsunknown{ARB}}
}
{}
}

\newcommand{\defnudpTsockTof}{\ddefnc{udpTsockTof}{\iA{udp\_sock\_of}}{\subddefnA[{ helper accessor (beware ARBitrary behaviour on non-UDP socket) }]{udp\_sock\_of}{\tsaux{udp\_sock\_of} \;\tsunknown{sock} = \Mcase  \;\tsunknown{sock}.\tsvar{pr} \;\Mof  \;\tscon{UDP\_PROTO}(\tsunknown{udp\_sock}) \Mtotype  \tsunknown{udp\_sock} \Mdpipe  \tsunknown{\_} \Mtotype  \tsunknown{ARB}}
}
{}
}

\newcommand{\defnprotoTof}{\ddefnc{protoTof}{\iA{proto\_of}}{\subddefnA[{ helper accessor }]{proto\_of}{\tsaux{proto\_of} (\tscon{TCP\_PROTO}(\tsunknown{\_1})) = \tscon{PROTO\_TCP} \Mwedge {}\\{}
 \tsaux{proto\_of} (\tscon{UDP\_PROTO}(\tsunknown{\_3})) = \tscon{PROTO\_UDP}}
}
{}
}

\newcommand{\defnprotoTeq}{\ddefnc{protoTeq}{\iA{proto\_eq}}{\subddefnA[{ compare protocol of two protocol info structures }]{proto\_eq}{\tsaux{proto\_eq} \;\tsvar{pr} \;\tsvar{pr}' = (\tsaux{proto\_of} \;\tsvar{pr} = \tsaux{proto\_of} \;\tsvar{pr}')}
}
{\rulesubsection{Description}
Various convenience functions.


\rrulepad }
}

\newcommand{\seccommhosttyThost}{\clustersection{(TCP and UDP)}{The host}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{host}$
&
&  host details \\
$\tsrule{privileged\_ports}$
&
& \\
$\tsrule{ephemeral\_ports}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnhost}{\ddefnc{host}{\iA{host}}{\subddefnA[{ host details }]{host}{\tstype{host} = \Mmagiclrec {}\\{}
 \tstype{arch}  : \tstype{arch};  \tscomm{ architecture }{}\\{}
 \tsvar{privs} : \tstype{bool};  \tscomm{ whether process has root/CAP\textunderscore{}NET\textunderscore{}ADMIN privilege }{}\\{}
 \tsvar{ifds}  : \tsvar{ifid} \mapsto  \tstype{ifd}; \tscomm{ interfaces }{}\\{}
 \tsvar{rttab} : \tsunknown{routing\_table};  \tscomm{ routing table }{}\\{}
 \tsvar{ts}    : \tstype{tid} \mapsto  \tstype{hostThreadState} \;\tstype{timed}; \tscomm{ host view of each thread state }{}\\{}
 \tsvar{files} : \tstype{fid} \mapsto  \tstype{file}; \tscomm{ files }{}\\{}
 \tsvar{socks} : \tstype{sid} \mapsto  \tslib{socket}; \tscomm{ sockets }{}\\{}
 \tslib{listen} : \tstype{sid} \;\tstype{list}; \tscomm{ list of listening sockets }{}\\{}
 \tsvar{bound} : \tstype{sid} \;\tstype{list}; \tscomm{ list of sockets bound: head of list was first to be bound }{}\\{}
 \tsvar{iq}    : \tstype{msg} \;\tstype{list} \;\tstype{timed}; \tscomm{ input queue }{}\\{}
 \tsvar{oq}    : \tstype{msg} \;\tstype{list} \;\tstype{timed}; \tscomm{ output queue }{}\\{}
 \tsvar{bndlm} : \tsunknown{bandlim\_state}; \tscomm{ bandlimiting }{}\\{}
 \tsvar{ticks} : \tstype{ticker};  \tscomm{ ticker }{}\\{}
 \tsvar{fds}   : \tstype{fd} \mapsto  \tstype{fid}; \tscomm{ file descriptors (per-process) }{}\\{}
 \tsvar{params}: \tstype{hostParams} \tscomm{ configuration info}{}\\{}
 \Mmagicbolrrec }
}
{\rulesubsection{Description}
The input and output queue timers model the interrupt scheduling delay; the first element (if any) must be processed by the timer expiry.
\rrulepad }
}

\newcommand{\defnprivilegedTports}{\ddefnc{privilegedTports}{\iA{privileged\_ports}}{\subddefnA{privileged\_ports}{\tsaux{privileged\_ports} \;\tsunknown{h} = \{ \tscon{Port} \;\tsvar{n} \mid  \tsvar{n} < 1024 \}}
}
{}
}

\newcommand{\defnephemeralTports}{\ddefnc{ephemeralTports}{\iA{ephemeral\_ports}}{\subddefnA{ephemeral\_ports}{\tsaux{ephemeral\_ports} \;\tsunknown{h} = \{ \tscon{Port} \;\tsvar{n} \mid  \tsvar{n} \geq  \tsunknown{h}.\tsvar{params}.\tsfield{min\_eph\_port} \Mwedge  \tsvar{n} \leq  \tsunknown{h}.\tsvar{params}.\tsfield{max\_eph\_port} \}}
}
{\rulesubsection{Description}
Ports below 1024 (on all systems that we know of) are reserved, and can be bound
by privileged users only.  Additionally there is a range of ports (1024 through
2048, 3072 or 4999 or 32768 through 61000 inclusive, depending on configuration,
are used for autobinding, when no specific port is specified; these ports are
called "ephemeral".

\rrulepad }
}

\newcommand{\seccommhosttyTtrace}{\clustersection{(TCP and UDP)}{Trace records}
\seccomm{
   For BSD testing we make use of the BSD \wasverb{TCP\textunderscore{}DEBUG} option, which
   enables TCP debug trace records at various points in the code.  This
   permits earlier resolution of nondeterminism in the trace checking
   process.

   Debug records contain IP and TCP headers, a timestamp, and a copy
   of the implementation TCP control block.
%
   Three issues complicate their use: firstly, not all the relevant
   state appears in the trace record; secondly, the model deviates in
   its internal structures from the BSD implementation in several
   ways; and thirdly, BSD generates trace records in the middle of
   processing messages, whereas the model performs atomic transitions
   (albeit split for blocking invocations).
 %
   These mean that in different circumstances we can use only some of
   the debug record fields.
%
   To save defining a whole new datatype, we reuse $\tstype{tcpcb}$.  However, we
   define a special equality that only inspects certain fields, and
   leaves the others unconstrained.

   Frustratingly, the \wasverb{is1} \wasverb{ps1} \wasverb{is2} \wasverb{ps2} are not always
   available, since although the TCP control block is structure-copied
   into the trace record, the embedded Internet control block is not!
   However, in cases where these are not available, the \wasverb{iss} should
   be sufficiently unique to identify the socket of interest.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{type\_abbrev\_tracerecord}$
&
& \\
$\tsrule{tracecb\_eq}$
&
&  compare two control blocks for "equality" modulo known issues \\
$\tsrule{tracesock\_eq}$
&
&  compare two sockets for "equality" modulo known issues \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntypeTabbrevTtracerecord}{\ddefnn{typeTabbrevTtracerecord}{\iA{type\_abbrev\_tracerecord}}{\subddefnA{type\_abbrev\_tracerecord}{\tsholop{type\_abbrev} \;\tsunknown{tracerecord} : \tstype{traceflavour}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \# \tstype{sid}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \# (\tstype{ip} \;\;\tstype{option} \tscomm{ is1 }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \# \tstype{port} \;\;\tstype{option} \tscomm{ ps1 }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \# \tstype{ip} \;\;\tstype{option} \tscomm{ is2 }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \# \tstype{port} \;\;\tstype{option} \tscomm{ ps2 }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad ) \;\tstype{option} \tscomm{ not always available! }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \# \tstype{tcpstate} \tscomm{ st }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \# \tstype{tcpcb} \tscomm{ cb subset }}
}
{}
}

\newcommand{\defntracecbTeq}{\ddefnn{tracecbTeq}{\iA{tracecb\_eq}}{\subddefnA[{ compare two control blocks for "equality" modulo known issues }]{tracecb\_eq}{\tsaux{tracecb\_eq} (\tsunknown{flav}:\tstype{traceflavour}) (\tsvar{st}:\tstype{tcpstate}) (\tsvar{es}:\tstype{error} \;\;\tstype{option}) (\tsvar{cb}:\tstype{tcpcb}) (\tsvar{cb}':\tstype{tcpcb}){}\\{}
 = ((                                \tsvar{cb}.\tsfield{snd\_una}       = \tsvar{cb}'.\tsfield{snd\_una}      ) \Mwedge {}\\{}
\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_OUTPUT} \;\Mthen  \;\Mtrue  \;\Melse  \;\tsvar{cb}.\tsfield{snd\_max}       = \tsvar{cb}'.\tsfield{snd\_max}      ) \Mwedge {}\\{}
\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_OUTPUT} \Mvee  (\tsvar{st} = \tscon{SYN\_SENT} \Mwedge  \tsvar{es} \neq  *){}\\{}
\quad \Mthen  \;\Mtrue {}\\{}
\quad \Melse  \;\tsvar{cb}.\tsfield{snd\_nxt}       = \tsvar{cb}'.\tsfield{snd\_nxt}      ) \Mwedge   \tscomm{ only bad on error }{}\\{}
\quad (                                \tsvar{cb}.\tsfield{snd\_wl1}       = \tsvar{cb}'.\tsfield{snd\_wl1}      ) \Mwedge {}\\{}
\quad (                                \tsvar{cb}.\tsfield{snd\_wl2}       = \tsvar{cb}'.\tsfield{snd\_wl2}      ) \Mwedge {}\\{}
\quad (                                \tsvar{cb}.\tsvar{iss}           = \tsvar{cb}'.\tsvar{iss}          ) \Mwedge {}\\{}
\quad (                                \tsvar{cb}.\tsfield{snd\_wnd}       = \tsvar{cb}'.\tsfield{snd\_wnd}      ) \Mwedge {}\\{}
\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_OUTPUT} \;\Mthen  \;\Mtrue  \;\Melse  \;\tsvar{cb}.\tsfield{snd\_cwnd}      = \tsvar{cb}'.\tsfield{snd\_cwnd}     ) \Mwedge   \tscomm{ only bad on error }{}\\{}
\quad (                                \tsvar{cb}.\tsfield{snd\_ssthresh}  = \tsvar{cb}'.\tsfield{snd\_ssthresh} ) \Mwedge {}\\{}
 {}\\{}
\quad \tsholcomm{ Don't check equality of $\tsfield{rcv\_wnd}$: we recalculate $\tsfield{rcv\_wnd}$ lazily in $\tsunknown{tcp\_output}$ instead of after every successful $\tslib{recv}()$ call, so our value is often out of date. }{}\\{}
 {}\\{}
\quad \tsholcomm{ $(\Mif  \;\tsvar{st} = \tscon{SYN\_SENT}    \;\Mthen  \;\Mtrue  \;\Melse  \;\tsvar{cb}.\tsfield{rcv\_wnd}       = \tsvar{cb}'.\tsfield{rcv\_wnd}      ) \Mwedge  $ }{}\\{}
 {}\\{}
\quad \tslongcomm{ Removing this clause is an allowance for the fact that BSD chooses its
          window size rather late.  }{}\\{}
 {}\\{}
\quad \tslongcomm{ Note: we should check how it ensures that
          a window size it emits on a SYN retransmit is the same as on the initial transmit,
          and how it ensures it does not accidentally shrink the window on the next output
          segment (ACK of other end's SYN,ACK). }{}\\{}
 {}\\{}
\quad (                                \tsvar{cb}.\tsfield{rcv\_nxt}       = \tsvar{cb}'.\tsfield{rcv\_nxt}      ) \Mwedge {}\\{}
\quad (                                \tsvar{cb}.\tsfield{rcv\_up}        = \tsvar{cb}'.\tsfield{rcv\_up}       ) \Mwedge {}\\{}
\quad (                                \tsvar{cb}.\tsvar{irs}           = \tsvar{cb}'.\tsvar{irs}          ) \Mwedge {}\\{}
\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_OUTPUT} \Mvee  \tsunknown{flav} = \tscon{TA\_INPUT} \;\Mthen  \;\Mtrue  \;\Melse  \;\tsvar{cb}.\tsfield{rcv\_adv}       = \tsvar{cb}'.\tsfield{rcv\_adv}      ) \Mwedge {}\\{}
\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_OUTPUT} \Mvee  \tsvar{st} = \tscon{SYN\_SENT} \Mvee  \tsvar{st} = \tscon{TIME\_WAIT}{}\\{}
\quad\quad\quad \tsholcomm{ we store our initially-sent MSS in $\tsfield{t\_maxseg}$,
              whereas BSD just recalculates it.  This test decouples
              the model from BSD in order to cope with this. }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mthen  \;\Mtrue  \;\Melse  \;\tsvar{cb}.\tsfield{t\_maxseg}      = \tsvar{cb}'.\tsfield{t\_maxseg}     ) \Mwedge   \tscomm{ only bad on error }{}\\{}
\quad (                                \tsvar{cb}.\tsfield{t\_dupacks}     = \tsvar{cb}'.\tsfield{t\_dupacks}    ) \Mwedge {}\\{}
\quad (                                \tsvar{cb}.\tsfield{snd\_scale}     = \tsvar{cb}'.\tsfield{snd\_scale}    ) \Mwedge {}\\{}
\quad (                                \tsvar{cb}.\tsfield{rcv\_scale}     = \tsvar{cb}'.\tsfield{rcv\_scale}    ) \Mwedge {}\\{}
\quad \tscomm{ t\textunderscore{}rtseq, if t\textunderscore{}rtttime \textless{}\textgreater{} 0; ignore t\textunderscore{}rtttime }  \tscomm{ only bad on error }{}\\{}
\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_OUTPUT} \Mvee  \tsunknown{flav} = \tscon{TA\_INPUT} \;\Mthen  \;\Mtrue  \;\Melse {}\\{}
\quad\quad\quad \tsholop{option\_map}\Mspii{\tsholop{SND}}{\tsvar{cb}.\tsfield{t\_rttseg}} = \tsholop{option\_map}\Mspii{\tsholop{SND}}{\tsvar{cb}'.\tsfield{t\_rttseg}} ) \Mwedge {}\\{}
\quad (                                \tsaux{timewindow\_val\_of} \;\tsvar{cb}.\tsfield{ts\_recent} = \tsaux{timewindow\_val\_of} \;\tsvar{cb}'.\tsfield{ts\_recent}) \Mwedge {}\\{}
\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_OUTPUT} \Mvee  \tsunknown{flav} = \tscon{TA\_INPUT} \;\Mthen  \;\Mtrue  \;\Melse  \;\tsvar{cb}.\tsfield{last\_ack\_sent} = \tsvar{cb}'.\tsfield{last\_ack\_sent})){}\\{}
\quad \tsholcomm{ also ignore, always: $\tsfield{tt\_delack}$; in case of error: $\tsfield{tt\_rexmt}$, $\tsfield{t\_softerror}$ }}
}
{}
}

\newcommand{\defntracesockTeq}{\ddefnn{tracesockTeq}{\iA{tracesock\_eq}}{\subddefnA[{ compare two sockets for "equality" modulo known issues }]{tracesock\_eq}{\tsaux{tracesock\_eq} (\tsunknown{flav},\tstype{sid},\tsunknown{quad},\tsvar{st},\tsvar{cb}) \tsunknown{sid'} \;\tsunknown{sock}{}\\{}
 = (\tsaux{proto\_of} \;\tsunknown{sock}.\tsvar{pr} = \tscon{PROTO\_TCP} \Mwedge {}\\{}
\quad \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsunknown{sock} \;\Min {}\\{}
\quad \tstype{sid} = \tsunknown{sid'} \Mwedge {}\\{}
\quad \tsholcomm{ If trace is $\tscon{TA\_DROP}$ then the $\tsvar{is}_{2},\tsvar{ps}_{2}$ values in the trace may
          not match those in the socket record --- the segment is
          dropped because it is somehow invalid (and thus not safe to
          compare) }{}\\{}
\quad (\Mcase  \;\tsunknown{quad} \;\Mof {}\\{}
\quad\quad \Msome  (\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}) \Mtotype  \tsvar{is}_{1} = \tsunknown{sock}.\tsvar{is}_{1} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{ps}_{1} = \tsunknown{sock}.\tsvar{ps}_{1} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_DROP} \;\Mthen  \;\Mtrue  \;\Melse  \;\tsvar{is}_{2} = \tsunknown{sock}.\tsvar{is}_{2}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mif  \;\tsunknown{flav} = \tscon{TA\_DROP} \;\Mthen  \;\Mtrue  \;\Melse  \;\tsvar{ps}_{2} = \tsunknown{sock}.\tsvar{ps}_{2}) \Mdpipe {}\\{}
\quad\quad *                   \Mtotype  \Mtrue ) \Mwedge {}\\{}
\quad \tsvar{st}  = \tsunknown{tcp\_sock}.\tsvar{st} \Mwedge {}\\{}
\quad \tsaux{tracecb\_eq} \;\tsunknown{flav} \;\tsvar{st} \;\tsunknown{sock}.\tsvar{es} \;\tsvar{cb} \;\tsunknown{tcp\_sock}.\tsvar{cb})}
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPIThostTypes}
\showrule{\seccommhosttyTtcpcp}
\showrule{\defntcpReassSegment}
\showrule{\defnrexmtmode}
\showrule{\defnrttinf}
\showrule{\defntcpcb}
\showrule{\seccommhosttyTsockets}
\showrule{\defniobc}
\showrule{\defntcpTsocket}
\showrule{\defnprotocolTinfo}
\showrule{\defnsocket}
\showrule{\defnTCPTSockZ}
\showrule{\defnTCPTSock}
\showrule{\defnUDPTSockZ}
\showrule{\defnUDPTSock}
\showrule{\defnSock}
\showrule{\defntcpTsockTof}
\showrule{\defnudpTsockTof}
\showrule{\defnprotoTof}
\showrule{\defnprotoTeq}
\showrule{\seccommhosttyThost}
\showrule{\defnhost}
\showrule{\defnprivilegedTports}
\showrule{\defnephemeralTports}
\showrule{\seccommhosttyTtrace}
\showrule{\defntypeTabbrevTtracerecord}
\showrule{\defntracecbTeq}
\showrule{\defntracesockTeq}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore params

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPITparams}{\chaptersection{ Host behavioural parameters}
\label{TCP1_params}%
\chapcomm{
This file defines a large number of constants affecting the behaviour
of the host.  Many of these of are adjustable by sysctls/registry keys on
the target architectures.


}
}

\newcommand{\seccommFIXME}{\clustersection{(TCP and UDP)}{FIXME}
\seccomm{
Stuff imported from hostTypes.


}\clustersubsection{Rules}
~}

\newcommand{\seccommhosttyTfiles}{\clustersection{(TCP and UDP)}{Files}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{fid}$
&
&  file ID \\
$\tsrule{sid}$
&
&  socket ID \\
$\tsrule{filetype}$
&
&  type of file, with pointer to details structure \\
$\tsrule{fileflags}$
&
&  flags set on a file \\
$\tsrule{file}$
&
&  open file description  \\
$\tsrule{File}$
&
&  helper constructor \\
$\tsrule{sockflags}$
&
&  flags set on a socket \\
$\tsrule{arch}$
&
&  the architectures we consider \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnfid}{\ddefnc{fid}{\iA{fid}}{\subddefnA[{ file ID }]{fid}{\tstype{fid} = \tscon{FID} \;\Mof  \;\tstype{num}}
}
{}
}

\newcommand{\defnsid}{\ddefnc{sid}{\iA{sid}}{\subddefnA[{ socket ID }]{sid}{\tstype{sid} = \tscon{SID} \;\Mof  \;\tstype{num}}
}
{\rulesubsection{Description}
File IDs $\tstype{fid}$ and socket IDs $\tstype{sid}$ are really unique, unlike file
descriptors $\tstype{fd}$.


\rrulepad }
}

\newcommand{\defnfiletype}{\ddefnc{filetype}{\iA{filetype}}{\subddefnA[{ type of file, with pointer to details structure }]{filetype}{\tstype{filetype} = \tscon{FT\_Console}            \mid  \tscon{FT\_Socket} \;\Mof  \;\tstype{sid}}
}
{}
}

\newcommand{\defnfileflags}{\ddefnc{fileflags}{\iA{fileflags}}{\subddefnA[{ flags set on a file }]{fileflags}{\tstype{fileflags} = \Mmagiclrec  \tsvar{b} : \tstype{filebflag} \Mtotype  \tstype{bool}     \Mmagicrrec }
}
{}
}

\newcommand{\defnfile}{\ddefnc{file}{\iA{file}}{\subddefnA[{ open file description  }]{file}{\tstype{file}  = \Mmagiclrec  \tsvar{ft}  : \tstype{filetype};  \tsvar{ff}  : \tstype{fileflags}  \Mmagicrrec }
}
{}
}

\newcommand{\defnFile}{\ddefnc{File}{\iA{File}}{\subddefnA[{ helper constructor }]{File}{\tscon{File}(\tsvar{ft},\tsvar{ff}) = \Mmagiclrec  \tsvar{ft}\Mass \tsvar{ft}; \tsvar{ff}\Mass \tsvar{ff} \Mmagicrrec }
}
{\rulesubsection{Description}
A file is represented by an "open file description" (in POSIX
terminology).  This contains file flags and a file type; the specification only covers $\tscon{FT\_Console}$ and $\tscon{FT\_Socket}$ files.  For most
file types, it also contains a pointer to another structure containing
data specific to that file type -- in our case, a $\tstype{sid}$ pointing to
a $\tslib{socket}$ structure for files of type $\tscon{FT\_Socket}$.
%
The file flags are defined in TCP1\_baseTypes: see \ltslink{filebflag}{$\tstype{filebflag}$}.


\rrulepad }
}

\newcommand{\defnsockflags}{\ddefnn{sockflags}{\iA{sockflags}}{\subddefnA[{ flags set on a socket }]{sockflags}{\tstype{sockflags} = \Mmagiclrec  \tsvar{b} : \tstype{sockbflag} \Mtotype  \tstype{bool};{}\\{}
 \tsvar{n} : \tstype{socknflag} \Mtotype  \tstype{num};{}\\{}
 \tsvar{t} : \tstype{socktflag} \Mtotype  \tstype{time}{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defnarch}{\ddefnc{arch}{\iA{arch}}{\subddefnA[{ the architectures we consider }]{arch}{\tstype{arch} = \tscon{Linux\_2\_4\_20\_8}{}\\{}
\quad \mid  \tscon{WinXP\_Prof\_SP1}{}\\{}
\quad \mid  \tscon{FreeBSD\_4\_6\_RELEASE}}
}
{\rulesubsection{Description}
%
The behaviour of TCP/IP stacks varies between architectures.  Here we
list the architectures we consider.

In fact our FreeBSD build also has the \wasverb{TCP\textunderscore{}DEBUG} option turned on,
and another edit to improve the accuracy of kernel time (for our
automated testing).  We believe that these do not impact the TCP
semantics in any way.


\rrulepad }
}

\newcommand{\seccommparamsTmodel}{\clustersection{(TCP and UDP)}{Model parameters}
\seccomm{
Booleans that select a particular model semantics.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{INFINITE\_RESOURCES}$
&
& \\
$\tsrule{BSD\_RTTVAR\_BUG}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnINFINITETRESOURCES}{\ddefnc{INFINITETRESOURCES}{\iA{INFINITE\_RESOURCES}}{\subddefnA{INFINITE\_RESOURCES}{\tsaux{INFINITE\_RESOURCES} = \Mtrue }
}
{\rulesubsection{Description}

$\tsaux{INFINITE\_RESOURCES}$ forbids various resource
failures, e.g.~lack of kernel memory.  These failures are
nondeterministic in the specification (to be more precise the
specification would have to model far more detail about the real
system) and rare in practice, so for testing and reasoning one often
wants to exclude them altogether.


\rrulepad }
}

\newcommand{\defnBSDTRTTVARTBUG}{\ddefnc{BSDTRTTVARTBUG}{\iA{BSD\_RTTVAR\_BUG}}{\subddefnA{BSD\_RTTVAR\_BUG}{\tsaux{BSD\_RTTVAR\_BUG} = \Mtrue }
}
{\rulesubsection{Description}
 $\tsaux{BSD\_RTTVAR\_BUG}$ enables a peculiarity of BSD behaviour for retransmit timeouts.
%
     After $\tsaux{TCP\_MAXRXTSHIFT} / 4$ retransmit timeouts, $\tsfield{t\_srtt}$ and
     $\tsfield{t\_rttvar}$ are invalidated, but should still be used to compute
     future retransmit timeouts until better information becomes
     available.  BSD makes a mistake in doing this, thus causing
     future retransmit timeouts to be wrong.

     The code at \wasverb{tcp\textunderscore{}timer.c:420} adds the $\tsunknown{srtt}$ value to the $\tsunknown{rttvar}$,
     shifted "appropriately", and sets $\tsunknown{srtt}$ to zero.  $\tsunknown{srtt}==0$ is the
     indication (in BSD) that the $\tsunknown{srtt}$ is invalid.  We instead code this
     with a separate boolean, and are thus able to keep using
     both $\tsunknown{srtt}$ and $\tsunknown{rttvar}$.

     But comparing with \wasverb{tcp\textunderscore{}var.h:281}, where the values are used,
     reveals that the correction is in fact wrong.

     This is not visible in the $\tscon{RexmtSyn}$ case (where it would be most
     obvious),  because in that case the $\tsunknown{srtt}$ never was valid,
     and $\tsunknown{rttvar}$ was cunningly hacked up to give the right value (in
     \wasverb{tcp\textunderscore{}subr.c:542} --- and the \wasverb{tcp\textunderscore{}timer.c:420} code has no effect at
     all.

\rrulepad }
}

\newcommand{\seccommparamsTsched}{\clustersection{(TCP and UDP)}{Scheduling parameters}
\seccomm{
Parameters controlling the timing of the OS scheduler.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{dschedmax}$
&
& \\
$\tsrule{diqmax}$
&
& \\
$\tsrule{doqmax}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defndschedmax}{\ddefnc{dschedmax}{\iA{dschedmax}}{\subddefnA{dschedmax}{\tsaux{dschedmax} = \tstype{time} ( 1000/1000) \tscomm{ make large for now, tighten when better understood }}
}
{}
}

\newcommand{\defndiqmax}{\ddefnc{diqmax}{\iA{diqmax}}{\subddefnA{diqmax}{\tsaux{diqmax} = \tstype{time} ( 1000/1000) \tscomm{ make large for now, tighten when better understood }}
}
{}
}

\newcommand{\defndoqmax}{\ddefnc{doqmax}{\iA{doqmax}}{\subddefnA{doqmax}{\tsaux{doqmax} = \tstype{time} ( 1000/1000) \tscomm{ make large for now, tighten when better understood }}
}
{\rulesubsection{Description}
%
$\tsaux{dschedmax}$ is the maximum scheduling delay between a system call
yielding a return value and that return value being passed to the
process.
%
$\tsaux{diqmax}$ and $\tsaux{doqmax}$ are the maximum scheduling delays between a
message being placed on the queue and being processed (respectively,
emitted).
%
For now, pending investigation of tighter realistic upper bounds, they
are all made conservatively large.


\rrulepad }
}

\newcommand{\seccommparamsTtimer}{\clustersection{(TCP and UDP)}{Timers}
\seccomm{
Parameters controlling the rate and fuzziness of the various timers
used in the model.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{HZ}$
&
& \\
$\tsrule{tickintvlmin}$
&
& \\
$\tsrule{tickintvlmax}$
&
& \\
$\tsrule{stopwatchfuzz}$
&
& \\
$\tsrule{stopwatch\_zero}$
&
& \\
$\tsrule{SLOW\_TIMER\_INTVL}$
&
& \\
$\tsrule{SLOW\_TIMER\_MODEL\_INTVL}$
&
& \\
$\tsrule{FAST\_TIMER\_INTVL}$
&
& \\
$\tsrule{FAST\_TIMER\_MODEL\_INTVL}$
&
& \\
$\tsrule{KERN\_TIMER\_INTVL}$
&
& \\
$\tsrule{KERN\_TIMER\_MODEL\_INTVL}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnHZ}{\ddefnc{HZ}{\iA{HZ}}{\subddefnA{HZ}{\tsaux{HZ} = 100 : \tsunknown{real}  \tslongcomm{ Note this is the FreeBSD 4.6 value. Becomes 1000 in
                      FreeBSD 6.0 }}
}
{\rulesubsection{Description}
The nominal rate at which the timestamp (etc.) clock ticks, in hertz (ticks per second).

\rrulepad }
}

\newcommand{\defntickintvlmin}{\ddefnc{tickintvlmin}{\iA{tickintvlmin}}{\subddefnA{tickintvlmin}{\tsaux{tickintvlmin} = 100/(105*\tsaux{HZ}) : \tsunknown{real}}
}
{}
}

\newcommand{\defntickintvlmax}{\ddefnc{tickintvlmax}{\iA{tickintvlmax}}{\subddefnA{tickintvlmax}{\tsaux{tickintvlmax} = 105/(100*\tsaux{HZ}) : \tsunknown{real}}
}
{\rulesubsection{Description}
The actual bounds on the tick interval, in seconds-per-tick; must include $1/\tsaux{HZ}$, and be within the RFC1323 bounds of 1sec to 1msec.

\rrulepad }
}

\newcommand{\defnstopwatchfuzz}{\ddefnc{stopwatchfuzz}{\iA{stopwatchfuzz}}{\subddefnA{stopwatchfuzz}{\tsaux{stopwatchfuzz} = (5/100) : \tsunknown{real}  \tscomm{ +/- factor on accuracy of stopwatch timers }}
}
{}
}

\newcommand{\defnstopwatchTzero}{\ddefnc{stopwatchTzero}{\iA{stopwatch\_zero}}{\subddefnA{stopwatch\_zero}{\tsaux{stopwatch\_zero} = \tscon{Stopwatch}(0,1/(1+\tsaux{stopwatchfuzz}),1+\tsaux{stopwatchfuzz})}
}
{\rulesubsection{Description}
A stopwatch timer is initialised to $\tsaux{stopwatch\_zero}$, which gives it an initial time of $0$ and a fuzz of $\tsaux{stopwatchfuzz}$.

\rrulepad }
}

\newcommand{\defnSLOWTTIMERTINTVL}{\ddefnc{SLOWTTIMERTINTVL}{\iA{SLOW\_TIMER\_INTVL}}{\subddefnA{SLOW\_TIMER\_INTVL}{\tsaux{SLOW\_TIMER\_INTVL} = (1/2) : \tsaux{duration}  \tscomm{ slow timer is 500msec on BSD }}
}
{}
}

\newcommand{\defnSLOWTTIMERTMODELTINTVL}{\ddefnc{SLOWTTIMERTMODELTINTVL}{\iA{SLOW\_TIMER\_MODEL\_INTVL}}{\subddefnA{SLOW\_TIMER\_MODEL\_INTVL}{\tsaux{SLOW\_TIMER\_MODEL\_INTVL} = (1/1000) : \tsaux{duration} \tsholcomm{ 1msec fuzziness to mask atomicity of model; Note that it might be possible to reduce this fuzziness }}
}
{}
}

\newcommand{\defnFASTTTIMERTINTVL}{\ddefnc{FASTTTIMERTINTVL}{\iA{FAST\_TIMER\_INTVL}}{\subddefnA{FAST\_TIMER\_INTVL}{\tsaux{FAST\_TIMER\_INTVL} = (1/5) : \tsaux{duration}  \tscomm{ fast timer is 200msec on BSD }}
}
{}
}

\newcommand{\defnFASTTTIMERTMODELTINTVL}{\ddefnc{FASTTTIMERTMODELTINTVL}{\iA{FAST\_TIMER\_MODEL\_INTVL}}{\subddefnA{FAST\_TIMER\_MODEL\_INTVL}{\tsaux{FAST\_TIMER\_MODEL\_INTVL} = (1/1000) : \tsaux{duration} \tsholcomm{ 1msec fuzziness to mask atomicity of model; Note that it might be possible to reduce this fuzziness }}
}
{}
}

\newcommand{\defnKERNTTIMERTINTVL}{\ddefnc{KERNTTIMERTINTVL}{\iA{KERN\_TIMER\_INTVL}}{\subddefnA{KERN\_TIMER\_INTVL}{\tsaux{KERN\_TIMER\_INTVL} = \tsaux{tickintvlmax} : \tsaux{duration}  \tscomm{ precision of select timer }}
}
{}
}

\newcommand{\defnKERNTTIMERTMODELTINTVL}{\ddefnc{KERNTTIMERTMODELTINTVL}{\iA{KERN\_TIMER\_MODEL\_INTVL}}{\subddefnA{KERN\_TIMER\_MODEL\_INTVL}{\tsaux{KERN\_TIMER\_MODEL\_INTVL} = (\tsaux{the\_time} \;\tsaux{dschedmax}) : \tsaux{duration} \tsholcomm{ Note that some fuzziness may be required here }{}\\{}
 \tslongcomm{ Note this was previously 0usec fuzziness; it should really have some fuzziness, though dschedmax
     has a current value of 1s which is too high. Once epsilon\textunderscore{}2 is used properly by the checker,
     we should be able to reduce this fuzziness as it will enable the time transitions to be
     split. e.g. in pselect rules, we really want to change from PSelect2() to Ret() states
     pretty much exactly when the timer goes off, then allow a further epsilon transition
     before returning. }}
}
{\rulesubsection{Description}
The slow, fast, and kernel timers are the timers used to control TCP time-related behaviour.
The parameters here set their rates and fuzziness.

The slow timer is used for retransmit, persist, keepalive, connection
establishment, FIN\_WAIT\_2, 2MSL, and linger timers.  The fast timer
is used for delayed acks.  The kernel timer is used for timestamp
expiry, \texttt{select}, and bad-retransmit detection.

\rrulepad }
}

\newcommand{\seccommparamsTportsetc}{\clustersection{(TCP and UDP)}{Ports, sockets, and files}
\seccomm{
Parameters defining the classes of ports, and limits on numbers of
file descriptors and sockets.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{OPEN\_MAX}$
&
& \\
$\tsrule{OPEN\_MAX\_FD}$
&
& \\
$\tsrule{FD\_SETSIZE}$
&
& \\
$\tsrule{SOMAXCONN}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnOPENTMAX}{\ddefnc{OPENTMAX}{\iA{OPEN\_MAX}}{\subddefnA{OPEN\_MAX}{\tsaux{OPEN\_MAX} = 957 : \tstype{num}  \tsholcomm{ typical value of \wasverb{kern.maxfilesperproc} on one of our BSD boxen }}
}
{}
}

\newcommand{\defnOPENTMAXTFD}{\ddefnc{OPENTMAXTFD}{\iA{OPEN\_MAX\_FD}}{\subddefnA{OPEN\_MAX\_FD}{\tsaux{OPEN\_MAX\_FD} = \tscon{FD} \;\tsaux{OPEN\_MAX}}
}
{\rulesubsection{Description}
A process may hold a maximum of $\tsaux{OPEN\_MAX}$ file descriptors at any
one time.  These are numbered consecutively from zero on non-Windows
architectures, and so the first forbidden file descriptor is $\tsaux{OPEN\_MAX\_FD}$.

\rrulepad }
}

\newcommand{\defnFDTSETSIZE}{\ddefnc{FDTSETSIZE}{\iA{FD\_SETSIZE}}{\subddefnA{FD\_SETSIZE}{(\tsaux{FD\_SETSIZE} : \tstype{arch} \Mtotype  \tstype{num})  \tscon{Linux\_2\_4\_20\_8} = 1024n \Mwedge {}\\{}
 \tsaux{FD\_SETSIZE}                 \;\tscon{WinXP\_Prof\_SP1} = 64n \Mwedge {}\\{}
 \tsaux{FD\_SETSIZE}                 \;\tsunknown{FreeBDS\_4\_6\_RELEASE} = 1024n}
}
{\rulesubsection{Description}
The sets of file descriptors used in calls to $\tslib{pselect}$ can contain
only file descriptors numbered less than $\tsaux{FD\_SETSIZE}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
$\tsaux{FD\_SETSIZE}$ refers to the maximum number of file descriptors in a
file descriptor set.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\defnSOMAXCONN}{\ddefnc{SOMAXCONN}{\iA{SOMAXCONN}}{\subddefnA{SOMAXCONN}{\tsaux{SOMAXCONN} = 128 : \tstype{num}}
}
{\rulesubsection{Description}
The maximum listen-queue length.

\rrulepad }
}

\newcommand{\seccommparamsTudp}{\clustersection{(UDP only)}{UDP parameters}
\seccomm{
UDP-specific parameters.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{UDPpayloadMax}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnUDPpayloadMax}{\ddefnc{UDPpayloadMax}{\iA{UDPpayloadMax}}{\subddefnA{UDPpayloadMax}{(\tsaux{UDPpayloadMax} : \tstype{arch} \Mtotype  \tstype{num}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tscon{Linux\_2\_4\_20\_8} = 65507n \Mwedge {}\\{}
 \tsaux{UDPpayloadMax} \;\tscon{WinXP\_Prof\_SP1} = 65507n \Mwedge {}\\{}
 \tsaux{UDPpayloadMax} \;\tscon{FreeBSD\_4\_6\_RELEASE} = 9216n}
}
{\rulesubsection{Description}
The architecture-dependent maximum payload for a UDP datagram.

\rrulepad }
}

\newcommand{\seccommparamsTbuffers}{\clustersection{(TCP and UDP)}{Buffers}
\seccomm{
Parameters to the buffer size computation.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{MCLBYTES}$
&
&  size of an mbuf cluster \\
$\tsrule{MSIZE}$
&
& \\
$\tsrule{SB\_MAX}$
&
& \\
$\tsrule{oob\_extra\_sndbuf}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnMCLBYTES}{\ddefnc{MCLBYTES}{\iA{MCLBYTES}}{\subddefnA[{ size of an mbuf cluster }]{MCLBYTES}{\tsaux{MCLBYTES} = 2048 : \tstype{num}  \tscomm{ BSD default on i386; really, just needs to be \textgreater{}=1500 to fit an etherseg }}
}
{}
}

\newcommand{\defnMSIZE}{\ddefnc{MSIZE}{\iA{MSIZE}}{\subddefnA{MSIZE}{\tsaux{MSIZE} = 256 : \tstype{num}  \tscomm{ BSD default on i386; really, size of an mbuf }}
}
{}
}

\newcommand{\defnSBTMAX}{\ddefnc{SBTMAX}{\iA{SB\_MAX}}{\subddefnA{SB\_MAX}{\tsaux{SB\_MAX} = 256 * 1024 : \tstype{num}  \tscomm{ BSD }}
}
{}
}

\newcommand{\defnoobTextraTsndbuf}{\ddefnn{oobTextraTsndbuf}{\iA{oob\_extra\_sndbuf}}{\subddefnA{oob\_extra\_sndbuf}{\tsaux{oob\_extra\_sndbuf} = 1024 : \tstype{num}}
}
{}
}

\newcommand{\seccommparamsTflags}{\clustersection{(TCP and UDP)}{File and socket flag defaults}
\seccomm{
Default values of file and socket flags, applied on creation.  Some of
these are architecture-dependent. Note that $\tscon{SO\_BSDCOMPAT}$ should
really be set to $\Mtrue $ by default on FreeBSD.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{ff\_default\_b}$
&
&  file flags default \\
$\tsrule{ff\_default}$
&
& \\
$\tsrule{sf\_default\_b}$
&
&  $\tstype{bool}$ socket flags default \\
$\tsrule{sf\_default\_n}$
&
&  $\tstype{num}$ socket flags defaults \\
$\tsrule{sf\_default\_t}$
&
&  $\tstype{time}$ socket flags defaults \\
$\tsrule{sf\_default}$
&
&  socket flags defaults \\
$\tsrule{sf\_min\_n}$
&
&  minimum values of $\tstype{num}$ socket flags \\
$\tsrule{sf\_max\_n}$
&
&  maximum values of $\tstype{num}$ socket flags \\
$\tsrule{sndrcv\_timeo\_t\_max}$
&
&  maximum value of $\tslib{send}$/$\tslib{recv}$ timeouts \\
$\tsrule{pselect\_timeo\_t\_max}$
&
&  maximum value of $\tslib{pselect}$ timeouts \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnffTdefaultTb}{\ddefnc{ffTdefaultTb}{\iA{ff\_default\_b}}{\subddefnA[{ file flags default }]{ff\_default\_b}{(\tsaux{ff\_default\_b} : \tstype{filebflag} \Mtotype  \tstype{bool}){}\\{}
\quad\quad\quad\quad\quad \tscon{O\_NONBLOCK} = \Mfalse  \Mwedge {}\\{}
 \tsaux{ff\_default\_b} \;\tscon{O\_ASYNC}    = \Mfalse }
}
{}
}

\newcommand{\defnffTdefault}{\ddefnn{ffTdefault}{\iA{ff\_default}}{\subddefnA{ff\_default}{\tsaux{ff\_default} = \Mmagiclrec  \tsvar{b} \Mass  \tsaux{ff\_default\_b} \Mmagicrrec }
}
{}
}

\newcommand{\defnsfTdefaultTb}{\ddefnn{sfTdefaultTb}{\iA{sf\_default\_b}}{\subddefnA[{ $\tstype{bool}$ socket flags default }]{sf\_default\_b}{(\tsaux{sf\_default\_b} : \tstype{sockbflag} \Mtotype  \tstype{bool}){}\\{}
\quad\quad\quad\quad\quad \tscon{SO\_BSDCOMPAT}  = \Mfalse  \Mwedge {}\\{}
 \tsaux{sf\_default\_b} \;\tscon{SO\_REUSEADDR}  = \Mfalse  \Mwedge {}\\{}
 \tsaux{sf\_default\_b} \;\tscon{SO\_KEEPALIVE}  = \Mfalse  \Mwedge {}\\{}
 \tsaux{sf\_default\_b} \;\tscon{SO\_OOBINLINE}  = \Mfalse  \Mwedge {}\\{}
 \tsaux{sf\_default\_b} \;\tscon{SO\_DONTROUTE}  = \Mfalse }
}
{}
}

\newcommand{\defnsfTdefaultTn}{\ddefnn{sfTdefaultTn}{\iA{sf\_default\_n}}{\subddefnA[{ $\tstype{num}$ socket flags defaults }]{sf\_default\_n}{(\tsaux{sf\_default\_n} : \tstype{arch} \Mtotype  \tstype{socktype} \Mtotype  \tstype{socknflag} \Mtotype  \tstype{num}){}\\{}
\quad\quad\quad\quad\quad \tscon{Linux\_2\_4\_20\_8} \;\tscon{SOCK\_STREAM} \;\tscon{SO\_SNDBUF}      = 16384 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_default\_n} \;\tscon{WinXP\_Prof\_SP1} \;\tscon{SOCK\_STREAM} \;\tscon{SO\_SNDBUF}      = 8192 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_default\_n} \;\tscon{FreeBSD\_4\_6\_RELEASE} \;\tscon{SOCK\_STREAM} \;\tscon{SO\_SNDBUF} = 32*1024 \Mwedge  \tscomm{ from code}{}\\{}
 {}\\{}
 \tsaux{sf\_default\_n} \;\tscon{Linux\_2\_4\_20\_8} \;\tscon{SOCK\_STREAM} \;\tscon{SO\_RCVBUF}      = 43689 \Mwedge  \tscomm{ from tests - strange number? }{}\\{}
 \tsaux{sf\_default\_n} \;\tscon{WinXP\_Prof\_SP1} \;\tscon{SOCK\_STREAM} \;\tscon{SO\_RCVBUF}      = 8192  \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_default\_n} \;\tscon{FreeBSD\_4\_6\_RELEASE} \;\tscon{SOCK\_STREAM} \;\tscon{SO\_RCVBUF} = 57344 \Mwedge  \tscomm{ from code, becomes 65536 in FreeBSD 6.0 }{}\\{}
 {}\\{}
 \tsaux{sf\_default\_n} \;\tscon{Linux\_2\_4\_20\_8} \;\tscon{SOCK\_STREAM} \;\tscon{SO\_SNDLOWAT}      = 1 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_default\_n} \;\tscon{WinXP\_Prof\_SP1} \;\tscon{SOCK\_STREAM} \;\tscon{SO\_SNDLOWAT}      = 1 \Mwedge  \tscomm{ Note this value has not been checked in testing. }{}\\{}
 \tsaux{sf\_default\_n} \;\tscon{FreeBSD\_4\_6\_RELEASE} \;\tscon{SOCK\_STREAM} \;\tscon{SO\_SNDLOWAT} = 2048 \Mwedge  \tscomm{ from code }{}\\{}
 {}\\{}
 \tsaux{sf\_default\_n} \;\tscon{Linux\_2\_4\_20\_8} \;\tscon{SOCK\_STREAM} \;\tscon{SO\_RCVLOWAT}      = 1 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_default\_n} \;\tscon{WinXP\_Prof\_SP1} \;\tscon{SOCK\_STREAM} \;\tscon{SO\_RCVLOWAT}      = 1 \Mwedge {}\\{}
 \tsaux{sf\_default\_n} \;\tscon{FreeBSD\_4\_6\_RELEASE} \;\tscon{SOCK\_STREAM} \;\tscon{SO\_RCVLOWAT} = 1 \Mwedge  \tscomm{ from code }{}\\{}
 {}\\{}
 \tsaux{sf\_default\_n} \;\tscon{Linux\_2\_4\_20\_8} \;\tscon{SOCK\_DGRAM} \;\tscon{SO\_SNDBUF}       = 65535 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_default\_n} \;\tscon{WinXP\_Prof\_SP1} \;\tscon{SOCK\_DGRAM} \;\tscon{SO\_SNDBUF}       = 8192 \Mwedge   \tscomm{ from tests }{}\\{}
 \tsaux{sf\_default\_n} \;\tscon{FreeBSD\_4\_6\_RELEASE} \;\tscon{SOCK\_DGRAM} \;\tscon{SO\_SNDBUF}  = 9216  \Mwedge  \tscomm{ from code }{}\\{}
 {}\\{}
 \tsaux{sf\_default\_n} \;\tscon{Linux\_2\_4\_20\_8} \;\tscon{SOCK\_DGRAM} \;\tscon{SO\_RCVBUF}       = 65535 \Mwedge  \tscomm{ correct from tests }{}\\{}
 \tsaux{sf\_default\_n} \;\tscon{WinXP\_Prof\_SP1} \;\tscon{SOCK\_DGRAM} \;\tscon{SO\_RCVBUF}       = 8192 \Mwedge   \tscomm{ correct from tests }{}\\{}
 \tsaux{sf\_default\_n} \;\tscon{FreeBSD\_4\_6\_RELEASE} \;\tscon{SOCK\_DGRAM} \;\tscon{SO\_RCVBUF}  = 42080 \Mwedge  \tsholcomm{ from tests but:  41600 from code; i386 only as dependent on \wasverb{sizeof(struct sockaddr\textunderscore{}in)} }{}\\{}
 {}\\{}
 \tsaux{sf\_default\_n} \;\tscon{Linux\_2\_4\_20\_8} \;\tscon{SOCK\_DGRAM} \;\tscon{SO\_SNDLOWAT}       = 1 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_default\_n} \;\tscon{WinXP\_Prof\_SP1} \;\tscon{SOCK\_DGRAM} \;\tscon{SO\_SNDLOWAT}       = 1 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_default\_n} \;\tscon{FreeBSD\_4\_6\_RELEASE} \;\tscon{SOCK\_DGRAM} \;\tscon{SO\_SNDLOWAT}  = 2048 \Mwedge  \tscomm{ from code }{}\\{}
 {}\\{}
 \tsaux{sf\_default\_n} \;\tscon{Linux\_2\_4\_20\_8} \;\tscon{SOCK\_DGRAM} \;\tscon{SO\_RCVLOWAT}       = 1 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_default\_n} \;\tscon{WinXP\_Prof\_SP1} \;\tscon{SOCK\_DGRAM} \;\tscon{SO\_RCVLOWAT}       = 1 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_default\_n} \;\tscon{FreeBSD\_4\_6\_RELEASE} \;\tscon{SOCK\_DGRAM} \;\tscon{SO\_RCVLOWAT}  = 1 \tscomm{ from code }}
}
{}
}

\newcommand{\defnsfTdefaultTt}{\ddefnn{sfTdefaultTt}{\iA{sf\_default\_t}}{\subddefnA[{ $\tstype{time}$ socket flags defaults }]{sf\_default\_t}{(\tsaux{sf\_default\_t} : \tstype{socktflag} \Mtotype  \tstype{time}){}\\{}
\quad\quad\quad\quad\quad \tscon{SO\_LINGER}     = \infty \Mwedge {}\\{}
 \tsaux{sf\_default\_t} \;\tscon{SO\_SNDTIMEO}   = \infty \Mwedge {}\\{}
 \tsaux{sf\_default\_t} \;\tscon{SO\_RCVTIMEO}   = \infty}
}
{}
}

\newcommand{\defnsfTdefault}{\ddefnn{sfTdefault}{\iA{sf\_default}}{\subddefnA[{ socket flags defaults }]{sf\_default}{\tsaux{sf\_default} \;\tstype{arch} \;\tstype{socktype} = \Mmagiclrec  \tsvar{b} \Mass  \tsaux{sf\_default\_b};{}\\{}
 \tsvar{n} \Mass  \tsaux{sf\_default\_n} \;\tstype{arch} \;\tstype{socktype};{}\\{}
 \tsvar{t} \Mass  \tsaux{sf\_default\_t}{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defnsfTminTn}{\ddefnc{sfTminTn}{\iA{sf\_min\_n}}{\subddefnA[{ minimum values of $\tstype{num}$ socket flags }]{sf\_min\_n}{(\tsaux{sf\_min\_n} : \tstype{arch} \Mtotype  \tstype{socknflag} \Mtotype  \tstype{num}){}\\{}
\quad\quad\quad \tscon{Linux\_2\_4\_20\_8} \;\tscon{SO\_SNDBUF}      = 2048 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_min\_n} \;\tscon{WinXP\_Prof\_SP1} \;\tscon{SO\_SNDBUF}      = 0 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_min\_n} \;\tscon{FreeBSD\_4\_6\_RELEASE} \;\tscon{SO\_SNDBUF} = 1 \Mwedge  \tscomm{ from code }{}\\{}
 \tsaux{sf\_min\_n} \;\tscon{Linux\_2\_4\_20\_8} \;\tscon{SO\_RCVBUF}      = 256 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_min\_n} \;\tscon{WinXP\_Prof\_SP1} \;\tscon{SO\_RCVBUF}      = 0 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_min\_n} \;\tscon{FreeBSD\_4\_6\_RELEASE} \;\tscon{SO\_RCVBUF} = 1 \Mwedge  \tscomm{ from code }{}\\{}
 \tsaux{sf\_min\_n} \;\tscon{Linux\_2\_4\_20\_8} \;\tscon{SO\_SNDLOWAT}      = 1 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_min\_n} \;\tscon{WinXP\_Prof\_SP1} \;\tscon{SO\_SNDLOWAT}      = 1 \Mwedge  \tscomm{ Note this value has not been checked in testing. }{}\\{}
 \tsaux{sf\_min\_n} \;\tscon{FreeBSD\_4\_6\_RELEASE} \;\tscon{SO\_SNDLOWAT} = 1 \Mwedge  \tscomm{ from code }{}\\{}
 \tsaux{sf\_min\_n} \;\tscon{Linux\_2\_4\_20\_8} \;\tscon{SO\_RCVLOWAT}      = 1 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_min\_n} \;\tscon{WinXP\_Prof\_SP1} \;\tscon{SO\_RCVLOWAT}      = 1 \Mwedge  \tscomm{ Note this value has not been checked in testing. }{}\\{}
 \tsaux{sf\_min\_n} \;\tscon{FreeBSD\_4\_6\_RELEASE} \;\tscon{SO\_RCVLOWAT} = 1  \tscomm{ from code }}
}
{}
}

\newcommand{\defnsfTmaxTn}{\ddefnn{sfTmaxTn}{\iA{sf\_max\_n}}{\subddefnA[{ maximum values of $\tstype{num}$ socket flags }]{sf\_max\_n}{(\tsaux{sf\_max\_n} : \tstype{arch} \Mtotype  \tstype{socknflag} \Mtotype  \tstype{num}){}\\{}
\quad\quad\quad \tscon{Linux\_2\_4\_20\_8} \;\tscon{SO\_SNDBUF}      = 131070 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_max\_n} \;\tscon{WinXP\_Prof\_SP1} \;\tscon{SO\_SNDBUF}      = 131070 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_max\_n} \;\tscon{FreeBSD\_4\_6\_RELEASE} \;\tscon{SO\_SNDBUF} ={}\\{}
\quad \tsaux{SB\_MAX} * \tsaux{MCLBYTES} \;\tsholop{DIV} (\tsaux{MCLBYTES} + \tsaux{MSIZE}) \Mwedge  \tscomm{ from code }{}\\{}
 \tsaux{sf\_max\_n} \;\tscon{Linux\_2\_4\_20\_8} \;\tscon{SO\_RCVBUF}      = 131070 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_max\_n} \;\tscon{WinXP\_Prof\_SP1} \;\tscon{SO\_RCVBUF}      = 131070 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_max\_n} \;\tscon{FreeBSD\_4\_6\_RELEASE} \;\tscon{SO\_RCVBUF} ={}\\{}
\quad \tsaux{SB\_MAX} * \tsaux{MCLBYTES} \;\tsholop{DIV} (\tsaux{MCLBYTES} + \tsaux{MSIZE}) \Mwedge  \tscomm{ from code }{}\\{}
 \tsaux{sf\_max\_n} \;\tscon{Linux\_2\_4\_20\_8} \;\tscon{SO\_SNDLOWAT}      = 1 \Mwedge  \tscomm{ from tests }{}\\{}
 \tsaux{sf\_max\_n} \;\tscon{WinXP\_Prof\_SP1} \;\tscon{SO\_SNDLOWAT}      = 1 \Mwedge  \tscomm{ Note this value has not been checked in testing. }{}\\{}
 \tsaux{sf\_max\_n} \;\tscon{FreeBSD\_4\_6\_RELEASE} \;\tscon{SO\_SNDLOWAT} ={}\\{}
\quad \tsaux{SB\_MAX} * \tsaux{MCLBYTES} \;\tsholop{DIV} (\tsaux{MCLBYTES} + \tsaux{MSIZE}) \Mwedge  \tscomm{ clip to SO\textunderscore{}SNDBUF }{}\\{}
 \tsaux{sf\_max\_n} \;\tscon{Linux\_2\_4\_20\_8} \;\tscon{SO\_RCVLOWAT}      = \tsholop{w2n} \;\tsunknown{INT32\_SIGNED\_MAX} \Mwedge  \tscomm{ from code }{}\\{}
 \tsaux{sf\_max\_n} \;\tscon{WinXP\_Prof\_SP1} \;\tscon{SO\_RCVLOWAT}      = 1 \Mwedge  \tscomm{ Note this value has not been checked in testing. }{}\\{}
 \tsaux{sf\_max\_n} \;\tscon{FreeBSD\_4\_6\_RELEASE} \;\tscon{SO\_RCVLOWAT} ={}\\{}
\quad \tsaux{SB\_MAX} * \tsaux{MCLBYTES} \;\tsholop{DIV} (\tsaux{MCLBYTES} + \tsaux{MSIZE})\tscomm{ clip to SO\textunderscore{}RCVBUF }}
}
{}
}

\newcommand{\defnsndrcvTtimeoTtTmax}{\ddefnc{sndrcvTtimeoTtTmax}{\iA{sndrcv\_timeo\_t\_max}}{\subddefnA[{ maximum value of $\tslib{send}$/$\tslib{recv}$ timeouts }]{sndrcv\_timeo\_t\_max}{\tsaux{sndrcv\_timeo\_t\_max} = \tstype{time} \;655350000}
}
{}
}

\newcommand{\defnpselectTtimeoTtTmax}{\ddefnn{pselectTtimeoTtTmax}{\iA{pselect\_timeo\_t\_max}}{\subddefnA[{ maximum value of $\tslib{pselect}$ timeouts }]{pselect\_timeo\_t\_max}{\tsaux{pselect\_timeo\_t\_max} = \tstype{time} (31 * 24 * 3600)}
}
{}
}

\newcommand{\seccommparamsTrfc}{\clustersection{(TCP only)}{RFC-specified limits}
\seccomm{
Protocol value limits specified in the TCP RFCs.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{dtsinval}$
&
&
RFC1323 s4.2.3: timestamp validity period.
\\
$\tsrule{TCP\_MAXWIN}$
&
&  maximum (scaled) window size \\
$\tsrule{TCP\_MAXWINSCALE}$
&
&  maximum window scaling exponent \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defndtsinval}{\ddefnn{dtsinval}{\iA{dtsinval}}{\subddefnA[{
RFC1323 s4.2.3: timestamp validity period.
}]{dtsinval}{\tsaux{dtsinval} = \tstype{time} (24 * 24 * 60 * 60)}
}
{}
}

\newcommand{\defnTCPTMAXWIN}{\ddefnc{TCPTMAXWIN}{\iA{TCP\_MAXWIN}}{\subddefnA[{ maximum (scaled) window size }]{TCP\_MAXWIN}{\tsaux{TCP\_MAXWIN} = 65535 : \tstype{num}}
}
{}
}

\newcommand{\defnTCPTMAXWINSCALE}{\ddefnc{TCPTMAXWINSCALE}{\iA{TCP\_MAXWINSCALE}}{\subddefnA[{ maximum window scaling exponent }]{TCP\_MAXWINSCALE}{\tsaux{TCP\_MAXWINSCALE} = 14 : \tstype{num}}
}
{\rulesubsection{Description}
The maximum (scaled) window size value is $\tsaux{TCP\_MAXWIN}$, and
the maximum scaling exponent is $\tsaux{TCP\_MAXWINSCALE}$.  Thus the maximum
window size is $\tsaux{TCP\_MAXWIN} \ll  \tsaux{TCP\_MAXWINSCALE}$.

\rrulepad }
}

\newcommand{\seccommparamsTproto}{\clustersection{(TCP only)}{Protocol parameters}
\seccomm{
Various TCP protocol parameters, many adjustable by \wasverb{sysctl} settings
(or equivalent).  The values here are typical.  It was not considered
worthwhile modelling these parameters changing during operation.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{MSSDFLT}$
&
&  initial $\tsfield{t\_maxseg}$, modulo route and link MTUs \\
$\tsrule{SS\_FLTSZ\_LOCAL}$
&
&  initial $\tsfield{snd\_cwnd}$ for local connections \\
$\tsrule{SS\_FLTSZ}$
&
&  initial $\tsfield{snd\_cwnd}$ for non-local connections \\
$\tsrule{TCP\_DO\_NEWRENO}$
&
&  do NewReno fast recovery \\
$\tsrule{TCP\_Q0MINLIMIT}$
&
& \\
$\tsrule{TCP\_Q0MAXLIMIT}$
&
& \\
$\tsrule{backlog\_fudge}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnMSSDFLT}{\ddefnn{MSSDFLT}{\iA{MSSDFLT}}{\subddefnA[{ initial $\tsfield{t\_maxseg}$, modulo route and link MTUs }]{MSSDFLT}{\tsaux{MSSDFLT} = 512 : \tstype{num}  \tscomm{ BSD default; RFC1122 sec. 4.2.2.6 says this MUST be 536 }}
}
{}
}

\newcommand{\defnSSTFLTSZTLOCAL}{\ddefnc{SSTFLTSZTLOCAL}{\iA{SS\_FLTSZ\_LOCAL}}{\subddefnA[{ initial $\tsfield{snd\_cwnd}$ for local connections }]{SS\_FLTSZ\_LOCAL}{\tsaux{SS\_FLTSZ\_LOCAL} = 4 : \tstype{num}  \tscomm{ BSD; is a sysctl }}
}
{}
}

\newcommand{\defnSSTFLTSZ}{\ddefnn{SSTFLTSZ}{\iA{SS\_FLTSZ}}{\subddefnA[{ initial $\tsfield{snd\_cwnd}$ for non-local connections }]{SS\_FLTSZ}{\tsaux{SS\_FLTSZ} = 1 : \tstype{num}  \tscomm{ BSD; is a sysctl }}
}
{}
}

\newcommand{\defnTCPTDOTNEWRENO}{\ddefnn{TCPTDOTNEWRENO}{\iA{TCP\_DO\_NEWRENO}}{\subddefnA[{ do NewReno fast recovery }]{TCP\_DO\_NEWRENO}{\tsaux{TCP\_DO\_NEWRENO} = \Mtrue  : \tstype{bool} \tscomm{ BSD default }}
}
{}
}

\newcommand{\defnTCPTQZMINLIMIT}{\ddefnc{TCPTQZMINLIMIT}{\iA{TCP\_Q0MINLIMIT}}{\subddefnA{TCP\_Q0MINLIMIT}{\tsaux{TCP\_Q0MINLIMIT} = 30 : \tstype{num}  \tscomm{ FreeBSD 4.6-RELEASE: tcp\textunderscore{}syncache.bucket\textunderscore{}limit }}
}
{}
}

\newcommand{\defnTCPTQZMAXLIMIT}{\ddefnc{TCPTQZMAXLIMIT}{\iA{TCP\_Q0MAXLIMIT}}{\subddefnA{TCP\_Q0MAXLIMIT}{\tsaux{TCP\_Q0MAXLIMIT} = 512 * 30 : \tstype{num}  \tscomm{ FreeBSD 4.6-RELEASE: tcp\textunderscore{}syncache.cache\textunderscore{}limit }}
}
{\rulesubsection{Description}
The incomplete-connection listen queue $\tsvar{q}_{0}$ has a nondeterministic
length limit.  Connections \emph{may} be dropped once $\tsvar{q}_{0}$ reaches
$\tsaux{TCP\_Q0MINLIMIT}$, and \emph{must} be dropped once $\tsvar{q}_{0}$ reaches
$\tsaux{TCP\_Q0MAXLIMIT}$.

\rrulepad }
}

\newcommand{\defnbacklogTfudge}{\ddefnc{backlogTfudge}{\iA{backlog\_fudge}}{\subddefnA{backlog\_fudge}{\tsaux{backlog\_fudge} (\tsvar{n}:\tstype{int}) = \tsholop{MIN} \;\tsaux{SOMAXCONN} (\tsaux{clip\_int\_to\_num} \;\tsvar{n})}
}
{\rulesubsection{Description}
The backlog length fudge-factor function, which translates the
requested length of the listen queue into the actual value used.  Some
architectures apply a linear transformation here.

\rrulepad }
}

\newcommand{\seccommparamsTtimevalues}{\clustersection{(TCP only)}{Time values}
\seccomm{
Various time intervals controlling TCP's behaviour.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{TCPTV\_DELACK}$
&
& \\
$\tsrule{TCPTV\_RTOBASE}$
&
& \\
$\tsrule{TCPTV\_RTTVARBASE}$
&
& \\
$\tsrule{TCPTV\_MIN}$
&
& \\
$\tsrule{TCPTV\_REXMTMAX}$
&
& \\
$\tsrule{TCPTV\_MSL}$
&
& \\
$\tsrule{TCPTV\_PERSMIN}$
&
& \\
$\tsrule{TCPTV\_PERSMAX}$
&
& \\
$\tsrule{TCPTV\_KEEP\_INIT}$
&
& \\
$\tsrule{TCPTV\_KEEP\_IDLE}$
&
& \\
$\tsrule{TCPTV\_KEEPINTVL}$
&
& \\
$\tsrule{TCPTV\_KEEPCNT}$
&
& \\
$\tsrule{TCPTV\_MAXIDLE}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnTCPTVTDELACK}{\ddefnc{TCPTVTDELACK}{\iA{TCPTV\_DELACK}}{\subddefnA{TCPTV\_DELACK}{\tsaux{TCPTV\_DELACK} = \tstype{time} (1 / 10)  \tscomm{ FreeBSD 4.6-RELEASE, tcp\textunderscore{}timer.h }}
}
{\rrulepad }
}

\newcommand{\defnTCPTVTRTOBASE}{\ddefnc{TCPTVTRTOBASE}{\iA{TCPTV\_RTOBASE}}{\subddefnA{TCPTV\_RTOBASE}{\tsaux{TCPTV\_RTOBASE} = 3 : \tsaux{duration} \tscomm{ initial RTT, in seconds: FreeBSD 4.6-RELEASE, tcp\textunderscore{}timer.h }}
}
{}
}

\newcommand{\defnTCPTVTRTTVARBASE}{\ddefnc{TCPTVTRTTVARBASE}{\iA{TCPTV\_RTTVARBASE}}{\subddefnA{TCPTV\_RTTVARBASE}{\tsaux{TCPTV\_RTTVARBASE} = 0 : \tsaux{duration}  \tscomm{ initial retransmit variance, in seconds }{}\\{}
 \tslongcomm{ FreeBSD has no way of encoding an initial RTT variance,
        but we do (thanks to tf\textunderscore{}srttvalid); it should be zero
        so TCPTV\textunderscore{}RTOBASE = initial RTO }}
}
{}
}

\newcommand{\defnTCPTVTMIN}{\ddefnc{TCPTVTMIN}{\iA{TCPTV\_MIN}}{\subddefnA{TCPTV\_MIN}{\tsaux{TCPTV\_MIN} = 1 : \tsaux{duration}  \tscomm{ minimum RTT in absence of cached value, in seconds: FreeBSD 4.6-RELEASE, tcp\textunderscore{}timer.h }}
}
{}
}

\newcommand{\defnTCPTVTREXMTMAX}{\ddefnn{TCPTVTREXMTMAX}{\iA{TCPTV\_REXMTMAX}}{\subddefnA{TCPTV\_REXMTMAX}{\tsaux{TCPTV\_REXMTMAX} = \tstype{time} \;64  \tscomm{ BSD: maximum possible RTT }}
}
{}
}

\newcommand{\defnTCPTVTMSL}{\ddefnn{TCPTVTMSL}{\iA{TCPTV\_MSL}}{\subddefnA{TCPTV\_MSL}{\tsaux{TCPTV\_MSL} = \tstype{time} \;30 \tscomm{ maximum segment lifetime: BSD: tcp\textunderscore{}timer.h:79 }}
}
{}
}

\newcommand{\defnTCPTVTPERSMIN}{\ddefnc{TCPTVTPERSMIN}{\iA{TCPTV\_PERSMIN}}{\subddefnA{TCPTV\_PERSMIN}{\tsaux{TCPTV\_PERSMIN} = \tstype{time} \;5  \tscomm{ BSD: minimum possible persist interval: tcp\textunderscore{}timer.h:85 }}
}
{}
}

\newcommand{\defnTCPTVTPERSMAX}{\ddefnn{TCPTVTPERSMAX}{\iA{TCPTV\_PERSMAX}}{\subddefnA{TCPTV\_PERSMAX}{\tsaux{TCPTV\_PERSMAX} = \tstype{time} \;60  \tscomm{ BSD: maximum possible persist interval: tcp\textunderscore{}timer.h:86 }}
}
{}
}

\newcommand{\defnTCPTVTKEEPTINIT}{\ddefnc{TCPTVTKEEPTINIT}{\iA{TCPTV\_KEEP\_INIT}}{\subddefnA{TCPTV\_KEEP\_INIT}{\tsaux{TCPTV\_KEEP\_INIT} = \tstype{time} \;75 \tscomm{ connect timeout: BSD: tcp\textunderscore{}timer.h:88 }}
}
{}
}

\newcommand{\defnTCPTVTKEEPTIDLE}{\ddefnc{TCPTVTKEEPTIDLE}{\iA{TCPTV\_KEEP\_IDLE}}{\subddefnA{TCPTV\_KEEP\_IDLE}{\tsaux{TCPTV\_KEEP\_IDLE} = \tstype{time} (120*60) \tscomm{ time before first keepalive probe: BSD: tcp\textunderscore{}timer.h:89 }}
}
{}
}

\newcommand{\defnTCPTVTKEEPINTVL}{\ddefnc{TCPTVTKEEPINTVL}{\iA{TCPTV\_KEEPINTVL}}{\subddefnA{TCPTV\_KEEPINTVL}{\tsaux{TCPTV\_KEEPINTVL} = \tstype{time} \;75 \tscomm{ time between subsequent keepalive probes: BSD: tcp\textunderscore{}timer.h:90 }}
}
{}
}

\newcommand{\defnTCPTVTKEEPCNT}{\ddefnc{TCPTVTKEEPCNT}{\iA{TCPTV\_KEEPCNT}}{\subddefnA{TCPTV\_KEEPCNT}{\tsaux{TCPTV\_KEEPCNT} = 8 : \tstype{num} \tscomm{ max number of keepalive probes (+/- a few?): BSD: tcp\textunderscore{}timer.h:91 }}
}
{}
}

\newcommand{\defnTCPTVTMAXIDLE}{\ddefnn{TCPTVTMAXIDLE}{\iA{TCPTV\_MAXIDLE}}{\subddefnA{TCPTV\_MAXIDLE}{\tsaux{TCPTV\_MAXIDLE} = 8 * \tsaux{TCPTV\_KEEPINTVL} \tscomm{ BSD calls this tcp\textunderscore{}maxidle }}
}
{}
}

\newcommand{\seccommparamsTtimingrelated}{\clustersection{(TCP only)}{Timing-related parameters}
\seccomm{
Parameters relating to TCP's exponential backoff.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{TCP\_BSD\_BACKOFFS}$
&
&  TCP exponential retransmit backoff: BSD: from source code, tcp\textunderscore{}timer.c:155 \\
$\tsrule{TCP\_LINUX\_BACKOFFS}$
&
&  TCP exponential retransmit backoff: Linux: experimentally determined \\
$\tsrule{TCP\_WINXP\_BACKOFFS}$
&
&  TCP exponential retransmit backoff: WinXP: experimentally determined \\
$\tsrule{TCP\_MAXRXTSHIFT}$
&
&  TCP maximum retransmit shift \\
$\tsrule{TCP\_SYNACKMAXRXTSHIFT}$
&
&  TCP maximum SYNACK retransmit shift \\
$\tsrule{TCP\_SYN\_BSD\_BACKOFFS}$
&
&  TCP exponential SYN retransmit backoff: BSD: tcp\textunderscore{}timer.c:152 \\
$\tsrule{TCP\_SYN\_LINUX\_BACKOFFS}$
&
&  TCP exponential SYN retransmit backoff: Linux: experimentally determined \\
$\tsrule{TCP\_SYN\_WINXP\_BACKOFFS}$
&
&  TCP exponential SYN retransmit backoff: WinXP: experimentally determined \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnTCPTBSDTBACKOFFS}{\ddefnc{TCPTBSDTBACKOFFS}{\iA{TCP\_BSD\_BACKOFFS}}{\subddefnA[{ TCP exponential retransmit backoff: BSD: from source code, tcp\textunderscore{}timer.c:155 }]{TCP\_BSD\_BACKOFFS}{\tsaux{TCP\_BSD\_BACKOFFS} = [ 1; 2; 4; 8; 16; 32; 64; 64; 64; 64; 64; 64; 64 ] : \tstype{num} \;\tstype{list}}
}
{}
}

\newcommand{\defnTCPTLINUXTBACKOFFS}{\ddefnc{TCPTLINUXTBACKOFFS}{\iA{TCP\_LINUX\_BACKOFFS}}{\subddefnA[{ TCP exponential retransmit backoff: Linux: experimentally determined }]{TCP\_LINUX\_BACKOFFS}{\tsaux{TCP\_LINUX\_BACKOFFS} = [ 1; 2; 4; 8; 16; 32; 64; 128; 256; 512; 512 ] : \tstype{num} \;\tstype{list} \tscomm{ Note: the tail may be  incomplete }}
}
{}
}

\newcommand{\defnTCPTWINXPTBACKOFFS}{\ddefnn{TCPTWINXPTBACKOFFS}{\iA{TCP\_WINXP\_BACKOFFS}}{\subddefnA[{ TCP exponential retransmit backoff: WinXP: experimentally determined }]{TCP\_WINXP\_BACKOFFS}{\tsaux{TCP\_WINXP\_BACKOFFS} = [ 1; 2; 4; 8; 16 ] : \tstype{num} \;\tstype{list} \tscomm{ Note: the tail may be incomplete }}
}
{}
}

\newcommand{\defnTCPTMAXRXTSHIFT}{\ddefnc{TCPTMAXRXTSHIFT}{\iA{TCP\_MAXRXTSHIFT}}{\subddefnA[{ TCP maximum retransmit shift }]{TCP\_MAXRXTSHIFT}{\tsaux{TCP\_MAXRXTSHIFT} = 12 : \tstype{num}  \tscomm{ TCPv2p842 }}
}
{}
}

\newcommand{\defnTCPTSYNACKMAXRXTSHIFT}{\ddefnn{TCPTSYNACKMAXRXTSHIFT}{\iA{TCP\_SYNACKMAXRXTSHIFT}}{\subddefnA[{ TCP maximum SYNACK retransmit shift }]{TCP\_SYNACKMAXRXTSHIFT}{\tsaux{TCP\_SYNACKMAXRXTSHIFT} = 3 : \tstype{num}  \tscomm{ FreeBSD 4.6-RELEASE, tcp\textunderscore{}syncache.c:SYNCACHE\textunderscore{}MAXREXMTS }}
}
{}
}

\newcommand{\defnTCPTSYNTBSDTBACKOFFS}{\ddefnc{TCPTSYNTBSDTBACKOFFS}{\iA{TCP\_SYN\_BSD\_BACKOFFS}}{\subddefnA[{ TCP exponential SYN retransmit backoff: BSD: tcp\textunderscore{}timer.c:152 }]{TCP\_SYN\_BSD\_BACKOFFS}{\tsaux{TCP\_SYN\_BSD\_BACKOFFS} = [ 1; 1; 1; 1; 1; 2; 4; 8; 16; 32; 64; 64; 64 ] : \tstype{num} \;\tstype{list} \tslongcomm{ Our experimentation shows that this list stops at 8. This will be
   due to the connection establishment timer firing. Values here are
   obtained from the BSD source }}
}
{}
}

\newcommand{\defnTCPTSYNTLINUXTBACKOFFS}{\ddefnc{TCPTSYNTLINUXTBACKOFFS}{\iA{TCP\_SYN\_LINUX\_BACKOFFS}}{\subddefnA[{ TCP exponential SYN retransmit backoff: Linux: experimentally determined }]{TCP\_SYN\_LINUX\_BACKOFFS}{\tsaux{TCP\_SYN\_LINUX\_BACKOFFS} = [ 1; 2; 4; 8; 16 ] : \tstype{num} \;\tstype{list}  \tslongcomm{ This list might be longer. Experimentation does not show further entries, perhaps
   due to the connection establishment timer firing }}
}
{}
}

\newcommand{\defnTCPTSYNTWINXPTBACKOFFS}{\ddefnn{TCPTSYNTWINXPTBACKOFFS}{\iA{TCP\_SYN\_WINXP\_BACKOFFS}}{\subddefnA[{ TCP exponential SYN retransmit backoff: WinXP: experimentally determined }]{TCP\_SYN\_WINXP\_BACKOFFS}{\tsaux{TCP\_SYN\_WINXP\_BACKOFFS} = [ 1; 2 ] : \tstype{num} \;\tstype{list}  \tslongcomm{ This list might be longer. Experimentation does not show further entries, perhaps
   due to the connection establishment timer firing }}
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPITparams}
\showrule{\seccommFIXME}
\showrule{\seccommhosttyTfiles}
\showrule{\defnfid}
\showrule{\defnsid}
\showrule{\defnfiletype}
\showrule{\defnfileflags}
\showrule{\defnfile}
\showrule{\defnFile}
\showrule{\defnsockflags}
\showrule{\defnarch}
\showrule{\seccommparamsTmodel}
\showrule{\defnINFINITETRESOURCES}
\showrule{\defnBSDTRTTVARTBUG}
\showrule{\seccommparamsTsched}
\showrule{\defndschedmax}
\showrule{\defndiqmax}
\showrule{\defndoqmax}
\showrule{\seccommparamsTtimer}
\showrule{\defnHZ}
\showrule{\defntickintvlmin}
\showrule{\defntickintvlmax}
\showrule{\defnstopwatchfuzz}
\showrule{\defnstopwatchTzero}
\showrule{\defnSLOWTTIMERTINTVL}
\showrule{\defnSLOWTTIMERTMODELTINTVL}
\showrule{\defnFASTTTIMERTINTVL}
\showrule{\defnFASTTTIMERTMODELTINTVL}
\showrule{\defnKERNTTIMERTINTVL}
\showrule{\defnKERNTTIMERTMODELTINTVL}
\showrule{\seccommparamsTportsetc}
\showrule{\defnOPENTMAX}
\showrule{\defnOPENTMAXTFD}
\showrule{\defnFDTSETSIZE}
\showrule{\defnSOMAXCONN}
\showrule{\seccommparamsTudp}
\showrule{\defnUDPpayloadMax}
\showrule{\seccommparamsTbuffers}
\showrule{\defnMCLBYTES}
\showrule{\defnMSIZE}
\showrule{\defnSBTMAX}
\showrule{\defnoobTextraTsndbuf}
\showrule{\seccommparamsTflags}
\showrule{\defnffTdefaultTb}
\showrule{\defnffTdefault}
\showrule{\defnsfTdefaultTb}
\showrule{\defnsfTdefaultTn}
\showrule{\defnsfTdefaultTt}
\showrule{\defnsfTdefault}
\showrule{\defnsfTminTn}
\showrule{\defnsfTmaxTn}
\showrule{\defnsndrcvTtimeoTtTmax}
\showrule{\defnpselectTtimeoTtTmax}
\showrule{\seccommparamsTrfc}
\showrule{\defndtsinval}
\showrule{\defnTCPTMAXWIN}
\showrule{\defnTCPTMAXWINSCALE}
\showrule{\seccommparamsTproto}
\showrule{\defnMSSDFLT}
\showrule{\defnSSTFLTSZTLOCAL}
\showrule{\defnSSTFLTSZ}
\showrule{\defnTCPTDOTNEWRENO}
\showrule{\defnTCPTQZMINLIMIT}
\showrule{\defnTCPTQZMAXLIMIT}
\showrule{\defnbacklogTfudge}
\showrule{\seccommparamsTtimevalues}
\showrule{\defnTCPTVTDELACK}
\showrule{\defnTCPTVTRTOBASE}
\showrule{\defnTCPTVTRTTVARBASE}
\showrule{\defnTCPTVTMIN}
\showrule{\defnTCPTVTREXMTMAX}
\showrule{\defnTCPTVTMSL}
\showrule{\defnTCPTVTPERSMIN}
\showrule{\defnTCPTVTPERSMAX}
\showrule{\defnTCPTVTKEEPTINIT}
\showrule{\defnTCPTVTKEEPTIDLE}
\showrule{\defnTCPTVTKEEPINTVL}
\showrule{\defnTCPTVTKEEPCNT}
\showrule{\defnTCPTVTMAXIDLE}
\showrule{\seccommparamsTtimingrelated}
\showrule{\defnTCPTBSDTBACKOFFS}
\showrule{\defnTCPTLINUXTBACKOFFS}
\showrule{\defnTCPTWINXPTBACKOFFS}
\showrule{\defnTCPTMAXRXTSHIFT}
\showrule{\defnTCPTSYNACKMAXRXTSHIFT}
\showrule{\defnTCPTSYNTBSDTBACKOFFS}
\showrule{\defnTCPTSYNTLINUXTBACKOFFS}
\showrule{\defnTCPTSYNTWINXPTBACKOFFS}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore auxFns

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPITauxFns}{\chaptersection{ Auxiliary functions}
\label{TCP1_auxFns}%
\chapcomm{
This file defines a large number of auxiliary functions to the host
specification.


}
}

\newcommand{\seccommauxTfiles}{\clustersection{(TCP and UDP)}{Files, file descriptors, and sockets}
\seccomm{
   The open files of a host are modelled by a set of open file
   descriptions, indexed by $\tstype{fid}$.  The open files of a process are
   identified by file descriptor $\tstype{fd}$, which is an index into a
   table of $\tstype{fid}$s.  This table is modelled by a finite map.
   File descriptors are isomorphic to the natural numbers.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{sane\_socket}$
&
&  socket sanity invariants hold \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnsaneTsocket}{\ddefnc{saneTsocket}{\iA{sane\_socket}}{\subddefnA[{ socket sanity invariants hold }]{sane\_socket}{\tsaux{sane\_socket} \;\tsunknown{sock} = \Mcase  \;\tsunknown{sock}.\tsvar{pr} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscon{TCP\_PROTO} \;\tsunknown{tcp\_sock} \Mtotype {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscomm{LENGTH tcp\textunderscore{}sock.rcvq \textless{}= sock.sf.n(SO\textunderscore{}RCVBUF) /\textbackslash{}  (* true?? *)}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholop{LENGTH} \;\tsunknown{tcp\_sock}.\tsvar{rcvq} \leq  \tsaux{TCP\_MAXWIN} \ll  \tsaux{TCP\_MAXWINSCALE} \tscomm{/\textbackslash{}}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscomm{LENGTH tcp\textunderscore{}sock.sndq \textless{}= sock.sf.n(SO\textunderscore{}SNDBUF)     (* true?? *)}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mdpipe  \tscon{UDP\_PROTO} \;\tsunknown{udp\_sock} \Mtotype {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mtrue }
}
{\rulesubsection{Description}
 There are some demonstrable invariants on a socket; this definition
 asserts them.  These are largely here to provide explicit bounds to
 the symbolic evaluator.


\rrulepad }
}

\newcommand{\seccommauxTbinding}{\clustersection{(TCP and UDP)}{Binding}
\seccomm{
Both TCP and UDP have a concept of a socket being \emph{bound} to a
local port, which means that that socket may receive datagrams
addressed to that port.  A specific local IP address may also be
specified, and a remote IP address and/or port.  This `quadruple'
(really a quintuple, since the protocol is also relevant) is used to
determine the socket that best matches an incoming datagram.

The functions in this section determine this best-matching socket,
using rules appropriate to each protocol.  Support is also provided
for determining which ports are available to be bound by a new socket,
and for automatically choosing a port to bind to in cases where the
user does not specify one.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{bound\_ports\_protocol\_autobind}$
&
&  the set of ports currently bound by a socket for a protocol \\
$\tsrule{bound\_port\_allowed}$
&
&  is it permitted to bind the given (IP,port) pair? \\
$\tsrule{autobind}$
&
&  set of ports available for autobinding \\
$\tsrule{bound\_after}$
&
&  was $\tstype{sid}$ bound more recently than $\tsunknown{sid'}$? \\
$\tsrule{match\_score}$
&
&  score the match against the given pattern of the given quadruple \\
$\tsrule{lookup\_udp}$
&
&  the set of sockets matching an address quad, for UDP \\
$\tsrule{tcp\_socket\_best\_match}$
&
&  the set of sockets matching a quad, for TCP \\
$\tsrule{lookup\_icmp}$
&
&  the set of sockets matching a quad, for ICMP \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnboundTportsTprotocolTautobind}{\ddefnc{boundTportsTprotocolTautobind}{\iA{bound\_ports\_protocol\_autobind}}{\subddefnA[{ the set of ports currently bound by a socket for a protocol }]{bound\_ports\_protocol\_autobind}{\tsaux{bound\_ports\_protocol\_autobind} \;\tsvar{pr} \;\tsvar{socks} = \{\tsunknown{p} \mid  \exists \tsvar{s}:\tslib{socket}.{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{s} \;\in  \Mfrange{\tsvar{socks}} \Mwedge  \tsvar{s}.\tsvar{ps}_{1} = \Msome  \;\tsunknown{p} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{proto\_of} \;\tsvar{s}.\tsvar{pr} = \tsvar{pr}\}}
}
{\rulesubsection{Description}
Rebinding of ports already bound is often restricted. $\tsaux{bound\_ports\_protocol\_autobind}$ is a list of all ports having
a socket of the given protocol binding that port.


\rrulepad }
}

\newcommand{\defnboundTportTallowed}{\ddefnc{boundTportTallowed}{\iA{bound\_port\_allowed}}{\subddefnA[{ is it permitted to bind the given (IP,port) pair? }]{bound\_port\_allowed}{\tsaux{bound\_port\_allowed} \;\tsvar{pr} \;\tsvar{socks} \;\tsvar{sf} \;\tstype{arch} \;\tsvar{is} \;\tsunknown{p} ={}\\{}
 \tsunknown{p} \;\notin {}\\{}
 \{\tstype{port} \mid  \exists \tsvar{s}:\tslib{socket}.{}\\{}
\quad \tsvar{s} \;\in  \Mfrange{\tsvar{socks}} \Mwedge  \tsvar{s}.\tsvar{ps}_{1} = \Msome  \;\tstype{port} \Mwedge {}\\{}
\quad \tsaux{proto\_eq} \;\tsvar{s}.\tsvar{pr} \;\tsvar{pr} \Mwedge {}\\{}
\quad (\Mif  \;\tsaux{bsd\_arch} \;\tstype{arch} \Mwedge  \tscon{SO\_REUSEADDR} \;\in  \;\tsvar{sf}.\tsvar{b} \;\Mthen {}\\{}
\quad\quad\quad \tsvar{s}.\tsvar{is}_{2} = * \Mwedge  \tsvar{s}.\tsvar{is}_{1} = \tsvar{is}{}\\{}
\quad\quad \Melse  \;\Mif  \;\tsaux{linux\_arch} \;\tstype{arch} \Mwedge  \tscon{SO\_REUSEADDR} \;\in  \;\tsvar{sf}.\tsvar{b} \Mwedge  \tscon{SO\_REUSEADDR} \;\in  \;\tsvar{s}.\tsvar{sf}.\tsvar{b} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad ((\exists \tsunknown{tcp\_sock}. \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = \tsvar{s}.\tsvar{pr} \Mwedge  \neg{}(\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{LISTEN})) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad \exists \tsunknown{udp\_sock}. \tscon{UDP\_PROTO}(\tsunknown{udp\_sock}) = \tsvar{s}.\tsvar{pr}) \Mthen {}\\{}
\quad\quad\quad \Mfalse  \tscomm{ If socket is not in LISTEN state or is a UDP socket can always rebind here }{}\\{}
\quad\quad \Melse  \;\Mif  \;\tsaux{windows\_arch} \;\tstype{arch} \Mwedge  \tscon{SO\_REUSEADDR} \;\in  \;\tsvar{sf}.\tsvar{b} \;\Mthen {}\\{}
\quad\quad\quad \Mfalse  \tscomm{ can rebind any UDP address; not sure about TCP - assume the same for now }{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad (\tsvar{is} = * \Mvee  \tsvar{s}.\tsvar{is}_{1} = * \Mvee  (\exists \tsvar{i}:\tsvar{ip}. \tsvar{is} = \Msome  \;\tsvar{i} \Mwedge  \tsvar{s}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}))) \}}
}
{\rulesubsection{Description}
   This determines whether binding a socket (of protocol $\tsvar{pr}$) to local address $\tsvar{is},\tsunknown{p}$ is
   permitted, by considering the other bound sockets on the host and the
   state of the sockets' $\tscon{SO\_REUSEADDR}$ flags.
   Note: SB believes this definition is correct for TCP and UDP on BSD
   and Linux through exhaustive manual verification.
   Note: WinXP is still to be checked.

\rrulepad }
}

\newcommand{\defnautobind}{\ddefnc{autobind}{\iA{autobind}}{\subddefnA[{ set of ports available for autobinding }]{autobind}{\tsaux{autobind}(\Msome  \;\tsunknown{p},\tsunknown{\_},\tsunknown{\_},\tsunknown{\_}) = \{\tsunknown{p}\} \Mwedge {}\\{}
 \tsaux{autobind}(*,\tsvar{pr},\tsunknown{h},\tsvar{socks}) = (\tsaux{ephemeral\_ports} \;\tsunknown{h}) \tsholop{DIFF} (\tsaux{bound\_ports\_protocol\_autobind} \;\tsvar{pr} \;\tsvar{socks})}
}
{\rulesubsection{Description}
Note that $\tscon{SO\_REUSEADDR}$ is not considered when choosing a port to
autobind to.


\rrulepad }
}

\newcommand{\defnboundTafter}{\ddefnc{boundTafter}{\iA{bound\_after}}{\subddefnA[{ was $\tstype{sid}$ bound more recently than $\tsunknown{sid'}$? }]{bound\_after}{\tsaux{bound\_after} (\tstype{sid}:\tstype{sid}) \tsunknown{sid'} [\,] = \tsaux{ASSERTION\_FAILURE} \text{``bound\textunderscore{}after''} \tscomm{ should never reach this case } \Mwedge {}\\{}
 \tsaux{bound\_after} \;\tstype{sid} \;\tsunknown{sid'} (\tsunknown{sid0}\Mcons \tsvar{bound}) ={}\\{}
 \Mif  \;\tstype{sid} = \tsunknown{sid0} \;\Mthen  \;\Mtrue   \tscomm{ newly-bound sockets are added to the head }{}\\{}
 \Melse  \;\Mif  \;\tsunknown{sid'} = \tsunknown{sid0} \;\Mthen  \;\Mfalse {}\\{}
\quad \Melse  \;\tsaux{bound\_after} \;\tstype{sid} \;\tsunknown{sid'} \;\tsvar{bound}}
}
{}
}

\newcommand{\defnmatchTscore}{\ddefnc{matchTscore}{\iA{match\_score}}{\subddefnA[{ score the match against the given pattern of the given quadruple }]{match\_score}{(\tsaux{match\_score} (\tsunknown{\_}:\tstype{ip} \;\;\tstype{option},*:\tstype{port} \;\;\tstype{option},\tsunknown{\_}:\tstype{ip} \;\;\tstype{option},\tsunknown{\_}:\tstype{port} \;\;\tstype{option}) \tsunknown{\_} = 0n) \Mwedge {}\\{}
 (\tsaux{match\_score} (*, \Msome  \;\tsvar{p}_{1}, *, *) (\tsvar{i}_{3},\tsvar{ps}_{3},\tsvar{i}_{4},\tsvar{ps}_{4}) ={}\\{}
\quad \Mif  \;\tsvar{ps}_{4} = \Msome  \;\tsvar{p}_{1} \;\Mthen  \;1 \;\Melse  \;0) \Mwedge {}\\{}
 (\tsaux{match\_score} (\Msome  \;\tsvar{i}_{1}, \Msome  \;\tsvar{p}_{1}, *, *) (\tsvar{i}_{3},\tsvar{ps}_{3},\tsvar{i}_{4},\tsvar{ps}_{4}) ={}\\{}
\quad \Mif  (\tsvar{i}_{1} = \tsvar{i}_{4}) \Mwedge  (\Msome  \;\tsvar{p}_{1} = \tsvar{ps}_{4}) \Mthen  \;2 \;\Melse  \;0) \Mwedge {}\\{}
 (\tsaux{match\_score} (\Msome  \;\tsvar{i}_{1}, \Msome  \;\tsvar{p}_{1}, \Msome  \;\tsvar{i}_{2}, *) (\tsvar{i}_{3},\tsvar{ps}_{3},\tsvar{i}_{4},\tsvar{ps}_{4}) ={}\\{}
\quad \Mif  (\tsvar{i}_{2} = \tsvar{i}_{3}) \Mwedge  (\tsvar{i}_{1} = \tsvar{i}_{4}) \Mwedge  (\Msome  \;\tsvar{p}_{1} = \tsvar{ps}_{4}) \Mthen  \;3 \;\Melse  \;0) \Mwedge {}\\{}
 (\tsaux{match\_score} (\Msome  \;\tsvar{i}_{1}, \Msome  \;\tsvar{p}_{1}, \Msome  \;\tsvar{i}_{2}, \Msome  \;\tsvar{p}_{2}) (\tsvar{i}_{3},\tsvar{ps}_{3},\tsvar{i}_{4},\tsvar{ps}_{4}) ={}\\{}
\quad \Mif  (\Msome  \;\tsvar{p}_{2} = \tsvar{ps}_{3}) \Mwedge  (\tsvar{i}_{2} = \tsvar{i}_{3}) \Mwedge  (\tsvar{i}_{1} = \tsvar{i}_{4}) \Mwedge  (\Msome  \;\tsvar{p}_{1} = \tsvar{ps}_{4}) \Mthen  \;4{}\\{}
\quad \Melse  \;0)}
}
{\rulesubsection{Description}
These two functions are used to match an incoming UDP datagram to a
socket. The $\tsaux{bound\_after}$ function returns $\Mtrue $ if the socket
$\tstype{sid}$ (the first agrument) was bound after the socket $\tsunknown{sid'}$ (the
second argument) according to a list of bound sockets (the third
argument).

The $\tsaux{match\_score}$ function gives a score specifying how closely two
address quads, one from a socket and one from a datagram, correspond;
a higher score indicates a more specific match.


\rrulepad }
}

\newcommand{\defnlookupTudp}{\ddefnc{lookupTudp}{\iA{lookup\_udp}}{\subddefnA[{ the set of sockets matching an address quad, for UDP }]{lookup\_udp}{\tsaux{lookup\_udp} \;\tsvar{socks} \;\tsunknown{quad} \;\tsvar{bound} \;\tstype{arch} ={}\\{}
\quad\quad\quad \{ \tstype{sid} \mid  \tstype{sid} \;\in  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mlet  \;\tsunknown{s} = \tsvar{socks} \Mfapply{}{\tstype{sid}} \Min {}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mlet  \;\tsunknown{sn} = \tsaux{match\_score} (\tsunknown{s}.\tsvar{is}_{1},\tsunknown{s}.\tsvar{ps}_{1},\tsunknown{s}.\tsvar{is}_{2},\tsunknown{s}.\tsvar{ps}_{2}) \tsunknown{quad} \;\Min {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{sn} > 0 \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mif  \;\tsaux{windows\_arch} \;\tstype{arch}  \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mif  \;\tsunknown{sn} = 1 \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \neg{}(\exists  (\tsunknown{sid'},\tsunknown{s'}) \Mcons  (\tsvar{socks} \backslash{}\backslash{} \tstype{sid}). \tsaux{match\_score} (\tsunknown{s'}.\tsvar{is}_{1},\tsunknown{s'}.\tsvar{ps}_{1},\tsunknown{s'}.\tsvar{is}_{2},\tsunknown{s'}.\tsvar{ps}_{2}) \tsunknown{quad} > \tsunknown{sn}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mtrue {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \neg{}(\exists (\tsunknown{sid'},\tsunknown{s'}) \Mcons  (\tsvar{socks} \backslash{}\backslash{} \tstype{sid}).{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsaux{match\_score} (\tsunknown{s'}.\tsvar{is}_{1},\tsunknown{s'}.\tsvar{ps}_{1},\tsunknown{s'}.\tsvar{is}_{2},\tsunknown{s'}.\tsvar{ps}_{2}) \tsunknown{quad} > \tsunknown{sn} \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsaux{linux\_arch} \;\tstype{arch} \Mwedge  \tsaux{match\_score} (\tsunknown{s'}.\tsvar{is}_{1},\tsunknown{s'}.\tsvar{ps}_{1},\tsunknown{s'}.\tsvar{is}_{2},\tsunknown{s'}.\tsvar{ps}_{2}) \tsunknown{quad} = \tsunknown{sn} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{bound\_after} \;\tsunknown{sid'} \;\tstype{sid} \;\tsvar{bound}))) \}}
}
{\rulesubsection{Description}
This function returns a set of UDP sockets which the datagram with
address quad $\tsunknown{quad}$ may be delivered to. For FreeBSD and Linux there
is only one such socket; for WinXP there may be multiple.

For each socket in the finite map of sockets $\tsvar{socks}$, the score,
$\tsunknown{sn}$, of the matching of the socket's address quad and $\tsunknown{quad}$ is
computed using \ltslink{matchTscore}{$\tsaux{match\_score}$}.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
For FreeBSD, the set contains the sockets for which  the score is greater than zero and there is no other
socket in $\tsvar{socks}$ with a higher score.

\\\hline
Linux
&
For Linux, the set contains the sockets for which the score is greater than zero, there are no sockets
with a higher score, and the socket was bound to its local port after
all the other sockets with the same score.

\\\hline
WinXP
&
For WinXP, the set contains all the sockets with score greater than one and also the sockets for which the score is one, $\tsunknown{sn}=1$, and there are no sockets
with greater scores.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\defntcpTsocketTbestTmatch}{\ddefnc{tcpTsocketTbestTmatch}{\iA{tcp\_socket\_best\_match}}{\subddefnA[{ the set of sockets matching a quad, for TCP }]{tcp\_socket\_best\_match}{\tsaux{tcp\_socket\_best\_match} (\tsvar{socks} : \tstype{sid} \mapsto  \tslib{socket}) (\tstype{sid},\tsunknown{sock}) (\tsunknown{seg} : \tstype{tcpSegment}) \tstype{arch} ={}\\{}
 \tscomm{ is the socket sid the best match for segment seg? }{}\\{}
 \Mlet  \;\tsunknown{s} = \tsunknown{sock} \;\Min {}\\{}
 \Mlet  \;\tsunknown{score} = \tsaux{match\_score} (\tsunknown{s}.\tsvar{is}_{1}, \tsunknown{s}.\tsvar{ps}_{1}, \tsunknown{s}.\tsvar{is}_{2}, \tsunknown{s}.\tsvar{ps}_{2}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsholop{THE} \;\tsunknown{seg}.\tsvar{is}_{1}, \tsunknown{seg}.\tsvar{ps}_{1}, \tsholop{THE} \;\tsunknown{seg}.\tsvar{is}_{2}, \tsunknown{seg}.\tsvar{ps}_{2}) \Min {}\\{}
 \neg{}(\exists (\tsunknown{sid'},\tsunknown{s'}) \Mcons  \tsvar{socks} \backslash{}\backslash{} \tstype{sid}.{}\\{}
\quad\quad\quad\quad\quad \tsaux{match\_score} (\tsunknown{s'}.\tsvar{is}_{1}, \tsunknown{s'}.\tsvar{ps}_{1}, \tsunknown{s'}.\tsvar{is}_{2}, \tsunknown{s'}.\tsvar{ps}_{2}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsholop{THE} \;\tsunknown{seg}.\tsvar{is}_{1}, \tsunknown{seg}.\tsvar{ps}_{1}, \tsholop{THE} \;\tsunknown{seg}.\tsvar{is}_{2}, \tsunknown{seg}.\tsvar{ps}_{2}) > \tsunknown{score})}
}
{\rulesubsection{Description}
 This function determines whether a given socket $\tstype{sid}$ is the best match for a
 received TCP segment $\tsunknown{seg}$.

 The score (obtained using \ltslink{matchTscore}{$\tsaux{match\_score}$}) for the given
 socket is determined, and compared with the score for each other
 socket in $\tsvar{socks}$.  If none have a greater score, this is the best
 match and true is returned; otherwise, false is returned.


\rrulepad }
}

\newcommand{\defnlookupTicmp}{\ddefnc{lookupTicmp}{\iA{lookup\_icmp}}{\subddefnA[{ the set of sockets matching a quad, for ICMP }]{lookup\_icmp}{\tsaux{lookup\_icmp} \;\tsvar{socks} \;\tsunknown{icmp} \;\tstype{arch} \;\tsvar{bound} ={}\\{}
\quad \{ \tsunknown{sid0} \mid  \exists  (\tstype{sid},\tsunknown{sock}) \Mcons  \tsvar{socks}.{}\\{}
\quad\quad\quad\quad\quad \tsunknown{sock}.\tsvar{ps}_{1} = \tsunknown{icmp}.\tsvar{ps}_{3} \Mwedge  \tsaux{proto\_of} \;\tsunknown{sock}.\tsvar{pr} = \tsunknown{icmp}.\tsvar{proto} \Mwedge  \tsunknown{sid0} = \tstype{sid} \Mwedge {}\\{}
\quad\quad\quad\quad\quad \Mif  \;\tsaux{windows\_arch} \;\tstype{arch} \;\Mthen  \;\Mtrue {}\\{}
\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsunknown{sock}.\tsvar{is}_{1} = \tsunknown{icmp}.\tsvar{is}_{3} \Mwedge  \tsunknown{sock}.\tsvar{is}_{2} = \tsunknown{icmp}.\tsvar{is}_{4} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad (\tsunknown{sock}.\tsvar{ps}_{2} = \tsunknown{icmp}.\tsvar{ps}_{4} \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad (\tsaux{linux\_arch} \;\tstype{arch} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{proto\_of} \;\tsunknown{sock}.\tsvar{pr} = \tscon{PROTO\_UDP} \Mwedge  \tsunknown{sock}.\tsvar{ps}_{2} = * \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \neg{}(\exists  (\tsunknown{sid'},\tsunknown{s}) \Mcons  (\tsvar{socks} \backslash{}\backslash{} \tstype{sid}).{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{1} = \tsunknown{icmp}.\tsvar{is}_{3} \Mwedge  \tsunknown{s}.\tsvar{is}_{2} = \tsunknown{icmp}.\tsvar{is}_{4} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{s}.\tsvar{ps}_{1} = \tsunknown{icmp}.\tsvar{ps}_{3} \Mwedge  \tsunknown{s}.\tsvar{ps}_{2} = \tsunknown{icmp}.\tsvar{ps}_{4} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{proto\_of} \;\tsunknown{s}.\tsvar{pr} = \tsunknown{icmp}.\tsvar{proto} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{bound\_after} \;\tsunknown{sid'} \;\tstype{sid} \;\tsvar{bound}){}\\{}
\quad\quad\quad\quad\quad\quad\quad )) \}}
}
{\rulesubsection{Description}

  This function returns the set of sockets matching a received ICMP
  datagram $\tsunknown{icmp}$.

  An ICMP datagram contains the initial portion of the header of the
  original message to which it is a response.  For a socket to match,
  it must at least be bound to the same port and protocol as the
  source of the original message.  Beyond this, architectures differ.
  Usually, the socket must be connected, and connected to the same
  port as the original destination; and the source and destination IP
  addresses must agree.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
  For Windows, the socket need not be connected, and the source and
  destination IP addresses need not agree; an ICMP is delivered to
  one socket bound to the same port and protocol as the original
  source.

\\\hline
Linux
&
  For Linux, UDP ICMPs may also be delivered to unconnected sockets,
  as long as no matching connected socket was bound more recently than
  that socket.

\\\hline
FreeBSD
&
  For FreeBSD, the behaviour is as described above.



\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommmiscTaux}{\clustersection{(TCP only)}{TCP Options}
\seccomm{
TCP option handling.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{do\_tcp\_options}$
&
&  Constrain the TCP timestamp option values that appear in an outgoing segment \\
$\tsrule{calculate\_tcp\_options\_len}$
&
&  Calculate the length consumed by the TCP options in a real TCP segment \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defndoTtcpToptions}{\ddefnn{doTtcpToptions}{\iA{do\_tcp\_options}}{\subddefnA[{ Constrain the TCP timestamp option values that appear in an outgoing segment }]{do\_tcp\_options}{\tsaux{do\_tcp\_options} \;\tsunknown{cb\_tf\_doing\_tstmp} \;\tsunknown{cb\_ts\_recent} \;\tsunknown{cb\_ts\_val}  ={}\\{}
 \Mif  \;\tsunknown{cb\_tf\_doing\_tstmp} \;\Mthen {}\\{}
\quad \Mlet  \;\tsunknown{ts\_ecr'} = \tsholop{option\_case}\Mspiii{(\tsaux{ts\_seq} \;0w)}{\MI }{(\tsaux{timewindow\_val\_of} \;\tsunknown{cb\_ts\_recent})} \Min {}\\{}
\quad\quad\quad \Msome (\tsunknown{cb\_ts\_val},\tsunknown{ts\_ecr'}){}\\{}
 \Melse {}\\{}
\quad\quad *}
}
{}
}

\newcommand{\defncalculateTtcpToptionsTlen}{\ddefnc{calculateTtcpToptionsTlen}{\iA{calculate\_tcp\_options\_len}}{\subddefnA[{ Calculate the length consumed by the TCP options in a real TCP segment }]{calculate\_tcp\_options\_len}{\tsaux{calculate\_tcp\_options\_len} \;\tsunknown{cb\_tf\_doing\_tstmp} ={}\\{}
 \Mif  \;\tsunknown{cb\_tf\_doing\_tstmp} \;\Mthen  \;12 \;\Melse  \;0 : \tstype{num}}
}
{\rulesubsection{Description}
This calculation omits
   window-scaling and mss options as these only appear in SYN segments during connection setup.
%
   The total length consumed by all options will always be a multiple of 4 bytes due to padding.
   If more TCP options were added to the model, the space consumed by options would be
   architecture/options/alignment/padding dependent.

\rrulepad }
}

\newcommand{\seccommauxTbuffers}{\clustersection{(TCP and UDP)}{Buffers, windows, and queues}
\seccomm{
Various functions that compute buffer sizes, window sizes, and
remaining send queue space.  Some of these computations are
architecture-specific.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{calculate\_buf\_sizes}$
&
&  Calculate buffer sizes for $\tsunknown{rcvbufsize}$, $\tsunknown{sndbufsize}$, $\tsfield{t\_maxseg}$, and $\tsfield{snd\_cwnd}$
\\
$\tsrule{calculate\_bsd\_rcv\_wnd}$
&
&   Calculation of $\tsfield{rcv\_wnd}$ \\
$\tsrule{send\_queue\_space}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defncalculateTbufTsizes}{\ddefnc{calculateTbufTsizes}{\iA{calculate\_buf\_sizes}}{\subddefnA[{ Calculate buffer sizes for $\tsunknown{rcvbufsize}$, $\tsunknown{sndbufsize}$, $\tsfield{t\_maxseg}$, and $\tsfield{snd\_cwnd}$
}]{calculate\_buf\_sizes}{\tsaux{calculate\_buf\_sizes} \;\tsunknown{cb\_t\_maxseg} \;\tsunknown{seg\_mss} \;\tsunknown{bw\_delay\_product\_for\_rt} \;\tsunknown{is\_local\_conn}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{rcvbufsize} \;\tsunknown{sndbufsize} \;\tsunknown{cb\_tf\_doing\_tstmp} \;\tstype{arch} ={}\\{}
 {}\\{}
 \Mlet  \;\tsunknown{t\_maxseg'} ={}\\{}
 \tsholcomm{ TCPv2p901 claims min 32 for "sanity"; FreeBSD4.6 has 64 in \wasverb{tcp\textunderscore{}mss()}.
         BSD has the route MTU if avail, or $\tsholop{MIN} \;\tsaux{MSSDFLT} (\tsunknown{link} \;\tsunknown{MTU})$ otherwise, as the first argument
         of the MIN below.  That is the same calculation as we did in $\tsrule{connect\_1}$. We don't repeat it,
         but use the cached value in $\tsvar{cb}.\tsfield{t\_maxseg}$. }{}\\{}
 \Mlet  \;\tsunknown{maxseg} = (\tsholop{MIN} \;\tsunknown{cb\_t\_maxseg} (\tsholop{MAX} \;64 (\tsholop{option\_case}\Mspiii{\tsaux{MSSDFLT}}{\MI }{\tsunknown{seg\_mss}}))) \Min {}\\{}
\quad\quad \Mif  \;\tsaux{linux\_arch} \;\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad \tsunknown{maxseg}{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad \tsholcomm{ BSD subtracts the size consumed by options in the TCP
            header post connection establishment. The WinXP and Linux
            behaviour has not been fully tested but it appears Linux
            does not do this and WinXP does. }{}\\{}
\quad\quad\quad \tsunknown{maxseg} - (\tsaux{calculate\_tcp\_options\_len} \;\tsunknown{cb\_tf\_doing\_tstmp}){}\\{}
 \Min {}\\{}
 \tsholcomm{ round down to multiple of cluster size if larger (as BSD).
    From BSD code; assuming true for WinXP for now }{}\\{}
 \Mlet  \;\tsunknown{t\_maxseg''} = \Mif  \;\tsaux{linux\_arch} \;\tstype{arch} \;\Mthen  \;\tsunknown{t\_maxseg'}  \tscomm{ from tests }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsaux{rounddown} \;\tsaux{MCLBYTES} \;\tsunknown{t\_maxseg'} \;\Min {}\\{}
 {}\\{}
 \tscomm{ buffootle: rcv }{}\\{}
 \Mlet  \;\tsunknown{rcvbufsize'} = \tsholop{option\_case}\Mspiii{\tsunknown{rcvbufsize}}{\MI }{\tsunknown{bw\_delay\_product\_for\_rt}} \Min {}\\{}
 \Mlet  (\tsunknown{rcvbufsize''},\tsunknown{t\_maxseg'''}) = (\Mif  \;\tsunknown{rcvbufsize'} < \tsunknown{t\_maxseg''}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mthen  (\tsunknown{rcvbufsize'},\tsunknown{rcvbufsize'}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  (\tsholop{MIN} \;\tsaux{SB\_MAX} (\tsaux{roundup} \;\tsunknown{t\_maxseg''} \;\tsunknown{rcvbufsize'}),{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{t\_maxseg''})) \Min {}\\{}
 {}\\{}
 \tscomm{ buffootle: snd }{}\\{}
 \Mlet  \;\tsunknown{sndbufsize'} = \tsholop{option\_case}\Mspiii{\tsunknown{sndbufsize}}{\MI }{\tsunknown{bw\_delay\_product\_for\_rt}} \Min {}\\{}
 \Mlet  \;\tsunknown{sndbufsize''} = (\Mif  \;\tsunknown{sndbufsize'} < \tsunknown{t\_maxseg'''}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mthen  \;\tsunknown{sndbufsize'}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsholop{MIN} \;\tsaux{SB\_MAX} (\tsaux{roundup} \;\tsunknown{t\_maxseg''} \;\tsunknown{sndbufsize'})) \Min {}\\{}
 {}\\{}
 \Mlet  \;\tsunknown{do\_rfc3390} = \Mfalse  \;\Min  \tslongcomm{ FIXME - fine in FreeBSD 4.6, may become T in
                                FreeBSD 6.0 }{}\\{}
 {}\\{}
 \tscomm{ compute initial cwnd }{}\\{}
 \Mlet  \;\tsfield{snd\_cwnd} ={}\\{}
 \Mif  \;\tsunknown{do\_rfc3390} \;\Mthen  \;\tsholop{MIN} (4 * \tsunknown{t\_maxseg'''}) (\tsholop{MAX} (2 * \tsunknown{t\_maxseg'''}) 4380){}\\{}
 \Melse {}\\{}
\quad (\tsunknown{t\_maxseg'''} * (\Mif  \;\tsunknown{is\_local\_conn} \;\Mthen  \;\tsaux{SS\_FLTSZ\_LOCAL} \;\Melse  \;\tsaux{SS\_FLTSZ})) \Min {}\\{}
 (\tsunknown{rcvbufsize''},\tsunknown{sndbufsize''},\tsunknown{t\_maxseg'''},\tsfield{snd\_cwnd})}
}
{\rulesubsection{Description}
Used in $\tsrule{deliver\_in\_1}$ and $\tsrule{deliver\_in\_2}$.
\rrulepad }
}

\newcommand{\defncalculateTbsdTrcvTwnd}{\ddefnc{calculateTbsdTrcvTwnd}{\iA{calculate\_bsd\_rcv\_wnd}}{\subddefnA[{  Calculation of $\tsfield{rcv\_wnd}$ }]{calculate\_bsd\_rcv\_wnd}{\tsaux{calculate\_bsd\_rcv\_wnd} \;\tsvar{sf} \;\tsunknown{tcp\_sock} ={}\\{}
 \tsholop{MAX} (\tsholop{Num} (\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{rcv\_adv} - \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{rcv\_nxt})){}\\{}
\quad (\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) - \tsholop{LENGTH} \;\tsunknown{tcp\_sock}.\tsvar{rcvq})}
}
{\rulesubsection{Description}
 Calculation of $\tsfield{rcv\_wnd}$ as done in BSD's \wasverb{tcp\textunderscore{}input.c}, line 1052. The model currently calls this from
   $\tsaux{tcp\_output\_really}$ in post-ESTABLISHED states, using $\tsrule{deliver\_in\_3}$ to update $\tsfield{rcv\_wnd}$ as
   soon as a segment comes, rather than waiting for the next $\tsunknown{deliver\_in}$, as BSD does --- this
   is a saner thing to do. In order to comply with BSD however, we need $\tsunknown{calculate\_bsd\_rcv}$
   to be called on receipt of the first 'real' (i.e. non-syncache) segment, to update $\tsfield{rcv\_wnd}$
   from the temporary initial value.

\rrulepad }
}

\newcommand{\defnsendTqueueTspace}{\ddefnc{sendTqueueTspace}{\iA{send\_queue\_space}}{\subddefnA{send\_queue\_space}{\tsaux{send\_queue\_space} (\tsunknown{sndq\_max} : \tstype{num}) \tsunknown{sndq\_size} \;\tsunknown{oob} \;\tstype{arch} \;\tsunknown{maxseg} \;\tsvar{i}_{2} ={}\\{}
\quad \{ \tsvar{n} \mid  \Mif  \;\tsaux{bsd\_arch} \;\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \tsvar{n} \leq  (\tsunknown{sndq\_max} - \tsunknown{sndq\_size}) + (\Mif  \;\tsunknown{oob} \;\Mthen  \;\tsaux{oob\_extra\_sndbuf} \;\Melse  \;0){}\\{}
\quad\quad\quad\quad \Melse  \;\Mif  \;\tsaux{linux\_arch} \;\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad (\Mif  \;\tsaux{in\_loopback} \;\tsvar{i}_{2} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{n} = \tsunknown{maxseg} + ((\tsunknown{sndq\_max} - \tsunknown{sndq\_size}) \tsholop{DIV} \;16816) * \tsunknown{maxseg}{}\\{}
\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{n} = (2 * \tsunknown{maxseg}) + ((\tsunknown{sndq\_max} - \tsunknown{sndq\_size} - 1890) \tsholop{DIV} \;1888) * \tsunknown{maxseg}){}\\{}
\quad\quad\quad\quad \Melse  \;\tsvar{n} \geq  0 \}}
}
{\rulesubsection{Description}
   Calculation of the usable send queue space.

   FreeBSD calculates send buffer space based on the byte-count size and
   max, and the number and max of mbufs. As we do not model mbuf usage precisely we are somewhat nondeterministic
   here.

   Linux calculates it based on the MSS: the space is some multiple of
   the MSS; the number of bytes for each MSS-sized segment is the
   MSS+overhead where overhead is 420+(20 if using IP), which is why
   the i2 argument is needed.

   Windows is very strange.  Leaving it completely unconstrained is not
   what actually happens, but more investigation is needed in future to determine the actual behaviour.


\rrulepad }
}

\newcommand{\seccommauxTbandlim}{\clustersection{(TCP and UDP)}{Band limiting}
\seccomm{
The rate of emission of certain TCP and ICMP responses from a host is
often controlled by a bandwidth limiter.  This limits resource usage
in the event of some error conditions, and also defends against
certain denial-of-service attacks.

Responses that may be bandlimited are grouped into categories
($\tstype{bandlim\_reason}$), and bandlimiting is applied to each category
separately.  Bandlimiting is applied across the entire host, not per
socket or process.  There are a range of different schemes that may be
used, from none at all, through limiting the number of packets in any
given second, to a decaying average tuned to limit bursts and
sustained throughput differently.  We provide specifications for the
first two.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{bandlim\_state\_init}$
&
&  initial state of bandlimiter \\
$\tsrule{bandlim\_rst\_ok\_always}$
&
&  the trivial 'always OK' bandlimiter \\
$\tsrule{simple\_limit}$
&
&  simple-bandlimiter rate settings \\
$\tsrule{bandlim\_rst\_ok\_simple}$
&
&  a simple rate-limiting bandlimiter \\
$\tsrule{bandlim\_rst\_ok}$
&
&  the bandlimiter actually used \\
$\tsrule{enqueue\_oq\_bndlim\_rst}$
&
&  enqueue onto out-queue if allowed by bandlimiter \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnbandlimTstateTinit}{\ddefnc{bandlimTstateTinit}{\iA{bandlim\_state\_init}}{\subddefnA[{ initial state of bandlimiter }]{bandlim\_state\_init}{\tsaux{bandlim\_state\_init} = [\,] : \tsunknown{bandlim\_state}}
}
{}
}

\newcommand{\defnbandlimTrstTokTalways}{\ddefnc{bandlimTrstTokTalways}{\iA{bandlim\_rst\_ok\_always}}{\subddefnA[{ the trivial 'always OK' bandlimiter }]{bandlim\_rst\_ok\_always}{(\tsaux{bandlim\_rst\_ok\_always} : \tstype{tcpSegment} \# \tsaux{ts\_seq} \# \tstype{bandlim\_reason} \# \tsunknown{bandlim\_state} \Mtotype  \tstype{bool} \# \tsunknown{bandlim\_state}){}\\{}
\quad (\tsunknown{seg},\tsvar{ticks},\tsunknown{reason},\tsvar{bndlm}){}\\{}
\quad = \Mlet  \;\tsvar{bndlm}' = (\tsunknown{seg},\tsvar{ticks},\tsunknown{reason})\Mcons \tsvar{bndlm}{}\\{}
\quad\quad \Min {}\\{}
\quad\quad (\Mtrue ,\tsvar{bndlm}')}
}
{}
}

\newcommand{\defnsimpleTlimit}{\ddefnc{simpleTlimit}{\iA{simple\_limit}}{\subddefnA[{ simple-bandlimiter rate settings }]{simple\_limit}{(\tsaux{simple\_limit} : \tstype{bandlim\_reason} \Mtotype  \tstype{num} \;\;\tstype{option}){}\\{}
\quad\quad\quad\quad\quad \tscon{BANDLIM\_UNLIMITED}      = * \Mwedge {}\\{}
 \tsaux{simple\_limit} \;\tscon{BANDLIM\_RST\_CLOSEDPORT} = \Msome  \;200 \Mwedge {}\\{}
 \tsaux{simple\_limit} \;\tscon{BANDLIM\_RST\_OPENPORT}   = \Msome  \;200}
}
{}
}

\newcommand{\defnbandlimTrstTokTsimple}{\ddefnc{bandlimTrstTokTsimple}{\iA{bandlim\_rst\_ok\_simple}}{\subddefnA[{ a simple rate-limiting bandlimiter }]{bandlim\_rst\_ok\_simple}{(\tsaux{bandlim\_rst\_ok\_simple} : \tstype{tcpSegment} \# \tsaux{ts\_seq} \# \tstype{bandlim\_reason} \# \tsunknown{bandlim\_state} \Mtotype  \tstype{bool} \# \tsunknown{bandlim\_state}){}\\{}
\quad\quad\quad\quad\quad\quad (\tsunknown{seg},\tsvar{ticks},\tsunknown{reason},\tsvar{bndlm}){}\\{}
 = \Mlet  \;\tsunknown{reasoneq} = (\lambda  \tsvar{r}_{0}. \lambda  (\tsunknown{s},\tsvar{t},\tsunknown{r}). \tsunknown{r} = \tsvar{r}_{0}){}\\{}
\quad \Mand  \;\tsunknown{ticksgt}  = (\lambda  \tsvar{t}_{0}. \lambda  (\tsunknown{s},\tsvar{t},\tsunknown{r}). \tsvar{t} > \tsvar{t}_{0}){}\\{}
\quad \Min {}\\{}
\quad \Mlet  \;\tsunknown{count} = \tsholop{LENGTH} (\tsholop{FILTER} (\tsunknown{reasoneq} \;\tsunknown{reason}) (\tsaux{TAKEWHILE} (\tsunknown{ticksgt} (\tsvar{ticks} - \tsaux{num\_floor} (1 * \tsaux{HZ}))) \tsvar{bndlm})){}\\{}
\quad \Min {}\\{}
\quad ((\Mcase  \;\tsaux{simple\_limit} \;\tsunknown{reason} \;\Mof {}\\{}
\quad\quad\quad *   \Mtotype  \Mtrue {}\\{}
\quad\quad \Mdpipe  \Msome  \;\tsvar{n} \Mtotype  \tsunknown{count} < \tsvar{n}),{}\\{}
\quad (\tsunknown{seg},\tsvar{ticks},\tsunknown{reason})\Mcons \tsvar{bndlm})}
}
{\rulesubsection{Description}
 Simple bandlimiter: limit number of ICMPs in the last second to the listed value.  This is based roughly on the BSD behaviour, save that for BSD it is "since the
   last second" not "in the last second".

\rrulepad }
}

\newcommand{\defnbandlimTrstTok}{\ddefnc{bandlimTrstTok}{\iA{bandlim\_rst\_ok}}{\subddefnA[{ the bandlimiter actually used }]{bandlim\_rst\_ok}{\tsaux{bandlim\_rst\_ok} = \tsaux{bandlim\_rst\_ok\_simple}}
}
{\rulesubsection{Description}
 Which band limiter to use?

\rrulepad }
}

\newcommand{\defnenqueueToqTbndlimTrst}{\ddefnc{enqueueToqTbndlimTrst}{\iA{enqueue\_oq\_bndlim\_rst}}{\subddefnA[{ enqueue onto out-queue if allowed by bandlimiter }]{enqueue\_oq\_bndlim\_rst}{\tsaux{enqueue\_oq\_bndlim\_rst}(\tsvar{oq},\tsunknown{seg},\tsvar{ticks},\tsunknown{reason},\tsvar{bndlm},\tsvar{oq}',\tsvar{bndlm}',\tsunknown{queued\_or\_dropped}){}\\{}
 = \Mlet  (\tsunknown{emit},\tsvar{bndlm}_{0}) = \tsaux{bandlim\_rst\_ok}(\tsunknown{seg},\tsvar{ticks},\tsunknown{reason},\tsvar{bndlm}){}\\{}
 \Min {}\\{}
 \tsvar{bndlm}' = \tsvar{bndlm}_{0} \Mwedge {}\\{}
 \Mif  \;\tsunknown{emit} \;\Mthen {}\\{}
\quad \tsaux{enqueue\_oq}(\tsvar{oq},\tscon{TCP} \;\tsunknown{seg},\tsvar{oq}',\tsunknown{queued\_or\_dropped}){}\\{}
 \Melse {}\\{}
\quad (\tsvar{oq}' = \tsvar{oq} \Mwedge  \tsunknown{queued\_or\_dropped} = \Mtrue )}
}
{\rulesubsection{Description}
For convenience, combine enqueueing and bandlimiting into a single function.


\rrulepad }
}

\newcommand{\seccommauxTudp}{\clustersection{(UDP only)}{UDP support}
\seccomm{
Performing a UDP send, filling in required details as necessary.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{dosend}$
&
&  do a UDP send, filling in source address and port as necessary \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defndosend}{\ddefnc{dosend}{\iA{dosend}}{\subddefnA[{ do a UDP send, filling in source address and port as necessary }]{dosend}{(\tsaux{dosend} (\tsvar{ifds}, \tsvar{rttab}, (*, \tsvar{data}), (\Msome  \;\tsvar{i}_{1}, \Msome  \;\tsvar{p}_{1}, \Msome  \;\tsvar{i}_{2}, \tsvar{ps}_{2}), \tsvar{oq}, \tsvar{oq}', \tsunknown{ok}) ={}\\{}
 \tsaux{enqueue\_oq}(\tsvar{oq},\tscon{UDP}(\Mmagiclrec  \tsvar{is}_{1} \Mass  \Msome  \;\tsvar{i}_{1}; \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}_{1}; \tsvar{ps}_{2} \Mass  \tsvar{ps}_{2};{}\\{}
 \tsvar{data} \Mass  \tsvar{data} \Mmagicrrec ),{}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{oq}',\tsunknown{ok})) \Mwedge {}\\{}
 (\tsaux{dosend} (\tsvar{ifds}, \tsvar{rttab}, (\Msome (\tsunknown{i},\tsunknown{p}), \tsvar{data}), (*, \Msome  \;\tsvar{p}_{1}, *, *), \tsvar{oq}, \tsvar{oq}', \tsunknown{ok}) ={}\\{}
 (\exists \tsvar{i}'_{1}.\tsaux{enqueue\_oq}(\tsvar{oq},\tscon{UDP}(\Mmagiclrec  \tsvar{is}_{1} \Mass  \Msome  \;\tsvar{i}'_{1}; \tsvar{is}_{2} \Mass  \Msome  \;\tsunknown{i};{}\\{}
 \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}_{1};  \tsvar{ps}_{2} \Mass  \Msome  \;\tsunknown{p};{}\\{}
 \tsvar{data} \Mass  \tsvar{data} \Mmagicrrec ),{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{oq}',\tsunknown{ok}) \Mwedge  \tsvar{i}'_{1} \;\in  \;\tsaux{auto\_outroute}(\tsunknown{i},*,\tsvar{rttab},\tsvar{ifds}))) \Mwedge {}\\{}
 (\tsaux{dosend} (\tsvar{ifds}, \tsvar{rttab}, (\Msome (\tsunknown{i},\tsunknown{p}), \tsvar{data}),(\Msome  \;\tsvar{i}_{1}, \Msome  \;\tsvar{p}_{1}, \tsvar{is}_{2}, \tsvar{ps}_{2}), \tsvar{oq}, \tsvar{oq}', \tsunknown{ok}) ={}\\{}
 \tsaux{enqueue\_oq}(\tsvar{oq},\tscon{UDP}(\Mmagiclrec  \tsvar{is}_{1} \Mass  \Msome  \;\tsvar{i}_{1}; \tsvar{is}_{2} \Mass  \Msome  \;\tsunknown{i};{}\\{}
 \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}_{1}; \tsvar{ps}_{2} \Mass  \Msome  \;\tsunknown{p};{}\\{}
 \tsvar{data} \Mass  \tsvar{data} \Mmagicrrec ),{}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{oq}',\tsunknown{ok}))}
}
{\rulesubsection{Description}
 For use in UDP $\tsunknown{sendto}()$.

\rrulepad }
}

\newcommand{\seccommauxTtcptime}{\clustersection{(TCP only)}{TCP timing and RTT}
\seccomm{
TCP performs repeated transmissions in three situations:
retransmission of unacknowledged data, retransmission of an
unacknowledged SYN, and probing a closed window (`persisting').  In
each case the interval between transmissions is a function of the
estimated round-trip time for the connection, and is exponentially
backed off if no response is received.  The RTT estimate indicates
when TCP should expect a reply, and the exponential backoff controls
TCP's resource usage.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{tcp\_backoffs}$
&
&  select this architecture's retransmit backoff list \\
$\tsrule{tcp\_syn\_backoffs}$
&
&  select this architecture's $\tsvar{SYN}$-retransmit backoff list \\
$\tsrule{mode\_of}$
&
&  obtain the mode of a backoff timer \\
$\tsrule{shift\_of}$
&
&  obtain the shift of a backoff timer \\
$\tsrule{computed\_rto}$
&
&  compute retransmit timeout to use \\
$\tsrule{computed\_rxtcur}$
&
&  compute the last-used $\tsunknown{rxtcur}$ \\
$\tsrule{start\_tt\_rexmt\_gen}$
&
&  construct retransmit timer (generic) \\
$\tsrule{start\_tt\_rexmt}$
&
&  construct normal retransmit timer \\
$\tsrule{start\_tt\_rexmtsyn}$
&
&  construct $\tsvar{SYN}$-retransmit timer \\
$\tsrule{start\_tt\_persist}$
&
&  construct persist timer \\
$\tsrule{update\_rtt}$
&
&  update RTT estimators from new measurement \\
$\tsrule{expand\_cwnd}$
&
&  expand congestion window \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntcpTbackoffs}{\ddefnc{tcpTbackoffs}{\iA{tcp\_backoffs}}{\subddefnA[{ select this architecture's retransmit backoff list }]{tcp\_backoffs}{\tsaux{tcp\_backoffs} (\tstype{arch}: \tstype{arch}) ={}\\{}
 \Mif  \;\tsaux{bsd\_arch} \;\tstype{arch} \;\Mthen  \;\tsaux{TCP\_BSD\_BACKOFFS}{}\\{}
 \Melse  \;\Mif  \;\tsaux{linux\_arch} \;\tstype{arch} \;\Mthen  \;\tsaux{TCP\_LINUX\_BACKOFFS}{}\\{}
 \Melse  \;\Mif  \;\tsaux{windows\_arch} \;\tstype{arch} \;\Mthen  \;\tsaux{TCP\_WINXP\_BACKOFFS}{}\\{}
 \Melse  \;\tsaux{TCP\_BSD\_BACKOFFS} \tscomm{ default to BSD }}
}
{}
}

\newcommand{\defntcpTsynTbackoffs}{\ddefnn{tcpTsynTbackoffs}{\iA{tcp\_syn\_backoffs}}{\subddefnA[{ select this architecture's $\tsvar{SYN}$-retransmit backoff list }]{tcp\_syn\_backoffs}{\tsaux{tcp\_syn\_backoffs} (\tstype{arch}: \tstype{arch}) ={}\\{}
 \Mif  \;\tsaux{bsd\_arch} \;\tstype{arch} \;\Mthen  \;\tsaux{TCP\_SYN\_BSD\_BACKOFFS}{}\\{}
 \Melse  \;\Mif  \;\tsaux{linux\_arch} \;\tstype{arch} \;\Mthen  \;\tsaux{TCP\_SYN\_LINUX\_BACKOFFS}{}\\{}
 \Melse  \;\Mif  \;\tsaux{windows\_arch} \;\tstype{arch} \;\Mthen  \;\tsaux{TCP\_SYN\_WINXP\_BACKOFFS}{}\\{}
 \Melse  \;\tsaux{TCP\_SYN\_BSD\_BACKOFFS} \tscomm{ default to BSD }}
}
{}
}

\newcommand{\defnmodeTof}{\ddefnc{modeTof}{\iA{mode\_of}}{\subddefnA[{ obtain the mode of a backoff timer }]{mode\_of}{(\tsaux{mode\_of} : (\tstype{rexmtmode} \# \tstype{num}) \tstype{timed} \;\;\tstype{option} \Mtotype  \tstype{rexmtmode} \;\;\tstype{option}){}\\{}
\quad\quad (\Msome  (\Mtimed{(\tsunknown{mode},\tsunknown{\_})}{\tsunknown{\_}})) = \Msome  \;\tsunknown{mode} \Mwedge {}\\{}
 \tsaux{mode\_of}  \;*                      = *}
}
{}
}

\newcommand{\defnshiftTof}{\ddefnc{shiftTof}{\iA{shift\_of}}{\subddefnA[{ obtain the shift of a backoff timer }]{shift\_of}{\tsaux{shift\_of} (\Msome  (\Mtimed{(\tsunknown{\_},\tsunknown{shift})}{\tsunknown{\_}})) = \tsunknown{shift}}
}
{\rulesubsection{Description}
 TCP exponential-backoff timers are represented as $(\tstype{rexmtmode} \# \tstype{num}) \tstype{timed} \;\;\tstype{option}$,
   where $\tsunknown{mode} : \tstype{rexmtmode}$ is the current TCP output mode (see \ltslink{rexmtmode}{$\tstype{rexmtmode}$}), and
   $\tsunknown{shift} : \tstype{num}$ is the 0-origin index into the backoff list of the
   interval \emph{currently underway}.

\rrulepad }
}

\newcommand{\defncomputedTrto}{\ddefnc{computedTrto}{\iA{computed\_rto}}{\subddefnA[{ compute retransmit timeout to use }]{computed\_rto}{\tsaux{computed\_rto} (\tsunknown{backoffs}:\tstype{num} \;\tstype{list}) (\tsunknown{shift}:\tstype{num}) (\tsunknown{ri}:\tstype{rttinf}){}\\{}
 = \tsholop{real\_of\_num} (\tsunknown{EL} \;\tsunknown{shift} \;\tsunknown{backoffs}) *{}\\{}
 \tsholop{MAX} \;\tsunknown{ri}.\tsfield{t\_rttmin} (\tsunknown{ri}.\tsfield{t\_srtt}     + 4 * \tsunknown{ri}.\tsfield{t\_rttvar})}
}
{}
}

\newcommand{\defncomputedTrxtcur}{\ddefnc{computedTrxtcur}{\iA{computed\_rxtcur}}{\subddefnA[{ compute the last-used $\tsunknown{rxtcur}$ }]{computed\_rxtcur}{\tsaux{computed\_rxtcur} (\tsunknown{ri}:\tstype{rttinf}) (\tstype{arch}: \tstype{arch}){}\\{}
 = \tsholop{MAX} \;\tsunknown{ri}.\tsfield{t\_rttmin}{}\\{}
\quad\quad (\tsholop{MIN} (\tsholop{THE} \;\tsaux{TCPTV\_REXMTMAX}){}\\{}
\quad\quad\quad\quad\quad (\tsaux{computed\_rto} (\Mif  \;\tsunknown{ri}.\tsfield{t\_wassyn} \;\Mthen  \;\tsaux{tcp\_syn\_backoffs} \;\tstype{arch}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsaux{tcp\_backoffs} \;\tstype{arch}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{ri}.\tsfield{t\_lastshift} \;\tsunknown{ri}))}
}
{\rulesubsection{Description}

 $\tsaux{computed\_rto}$ computes the retransmit timeout to be used, from the
 backoff list, the shift, and the current RTT estimators.  The base
 time is $\mathit{RTT} + 4\mathit{RTTVAR}$; this is clipped against a
 minimum value, and then multiplied by the value from the backoff
 list.

 $\tsaux{computed\_rxtcur}$ is not used in constructing timers, but
 $\tsunknown{tcp\_output}$ uses it to check if TCP has been idle for a while
 (causing slow start to be entered again).  It is an approximation to
 the value actually used below.  Note it might be possible to make
 this precise rather than an approximation; also, $\tsunknown{computed\_rxmtcur}$
 and $\tsaux{start\_tt\_rexmt\_gen}$ could be merged.

 Note: $\tsaux{TCPTV\_REXMTMAX}$ had better not be infinite!


\rrulepad }
}

\newcommand{\defnstartTttTrexmtTgen}{\ddefnc{startTttTrexmtTgen}{\iA{start\_tt\_rexmt\_gen}}{\subddefnA[{ construct retransmit timer (generic) }]{start\_tt\_rexmt\_gen}{\tsaux{start\_tt\_rexmt\_gen} (\tsunknown{mode}:\tstype{rexmtmode}) (\tsunknown{backoffs}:\tstype{num} \;\tstype{list}) (\tsunknown{shift}:\tstype{num}) (\tsunknown{wantmin}:\tstype{bool}) (\tsunknown{ri}:\tstype{rttinf}){}\\{}
 = \Mlet  \;\tsunknown{rxtcur} = \tsholop{MAX} (\Mif  \;\tsunknown{wantmin}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mthen  \;\tsholop{MAX} \;\tsunknown{ri}.\tsfield{t\_rttmin} (\tsunknown{ri}.\tsfield{t\_lastrtt} + 2/\tsaux{HZ}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsunknown{ri}.\tsfield{t\_rttmin}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsholop{MIN} (\tsholop{THE} \;\tsaux{TCPTV\_REXMTMAX} \tscomm{ better not be infinite! } ){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsaux{computed\_rto} \;\tsunknown{backoffs} \;\tsunknown{shift} \;\tsunknown{ri}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad ){}\\{}
 \Min {}\\{}
 \Msome  (\Mtimed{(\tsunknown{mode},\tsunknown{shift})}{\tsaux{slow\_timer} (\tstype{time} \;\tsunknown{rxtcur})})}
}
{}
}

\newcommand{\defnstartTttTrexmt}{\ddefnc{startTttTrexmt}{\iA{start\_tt\_rexmt}}{\subddefnA[{ construct normal retransmit timer }]{start\_tt\_rexmt}{\tsaux{start\_tt\_rexmt} (\tstype{arch}: \tstype{arch}) = \tsaux{start\_tt\_rexmt\_gen} \;\tscon{Rexmt} (\tsaux{tcp\_backoffs} \;\tstype{arch})}
}
{}
}

\newcommand{\defnstartTttTrexmtsyn}{\ddefnc{startTttTrexmtsyn}{\iA{start\_tt\_rexmtsyn}}{\subddefnA[{ construct $\tsvar{SYN}$-retransmit timer }]{start\_tt\_rexmtsyn}{\tsaux{start\_tt\_rexmtsyn} (\tstype{arch}: \tstype{arch}) = \tsaux{start\_tt\_rexmt\_gen} \;\tscon{RexmtSyn} (\tsaux{tcp\_syn\_backoffs} \;\tstype{arch})}
}
{}
}

\newcommand{\defnstartTttTpersist}{\ddefnc{startTttTpersist}{\iA{start\_tt\_persist}}{\subddefnA[{ construct persist timer }]{start\_tt\_persist}{\tsaux{start\_tt\_persist} (\tsunknown{shift}:\tstype{num}) (\tsunknown{ri}:\tstype{rttinf}) (\tstype{arch}: \tstype{arch}){}\\{}
 = \Mlet  \;\tsunknown{cur} = \tsholop{MAX} (\tsholop{THE} \;\tsaux{TCPTV\_PERSMIN} \tscomm{ better not be infinite! } ){}\\{}
\quad\quad\quad\quad\quad\quad\quad (\tsholop{MIN} (\tsholop{THE} \;\tsaux{TCPTV\_PERSMAX} \tscomm{ better not be infinite! } ){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsaux{computed\_rto} (\tsaux{tcp\_backoffs} \;\tstype{arch}) \tsunknown{shift} \;\tsunknown{ri}){}\\{}
\quad\quad\quad\quad\quad\quad\quad ){}\\{}
 \Min {}\\{}
 \Msome  (\Mtimed{(\tscon{Persist},\tsunknown{shift})}{\tsaux{slow\_timer} (\tstype{time} \;\tsunknown{cur})})}
}
{\rulesubsection{Description}

 Starting the retransmit, $\tsvar{SYN}$-retransmit, and persist timers:
   these function return the new timer with the given shift.  This
   models both initialisation on receiving a segment, and update in
   the retransmit timer handler.

 There are two alternative clipping values used for the minimum timer.
 $\tsunknown{ri}.\tsfield{t\_rttmin}$ is used always, but in one place $\tsvar{t}.\tsunknown{last\_rtt}+2/\tsaux{HZ}$
 (i.e., 0.02s plus the last measured RTT) is used as well.  The BSD
 sources have a comment here saying "minimum feasible timer"; it is a
 puzzle why this value is not used elsewhere also.  (tcp\_input.c:2408
 vs tcp\_timer.c:394, tcp\_input.c:2542).

  Starting the persist timer is similar to starting the retransmit
  timers, but the bounds are different.

 Note that we don't need to look at $\tsunknown{tf\_srttvalid}$, since in any case
   $\tsfield{t\_srtt}$ and $\tsfield{t\_rttvar}$ will have sensible values.  That flag is just
   for the benefit of $\tsaux{update\_rtt}$.


\rrulepad }
}

\newcommand{\defnupdateTrtt}{\ddefnc{updateTrtt}{\iA{update\_rtt}}{\subddefnA[{ update RTT estimators from new measurement }]{update\_rtt}{\tsaux{update\_rtt} (\tsunknown{rtt}:\tsaux{duration}) (\tsunknown{ri}:\tstype{rttinf}){}\\{}
 = \Mlet  (\tsunknown{t\_srtt'},\tsunknown{t\_rttvar'}){}\\{}
\quad = (\Mif  \;\tsunknown{ri}.\tsfield{tf\_srtt\_valid} \;\Mthen {}\\{}
\quad\quad\quad\quad \Mlet  \;\tsunknown{delta}     = (\tsunknown{rtt} - 1/\tsaux{HZ}) - \tsunknown{ri}.\tsfield{t\_srtt}{}\\{}
\quad\quad\quad\quad \Min {}\\{}
\quad\quad\quad\quad \Mlet  \;\tsunknown{vardelta}  = \tsunknown{abs} \;\tsunknown{delta} - \tsunknown{ri}.\tsfield{t\_rttvar}{}\\{}
\quad\quad\quad\quad \Min {}\\{}
\quad\quad\quad\quad \Mlet  \;\tsunknown{t\_srtt'}   = \tsholop{MAX} (1/(32*\tsaux{HZ})) (\tsunknown{ri}.\tsfield{t\_srtt} + (1/8) * \tsunknown{delta}){}\\{}
\quad\quad\quad\quad \Mand  \;\tsunknown{t\_rttvar'} = \tsholop{MAX} (1/(16*\tsaux{HZ})) (\tsunknown{ri}.\tsfield{t\_rttvar} + (1/4) * \tsunknown{vardelta}){}\\{}
\quad\quad\quad\quad\quad\quad \tslongcomm{ BSD behaviour is never to let these go to zero,
                    but clip at the least positive value.  Since SRTT
                    is measured in 1/32 tick and RTTVAR in 1/16 tick,
                    these are the minimum values.  A more natural
                    implementation would clip these to zero. }{}\\{}
\quad\quad\quad\quad \Min {}\\{}
\quad\quad\quad\quad (\tsunknown{t\_srtt'},\tsunknown{t\_rttvar'}){}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad \Mlet  \;\tsunknown{t\_srtt'} = \tsunknown{rtt}{}\\{}
\quad\quad\quad\quad \Mand  \;\tsunknown{t\_rttvar'} = \tsunknown{rtt} / 2{}\\{}
\quad\quad\quad\quad \Min {}\\{}
\quad\quad\quad\quad (\tsunknown{t\_srtt'},\tsunknown{t\_rttvar'})){}\\{}
 \Min {}\\{}
 \tsunknown{ri} \; \Mmagiclrec  \tsfield{t\_rttupdated}  \Mass  \tsunknown{ri}.\tsfield{t\_rttupdated} + 1;{}\\{}
 \tsfield{tf\_srtt\_valid} \Mass  \Mtrue ;{}\\{}
 \tsfield{t\_srtt}        \Mass  \tsunknown{t\_srtt'};{}\\{}
 \tsfield{t\_rttvar}      \Mass  \tsunknown{t\_rttvar'};{}\\{}
 \tsfield{t\_lastrtt}     \Mass  \tsunknown{rtt};{}\\{}
 \tsfield{t\_lastshift}   \Mass  0;{}\\{}
 \tsfield{t\_wassyn}      \Mass  \Mfalse   \tscomm{ if t\textunderscore{}lastshift=0, this doesn't make a difference }{}\\{}
 \tscomm{ t\textunderscore{}softerror, t\textunderscore{}rttseg, and t\textunderscore{}rxtcur must be handled by the caller }{}\\{}
 \Mmagicbolrrec }
}
{\rulesubsection{Description}
 Update the round trip time estimators on obtaining a new instantaneous value.
 Based on a close reading of tcp\_xmit\_timer(), tcp\_input.c:2347-2419.

\rrulepad }
}

\newcommand{\defnexpandTcwnd}{\ddefnc{expandTcwnd}{\iA{expand\_cwnd}}{\subddefnA[{ expand congestion window }]{expand\_cwnd}{\tsaux{expand\_cwnd} \;\tsunknown{ssthresh} \;\tsunknown{maxseg} \;\tsunknown{maxwin} \;\tsunknown{cwnd}{}\\{}
 = \tsholop{MIN} \;\tsunknown{maxwin} (\tsunknown{cwnd} + (\Mif  \;\tsunknown{cwnd} > \tsunknown{ssthresh} \;\Mthen  (\tsunknown{maxseg} * \tsunknown{maxseg}) \tsholop{DIV} \;\tsunknown{cwnd} \;\Melse  \;\tsunknown{maxseg}))}
}
{\rulesubsection{Description}

 Congestion window expansion is linear or exponential depending on the
 current threshold $\tsunknown{ssthresh}$.


\rrulepad }
}

\newcommand{\seccommauxTpmtu}{\clustersection{(TCP only)}{Path MTU Discovery}
\seccomm{
For efficiency and reliability, it is best to send datagrams that do
not need to be fragmented in the network.  However, TCP has direct
access only to the maximum packet size (MTU) for the interfaces at
either end of the connection -- it has no information about routers
and links in between.

To determine the MTU for the entire path, TCP marks all datagrams `do
not fragment'.  It begins by sending a large datagram; if it receives
a `fragmentation needed' ICMP in return it reduces the size of the
datagram and repeats the process.  Most modern routers include the
link MTU in the ICMP message; if the message does not contain an MTU,
however, TCP uses the next lower MTU in the table below.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{next\_smaller}$
&
&  find next-smaller element of a set \\
$\tsrule{mtu\_tab}$
&
&  path MTU plateaus to try \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnnextTsmaller}{\ddefnc{nextTsmaller}{\iA{next\_smaller}}{\subddefnA[{ find next-smaller element of a set }]{next\_smaller}{(\tsaux{next\_smaller}:(\tstype{num}\Mtotype \tstype{bool}) \Mtotype  \tstype{num} \Mtotype  \tstype{num}) \tsvar{xs} \;\tsunknown{y} = @\tsvar{x}\Mcons \tsvar{xs}. \tsvar{x} < \tsunknown{y} \Mwedge  \forall \tsvar{x}'\Mcons \tsvar{xs}. \tsvar{x}' > \tsvar{x} \implies  \tsvar{x}' \geq  \tsunknown{y}}
}
{}
}

\newcommand{\defnmtuTtab}{\ddefnc{mtuTtab}{\iA{mtu\_tab}}{\subddefnA[{ path MTU plateaus to try }]{mtu\_tab}{\tsaux{mtu\_tab} \;\tstype{arch} = \Mif  \;\tsaux{linux\_arch} \;\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \{32000; 17914; 8166; 4352; 2002; 1492; 576; 296; 216; 128; 68\} : \tstype{num} \;\tstype{set}{}\\{}
\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \{65535; 32000; 17914; 8166; 4352; 2002; 1492; 1006; 508; 296; 68\}}
}
{\rulesubsection{Description}
 MTUs to guess for path MTU discovery.  This table is from RFC1191,
   and is the one that appears in BSD.

   On \wasverb{comp.protocols.tcp-ip, Sun, 15 Feb 2004 01:38:26 -0000,
   \textless{}102tjcifv6vgm02@corp.supernews.com\textgreater{}, kml@bayarea.net (Kevin Lahey)}
   suggests that this is out-of-date, and 2312 (WiFi 802.11), 9180
   (common ATM), and 9000 (jumbo Ethernet) should be added.  For some
   polemic discussion, see \wasverb{http://www.psc.edu/\textasciitilde{}mathis/MTU/}.

   RFC1191 says explicitly "We do not expect that the values in the
   table [...] are going to be valid forever.  The values given here
   are an implementation suggestion, NOT a specification or
   requirement.  Implementors should use up-to-date references to pick
   a set of plateaus [...]".  BSD is therefore not compliant here.

   Linux adds 576, 216, 128 and drops 1006.  576 is used in X.25
   networks, and the source says 216 and 128 are needed for AMPRnet
   AX.25 paths.  1006 is used for SLIP, and was used on the ARPANET.
   Linux does not include the modern MTUs listed above.


\rrulepad }
}

\newcommand{\seccommauxTreass}{\clustersection{(TCP only)}{Reassembly}
\seccomm{
TCP segments may arrive out-of-order, leaving holes in the data
stream.  They may also overlap, due to retransmission, confusion, or
deliberate effort by an unusual TCP implementation.  The TCP
reassembly algorithm is responsible for retrieving the data stream
from the segments that arrive (note this is not to be confused with IP
fragmentation reassembly, which is beneath the scope of this
specification).

There are various ways of resolving overlaps; in this specification we
are completely nondeterministic, and allow any legal reassembly.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{tcp\_reass}$
&
&  perform TCP segment reassembly \\
$\tsrule{tcp\_reass\_prune}$
&
&  drop prefix of reassembly queue \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntcpTreass}{\ddefnc{tcpTreass}{\iA{tcp\_reass}}{\subddefnA[{ perform TCP segment reassembly }]{tcp\_reass}{\tsaux{tcp\_reass} \;\tsvar{seq} (\tsunknown{rsegq} : \tstype{tcpReassSegment} \;\tstype{list}) ={}\\{}
 \Mlet  \;\tsunknown{myrel} = \{ (\tsunknown{i},\tsvar{c}) \mid  \exists \tsvar{rseg}.{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{rseg} \;\in  \;\tsunknown{rsegq} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{i} \geq  \tsvar{rseg}.\tsvar{seq} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{i} < \tsvar{rseg}.\tsvar{seq} + \tsholop{LENGTH} \;\tsvar{rseg}.\tsvar{data} +{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mif  \;\tsvar{rseg}.\tsfield{spliced\_urp} \neq  * \;\Mthen  \;1 \;\Melse  \;0) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mcase  \;\tsvar{rseg}.\tsfield{spliced\_urp} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome (\tsvar{n}) \Mtotype {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mif  \;\tsunknown{i} > \tsvar{n} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{c} = \Msome (\tsunknown{EL} (\tsholop{Num} (\tsunknown{i} - \tsvar{rseg}.\tsvar{seq} - 1)) (\tsvar{rseg}.\tsvar{data})){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{i} = \tsvar{n} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{c} = *{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{c} = \Msome (\tsunknown{EL} (\tsholop{Num} (\tsunknown{i} - \tsvar{rseg}.\tsvar{seq})) (\tsvar{rseg}.\tsvar{data}))) \Mdpipe {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad * \Mtotype {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{c} = \Msome (\tsunknown{EL} (\tsholop{Num} (\tsunknown{i} - \tsvar{rseg}.\tsvar{seq})) (\tsvar{rseg}.\tsvar{data}))) \} \Min {}\\{}
 \{ (\tsvar{cs}',\tsunknown{len},\tsvar{FIN}) \mid  \exists \tsvar{cs}. \tsvar{cs}' = \tsaux{CONCAT\_OPTIONAL} \;\tsvar{cs} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad (\forall \tsvar{n}:\tsvar{num}. \tsvar{n} < \tsholop{LENGTH} \;\tsvar{cs} \implies  (\tsvar{seq}+\tsvar{n},\tsunknown{EL} \;\tsvar{n} \;\tsvar{cs}) \in  \;\tsunknown{myrel}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad (\neg{}\exists \tsvar{c}. (\tsvar{seq}+\tsholop{LENGTH} \;\tsvar{cs},\tsvar{c}) \in  \;\tsunknown{myrel}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad (\tsunknown{len} = \tsholop{LENGTH} \;\tsvar{cs}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad (\tsvar{FIN} = \exists \tsvar{rseg}. \tsvar{rseg} \;\in  \;\tsunknown{rsegq} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{rseg}.\tsvar{seq} + \tsholop{LENGTH} \;\tsvar{rseg}.\tsvar{data} +{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mif  \;\tsvar{rseg}.\tsfield{spliced\_urp} \neq  * \;\Mthen  \;1 \;\Melse  \;0) ={}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{seq} + \tsholop{LENGTH} \;\tsvar{cs} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{rseg}.\tsvar{FIN} ) \}{}\\{}
 {}\\{}
\quad\quad \tslongcomm{ NB: the FIN may come from a 0-length segment, or from a
         different segment from that which the last character came but logically is
         always at the end of cs's. }}
}
{\rulesubsection{Description}
 Returns the set of maximal-length strings starting at $\tsvar{seq}$ that can
   be constructed by taking bytes from the segments in $\tsunknown{rsegq}$, accounting for
   any spliced (out-of-line) urgent data.

\rrulepad }
}

\newcommand{\defntcpTreassTprune}{\ddefnc{tcpTreassTprune}{\iA{tcp\_reass\_prune}}{\subddefnA[{ drop prefix of reassembly queue }]{tcp\_reass\_prune}{\tsaux{tcp\_reass\_prune} \;\tsvar{seq} (\tsunknown{rsegq} : \tstype{tcpReassSegment} \;\tstype{list}) ={}\\{}
 \tsholop{FILTER} (\lambda \tsvar{rseg}. \tsvar{rseg}.\tsvar{seq} + \tsholop{LENGTH} \;\tsvar{rseg}.\tsvar{data} + (\Mif  \;\tsvar{rseg}.\tsfield{spliced\_urp} \neq  * \;\Mthen  \;1 \;\Melse  \;0) +{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad (\Mif  \;\tsvar{rseg}.\tsvar{FIN} \;\Mthen  \;1 \;\Melse  \;0) > \tsvar{seq}) \tsunknown{rsegq}}
}
{\rulesubsection{Description}
 Prune away every segment ending before the specified $\tsvar{seq}$, accounting for
   any spliced (out-of-line) urgent data.

\rrulepad }
}

\newcommand{\seccomminitialTcb}{\clustersection{(TCP only)}{The initial TCP control block}
\seccomm{
The initial state of the TCP control block.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{initial\_cb}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defninitialTcb}{\ddefnn{initialTcb}{\iA{initial\_cb}}{\subddefnA{initial\_cb}{\tsaux{initial\_cb} ={}\\{}
 \Mmagiclrec  \tsfield{t\_segq}            \Mass  [\,];{}\\{}
 \tsfield{tt\_rexmt}          \Mass  *;{}\\{}
 \tsfield{tt\_keep}           \Mass  *;{}\\{}
 \tsfield{tt\_2msl}           \Mass  *;{}\\{}
 \tsfield{tt\_delack}         \Mass  *;{}\\{}
 \tsfield{tt\_conn\_est}       \Mass  *;{}\\{}
 \tsfield{tt\_fin\_wait\_2}     \Mass  *;{}\\{}
 \tsfield{tf\_needfin}        \Mass  \Mfalse ;{}\\{}
 \tsfield{tf\_shouldacknow}   \Mass  \Mfalse ;{}\\{}
 \tsfield{snd\_una}           \Mass  \tsaux{tcp\_seq\_local} \;0w;{}\\{}
 \tsfield{snd\_max}           \Mass  \tsaux{tcp\_seq\_local} \;0w;{}\\{}
 \tsfield{snd\_nxt}           \Mass  \tsaux{tcp\_seq\_local} \;0w;{}\\{}
 \tsfield{snd\_wl1}           \Mass  \tsaux{tcp\_seq\_foreign} \;0w;{}\\{}
 \tsfield{snd\_wl2}           \Mass  \tsaux{tcp\_seq\_local} \;0w;{}\\{}
 \tsvar{iss}               \Mass  \tsaux{tcp\_seq\_local} \;0w;{}\\{}
 \tsfield{snd\_wnd}           \Mass  0;{}\\{}
 \tsfield{snd\_cwnd}          \Mass  \tsaux{TCP\_MAXWIN} \ll  \tsaux{TCP\_MAXWINSCALE};{}\\{}
 \tsfield{snd\_ssthresh}      \Mass  \tsaux{TCP\_MAXWIN} \ll  \tsaux{TCP\_MAXWINSCALE};{}\\{}
 \tsfield{rcv\_wnd}           \Mass  0;{}\\{}
 \tsfield{tf\_rxwin0sent}     \Mass  \Mfalse ;{}\\{}
 \tsfield{rcv\_nxt}           \Mass  \tsaux{tcp\_seq\_foreign} \;0w;{}\\{}
 \tsfield{rcv\_up}            \Mass  \tsaux{tcp\_seq\_foreign} \;0w;{}\\{}
 \tsvar{irs}               \Mass  \tsaux{tcp\_seq\_foreign} \;0w;{}\\{}
 \tsfield{rcv\_adv}           \Mass  \tsaux{tcp\_seq\_foreign} \;0w;{}\\{}
 \tsfield{snd\_recover}       \Mass  \tsaux{tcp\_seq\_local} \;0w;{}\\{}
 \tsfield{t\_maxseg}          \Mass  \tsaux{MSSDFLT};{}\\{}
 \tsfield{t\_advmss}          \Mass  *;{}\\{}
 \tsfield{t\_rttseg}          \Mass  *;{}\\{}
 \tsfield{t\_rttinf} \Mass {}\\{}
 \Mmagiclrec {}\\{}
 \tsfield{t\_rttupdated}      \Mass  0;{}\\{}
 \tsfield{tf\_srtt\_valid}     \Mass  \Mfalse ;{}\\{}
 \tsfield{t\_srtt}            \Mass  \tsaux{TCPTV\_RTOBASE};{}\\{}
 \tsfield{t\_rttvar}          \Mass  \tsaux{TCPTV\_RTTVARBASE};{}\\{}
 \tsfield{t\_rttmin}          \Mass  \tsaux{TCPTV\_MIN};{}\\{}
 \tsfield{t\_lastrtt}         \Mass  0;{}\\{}
 \tsfield{t\_lastshift}       \Mass  0;{}\\{}
 \tsfield{t\_wassyn}          \Mass  \Mfalse   \tscomm{ if t\textunderscore{}lastshift=0, this doesn't make a difference }{}\\{}
 \Mmagicbolrrec ;{}\\{}
 \tsfield{t\_dupacks}         \Mass  0;{}\\{}
 \tsfield{t\_idletime}        \Mass  \tsaux{stopwatch\_zero};{}\\{}
 \tsfield{t\_softerror}       \Mass  *;{}\\{}
 \tsfield{snd\_scale}         \Mass  0;{}\\{}
 \tsfield{rcv\_scale}         \Mass  0;{}\\{}
 \tsfield{request\_r\_scale}   \Mass  *; \tslongcomm{ this like many other things is overwritten with
                                     the chosen value later - cf tcp\textunderscore{}newtcpcb() }{}\\{}
 \tsfield{tf\_doing\_ws}       \Mass  \Mfalse ;{}\\{}
 \tsfield{ts\_recent}         \Mass  \tscon{TimeWindowClosed};{}\\{}
 \tsfield{tf\_req\_tstmp}      \Mass  \Mfalse ;    \tscomm{ cf tcp\textunderscore{}newtcpcb() }{}\\{}
 \tsfield{tf\_doing\_tstmp}    \Mass  \Mfalse ;{}\\{}
 \tsfield{last\_ack\_sent}     \Mass  \tsaux{tcp\_seq\_foreign} \;0w;{}\\{}
 \tsfield{bsd\_cantconnect}   \Mass  \Mfalse ;{}\\{}
 \tsfield{snd\_cwnd\_prev}     \Mass  0;{}\\{}
 \tsfield{snd\_ssthresh\_prev} \Mass  0;{}\\{}
 \tsfield{t\_badrxtwin}       \Mass  \tscon{TimeWindowClosed}{}\\{}
 \tscomm{ Note: everything should be listed here, leaving nothing as ARB. }{}\\{}
 \tscomm{ Many are always overwritten, however. }{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\chapcommTCPITauxFnsTrelmonad}{\chaptersection{ Relational monad}
\label{TCP1_auxFns_relmonad}%
\chapcomm{
The relational `monad' is used to describe stateful computation in a
convenient and compositional way.


}
}

\newcommand{\seccommauxTrelmonad}{\clustersection{(TCP only)}{Relational monad}
\seccomm{
   The implementation TCP input and output routines are imperative C
   code, with mutations of state variables and calls to various other
   routines, some of which send messages or have other observable
   effects.  These are intertwined in a complex control flow.
%
   In the specification we have attempted, as much as possible, to
   adopt purely functional or relational styles.  To deal with the
   observable side effects in the middle of (e.g.) \wasverb{tcp\textunderscore{}output},
   however, we have had to identify some intermediate states.
%
   We introduce a relational monadic style to do so, using
   higher-order functions to hide the plumbing of state variables.
   The nondeterminism of our model adds another layer of complexity;
   instead of the usual functional monads, we use relational monads.

   An operation on the current state is modelled by a relation on the
   current and resulting states.  A number of primitive operations
   are defined; these operations are then chained together by a
   binding combinator, which takes two relations and yields their
   composition.  In this way arbitrarily complex operations on state
   may be defined in a modular manner, and the referential
   transparency of the logic is maintained.

   In the present application, the current state is a pair
   $(\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state})$ of the current socket and the
   state of the host's band limiter.  The resulting state is a
   quadruple $((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg}
\tstype{list}),\tsunknown{continue'}:\tstype{bool})$ of the final socket, band-limiter state, a
   list of segments to be output, and a flag.  This flag models
   aborting: if it is set, operations should be chained together
   normally; if it is cleared, subsequent operations should \emph{not}
   be performed, and instead the resulting state should be the final
   state of the entire composite operation of which this is a part.

   The binding combinator is $\tsaux{andThen}$.  Primitive operators include
   $\tsaux{cont}$, which does nothing and continues, and $\tsaux{stop}$, which
   does nothing and stops.  Several other operations are defined to
   manipulate the state -- the monadic glue is intended to abstract
   away from the implementation of that state as a pair of tuples.

   It should be a theorem that $\tsaux{andThen}$ is assoc, that $\tsaux{cont}$ is
   unit and $\tsaux{stop}$ is zero, and so on.

   Note that $\tsunknown{outsegs}$, the list of messages, is actually a list of
   arbitrary type; this enables us to lift the glue to the type $\tstype{msg}
\# \tstype{bool}$ in $\tsrule{deliver\_in\_3}$, where we need the flag to deal with
   queueing failure.

   As throughout this specification, beware that the nondeterminism
   of, e.g., $\tsaux{chooseM}$ is modelled by an existential, and is thus
   "angelic" in some sense.  This may or may not be what you expect.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{andThen}$
&
&  normal sequencing \\
$\tsrule{cont}$
&
&  do nothing, and continue (unit for $\tsaux{andThen}$) \\
$\tsrule{stop}$
&
&  do nothing, and stop (zero for $\tsaux{andThen}$) \\
$\tsrule{assert}$
&
&  assert truth of condition, and continue \\
$\tsrule{assert\_failure}$
&
&  assertion violated; fail noisily \\
$\tsrule{chooseM}$
&
&  choose a value from a set, nondeterministically \\
$\tsrule{get\_sock}$
&
&  get current socket \\
$\tsrule{get\_tcp\_sock}$
&
&  assert current socket is TCP, and get its protocol data \\
$\tsrule{get\_cb}$
&
&  assert current socket is TCP, and get its control block \\
$\tsrule{modify\_sock}$
&
&  apply function to current socket \\
$\tsrule{modify\_tcp\_sock}$
&
&  apply function to current socket \\
$\tsrule{modify\_cb}$
&
&  assert current socket is TCP, and apply function to its control block \\
$\tsrule{emit\_segs}$
&
&  append segments to current output list \\
$\tsrule{emit\_segs\_pred}$
&
&  append segments specified by a predicate (nondeterministic) \\
$\tsrule{mliftc}$
&
&  lift a monadic operation not involving $\tsunknown{continue}$ or $\tsvar{bndlm}$ \\
$\tsrule{mliftc\_bndlm}$
&
&  lift a monadic operation not involving $\tsunknown{continue}$ \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnandThen}{\ddefnc{andThen}{\iA{andThen}}{\subddefnA[{ normal sequencing }]{andThen}{(\tsunknown{op1} \;\tsaux{andThen} \;\tsunknown{op2}) ={}\\{}
 \lambda  (\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad \exists \tsvar{sock}_{1} \;\tsvar{bndlm}_{1} \;\tsvar{outsegs}_{1} \;\tsvar{continue}_{1} \;\tsvar{sock}_{2} \;\tsvar{bndlm}_{2} \;\tsvar{outsegs}_{2} \;\tsvar{continue}_{2}.{}\\{}
\quad \tsunknown{op1} (\tsunknown{sock},\tsvar{bndlm}) ((\tsvar{sock}_{1},\tsvar{bndlm}_{1},\tsvar{outsegs}_{1}),\tsvar{continue}_{1}) \Mwedge {}\\{}
\quad \Mif  \;\tsvar{continue}_{1} \;\Mthen {}\\{}
\quad\quad\quad \tsunknown{op2} (\tsvar{sock}_{1},\tsvar{bndlm}_{1}) ((\tsvar{sock}_{2},\tsvar{bndlm}_{2},\tsvar{outsegs}_{2}),\tsvar{continue}_{2}) \Mwedge {}\\{}
\quad\quad\quad (\tsunknown{sock'} = \tsvar{sock}_{2} \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm}_{2} \Mwedge  \tsunknown{outsegs'} = \Mappend{\tsvar{outsegs}_{1}}{\tsvar{outsegs}_{2}} \Mwedge  \tsunknown{continue'} = \tsvar{continue}_{2}){}\\{}
\quad \Melse {}\\{}
\quad\quad\quad (\tsunknown{sock'} = \tsvar{sock}_{1} \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm}_{1} \Mwedge  \tsunknown{outsegs'} = \tsvar{outsegs}_{1} \Mwedge  \tsunknown{continue'} = \Mfalse )}
}
{}
}

\newcommand{\defncont}{\ddefnc{cont}{\iA{cont}}{\subddefnA[{ do nothing, and continue (unit for $\tsaux{andThen}$) }]{cont}{\tsaux{cont} ={}\\{}
 \lambda  (\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\tsunknown{sock'} = \tsunknown{sock} \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\defnstop}{\ddefnc{stop}{\iA{stop}}{\subddefnA[{ do nothing, and stop (zero for $\tsaux{andThen}$) }]{stop}{\tsaux{stop} ={}\\{}
 \lambda  (\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\tsunknown{sock'} = \tsunknown{sock} \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsunknown{continue'} = \Mfalse )}
}
{}
}

\newcommand{\defnassert}{\ddefnc{assert}{\iA{assert}}{\subddefnA[{ assert truth of condition, and continue }]{assert}{\tsaux{assert} \;\tsunknown{p} ={}\\{}
 \lambda  (\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\tsunknown{p} \Mwedge  \tsunknown{sock'} = \tsunknown{sock} \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\defnassertTfailure}{\ddefnc{assertTfailure}{\iA{assert\_failure}}{\subddefnA[{ assertion violated; fail noisily }]{assert\_failure}{\tsaux{assert\_failure} \;\tsunknown{s} ={}\\{}
 \lambda  (\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad \tsaux{ASSERTION\_FAILURE} \;\tsunknown{s}}
}
{}
}

\newcommand{\defnchooseM}{\ddefnn{chooseM}{\iA{chooseM}}{\subddefnA[{ choose a value from a set, nondeterministically }]{chooseM}{\tsaux{chooseM} \;\tsunknown{s} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad \tsholop{choose} \;\tsunknown{x} \Mcons  \tsunknown{s}. \tsunknown{f} \;\tsunknown{x} (\tsunknown{sock},\tsvar{bndlm}) ((\tsunknown{sock'},\tsvar{bndlm}',\tsunknown{outsegs'}),\tsunknown{continue'})}
}
{}
}

\newcommand{\defngetTsock}{\ddefnc{getTsock}{\iA{get\_sock}}{\subddefnA[{ get current socket }]{get\_sock}{\tsaux{get\_sock} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad \tsunknown{f} \;\tsunknown{sock} (\tsunknown{sock},\tsvar{bndlm}) ((\tsunknown{sock'},\tsvar{bndlm}',\tsunknown{outsegs'}),\tsunknown{continue'})}
}
{}
}

\newcommand{\defngetTtcpTsock}{\ddefnc{getTtcpTsock}{\iA{get\_tcp\_sock}}{\subddefnA[{ assert current socket is TCP, and get its protocol data }]{get\_tcp\_sock}{\tsaux{get\_tcp\_sock} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad \exists \tsunknown{tcp\_sock}.{}\\{}
\quad \tsunknown{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad \tsunknown{f} \;\tsunknown{tcp\_sock} (\tsunknown{sock},\tsvar{bndlm}) ((\tsunknown{sock'},\tsvar{bndlm}',\tsunknown{outsegs'}),\tsunknown{continue'})}
}
{}
}

\newcommand{\defngetTcb}{\ddefnc{getTcb}{\iA{get\_cb}}{\subddefnA[{ assert current socket is TCP, and get its control block }]{get\_cb}{\tsaux{get\_cb} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad \exists \tsunknown{tcp\_sock}.{}\\{}
\quad \tsunknown{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad \tsunknown{f} \;\tsunknown{tcp\_sock}.\tsvar{cb} (\tsunknown{sock},\tsvar{bndlm}) ((\tsunknown{sock'},\tsvar{bndlm}',\tsunknown{outsegs'}),\tsunknown{continue'})}
}
{}
}

\newcommand{\defnmodifyTsock}{\ddefnc{modifyTsock}{\iA{modify\_sock}}{\subddefnA[{ apply function to current socket }]{modify\_sock}{\tsaux{modify\_sock} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\tsunknown{sock'} = \tsunknown{f} \;\tsunknown{sock} \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\defnmodifyTtcpTsock}{\ddefnc{modifyTtcpTsock}{\iA{modify\_tcp\_sock}}{\subddefnA[{ apply function to current socket }]{modify\_tcp\_sock}{\tsaux{modify\_tcp\_sock} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\exists \tsunknown{tcp\_sock}.{}\\{}
\quad \tsunknown{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad \tsunknown{sock'} = \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO} (\tsunknown{f} \;\tsunknown{tcp\_sock}) \Mmagicrrec  \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\defnmodifyTcb}{\ddefnn{modifyTcb}{\iA{modify\_cb}}{\subddefnA[{ assert current socket is TCP, and apply function to its control block }]{modify\_cb}{\tsaux{modify\_cb} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad \exists \tsunknown{tcp\_sock}.{}\\{}
\quad \tsunknown{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad (\tsunknown{sock'} = \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{cb} \Mass  (\tsunknown{f} \;\tsunknown{tcp\_sock}.\tsvar{cb}) \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad \tsvar{bndlm}' = \tsvar{bndlm} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\defnemitTsegs}{\ddefnc{emitTsegs}{\iA{emit\_segs}}{\subddefnA[{ append segments to current output list }]{emit\_segs}{\tsaux{emit\_segs} \;\tsunknown{segs} ={}\\{}
 \lambda  (\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\tsunknown{sock'} = \tsunknown{sock} \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm} \Mwedge  \tsunknown{outsegs'} = \tsunknown{segs} \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\defnemitTsegsTpred}{\ddefnn{emitTsegsTpred}{\iA{emit\_segs\_pred}}{\subddefnA[{ append segments specified by a predicate (nondeterministic) }]{emit\_segs\_pred}{\tsaux{emit\_segs\_pred} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\tsunknown{sock'} = \tsunknown{sock} \Mwedge  \tsunknown{f} \;\tsvar{bndlm} \;\tsvar{bndlm}' \;\tsunknown{outsegs'} \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\defnmliftc}{\ddefnc{mliftc}{\iA{mliftc}}{\subddefnA[{ lift a monadic operation not involving $\tsunknown{continue}$ or $\tsvar{bndlm}$ }]{mliftc}{\tsaux{mliftc} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\tsunknown{f} \;\tsunknown{sock} (\tsunknown{sock'},\tsunknown{outsegs'}) \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm} \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\defnmliftcTbndlm}{\ddefnn{mliftcTbndlm}{\iA{mliftc\_bndlm}}{\subddefnA[{ lift a monadic operation not involving $\tsunknown{continue}$ }]{mliftc\_bndlm}{\tsaux{mliftc\_bndlm} \;\tsunknown{f} ={}\\{}
 \lambda  (\tsunknown{sock}:\tslib{socket},\tsvar{bndlm}:\tsunknown{bandlim\_state}) ((\tsunknown{sock'}:\tslib{socket},\tsvar{bndlm}':\tsunknown{bandlim\_state},\tsunknown{outsegs'}:\tsunknown{'msg} \;\tstype{list}),\tsunknown{continue'}:\tstype{bool}).{}\\{}
\quad (\tsunknown{f} (\tsunknown{sock},\tsvar{bndlm}) (\tsunknown{sock'},\tsvar{bndlm}',\tsunknown{outsegs'}) \Mwedge  \tsunknown{continue'} = \Mtrue )}
}
{}
}

\newcommand{\chapcommTCPmajorAuxFns}{\chaptersection{ Auxiliary functions for TCP segment creation and drop}
\label{TCPmajorAuxFns}%
\chapcomm{
We gather here all the general TCP segment generation and processing
functions that are used in the host LTS.


}
}

\newcommand{\seccommtcpTsynTrstTsegmentTcreation}{\clustersection{(TCP only)}{SYN and RST Segment Creation}
\seccomm{
Generating various simple segments (none of which contain any user data).


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{make\_syn\_segment}$
&
&  Make a SYN segment for emission by $\tsrule{connect\_1}$ etc \\
$\tsrule{make\_syn\_ack\_segment}$
&
&  Make a SYN,ACK segment for emission by $\tsrule{deliver\_in\_1}$, $\tsrule{deliver\_in\_2}$, etc.\\
$\tsrule{make\_ack\_segment}$
&
&  Make a plain boring ACK segment in response to a SYN,ACK segment \\
$\tsrule{bsd\_make\_phantom\_segment}$
&
&  Make phantom (no flags) segment for BSD $\tscon{LISTEN}$ bug \\
$\tsrule{make\_rst\_segment\_from\_cb}$
&
&  Make a RST segment asynchronously, from socket information only \\
$\tsrule{make\_rst\_segment\_from\_seg}$
&
&  Make a RST segment synchronously, in response to an incoming segment \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnmakeTsynTsegment}{\ddefnn{makeTsynTsegment}{\iA{make\_syn\_segment}}{\subddefnA[{ Make a SYN segment for emission by $\tsrule{connect\_1}$ etc }]{make\_syn\_segment}{\tsaux{make\_syn\_segment} \;\tsvar{cb} (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) \tsunknown{ts\_val} \;\tsunknown{seg'} ={}\\{}
 (\tsholop{choose} \;\tsunknown{urp\_any} \Mcons  \tsunknown{UNIV}.{}\\{}
 \tsholop{choose} \;\tsunknown{ack\_any} \Mcons  \tsunknown{UNIV}.{}\\{}
 {}\\{}
 \tscomm{ Determine window size; fail if out of range }{}\\{}
 \Mlet  \;\tsvar{win} = \tsholop{n2w} \;\tsvar{cb}.\tsfield{rcv\_wnd} \;\Min {}\\{}
 \tsholop{w2n} \;\tsvar{win} = \tsvar{cb}.\tsfield{rcv\_wnd} \Mwedge  \tscomm{ FIXME: silly window avoidance logic missing}{}\\{}
 {}\\{}
 \tscomm{ Choose a window scaling; fail if out of range }{}\\{}
 \tscomm{ Note there may be a better place for this assertion. }{}\\{}
 \Mlet  \;\tsvar{ws} = \tsholop{option\_map}\Mspii{\tsunknown{CHR}}{\tsvar{cb}.\tsfield{request\_r\_scale}} \Min {}\\{}
 (\tsholop{IS\_SOME} \;\tsvar{cb}.\tsfield{request\_r\_scale} \implies  \tsholop{ORD} (\tsholop{THE} \;\tsvar{ws}) = \tsholop{THE} \;\tsvar{cb}.\tsfield{request\_r\_scale}) \Mwedge {}\\{}
 (\Mcase  \;\tsvar{ws} \;\Mof  \;* \Mtotype  \Mtrue  \Mdpipe  \Msome  \;\tsvar{n} \Mtotype  \tsholop{ORD} \;\tsvar{n} \leq  \tsaux{TCP\_MAXWINSCALE}) \Mwedge {}\\{}
 {}\\{}
 \tscomm{ Determine maximum segment size; fail if out of range }{}\\{}
 \tsholcomm{ Put the MSS we initially advertise into $\tsfield{t\_advmss}$ }{}\\{}
 \Mlet  \;\tsvar{mss} = (\Mcase  \;\tsvar{cb}.\tsfield{t\_advmss} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad *   \Mtotype  *{}\\{}
\quad\quad\quad\quad\quad \Mdpipe  \Msome  \;\tsunknown{v} \Mtotype  \Msome  (\tsholop{n2w} \;\tsunknown{v})) \Min {}\\{}
 (\Mcase  \;\tsvar{cb}.\tsfield{t\_advmss} \;\Mof {}\\{}
\quad *   \Mtotype  \Mtrue {}\\{}
 \Mdpipe  \Msome  \;\tsunknown{v} \Mtotype  \tsunknown{v} = \tsholop{w2n} (\tsholop{THE} \;\tsvar{mss})) \Mwedge {}\\{}
 {}\\{}
 \tscomm{ Do timestamping? }{}\\{}
 \Mlet  \;\tsvar{ts} = \tsaux{do\_tcp\_options} \;\tsvar{cb}.\tsfield{tf\_req\_tstmp} \;\tsvar{cb}.\tsfield{ts\_recent} \;\tsunknown{ts\_val} \;\Min {}\\{}
 {}\\{}
 \tsunknown{seg'} = \Mmagiclrec  \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{seq}  \Mass  \tsvar{cb}.\tsvar{iss};{}\\{}
 \tsvar{ack}  \Mass  \tsunknown{ack\_any};{}\\{}
 \tsvar{URG}  \Mass  \Mfalse ;{}\\{}
 \tsvar{ACK}  \Mass  \Mfalse ;{}\\{}
 \tsvar{PSH}  \Mass  \Mfalse ;{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mtrue ;{}\\{}
 \tsvar{FIN}  \Mass  \Mfalse ;{}\\{}
 \tsvar{win}  \Mass  \tsvar{win};{}\\{}
 \tsvar{ws}   \Mass  \tsvar{ws};{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_any};{}\\{}
 \tsvar{mss}  \Mass  \tsvar{mss};{}\\{}
 \tsvar{ts}   \Mass  \tsvar{ts};{}\\{}
 \tsvar{data} \Mass  [\,]{}\\{}
 \Mmagicbolrrec {}\\{}
 )}
}
{}
}

\newcommand{\defnmakeTsynTackTsegment}{\ddefnn{makeTsynTackTsegment}{\iA{make\_syn\_ack\_segment}}{\subddefnA[{ Make a SYN,ACK segment for emission by $\tsrule{deliver\_in\_1}$, $\tsrule{deliver\_in\_2}$, etc.}]{make\_syn\_ack\_segment}{\tsaux{make\_syn\_ack\_segment} \;\tsvar{cb} (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) \tsunknown{ts\_val'} \;\tsunknown{seg'} ={}\\{}
 \tsholop{choose} \;\tsunknown{urp\_any} \Mcons  \tsunknown{UNIV}.{}\\{}
 {}\\{}
 \tscomm{ Determine window size; fail if out of range }{}\\{}
 \tsholcomm{ We don't scale yet ($\gg  \tsunknown{rcv\_scale'}$). RFC1323 says: segments with SYN are not scaled, and BSD
       agrees.  Even though we know what scaling the other end wants to use, and we know whether we
       are doing scaling, we can't use it until we reach the ESTABLISHED state. }{}\\{}
 \Mlet  \;\tsvar{win} = \tsholop{n2w} \;\tsvar{cb}.\tsfield{rcv\_wnd} \;\Min  \tsholcomm{ $\tsunknown{rcv\_window} - \tsholop{LENGTH} \;\tsvar{data}'$ }{}\\{}
 \tsholop{w2n} \;\tsvar{win} = \tsvar{cb}.\tsfield{rcv\_wnd} \Mwedge  \tscomm{ FIXME: silly window avoidance logic }{}\\{}
 {}\\{}
 \tscomm{ If doing window scaling, set it; fail if out of range }{}\\{}
 \Mlet  \;\tsvar{ws} = \Mif  \;\tsvar{cb}.\tsfield{tf\_doing\_ws} \;\Mthen  \;\Msome  (\tsunknown{CHR} \;\tsvar{cb}.\tsfield{rcv\_scale}) \Melse  \;* \;\Min {}\\{}
 (\tsvar{cb}.\tsfield{tf\_doing\_ws} \implies  \tsholop{ORD} (\tsholop{THE} \;\tsvar{ws}) = \tsvar{cb}.\tsfield{rcv\_scale}) \Mwedge {}\\{}
 {}\\{}
 \tscomm{ Determine maximum segment size; fail if out of range }{}\\{}
 \tsholcomm{ Put the MSS we initially advertise into $\tsfield{t\_advmss}$ }{}\\{}
 \Mlet  \;\tsvar{mss} = (\Mcase  \;\tsvar{cb}.\tsfield{t\_advmss} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad *   \Mtotype  *{}\\{}
\quad\quad\quad\quad\quad \Mdpipe  \Msome  \;\tsunknown{v} \Mtotype  \Msome  (\tsholop{n2w} \;\tsunknown{v})) \Min {}\\{}
 (\Mcase  \;\tsvar{cb}.\tsfield{t\_advmss} \;\Mof {}\\{}
\quad *   \Mtotype  \Mtrue {}\\{}
 \Mdpipe  \Msome  \;\tsunknown{v} \Mtotype  \tsunknown{v} = \tsholop{w2n} (\tsholop{THE} \;\tsvar{mss})) \Mwedge {}\\{}
 {}\\{}
 \tscomm{ Set timestamping option? }{}\\{}
 \Mlet  \;\tsvar{ts} =  \tsaux{do\_tcp\_options} \;\tsvar{cb}.\tsfield{tf\_doing\_tstmp} \;\tsvar{cb}.\tsfield{ts\_recent} \;\tsunknown{ts\_val'} \;\Min {}\\{}
 {}\\{}
 \tsunknown{seg'} = \Mmagiclrec  \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{seq}  \Mass  \tsvar{cb}.\tsvar{iss};{}\\{}
 \tsvar{ack}  \Mass  \tsvar{cb}.\tsfield{rcv\_nxt};{}\\{}
 \tsvar{URG}  \Mass  \Mfalse ;{}\\{}
 \tsvar{ACK}  \Mass  \Mtrue ;{}\\{}
 \tsvar{PSH}  \Mass  \Mfalse ;  \tsholcomm{ see below }{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mtrue ;{}\\{}
 \tsvar{FIN}  \Mass  \Mfalse ;  \tscomm{ Note: we are not modelling T/TCP }{}\\{}
 \tsvar{win}  \Mass  \tsvar{win};{}\\{}
 \tsvar{ws}   \Mass  \tsvar{ws};{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_any};{}\\{}
 \tsvar{mss}  \Mass  \tsvar{mss};{}\\{}
 \tsvar{ts}   \Mass  \tsvar{ts};{}\\{}
 \tsvar{data} \Mass  [\,]  \tsholcomm{ see below }{}\\{}
 \Mmagicbolrrec {}\\{}
 \tsholcomm{ No $\tsvar{data}$ can be send here using the BSD sockets API, although
TCP notionally allows it.  Accordingly, the $\tsvar{PSH}$ flag is never set
(under BSD, PSH is only set if we're sending a non-zero amount of data
(and emptying the send buffer); see \wasverb{tcp\textunderscore{}output.c:626}). }}
}
{}
}

\newcommand{\defnmakeTackTsegment}{\ddefnn{makeTackTsegment}{\iA{make\_ack\_segment}}{\subddefnA[{ Make a plain boring ACK segment in response to a SYN,ACK segment }]{make\_ack\_segment}{\tsaux{make\_ack\_segment} \;\tsvar{cb} \;\tsvar{FIN} (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) \tsunknown{ts\_val'} \;\tsunknown{seg'} ={}\\{}
 (\tscomm{ SB thinks these should be unconstrained. }{}\\{}
 \tsholop{choose} \;\tsunknown{urp\_garbage} \Mcons  \tsunknown{UNIV}.{}\\{}
 {}\\{}
 \tscomm{ Determine window size; fail if out of range }{}\\{}
 \tscomm{ Connection is now established so any scaling should be taken into account }{}\\{}
 \tscomm{ Note it might be appropriate to clip the value to be in range rather than failing if out of range. }{}\\{}
 \Mlet  \;\tsvar{win} = \tsholop{n2w} (\tsvar{cb}.\tsfield{rcv\_wnd} \gg  \tsvar{cb}.\tsfield{rcv\_scale}) \Min {}\\{}
 \tsholop{w2n} \;\tsvar{win} = \tsvar{cb}.\tsfield{rcv\_wnd} \gg  \tsvar{cb}.\tsfield{rcv\_scale} \Mwedge  \tscomm{ FIXME: silly window avoidance }{}\\{}
 {}\\{}
 \tscomm{ Set timestamping option? }{}\\{}
 \Mlet  \;\tsvar{ts} = \tsaux{do\_tcp\_options} \;\tsvar{cb}.\tsfield{tf\_doing\_tstmp} \;\tsvar{cb}.\tsfield{ts\_recent} \;\tsunknown{ts\_val'} \;\Min {}\\{}
 {}\\{}
 \tsunknown{seg'} = \Mmagiclrec  \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{seq}  \Mass  \Mif  \;\tsvar{FIN} \;\Mthen  \;\tsvar{cb}.\tsfield{snd\_una} \;\Melse  \;\tsvar{cb}.\tsfield{snd\_nxt};{}\\{}
 \tsvar{ack}  \Mass  \tsvar{cb}.\tsfield{rcv\_nxt};{}\\{}
 \tsvar{URG}  \Mass  \Mfalse ;{}\\{}
 \tsvar{ACK}  \Mass  \Mtrue ;{}\\{}
 \tsvar{PSH}  \Mass  \Mfalse ;  \tsholcomm{ see comment for $\tsaux{make\_syn\_ack\_segment}$ }{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mfalse ;{}\\{}
 \tsvar{FIN}  \Mass  \tsvar{FIN};{}\\{}
 \tsvar{win}  \Mass  \tsvar{win};{}\\{}
 \tsvar{ws}   \Mass  *;{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_garbage};{}\\{}
 \tsvar{mss}  \Mass  *;{}\\{}
 \tsvar{ts}   \Mass  \tsvar{ts};{}\\{}
 \tsvar{data} \Mass  [\,] \tsholcomm{ Note that if there is data in $\tsvar{sndq}$ then it
                            should always appear in a seperate segment after the connnection
                            establishment handshake, but this needs to be verified. }{}\\{}
 \Mmagicbolrrec )}
}
{}
}

\newcommand{\defnbsdTmakeTphantomTsegment}{\ddefnn{bsdTmakeTphantomTsegment}{\iA{bsd\_make\_phantom\_segment}}{\subddefnA[{ Make phantom (no flags) segment for BSD $\tscon{LISTEN}$ bug }]{bsd\_make\_phantom\_segment}{\tslongcomm{ If a socket is changed to the LISTEN state, the rexmt timer may still be running.
   If it fires, phantom segments are emitted. }{}\\{}
 \tsaux{bsd\_make\_phantom\_segment} \;\tsvar{cb} (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) \tsunknown{ts\_val'} \;\tsvar{cantsndmore} \;\tsunknown{seg'} ={}\\{}
 (\tsholop{choose} \;\tsunknown{urp\_garbage} \Mcons  \tsunknown{UNIV}.{}\\{}
 {}\\{}
 \tscomm{ Determine window size; fail if out of range }{}\\{}
 \tscomm{ Connection is now established so any scaling should be taken into account }{}\\{}
 \tscomm{ Note it might be appropriate to clip the value to be in range rather than failing if out of range. }{}\\{}
 \Mlet  \;\tsvar{win} = \tsholop{n2w} (\tsvar{cb}.\tsfield{rcv\_wnd} \gg  \tsvar{cb}.\tsfield{rcv\_scale}) \Min {}\\{}
 \tsholop{w2n} \;\tsvar{win} = \tsvar{cb}.\tsfield{rcv\_wnd} \gg  \tsvar{cb}.\tsfield{rcv\_scale} \Mwedge  \tscomm{ FIXME: silly window avoidance}{}\\{}
 {}\\{}
 \Mlet  \;\tsvar{FIN} = (\tsvar{cantsndmore} \Mwedge  \tsvar{cb}.\tsfield{snd\_una} < (\tsvar{cb}.\tsfield{snd\_max} - 1)) \Min {}\\{}
 {}\\{}
 \tscomm{ Set timestamping option? }{}\\{}
 \Mlet  \;\tsvar{ts} = \tsaux{do\_tcp\_options} \;\tsvar{cb}.\tsfield{tf\_doing\_tstmp} \;\tsvar{cb}.\tsfield{ts\_recent} \;\tsunknown{ts\_val'} \;\Min {}\\{}
 {}\\{}
 \tsunknown{seg'} = \Mmagiclrec  \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{seq}  \Mass  \Mif  \;\tsvar{FIN} \;\Mthen  \;\tsvar{cb}.\tsfield{snd\_una} \;\Melse  \;\tsvar{cb}.\tsfield{snd\_max}; \tscomm{ no flags, no data, and no persist timer so use snd\textunderscore{}max }{}\\{}
 \tsvar{ack}  \Mass  \tsvar{cb}.\tsfield{rcv\_nxt};  \tsholcomm{ yes, really, even though $\neg{}\tsvar{ACK}$ }{}\\{}
 \tsvar{URG}  \Mass  \Mfalse ;{}\\{}
 \tsvar{ACK}  \Mass  \Mfalse ;{}\\{}
 \tsvar{PSH}  \Mass  \Mfalse ;{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mfalse ;{}\\{}
 \tsvar{FIN}  \Mass  \tsvar{FIN};{}\\{}
 \tsvar{win}  \Mass  \tsvar{win};{}\\{}
 \tsvar{ws}   \Mass  *;{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_garbage};{}\\{}
 \tsvar{mss}  \Mass  *;{}\\{}
 \tsvar{ts}   \Mass  \tsvar{ts};{}\\{}
 \tsvar{data} \Mass  [\,] \tsholcomm{ sndq always empty in this situation }{}\\{}
 \Mmagicbolrrec )}
}
{}
}

\newcommand{\defnmakeTrstTsegmentTfromTcb}{\ddefnn{makeTrstTsegmentTfromTcb}{\iA{make\_rst\_segment\_from\_cb}}{\subddefnA[{ Make a RST segment asynchronously, from socket information only }]{make\_rst\_segment\_from\_cb}{\tsaux{make\_rst\_segment\_from\_cb} \;\tsvar{cb} (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) \tsunknown{seg'} ={}\\{}
 \tscomm{ Deliberately unconstrained }{}\\{}
 \tsholop{choose} \;\tsunknown{urp\_garbage}  \Mcons  \tsunknown{UNIV} .{}\\{}
 \tsholop{choose} \;\tsunknown{URG\_garbage}  \Mcons  \tsunknown{UNIV} .{}\\{}
 \tsholop{choose} \;\tsunknown{PSH\_garbage}  \Mcons  \tsunknown{UNIV} .{}\\{}
 \tsholop{choose} \;\tsunknown{win\_garbage}  \Mcons  \tsunknown{UNIV} .{}\\{}
 \tsholop{choose} \;\tsunknown{data\_garbage} \Mcons  \tsunknown{UNIV}.{}\\{}
 \tsholop{choose} \;\tsunknown{FIN\_garbage}  \Mcons  \tsunknown{UNIV} .{}\\{}
 {}\\{}
 \tsholcomm{ Note that BSD is perfectly capable of putting data in a RST segment; try filling the buffer
       and then doing a force close: the result is a segment with RST+PSH+data+win advertisement.
       Presumably URG is also possible.  This is *not* the same as the RFC-suggested data carried by
       a RST; that would be an error message, this is just data from the buffer!  }{}\\{}
 \tsunknown{seg'} = \Mmagiclrec  \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{seq}  \Mass  \tsvar{cb}.\tsfield{snd\_nxt};   \tsholcomm{ from RFC793p62 }{}\\{}
 \tsvar{ack}  \Mass  \tsvar{cb}.\tsfield{rcv\_nxt};   \tsholcomm{ seems the right thing to do }{}\\{}
 \tsvar{URG}  \Mass  \tsunknown{URG\_garbage};  \tsholcomm{ expect: $\Mfalse $ }{}\\{}
 \tsvar{ACK}  \Mass  \Mtrue ;            \tsholcomm{ from TCPv1p248 }{}\\{}
 \tsvar{PSH}  \Mass  \tsunknown{PSH\_garbage};  \tsholcomm{ expect: $\Mfalse $ }{}\\{}
 \tsvar{RST}  \Mass  \Mtrue ;{}\\{}
 \tsvar{SYN}  \Mass  \Mfalse ;{}\\{}
 \tsvar{FIN}  \Mass  \tsunknown{FIN\_garbage};  \tsholcomm{ expect: $\Mfalse $ }{}\\{}
 \tsvar{win}  \Mass  \tsunknown{win\_garbage};  \tsholcomm{ expect: $0w$ }{}\\{}
 \tsvar{ws}   \Mass  *;{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_garbage};  \tsholcomm{ expect: $0w$ }{}\\{}
 \tsvar{mss}  \Mass  *;{}\\{}
 \tsvar{ts}   \Mass  *;  \tsholcomm{ RFC1323 S4.2 recommends no TS on RST, and BSD follows this }{}\\{}
 \tsvar{data} \Mass  \tsunknown{data\_garbage}  \tsholcomm{ expect: $ [\,] $ }{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defnmakeTrstTsegmentTfromTseg}{\ddefnn{makeTrstTsegmentTfromTseg}{\iA{make\_rst\_segment\_from\_seg}}{\subddefnA[{ Make a RST segment synchronously, in response to an incoming segment }]{make\_rst\_segment\_from\_seg}{\tsaux{make\_rst\_segment\_from\_seg} \;\tsunknown{seg} \;\tsunknown{seg'} ={}\\{}
 (\tsunknown{seg}.\tsvar{RST} = \Mfalse  \Mwedge   \tscomm{ Sanity check: never RST a RST }{}\\{}
 {}\\{}
 (\exists \tsvar{ack}'.{}\\{}
 \tscomm{ Deliberately unconstrained }{}\\{}
 \tsholop{choose} \;\tsunknown{urp\_garbage}\Mcons \tsunknown{UNIV}.{}\\{}
 \tsholop{choose} \;\tsunknown{URG\_garbage}\Mcons \tsunknown{UNIV}.{}\\{}
 \tsholop{choose} \;\tsunknown{PSH\_garbage}\Mcons \tsunknown{UNIV}.{}\\{}
 \tsholop{choose} \;\tsunknown{win\_garbage}\Mcons \tsunknown{UNIV}.{}\\{}
 \tsholop{choose} \;\tsunknown{data\_garbage}\Mcons \tsunknown{UNIV}.{}\\{}
 \tsholop{choose} \;\tsunknown{FIN\_garbage}\Mcons \tsunknown{UNIV}.{}\\{}
 {}\\{}
 \tslongcomm{ RFC795 S3.4: only ack segments that don't contain an ACK.
       SB believes this is equivalent to: only send a RST+ACK segment in response to a bad SYN
       segment }{}\\{}
 \Mlet  \;\tsvar{ACK}' = \neg{}\tsunknown{seg}.\tsvar{ACK} \;\Min {}\\{}
 {}\\{}
 \tslongcomm{ Sequence number is zero for RST+ACK segments, otherwise it is the next sequence number
       expected }{}\\{}
 \Mlet  \;\tsvar{seq}' = \Mif  \;\tsunknown{seg}.\tsvar{ACK} \;\Mthen  \;\tsunknown{tcp\_seq\_flip\_sense} \;\tsunknown{seg}.\tsvar{ack}{}\\{}
\quad\quad\quad\quad\quad \Melse  \;\tsaux{tcp\_seq\_local} \;0w \;\Min {}\\{}
 {}\\{}
 (\Mif  \;\tsvar{ACK}' \;\Mthen {}\\{}
\quad \tscomm{ RFC794 S3.4: for RST+ACK segments the ack value must be valid }{}\\{}
\quad \tsvar{ack}' = \tsunknown{tcp\_seq\_flip\_sense} \;\tsunknown{seg}.\tsvar{seq} + \tsholop{LENGTH} \;\tsunknown{seg}.\tsvar{data} + (\Mif  \;\tsunknown{seg}.\tsvar{SYN} \;\Mthen  \;1 \;\Melse  \;0){}\\{}
 \Melse {}\\{}
\quad \tscomm{ otherwise it can be arbitrary, although it possibly should be zero }{}\\{}
\quad \tsvar{ack}' \;\in  \{ \tsvar{n} \mid  \Mtrue  \}{}\\{}
 ) \Mwedge {}\\{}
 \tsunknown{seg'} = \Mmagiclrec  \tsvar{is}_{1}  \Mass  \tsunknown{seg}.\tsvar{is}_{2};{}\\{}
 \tsvar{ps}_{1}  \Mass  \tsunknown{seg}.\tsvar{ps}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \tsunknown{seg}.\tsvar{is}_{1};{}\\{}
 \tsvar{ps}_{2}  \Mass  \tsunknown{seg}.\tsvar{ps}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsvar{seq}';{}\\{}
 \tsvar{ack}  \Mass  \tsvar{ack}';{}\\{}
 \tsvar{URG}  \Mass  \tsunknown{URG\_garbage};  \tsholcomm{ expect: $\Mfalse $ }{}\\{}
 \tsvar{ACK}  \Mass  \tsvar{ACK}';{}\\{}
 \tsvar{PSH}  \Mass  \tsunknown{PSH\_garbage};  \tsholcomm{ expect: $\Mfalse $ }{}\\{}
 \tsvar{RST}  \Mass  \Mtrue ;{}\\{}
 \tsvar{SYN}  \Mass  \Mfalse ;{}\\{}
 \tsvar{FIN}  \Mass  \tsunknown{FIN\_garbage};  \tsholcomm{ expect: $\Mfalse $ }{}\\{}
 \tsvar{win}  \Mass  \tsunknown{win\_garbage};  \tsholcomm{ expect: $0w$ }{}\\{}
 \tsvar{ws}   \Mass  *;{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_garbage};  \tsholcomm{ expect: $0w$ }{}\\{}
 \tsvar{mss}  \Mass  *;{}\\{}
 \tsvar{ts}   \Mass  *;  \tsholcomm{ RFC1323 S4.2 recommends no TS on RST, and BSD follows this }{}\\{}
 \tsvar{data} \Mass  \tsunknown{data\_garbage}  \tsholcomm{ expect: $ [\,] $ }{}\\{}
 \Mmagicbolrrec {}\\{}
 ))}
}
{}
}

\newcommand{\seccommtcpTsegmentTcreation}{\clustersection{(TCP only)}{General Segment Creation}
\seccomm{
The TCP output routines.  These, together with the input routines in
$\tsrule{deliver\_in\_3}$, form the heart of TCP.



}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{tcp\_output\_required}$
&
&  determine whether TCP output is required \\
$\tsrule{tcp\_output\_really}$
&
&  do TCP output \\
$\tsrule{tcp\_output\_perhaps}$
&
&  combination of $\tsaux{tcp\_output\_required}$ and $\tsaux{tcp\_output\_really}$ \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntcpToutputTrequired}{\ddefnc{tcpToutputTrequired}{\iA{tcp\_output\_required}}{\subddefnA[{ determine whether TCP output is required }]{tcp\_output\_required}{\tsaux{tcp\_output\_required} \;\tstype{arch} \;\tsvar{ifds}_{0} \;\tsunknown{sock} ={}\\{}
 \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsunknown{sock} \;\Min {}\\{}
 \Mlet  \;\tsvar{cb} = \tsunknown{tcp\_sock}.\tsvar{cb} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Note this does not deal with \wasverb{TF\textunderscore{}LASTIDLE} and \wasverb{PRU\textunderscore{}MORETOCOME} }{}\\{}
 \Mlet  \;\tsunknown{snd\_cwnd'} ={}\\{}
 \Mif  \neg{}(\tsvar{cb}.\tsfield{snd\_max} = \tsvar{cb}.\tsfield{snd\_una} \Mwedge {}\\{}
\quad\quad\quad \tsaux{stopwatch\_val\_of} \;\tsvar{cb}.\tsfield{t\_idletime} \geq  \tsaux{computed\_rxtcur} \;\tsvar{cb}.\tsfield{t\_rttinf} \;\tstype{arch}){}\\{}
 \Mthen   \tscomm{ inverted so this clause is tried first }{}\\{}
\quad\quad \tsvar{cb}.\tsfield{snd\_cwnd}{}\\{}
 \Melse {}\\{}
\quad \tsholcomm{ The connection is idle and has been for  >= 1 RTO }{}\\{}
\quad\quad \tsholcomm{ Reduce $\tsfield{snd\_cwnd}$ to commence slow start }{}\\{}
\quad\quad \tsvar{cb}.\tsfield{t\_maxseg} * (\Mif  \;\tsaux{is\_localnet} \;\tsvar{ifds}_{0} (\tsholop{THE} \;\tsunknown{sock}.\tsvar{is}_{2}) \Mthen  \;\tsaux{SS\_FLTSZ\_LOCAL} \;\Melse  \;\tsaux{SS\_FLTSZ}) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Calculate the amount of unused send window }{}\\{}
 \Mlet  \;\tsvar{win} = \tsholop{MIN} \;\tsvar{cb}.\tsfield{snd\_wnd} \;\tsunknown{snd\_cwnd'} \;\Min {}\\{}
 \Mlet  \;\tsunknown{snd\_wnd\_unused} = \tsholop{int\_of\_num} \;\tsvar{win} - (\tsvar{cb}.\tsfield{snd\_nxt} - \tsvar{cb}.\tsfield{snd\_una}) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Is it possible that a FIN may need to be sent? }{}\\{}
 \Mlet  \;\tsunknown{fin\_required} = (\tsunknown{sock}.\tsvar{cantsndmore} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} \;\notin  \{\tscon{FIN\_WAIT\_2};\tscon{TIME\_WAIT}\}) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Under BSD, we may need to send a $\tsvar{FIN}$ in state $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$, so we may
        effectively still have a $\tsvar{SYN}$ on the send queue. }{}\\{}
 \Mlet  \;\tsunknown{syn\_not\_acked} = (\tsaux{bsd\_arch} \;\tstype{arch} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{SYN\_SENT};\tscon{SYN\_RECEIVED}\}) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Is there data or a FIN to transmit? }{}\\{}
 \Mlet  \;\tsunknown{last\_sndq\_data\_seq} = \tsvar{cb}.\tsfield{snd\_una} + \tsholop{LENGTH} \;\tsunknown{tcp\_sock}.\tsvar{sndq} \;\Min {}\\{}
 \Mlet  \;\tsunknown{last\_sndq\_data\_and\_fin\_seq}  = \tsunknown{last\_sndq\_data\_seq} + (\Mif  \;\tsunknown{fin\_required} \;\Mthen  \;1 \;\Melse  \;0){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad + (\Mif  \;\tsunknown{syn\_not\_acked} \;\Mthen  \;1 \;\Melse  \;0) \Min {}\\{}
 \Mlet  \;\tsunknown{have\_data\_to\_send} = \tsvar{cb}.\tsfield{snd\_nxt} < \tsunknown{last\_sndq\_data\_seq} \;\Min {}\\{}
 \Mlet  \;\tsunknown{have\_data\_or\_fin\_to\_send} = \tsvar{cb}.\tsfield{snd\_nxt} < \tsunknown{last\_sndq\_data\_and\_fin\_seq} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ The amount by which the right edge of the advertised window could be moved }{}\\{}
 \Mlet  \;\tsunknown{window\_update\_delta} = (\tsunknown{int\_min} (\tsholop{int\_of\_num}(\tsaux{TCP\_MAXWIN} \ll  \tsvar{cb}.\tsfield{rcv\_scale})){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsholop{int\_of\_num}(\tsunknown{sock}.\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF})) - \tsholop{int\_of\_num}(\tsholop{LENGTH}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{rcvq}))) -{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{cb}.\tsfield{rcv\_adv} - \tsvar{cb}.\tsfield{rcv\_nxt}) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Send a window update? This occurs when (a) the advertised window can be increased by at
        least two maximum segment sizes, or (b) the advertised window can be increased by at least
        half the receive buffer size. See \wasverb{tcp\textunderscore{}output.c:322ff}. }{}\\{}
 \Mlet  \;\tsunknown{need\_to\_send\_a\_window\_update} = (\tsunknown{window\_update\_delta} \geq  \tsholop{int\_of\_num} (2 * \tsvar{cb}.\tsfield{t\_maxseg}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad 2 * \tsunknown{window\_update\_delta} \geq  \tsholop{int\_of\_num} (\tsunknown{sock}.\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}))){}\\{}
 \Min {}\\{}
 {}\\{}
 \tsholcomm{ Note that silly window avoidance and $\tsunknown{max\_sndwnd}$ need to be dealt with here; see \wasverb{tcp\textunderscore{}output.c:309} }{}\\{}
 {}\\{}
 \tsholcomm{ Can a segment be transmitted? }{}\\{}
 \Mlet  \;\tsunknown{do\_output} = ({}\\{}
 \tsholcomm{ Data to send and the send window has some space, or a FIN can be sent }{}\\{}
 (\tsunknown{have\_data\_or\_fin\_to\_send} \Mwedge {}\\{}
\quad (\tsunknown{have\_data\_to\_send} \implies  \tsunknown{snd\_wnd\_unused} > 0)) \Mvee   \tscomm{ don't need space if only sending FIN }{}\\{}
 {}\\{}
 \tsholcomm{ Can send a window update }{}\\{}
 \tsunknown{need\_to\_send\_a\_window\_update} \Mvee {}\\{}
 {}\\{}
 \tsholcomm{ There is outstanding urgent data to be transmitted }{}\\{}
 \tsholop{IS\_SOME} \;\tsunknown{tcp\_sock}.\tsvar{sndurp} \Mvee {}\\{}
 {}\\{}
 \tsholcomm{ An ACK should be sent immediately (e.g. in reply to a window probe) }{}\\{}
 \tsvar{cb}.\tsfield{tf\_shouldacknow}{}\\{}
 ) \Min {}\\{}
 {}\\{}
 \Mlet  \;\tsunknown{persist\_fun} ={}\\{}
 \Mlet  \;\tsunknown{cant\_send} = (\neg{}\tsunknown{do\_output} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{sndq} \neq  [\,] \Mwedge  \tsaux{mode\_of} \;\tsvar{cb}.\tsfield{tt\_rexmt} = *) \Min {}\\{}
 \Mlet  \;\tsunknown{window\_shrunk} = (\tsvar{win} = 0 \Mwedge  \tsunknown{snd\_wnd\_unused} < 0 \Mwedge  \tsholcomm{ $\tsvar{win} = 0$ if in $\tscon{SYN\_SENT}$, but still may send FIN }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsaux{bsd\_arch} \;\tstype{arch} \implies  \tsunknown{tcp\_sock}.\tsvar{st} \neq  \tscon{SYN\_SENT})) \Min {}\\{}
 {}\\{}
 \Mif  \;\tsunknown{cant\_send} \;\Mthen   \tscomm{ takes priority over window\textunderscore{}shrunk; note this needs to be checked }{}\\{}
\quad \tsholcomm{ Can not transmit a segment despite a non-empty send queue and no running persist or
            retransmit timer. Must be the case that the receiver's advertised window is now zero, so
            start the persist timer. Normal: \wasverb{tcp\textunderscore{}output.c:378ff} }{}\\{}
\quad \Msome  \lambda \tsvar{cb}. \tsvar{cb} \; \Mmagiclrec  \tsfield{tt\_rexmt} \Mass  \tsaux{start\_tt\_persist} \;0 \;\tsvar{cb}.\tsfield{t\_rttinf} \;\tstype{arch} \Mmagicrrec {}\\{}
 \Melse  \;\Mif  \;\tsunknown{window\_shrunk} \;\Mthen {}\\{}
\quad \tsholcomm{ The receiver's advertised window is zero and the receiver has retracted window space
            that it had previously advertised. Reset $\tsfield{snd\_nxt}$ to $\tsfield{snd\_una}$ because the data
            from $\tsfield{snd\_una}$ to $\tsfield{snd\_nxt}$ has likely not been buffered by the receiver and should
            be retransmitted. Bizzarely (on FreeBSD 4.6-RELEASE), if the persist timer is running
            reset its shift value }{}\\{}
\quad \tscomm{ Window shrunk: |tcp\textunderscore{}output.c:250ff| }{}\\{}
\quad \Msome  \lambda \tsvar{cb}.{}\\{}
\quad\quad \tsvar{cb} \; \Mmagiclrec  \tsfield{tt\_rexmt} \Mass  \Mcase  \;\tsvar{cb}.\tsfield{tt\_rexmt} \;\Mof {}\\{}
 \Msome  (\Mtimed{(\tscon{Persist},\tsunknown{shift})}{\tsunknown{d}}) \Mtotype  \Msome  (\Mtimed{(\tscon{Persist},0)}{\tsunknown{d}}){}\\{}
 \Mdpipe  \tsunknown{\_593} \Mtotype  \tsaux{start\_tt\_persist} \;0 \;\tsvar{cb}.\tsfield{t\_rttinf} \;\tstype{arch} ;{}\\{}
 \tsfield{snd\_nxt} \Mass  \tsvar{cb}.\tsfield{snd\_una} \Mmagicrrec {}\\{}
 \Melse {}\\{}
\quad \tsholcomm{ Otherwise, leave the persist timer alone }{}\\{}
\quad *{}\\{}
 \Min {}\\{}
 (\tsunknown{do\_output},\tsunknown{persist\_fun})}
}
{\rulesubsection{Description}

  This function determines if it is currently necessary to emit a
  segment.  It is not quite a predicate, because in certain
  circumstances the operation of testing may start or reset the
  persist timer, and alter $\tsfield{snd\_nxt}$.  Thus it returns a pair of a
  flag $\tsunknown{do\_output}$ (with the obvious meaning), and an optional
  mutator function $\tsunknown{persist\_fun}$ which, if present, performs the
  required updates on the TCP control block.

\rrulepad }
}

\newcommand{\defntcpToutputTreally}{\ddefnc{tcpToutputTreally}{\iA{tcp\_output\_really}}{\subddefnA[{ do TCP output }]{tcp\_output\_really}{\tsaux{tcp\_output\_really} \;\tstype{arch} \;\tsunknown{window\_probe} \;\tsunknown{ts\_val'} \;\tsvar{ifds}_{0} \;\tsunknown{sock} (\tsunknown{sock'},\tsunknown{outsegs'}) ={}\\{}
 \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsunknown{sock} \;\Min {}\\{}
 \Mlet  \;\tsvar{cb} = \tsunknown{tcp\_sock}.\tsvar{cb} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Assert that the socket is fully bound and connected }{}\\{}
 \tsunknown{sock}.\tsvar{is}_{1} \neq  * \Mwedge {}\\{}
 \tsunknown{sock}.\tsvar{is}_{2} \neq  * \Mwedge {}\\{}
 \tsunknown{sock}.\tsvar{ps}_{1} \neq  * \Mwedge {}\\{}
 \tsunknown{sock}.\tsvar{ps}_{2} \neq  * \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Note this does not deal with \wasverb{TF\textunderscore{}LASTIDLE} and \wasverb{PRU\textunderscore{}MORETOCOME} }{}\\{}
 \Mlet  \;\tsunknown{snd\_cwnd'} ={}\\{}
 \Mif  \neg{}(\tsvar{cb}.\tsfield{snd\_max} = \tsvar{cb}.\tsfield{snd\_una} \Mwedge {}\\{}
\quad\quad\quad \tsaux{stopwatch\_val\_of} \;\tsvar{cb}.\tsfield{t\_idletime} \geq  \tsaux{computed\_rxtcur} \;\tsvar{cb}.\tsfield{t\_rttinf} \;\tstype{arch}){}\\{}
 \Mthen   \tscomm{ inverted so this clause is tried first }{}\\{}
\quad\quad \tsvar{cb}.\tsfield{snd\_cwnd}{}\\{}
 \Melse {}\\{}
\quad \tsholcomm{ The connection is idle and has been for >= 1RTO }{}\\{}
\quad\quad \tsholcomm{ Reduce $\tsfield{snd\_cwnd}$ to commence slow start }{}\\{}
\quad\quad \tsvar{cb}.\tsfield{t\_maxseg} * (\Mif  \;\tsaux{is\_localnet} \;\tsvar{ifds}_{0} (\tsholop{THE} \;\tsunknown{sock}.\tsvar{is}_{2}) \Mthen  \;\tsaux{SS\_FLTSZ\_LOCAL} \;\Melse  \;\tsaux{SS\_FLTSZ}) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Calculate the amount of unused send window }{}\\{}
 \Mlet  \;\tsvar{win}_{0} = \tsholop{MIN} \;\tsvar{cb}.\tsfield{snd\_wnd} \;\tsunknown{snd\_cwnd'} \;\Min {}\\{}
 \Mlet  \;\tsvar{win} = (\Mif  \;\tsunknown{window\_probe} \Mwedge  \tsvar{win}_{0} = 0 \;\Mthen  \;1 \;\Melse  \;\tsvar{win}_{0}) \Min {}\\{}
 \Mlet  (\tsunknown{snd\_wnd\_unused} : \tstype{int}) = \tsholop{int\_of\_num} \;\tsvar{win} - (\tsvar{cb}.\tsfield{snd\_nxt} - \tsvar{cb}.\tsfield{snd\_una}) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Is it possible that a $\tsvar{FIN}$ may need to be transmitted? }{}\\{}
 \Mlet  \;\tsunknown{fin\_required} = (\tsunknown{sock}.\tsvar{cantsndmore} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} \;\notin  \{\tscon{FIN\_WAIT\_2};\tscon{TIME\_WAIT}\}) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Calculate the sequence number after the last data byte in the send queue }{}\\{}
 \Mlet  \;\tsunknown{last\_sndq\_data\_seq} = \tsvar{cb}.\tsfield{snd\_una} + \tsholop{LENGTH} \;\tsunknown{tcp\_sock}.\tsvar{sndq} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ The data to send in this segment (if any) }{}\\{}
 \Mlet  \;\tsvar{data}' = \tsaux{DROP} (\tsholop{Num} (\tsvar{cb}.\tsfield{snd\_nxt} - \tsvar{cb}.\tsfield{snd\_una})) \tsunknown{tcp\_sock}.\tsvar{sndq} \;\Min {}\\{}
 \Mlet  \;\tsunknown{data\_to\_send} = \tsaux{TAKE} (\tsholop{MIN} (\tsaux{clip\_int\_to\_num} \;\tsunknown{snd\_wnd\_unused}) \tsvar{cb}.\tsfield{t\_maxseg}) \tsvar{data}' \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Should $\tsvar{FIN}$ be set in this segment? }{}\\{}
 \Mlet  \;\tsvar{FIN} = (\tsunknown{fin\_required} \Mwedge  \tsvar{cb}.\tsfield{snd\_nxt} + \tsholop{LENGTH} \;\tsunknown{data\_to\_send} \geq  \tsunknown{last\_sndq\_data\_seq}) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Should $\tsvar{ACK}$ be set in this segment? Under BSD, it is not set if the socket is in $\tscon{SYN\_SENT}$
        and emitting a $\tsvar{FIN}$ segment due to $\tslib{shutdown}()$ having been called. }{}\\{}
 \Mlet  \;\tsvar{ACK} = \Mif  (\tsaux{bsd\_arch} \;\tstype{arch} \Mwedge  \tsvar{FIN} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_SENT}) \Mthen  \;\Mfalse  \;\Melse  \;\Mtrue  \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ If this socket has previously sent a $\tsvar{FIN}$ which has not yet been acked, and $\tsfield{snd\_nxt}$
        is past the $\tsvar{FIN}$'s sequence number, then $\tsfield{snd\_nxt}$ should be set to the sequence number
        of the $\tsvar{FIN}$ flag, i.e. a retransmission. Check that $\tsfield{snd\_una} \neq  \tsvar{iss}$ as in this case no
        data has yet been sent over the socket  }{}\\{}
 \Mlet  \;\tsunknown{snd\_nxt'} = \Mif  \;\tsvar{FIN} \Mwedge  (\tsvar{cb}.\tsfield{snd\_nxt} + \tsholop{LENGTH} \;\tsunknown{data\_to\_send} = \tsunknown{last\_sndq\_data\_seq}+1 \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{snd\_una}  \neq  \tsvar{cb}.\tsvar{iss} \Mvee  \tsholop{Num}(\tsvar{cb}.\tsfield{snd\_nxt} - \tsvar{cb}.\tsvar{iss}) = 2) \Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{snd\_nxt} - 1{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{snd\_nxt} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ The BSD way: set $\tsvar{PSH}$ whenever sending the last byte of data in the send queue }{}\\{}
 \Mlet  \;\tsvar{PSH} = (\tsunknown{data\_to\_send} \neq  [\,] \Mwedge  \tsvar{cb}.\tsfield{snd\_nxt} + \tsholop{LENGTH} \;\tsunknown{data\_to\_send} = \tsunknown{last\_sndq\_data\_seq}) \Min {}\\{}
 {}\\{}
 \tsholcomm{ If sending urgent data, set the $\tsvar{URG}$ and $\tsvar{urp}$ fields appropriately }{}\\{}
 \Mlet  (\tsvar{URG},\tsvar{urp}) = (\Mcase  \;\tsunknown{tcp\_sock}.\tsvar{sndurp} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad * \Mtotype  (\Mfalse ,0) \Mdpipe   \tsholcomm{ No urgent data; don't set }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Msome  \;\tsunknown{sndurpn} \Mtotype  \Mlet  \;{\tsvar{urp}}_{\tsvar{n}} = (\tsvar{cb}.\tsfield{snd\_una} + \tsunknown{sndurpn}) - \tsvar{cb}.\tsfield{snd\_nxt} + 1 \;\Min {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscomm{ points one byte *past* the urgent byte }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mif  \;{\tsvar{urp}}_{\tsvar{n}} < 1 \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mfalse ,0) \tsholcomm{ Urgent data out of range; don't set }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;{\tsvar{urp}}_{\tsvar{n}} < 65536 \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mtrue ,\tsholop{Num} \;{\tsvar{urp}}_{\tsvar{n}}) \tsholcomm{ Urgent data in range; set }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ Urgent data in the very distant future; set }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscomm{ Steven's suggestion; not sure if followed }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mtrue ,65535)) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Calculate size of the receive window (based upon available buffer space) }{}\\{}
 \Mlet  \;\tsunknown{rcv\_wnd''} = \tsaux{calculate\_bsd\_rcv\_wnd} \;\tsunknown{sock}.\tsvar{sf} \;\tsunknown{tcp\_sock} \;\Min {}\\{}
 \Mlet  \;\tsunknown{rcv\_wnd'} = \tsholop{MAX} (\tsholop{Num} (\tsvar{cb}.\tsfield{rcv\_adv} - \tsvar{cb}.\tsfield{rcv\_nxt})) (\tsholop{MIN} (\tsaux{TCP\_MAXWIN} \ll  \tsvar{cb}.\tsfield{rcv\_scale}){}\\{}
\quad\quad\quad\quad\quad\quad (\Mif  \;\tsunknown{rcv\_wnd''} < \tsunknown{sock}.\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) \tsholop{DIV} \;4 \Mwedge  \tsunknown{rcv\_wnd''} < \tsvar{cb}.\tsfield{t\_maxseg}{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mthen  \;0  \tsholcomm{ Silly window avoidance: shouldn't advertise a tiny window }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsunknown{rcv\_wnd''})) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Possibly set the segment's timestamp option. Under BSD, we may need to send a
        $\tsvar{FIN}$ segment from $\tscon{SYN\_SENT}$, if the user called $\tslib{shutdown}()$, in which
        case the timestamp option hasn't yet been negotiated, so we used $\tsfield{tf\_req\_tstmp}$
        rather than $\tsfield{tf\_doing\_tstmp}$. }{}\\{}
 \Mlet  \;\tsunknown{want\_tstmp} = \Mif  (\tsaux{bsd\_arch} \;\tstype{arch} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_SENT}) \Mthen  \;\tsvar{cb}.\tsfield{tf\_req\_tstmp}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsvar{cb}.\tsfield{tf\_doing\_tstmp} \;\Min {}\\{}
 \Mlet  \;\tsvar{ts} = \tsaux{do\_tcp\_options} \;\tsunknown{want\_tstmp} \;\tsvar{cb}.\tsfield{ts\_recent} \;\tsunknown{ts\_val'} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Advertise an appropriately scaled receive window }{}\\{}
 \tsholcomm{ Assert the advertised window is within a sensible range }{}\\{}
 \Mlet  \;\tsvar{win} = \tsholop{n2w} (\tsunknown{rcv\_wnd'} \gg  \tsvar{cb}.\tsfield{rcv\_scale}) \Min {}\\{}
 \tsholop{w2n} \;\tsvar{win} = \tsunknown{rcv\_wnd'} \gg  \tsvar{cb}.\tsfield{rcv\_scale} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Assert the urgent pointer is within a sensible range }{}\\{}
 \Mlet  \;\tsunknown{urp\_} = \tsholop{n2w} \;\tsvar{urp} \;\Min {}\\{}
 \tsholop{w2n} \;\tsunknown{urp\_} = \tsvar{urp} \Mwedge {}\\{}
 {}\\{}
 \Mlet  \;\tsunknown{seg} = \Mmagiclrec  \tsvar{is}_{1}  \Mass  \tsunknown{sock}.\tsvar{is}_{1};{}\\{}
 \tsvar{is}_{2}  \Mass  \tsunknown{sock}.\tsvar{is}_{2};{}\\{}
 \tsvar{ps}_{1}  \Mass  \tsunknown{sock}.\tsvar{ps}_{1};{}\\{}
 \tsvar{ps}_{2}  \Mass  \tsunknown{sock}.\tsvar{ps}_{2};{}\\{}
 \tsvar{seq}  \Mass  \tsunknown{snd\_nxt'};{}\\{}
 \tsvar{ack}  \Mass  \tsvar{cb}.\tsfield{rcv\_nxt};{}\\{}
 \tsvar{URG}  \Mass  \tsvar{URG};{}\\{}
 \tsvar{ACK}  \Mass  \tsvar{ACK};{}\\{}
 \tsvar{PSH}  \Mass  \tsvar{PSH};{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mfalse ;{}\\{}
 \tsvar{FIN}  \Mass  \tsvar{FIN};{}\\{}
 \tsvar{win}  \Mass  \tsvar{win};{}\\{}
 \tsvar{ws}   \Mass  *;{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_};{}\\{}
 \tsvar{mss}  \Mass  *;{}\\{}
 \tsvar{ts}   \Mass  \tsvar{ts};{}\\{}
 \tsvar{data} \Mass  \tsunknown{data\_to\_send}{}\\{}
 \Mmagicbolrrec  \Min {}\\{}
 {}\\{}
 \tsholcomm{ If emitting a $\tsvar{FIN}$ for the first time then change TCP state }{}\\{}
 \Mlet  \;\tsvar{st}' = \Mif  \;\tsvar{FIN} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \Mcase  \;\tsunknown{tcp\_sock}.\tsvar{st} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad \tscon{SYN\_SENT}     \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ can't move yet -- wait until connection established (see $\tsrule{deliver\_in\_2}$/$\tsrule{deliver\_in\_3}$) }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{SYN\_RECEIVED} \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ can't move yet -- wait until connection established (see $\tsrule{deliver\_in\_2}$/$\tsrule{deliver\_in\_3}$) }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{ESTABLISHED}  \Mtotype  \tscon{FIN\_WAIT\_1} \Mdpipe {}\\{}
\quad\quad\quad\quad\quad\quad \tscon{CLOSE\_WAIT}   \Mtotype  \tscon{LAST\_ACK} \Mdpipe {}\\{}
\quad\quad\quad\quad\quad\quad \tscon{FIN\_WAIT\_1}   \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ FIN retransmission }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{FIN\_WAIT\_2}   \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ can't happen       }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{CLOSING}      \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ FIN retransmission }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{LAST\_ACK}     \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st} \Mdpipe     \tsholcomm{ FIN retransmission }{}\\{}
\quad\quad\quad\quad\quad\quad \tscon{TIME\_WAIT}    \Mtotype  \tsunknown{tcp\_sock}.\tsvar{st}       \tsholcomm{ can't happen       }{}\\{}
\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{st} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Updated values to store in the control block after the segment is output }{}\\{}
 \Mlet  \;\tsunknown{snd\_nxt''} = \tsunknown{snd\_nxt'} + \tsholop{LENGTH} \;\tsunknown{data\_to\_send} + (\Mif  \;\tsvar{FIN} \;\Mthen  \;1 \;\Melse  \;0) \Min {}\\{}
 \Mlet  \;\tsunknown{snd\_max'} = \tsholop{MAX} \;\tsvar{cb}.\tsfield{snd\_max} \;\tsunknown{snd\_nxt''} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Following a \wasverb{tcp\textunderscore{}output} code walkthrough by SB: }{}\\{}
 \Mlet  \;\tsunknown{tt\_rexmt'} = \Mif  (\tsaux{mode\_of} \;\tsvar{cb}.\tsfield{tt\_rexmt} = * \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsaux{mode\_of} \;\tsvar{cb}.\tsfield{tt\_rexmt} = \Msome (\tscon{Persist}) \Mwedge  \neg{}\tsunknown{window\_probe})) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{snd\_nxt''} > \tsvar{cb}.\tsfield{snd\_una} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ If the retransmit timer is not running, or the persist timer is running
                           and this segment isn't a window probe, and this segment contains data or
                           a $\tsvar{FIN}$ that occurs past $\tsfield{snd\_una}$ (i.e.~new data), then start the
                           retransmit timer. Note: if the persist timer is running it will be
                           implicitly stopped }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{start\_tt\_rexmt} \;\tstype{arch} \;0 \;\Mfalse  \;\tsvar{cb}.\tsfield{t\_rttinf}{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  (\tsunknown{window\_probe} \Mvee  (\tsholop{IS\_SOME} \;\tsunknown{tcp\_sock}.\tsvar{sndurp})) \Mwedge  \tsvar{win}_{0} \neq  0 \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{mode\_of} \;\tsvar{cb}.\tsfield{tt\_rexmt} = \Msome (\tscon{Persist}) \Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ If the segment is a window probe or urgent data is being sent, and in
                           either case the send window is not closed, stop any running persist
                           timer. Note: if $\tsunknown{window\_probe}$ is $\Mtrue $ then a persist timer will
                           always be running but this isn't necessarily true when urgent data is
                           being sent }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad * \tsholcomm{ stop persisting }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ Otherwise, leave the timers alone }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{tt\_rexmt} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Time this segment if it is sensible to do so, i.e.~the following conditions hold : (a) a
        segment is not already being timed, and (b) data or a FIN are being sent, and (c) the
        segment being emitted is not a retransmit, and (d) the segment is not a window probe }{}\\{}
 \Mlet  \;\tsunknown{t\_rttseg'} = \Mif  \;\tsunknown{IS\_NONE} \;\tsvar{cb}.\tsfield{t\_rttseg} \Mwedge  (\tsunknown{data\_to\_send} \neq  [\,] \Mvee  \tsvar{FIN}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{snd\_nxt''} > \tsvar{cb}.\tsfield{snd\_max} \Mwedge  \neg{}\tsunknown{window\_probe}{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome (\tsunknown{ts\_val'}, \tsunknown{snd\_nxt'}){}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{t\_rttseg} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Update the socket }{}\\{}
 \tsunknown{sock'} = \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{st} \Mass  \tsvar{st}'; \tsvar{cb} \Mass  \tsunknown{tcp\_sock}.\tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsfield{tt\_rexmt}      \Mass  \tsunknown{tt\_rexmt'};{}\\{}
 \tsfield{snd\_cwnd}      \Mass  \tsunknown{snd\_cwnd'};{}\\{}
 \tsfield{rcv\_wnd}       \Mass  \tsunknown{rcv\_wnd'};{}\\{}
 \tsfield{tf\_rxwin0sent} \Mass  (\tsunknown{rcv\_wnd'} = 0);{}\\{}
 \tsfield{tf\_shouldacknow} \Mass  \Mfalse ;{}\\{}
 \tsfield{t\_rttseg}      \Mass  \tsunknown{t\_rttseg'};{}\\{}
 \tsfield{snd\_max}       \Mass  \tsunknown{snd\_max'};{}\\{}
 \tsfield{snd\_nxt}       \Mass  \tsunknown{snd\_nxt''};{}\\{}
 \tsfield{tt\_delack}     \Mass  *;{}\\{}
 \tsfield{last\_ack\_sent} \Mass  \tsvar{cb}.\tsfield{rcv\_nxt};{}\\{}
 \tsfield{rcv\_adv}       \Mass  \tsvar{cb}.\tsfield{rcv\_nxt} + \tsunknown{rcv\_wnd'}{}\\{}
 \Mmagicbolrrec  \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Constrain the list of output segments to contain just the segment being emitted }{}\\{}
 \tsunknown{outsegs'} = [\tscon{TCP} \;\tsunknown{seg}]}
}
{\rulesubsection{Description}

  This function constructs the next segment to be output.  It is
  usually called once $\tsaux{tcp\_output\_required}$ has returned true, but
  sometimes is called directly when we wish always to emit a segment.
  A large number of TCP state variables are modified also.

  Note that while constructing the segment a variety of errors such as
  $\tscon{ENOBUFS}$ are possible, but this is not modelled here. Also,
  window shrinking is not dealt with properly here.

\rrulepad }
}

\newcommand{\defntcpToutputTperhaps}{\ddefnn{tcpToutputTperhaps}{\iA{tcp\_output\_perhaps}}{\subddefnA[{ combination of $\tsaux{tcp\_output\_required}$ and $\tsaux{tcp\_output\_really}$ }]{tcp\_output\_perhaps}{\tsaux{tcp\_output\_perhaps} \;\tstype{arch} \;\tsunknown{ts\_val} \;\tsvar{ifds}_{0} \;\tsunknown{sock} (\tsunknown{sock'},\tsunknown{outsegs}) ={}\\{}
 \Mlet  (\tsunknown{do\_output},\tsunknown{persist\_fun}) = \tsaux{tcp\_output\_required} \;\tstype{arch} \;\tsvar{ifds}_{0} \;\tsunknown{sock} \;\Min {}\\{}
 \Mlet  \;\tsunknown{sock''} ={}\\{}
 \tsholop{option\_case}\Mspiii{\tsunknown{sock}}{(\lambda  \tsvar{f}. \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsaux{tcp\_sock\_of} \;\tsunknown{sock} \; \;\tsvar{cb} \;\Mupdby  \;\tsvar{f}) \Mmagicrrec )}{\tsunknown{persist\_fun}} \Min {}\\{}
 \Mif  \;\tsunknown{do\_output} \;\Mthen {}\\{}
 \tsaux{tcp\_output\_really} \;\tstype{arch} \;\Mfalse  \;\tsunknown{ts\_val} \;\tsvar{ifds}_{0} \;\tsunknown{sock''} (\tsunknown{sock'},\tsunknown{outsegs}){}\\{}
 \Melse {}\\{}
 (\tsunknown{sock'} = \tsunknown{sock''} \Mwedge  \tsunknown{outsegs} = [\,])}
}
{}
}

\newcommand{\seccommtcpTsegmentTqueueing}{\clustersection{(TCP only)}{Segment Queueing}
\seccomm{
Once a segment is generated for output, it must be enqueued for
transmission.  This enqueuing may fail.  These functions model what
happens in this case, and encapsulate the
enqueuing-and-possibly-rolling-back process.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{rollback\_tcp\_output}$
&
&  Attempt to enqueue segments, reverting appropriate socket fields if the enqueue fails \\
$\tsrule{enqueue\_or\_fail}$
&
&  wrap $\tsaux{rollback\_tcp\_output}$ together with enqueue \\
$\tsrule{enqueue\_or\_fail\_sock}$
&
&  version of $\tsaux{enqueue\_or\_fail}$ that works with sockets rather than cbs \\
$\tsrule{enqueue\_and\_ignore\_fail}$
&
&  version of $\tsaux{enqueue\_or\_fail}$ that ignores errors and doesn't touch the tcpcb \\
$\tsrule{enqueue\_each\_and\_ignore\_fail}$
&
&  version of above that ignores errors and doesn't touch the tcpcb \\
$\tsrule{mlift\_tcp\_output\_perhaps\_or\_fail}$
&
&  do mliftc for function returning at most one segment and not dealing with queueing flag \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnrollbackTtcpToutput}{\ddefnn{rollbackTtcpToutput}{\iA{rollback\_tcp\_output}}{\subddefnA[{ Attempt to enqueue segments, reverting appropriate socket fields if the enqueue fails }]{rollback\_tcp\_output}{\tsaux{rollback\_tcp\_output} \;\tsunknown{rcvdsyn} \;\tsunknown{seg} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{is\_connect} \;\tsvar{cb}_{0} \;\tsunknown{cb\_in} (\tsvar{cb}',\tsvar{es}',\tsunknown{outsegs'}) ={}\\{}
 {}\\{}
 \tsholcomm{ NB: from $\tsvar{cb}_{0}$, only $\tsfield{snd\_nxt}$, $\tsfield{tt\_delack}$, $\tsfield{last\_ack\_sent}$, $\tsfield{rcv\_adv}$,
        $\tsfield{tf\_rxwin0sent}$, $\tsfield{t\_rttseg}$, $\tsfield{snd\_max}$, $\tsfield{tt\_rexmt}$ are
        used. }{}\\{}
 {}\\{}
 (\tsholop{choose} \;\tsunknown{allocated} \Mcons  (\Mif  \;\tsaux{INFINITE\_RESOURCES} \;\Mthen  \{\Mtrue \} \Melse  \{\Mtrue ;\Mfalse \}).{}\\{}
 \Mlet  \;\tsunknown{route} = \tsaux{test\_outroute} (\tsunknown{seg},\tsvar{rttab},\tsvar{ifds},\tstype{arch}) \Min {}\\{}
 \Mlet  \;\tsunknown{f0} = \lambda \tsvar{cb}. \tsvar{cb} \; \Mmagiclrec  \tscomm{ revert to original values; on ip\textunderscore{}output failure }{}\\{}
 \tsfield{snd\_nxt}       \Mass  \tsvar{cb}_{0}.\tsfield{snd\_nxt};{}\\{}
 \tsfield{tt\_delack}     \Mass  \tsvar{cb}_{0}.\tsfield{tt\_delack};{}\\{}
 \tsfield{last\_ack\_sent} \Mass  \tsvar{cb}_{0}.\tsfield{last\_ack\_sent};{}\\{}
 \tsfield{rcv\_adv}       \Mass  \tsvar{cb}_{0}.\tsfield{rcv\_adv}{}\\{}
 \Mmagicbolrrec  \Min {}\\{}
 \Mlet  \;\tsunknown{f1} = \lambda \tsvar{cb}. \Mif  \neg{}\tsunknown{rcvdsyn} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb} \; \Mmagiclrec  \tscomm{ set soft error flag; on ip\textunderscore{}output routing failure }{}\\{}
 \tsfield{t\_softerror} \Mass  \tsholop{THE} \;\tsunknown{route}  \tscomm{ assumes route = SOME (SOME e) }{}\\{}
 \Mmagicbolrrec  \Min {}\\{}
 \Mlet  \;\tsunknown{f2} = \lambda \tsvar{cb}. \tsvar{cb} \; \Mmagiclrec  \tscomm{ revert to original values; on early ENOBUFS }{}\\{}
 \tsfield{tf\_rxwin0sent} \Mass  \tsvar{cb}_{0}.\tsfield{tf\_rxwin0sent};{}\\{}
 \tsfield{t\_rttseg}      \Mass  \tsvar{cb}_{0}.\tsfield{t\_rttseg};{}\\{}
 \tsfield{snd\_max}       \Mass  \tsvar{cb}_{0}.\tsfield{snd\_max};{}\\{}
 \tsfield{tt\_rexmt}      \Mass  \tsvar{cb}_{0}.\tsfield{tt\_rexmt}{}\\{}
 \Mmagicbolrrec  \Min {}\\{}
 \Mlet  \;\tsunknown{f3} = \lambda \tsvar{cb}. \Mif  \;\tsholop{IS\_SOME} \;\tsvar{cb}.\tsfield{tt\_rexmt} \Mvee  \tsunknown{is\_connect} \;\Mthen   \tscomm{ quench; on ENOBUFS }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb} \; \Mmagiclrec  \tscomm{ maybe start rexmt and close down window }{}\\{}
 \tsfield{tt\_rexmt}      \Mass  \tsaux{start\_tt\_rexmt} \;\tstype{arch} \;0 \;\Mfalse  \;\tsvar{cb}.\tsfield{t\_rttinf};{}\\{}
 \tsfield{snd\_cwnd}      \Mass  \tsvar{cb}.\tsfield{t\_maxseg} \tscomm{ no LAN allowance, by design }{}\\{}
 \Mmagicbolrrec  \Min {}\\{}
 \Mif  \neg{}\tsunknown{allocated} \;\Mthen   \tscomm{ allocation failure }{}\\{}
\quad\quad \tsvar{cb}' = \tsunknown{f3} (\tsunknown{f2} (\tsunknown{f0} \;\tsunknown{cb\_in})) \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsvar{es}' = \Msome  \;\tscon{ENOBUFS}{}\\{}
 \Melse  \;\Mif  \;\tsunknown{route} = * \;\Mthen   \tscomm{ ill-formed segment }{}\\{}
\quad\quad \tsaux{ASSERTION\_FAILURE} \text{``rollback\textunderscore{}tcp\textunderscore{}output:1''}  \tscomm{ should never happen }{}\\{}
 \Melse  \;\Mif  \exists \tsvar{e}. \tsunknown{route} = \Msome  (\Msome  \;\tsvar{e}) \Mthen   \tscomm{ routing failure }{}\\{}
\quad\quad \tsvar{cb}' = \tsunknown{f1} (\tsunknown{f0} \;\tsunknown{cb\_in}) \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsvar{es}' = \tsholop{THE} \;\tsunknown{route}{}\\{}
 \Melse  \;\Mif  \;\tsaux{loopback\_on\_wire} \;\tsunknown{seg} \;\tsvar{ifds} \;\Mthen  \tscomm{ loopback not allowed on wire - RFC1122 }{}\\{}
\quad\quad (\Mif  \;\tsaux{windows\_arch} \;\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}' = \tsunknown{cb\_in} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsvar{es}' = *  \tscomm{ Windows silently drops segment! }{}\\{}
\quad\quad\quad \Melse  \;\Mif  \;\tsaux{bsd\_arch} \;\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}' = \tsunknown{f0} \;\tsunknown{cb\_in} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsvar{es}' = \Msome  \;\tscon{EADDRNOTAVAIL}{}\\{}
\quad\quad\quad \Melse  \;\Mif  \;\tsaux{linux\_arch} \;\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}' = \tsunknown{f0} \;\tsunknown{cb\_in} \Mwedge  \tsunknown{outsegs'} = [\,] \Mwedge  \tsvar{es}' = \Msome  \;\tscon{EINVAL}{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsaux{ASSERTION\_FAILURE} \text{``rollback\textunderscore{}tcp\textunderscore{}output:2''} \tscomm{ never happen }{}\\{}
\quad\quad ){}\\{}
 \Melse {}\\{}
\quad\quad (\exists \tsvar{queued}.{}\\{}
\quad\quad\quad \tsunknown{outsegs'} = [(\tsunknown{seg},\tsvar{queued})] \Mwedge {}\\{}
\quad\quad\quad \Mif  \neg{}\tsvar{queued} \;\Mthen   \tscomm{ queueing failure }{}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}' = \tsunknown{f3} (\tsunknown{f0} \;\tsunknown{cb\_in}) \Mwedge  \tsvar{es}' = \Msome  \;\tscon{ENOBUFS}{}\\{}
\quad\quad\quad \Melse   \tscomm{ success }{}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}' = \tsunknown{cb\_in} \Mwedge  \tsvar{es}' = *){}\\{}
 )}
}
{}
}

\newcommand{\defnenqueueTorTfail}{\ddefnn{enqueueTorTfail}{\iA{enqueue\_or\_fail}}{\subddefnA[{ wrap $\tsaux{rollback\_tcp\_output}$ together with enqueue }]{enqueue\_or\_fail}{\tsaux{enqueue\_or\_fail} \;\tsunknown{rcvdsyn} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{outsegs} \;\tsvar{oq} \;\tsvar{cb}_{0} \;\tsunknown{cb\_in} (\tsvar{cb}',\tsvar{oq}') ={}\\{}
 (\Mcase  \;\tsunknown{outsegs} \;\Mof {}\\{}
\quad [\,]    \Mtotype  \tsvar{cb}' = \tsvar{cb}_{0} \Mwedge  \tsvar{oq}' = \tsvar{oq}{}\\{}
 \Mdpipe  [\tsunknown{seg}] \Mtotype  (\exists \tsvar{outsegs}' \;\tsvar{es}'.{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{rollback\_tcp\_output} \;\tsunknown{rcvdsyn} \;\tsunknown{seg} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\Mfalse  \;\tsvar{cb}_{0} \;\tsunknown{cb\_in} (\tsvar{cb}',\tsvar{es}',\tsvar{outsegs}') \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{enqueue\_oq\_list\_qinfo} (\tsvar{oq},\tsvar{outsegs}',\tsvar{oq}')){}\\{}
 \Mdpipe  \tsunknown{\_other84} \Mtotype  \tsaux{ASSERTION\_FAILURE} \text{``enqueue\textunderscore{}or\textunderscore{}fail''} \tscomm{ only 0 or 1 segments at a time }{}\\{}
 )}
}
{}
}

\newcommand{\defnenqueueTorTfailTsock}{\ddefnn{enqueueTorTfailTsock}{\iA{enqueue\_or\_fail\_sock}}{\subddefnA[{ version of $\tsaux{enqueue\_or\_fail}$ that works with sockets rather than cbs }]{enqueue\_or\_fail\_sock}{\tsaux{enqueue\_or\_fail\_sock} \;\tsunknown{rcvdsyn} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{outsegs} \;\tsvar{oq} \;\tsunknown{sock0} \;\tsunknown{sock} (\tsunknown{sock'},\tsvar{oq}') ={}\\{}
 \tsholcomm{ NB: could calculate $\tsunknown{rcvdsyn}$, but clearer to pass it in }{}\\{}
 \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsunknown{sock} \;\Min {}\\{}
 \Mlet  \;\tsunknown{tcp\_sock0} = \tsaux{tcp\_sock\_of} \;\tsunknown{sock0} \;\Min {}\\{}
 (\exists \tsvar{cb}'.{}\\{}
 \tsaux{enqueue\_or\_fail} \;\tsunknown{rcvdsyn} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{outsegs} \;\tsvar{oq} (\tsaux{tcp\_sock\_of} \;\tsunknown{sock0}).\tsvar{cb} (\tsaux{tcp\_sock\_of} \;\tsunknown{sock}).\tsvar{cb} (\tsvar{cb}',\tsvar{oq}') \Mwedge {}\\{}
 \tsunknown{sock'} = \tsunknown{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsaux{tcp\_sock\_of} \;\tsunknown{sock} \; \Mmagiclrec {}\\{}
 \tsvar{cb} \Mass  \tsvar{cb}'{}\\{}
 \Mmagicbolrrec ) \Mmagicrrec )}
}
{}
}

\newcommand{\defnenqueueTandTignoreTfail}{\ddefnn{enqueueTandTignoreTfail}{\iA{enqueue\_and\_ignore\_fail}}{\subddefnA[{ version of $\tsaux{enqueue\_or\_fail}$ that ignores errors and doesn't touch the tcpcb }]{enqueue\_and\_ignore\_fail}{\tsaux{enqueue\_and\_ignore\_fail} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{outsegs} \;\tsvar{oq} \;\tsvar{oq}' ={}\\{}
 \exists \tsvar{rcvdsyn} \;\tsvar{cb}_{0} \;\tsunknown{cb\_in} \;\tsvar{cb}'.{}\\{}
 \tsaux{enqueue\_or\_fail} \;\tsvar{rcvdsyn} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{outsegs} \;\tsvar{oq} \;\tsvar{cb}_{0} \;\tsunknown{cb\_in} (\tsvar{cb}',\tsvar{oq}')}
}
{}
}

\newcommand{\defnenqueueTeachTandTignoreTfail}{\ddefnn{enqueueTeachTandTignoreTfail}{\iA{enqueue\_each\_and\_ignore\_fail}}{\subddefnA[{ version of above that ignores errors and doesn't touch the tcpcb }]{enqueue\_each\_and\_ignore\_fail}{(\tsaux{enqueue\_each\_and\_ignore\_fail} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} [\,] \tsvar{oq} \;\tsvar{oq}' = (\tsvar{oq} = \tsvar{oq}')) \Mwedge {}\\{}
 (\tsaux{enqueue\_each\_and\_ignore\_fail} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} (\tsunknown{seg}\Mcons \tsunknown{segs}) \tsvar{oq} \;\tsvar{oq}''{}\\{}
 = \exists \tsvar{oq}'. \tsaux{enqueue\_and\_ignore\_fail} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} [\tsunknown{seg}] \tsvar{oq} \;\tsvar{oq}' \Mwedge {}\\{}
\quad\quad\quad\quad \tsaux{enqueue\_each\_and\_ignore\_fail} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsunknown{segs} \;\tsvar{oq}' \;\tsvar{oq}'')}
}
{}
}

\newcommand{\defnmliftTtcpToutputTperhapsTorTfail}{\ddefnn{mliftTtcpToutputTperhapsTorTfail}{\iA{mlift\_tcp\_output\_perhaps\_or\_fail}}{\subddefnA[{ do mliftc for function returning at most one segment and not dealing with queueing flag }]{mlift\_tcp\_output\_perhaps\_or\_fail}{\tsaux{mlift\_tcp\_output\_perhaps\_or\_fail} \;\tsunknown{ts\_val} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds}_{0} ={}\\{}
 \tsaux{mliftc} (\lambda  \tsvar{s} (\tsvar{s}',\tsunknown{outsegs'}).{}\\{}
\quad\quad\quad\quad \exists \tsvar{s}_{1} \;\tsvar{segs}.{}\\{}
\quad\quad\quad\quad \tsaux{tcp\_output\_perhaps} \;\tstype{arch} \;\tsunknown{ts\_val} \;\tsvar{ifds}_{0} \;\tsvar{s} (\tsvar{s}_{1},\tsvar{segs}) \Mwedge {}\\{}
\quad\quad\quad\quad \Mcase  \;\tsvar{segs} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad [\,]       \Mtotype  \tsvar{s}' = \tsvar{s}_{1} \Mwedge  \tsunknown{outsegs'} = [\,]{}\\{}
\quad\quad\quad\quad \Mdpipe  [\tsunknown{seg}]    \Mtotype  (\exists \tsvar{cb}' \;\tsvar{es}'.  \tscomm{ ignore error return }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{rollback\_tcp\_output} \;\Mtrue  \;\tsunknown{seg} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds}_{0} \;\Mfalse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsaux{tcp\_sock\_of} \;\tsvar{s}).\tsvar{cb} (\tsaux{tcp\_sock\_of} \;\tsvar{s}_{1}).\tsvar{cb} (\tsvar{cb}',\tsvar{es}',\tsunknown{outsegs'}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{s}' = \tsvar{s}_{1} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsaux{tcp\_sock\_of} \;\tsvar{s}_{1} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}' \Mmagicrrec ) \Mmagicrrec ){}\\{}
\quad\quad\quad\quad \Mdpipe  \tsunknown{\_other58} \Mtotype  \tsaux{ASSERTION\_FAILURE} \text{``mlift\textunderscore{}tcp\textunderscore{}output\textunderscore{}perhaps\textunderscore{}or\textunderscore{}fail''}  \tscomm{ never happen }{}\\{}
\quad\quad\quad )}
}
{}
}

\newcommand{\seccommtcpTincomingTsegment}{\clustersection{(TCP only)}{Incoming Segment Functions}
\seccomm{
Updates performed to the idle, keepalive, and \wasverb{FIN\textunderscore{}WAIT\textunderscore{}2} timers for
every incoming segment.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{update\_idle}$
&
&  Do updates appropriate to receiving a new segment on a connection \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnupdateTidle}{\ddefnn{updateTidle}{\iA{update\_idle}}{\subddefnA[{ Do updates appropriate to receiving a new segment on a connection }]{update\_idle}{\tsaux{update\_idle} \;\tsunknown{tcp\_sock} ={}\\{}
 \Mlet  \;\tsunknown{t\_idletime'} = \tsaux{stopwatch\_zero} \;\Min      \tsholcomm{ update 'time most recent packet received' field }{}\\{}
 \Mlet  \;\tsunknown{tt\_keep'} = (\Mif  \neg{}(\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tf\_needfin}) \Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ reset keepalive timer to 2 hours. }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Msome  (\Mtimed{()}{\tsaux{slow\_timer} \;\tsaux{TCPTV\_KEEP\_IDLE}}){}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_keep}) \Min {}\\{}
 \Mlet  \;\tsunknown{tt\_fin\_wait\_2'} = (\Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{FIN\_WAIT\_2} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  (\Mtimed{()}{\tsaux{slow\_timer} \;\tsaux{TCPTV\_MAXIDLE}}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_fin\_wait\_2}) \Min {}\\{}
 (\tsunknown{t\_idletime'}, \tsunknown{tt\_keep'}, \tsunknown{tt\_fin\_wait\_2'})}
}
{}
}

\newcommand{\seccommtcpTdropTsegment}{\clustersection{(TCP only)}{Drop Segment Functions}
\seccomm{
When an erroneous or unexpected segment arrives, it is usually dropped
(i.e, ignored).  However, the peer is usually informed immediately by
means of a RST or ACK segment.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{dropwithreset}$
&
&  emit a RST segment corresponding to the passed segment, unless that would be stupid. \\
$\tsrule{mlift\_dropafterack\_or\_fail}$
&
&  send immediate ACK to segment, but otherwise process it no further \\
$\tsrule{dropwithreset\_ignore\_fail}$
&
&  do $\tsaux{emit\_segs\_pred}$, for function returning at most one seg and not dealing with queueing flag \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defndropwithreset}{\ddefnn{dropwithreset}{\iA{dropwithreset}}{\subddefnA[{ emit a RST segment corresponding to the passed segment, unless that would be stupid. }]{dropwithreset}{\tsaux{dropwithreset} \;\tsunknown{seg} \;\tsvar{ifds}_{0} \;\tsvar{ticks} \;\tsunknown{reason} \;\tsvar{bndlm} \;\tsvar{bndlm}' \;\tsunknown{outsegs} ={}\\{}
 \tsholcomm{ Needs list of the host's interfaces, to verify that the incoming segment wasn't broadcast.
   Returns a list of segments. }{}\\{}
 {}\\{}
 \Mif   \tscomm{ never RST a RST }{}\\{}
\quad \tsunknown{seg}.\tsvar{RST} \Mvee {}\\{}
\quad \tscomm{ is segment a (link-layer?) broadcast or multicast? }{}\\{}
\quad \Mfalse  \Mvee {}\\{}
\quad \tscomm{ is source or destination broadcast or multicast? }{}\\{}
\quad (\exists \tsvar{i}_{1}. \tsunknown{seg}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsaux{is\_broadormulticast} \;\emptyset  \;\tsvar{i}_{1}) \Mvee {}\\{}
\quad (\exists \tsvar{i}_{2}. \tsunknown{seg}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsaux{is\_broadormulticast} \;\tsvar{ifds}_{0} \;\tsvar{i}_{2}){}\\{}
\quad\quad \tscomm{ BSD only checks incoming interface, but should have same effect as long as interfaces don't overlap }{}\\{}
 \Mthen {}\\{}
\quad \tsunknown{outsegs} = [\,] \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm}{}\\{}
 \Melse {}\\{}
\quad (\tsholop{choose} \;\tsunknown{seg'} \Mcons  \tsaux{make\_rst\_segment\_from\_seg} \;\tsunknown{seg}.{}\\{}
\quad \Mlet  (\tsunknown{emit},\tsvar{bndlm}'') = \tsaux{bandlim\_rst\_ok}(\tsunknown{seg'},\tsvar{ticks},\tsunknown{reason},\tsvar{bndlm}) \Min   \tscomm{ finally: check if band-limited }{}\\{}
\quad \tsvar{bndlm}' = \tsvar{bndlm}'' \Mwedge {}\\{}
\quad \tsunknown{outsegs} = \Mif  \;\tsunknown{emit} \;\Mthen  [\tscon{TCP} \;\tsunknown{seg'}] \Melse  [\,])}
}
{}
}

\newcommand{\defnmliftTdropafterackTorTfail}{\ddefnn{mliftTdropafterackTorTfail}{\iA{mlift\_dropafterack\_or\_fail}}{\subddefnA[{ send immediate ACK to segment, but otherwise process it no further }]{mlift\_dropafterack\_or\_fail}{\tsaux{mlift\_dropafterack\_or\_fail} \;\tsunknown{seg} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsvar{ticks} (\tsunknown{sock},\tsvar{bndlm}) ((\tsunknown{sock'},\tsvar{bndlm}',\tsunknown{outsegs'}),\tsunknown{continue}) ={}\\{}
 \tsholcomm{    $\tsvar{ifds}$ is just in case we need to send a RST, to make sure we don't
   send it to a broadcast address. }{}\\{}
 \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsunknown{sock} \;\Min {}\\{}
 (\tsunknown{continue} = \Mtrue  \Mwedge {}\\{}
 \Mlet  \;\tsvar{cb} = \tsunknown{tcp\_sock}.\tsvar{cb} \;\Min {}\\{}
 \Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge {}\\{}
\quad \tsunknown{seg}.\tsvar{ACK} \Mwedge {}\\{}
\quad (\Mlet  \;\tsvar{ack} = \tsunknown{tcp\_seq\_flip\_sense} \;\tsunknown{seg}.\tsvar{ack} \;\Min {}\\{}
\quad\quad (\tsvar{ack} < \tsvar{cb}.\tsfield{snd\_una} \Mvee  \tsvar{cb}.\tsfield{snd\_max} < \tsvar{ack})){}\\{}
 \Mthen {}\\{}
\quad\quad \tsholcomm{ break loop in "LAND" DoS attack, and also prevent ACK
            storm between two listening ports that have been sent
            forged SYN segments, each with the source address of
            the other. (\wasverb{tcp\textunderscore{}input.c:2141}) }{}\\{}
\quad\quad \tsunknown{sock'} = \tsunknown{sock} \Mwedge {}\\{}
\quad\quad \tsaux{dropwithreset} \;\tsunknown{seg} \;\tsvar{ifds} \;\tsvar{ticks} \;\tscon{BANDLIM\_RST\_OPENPORT} \;\tsvar{bndlm} \;\tsvar{bndlm}' (\tsholop{MAP} \;\tsholop{FST} \;\tsunknown{outsegs'}){}\\{}
\quad\quad\quad\quad \tscomm{ ignore queue full error }{}\\{}
 \Melse {}\\{}
\quad\quad (\exists \tsvar{sock}_{1} \;\tsvar{msg} \;\tsvar{cb}' \;\tsvar{es}'.  \tscomm{ ignore errors }{}\\{}
\quad\quad \Mlet  \;\tsunknown{tcp\_sock1} = \tsaux{tcp\_sock\_of} \;\tsvar{sock}_{1} \;\Min {}\\{}
\quad\quad \tsaux{tcp\_output\_really} \;\tstype{arch} \;\Mfalse  \;\tsvar{ticks} \;\tsvar{ifds} \;\tsunknown{sock} (\tsvar{sock}_{1},[\tsvar{msg}]) \Mwedge   \tsholcomm{ did set $\tsunknown{tf\_acknow}$ and call $\tsaux{tcp\_output\_perhaps}$, which seemed a bit silly }{}\\{}
\quad\quad \tsholcomm{ notice we here bake in the assumption that the timestamps use the same counter as the band limiter; perhaps this is unwise }{}\\{}
\quad\quad \tsaux{rollback\_tcp\_output} \;\Mtrue  \;\tsvar{msg} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\Mfalse  \;\tsunknown{tcp\_sock}.\tsvar{cb} \;\tsunknown{tcp\_sock1}.\tsvar{cb} (\tsvar{cb}',\tsvar{es}',\tsunknown{outsegs'}) \Mwedge {}\\{}
\quad\quad \tsunknown{sock'} = \tsvar{sock}_{1} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock1} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}' \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad \tsvar{bndlm}' = \tsvar{bndlm}))}
}
{}
}

\newcommand{\defndropwithresetTignoreTfail}{\ddefnn{dropwithresetTignoreTfail}{\iA{dropwithreset\_ignore\_fail}}{\subddefnA[{ do $\tsaux{emit\_segs\_pred}$, for function returning at most one seg and not dealing with queueing flag }]{dropwithreset\_ignore\_fail}{\tsaux{dropwithreset\_ignore\_fail} \;\tsunknown{seg\_in} \;\tstype{arch} \;\tsvar{ifds} \;\tsvar{rttab} \;\tsvar{ticks} \;\tsunknown{reason} \;\tsvar{b} \;\tsvar{b}' (\tsunknown{outsegs'}:(\tstype{msg} \# \tstype{bool}) \tstype{list}) ={}\\{}
 \tsholcomm{  No rollback necessary here. }{}\\{}
 \exists \tsvar{segs}.{}\\{}
 \tsaux{dropwithreset} \;\tsunknown{seg\_in} \;\tsvar{ifds} \;\tsvar{ticks} \;\tsunknown{reason} \;\tsvar{b} \;\tsvar{b}' \;\tsvar{segs} \Mwedge {}\\{}
 \Mcase  \;\tsvar{segs} \;\Mof {}\\{}
\quad [\,]       \Mtotype  \tsunknown{outsegs'} = [\,]{}\\{}
 \Mdpipe  [\tsunknown{seg}]    \Mtotype  (\tsholop{choose} \;\tsunknown{allocated} \Mcons  \Mif  \;\tsaux{INFINITE\_RESOURCES} \;\Mthen  \{\Mtrue \} \Melse  \{\Mtrue ;\Mfalse \}.{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mif  \neg{}\tsunknown{allocated} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{outsegs'} = [\,]{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mcase  \;\tsaux{test\_outroute} (\tsunknown{seg},\tsvar{rttab},\tsvar{ifds},\tstype{arch}) \Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad *          \Mtotype  \tsaux{ASSERTION\_FAILURE} \text{``dropwithreset\textunderscore{}ignore\textunderscore{}fail:1''}  \tscomm{ never happen }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mdpipe  \Msome  (\Msome  \;\tsvar{e}) \Mtotype  \tsunknown{outsegs'} = [\,]  \tscomm{ ignore error }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mdpipe  \Msome  \;*     \Mtotype  \exists \tsvar{queued}. \tsunknown{outsegs'} = [(\tsunknown{seg},\tsvar{queued})])){}\\{}
 \Mdpipe  \tsunknown{\_other57} \Mtotype  \tsaux{ASSERTION\_FAILURE} \text{``dropwithreset\textunderscore{}ignore\textunderscore{}fail:2''}  \tscomm{ never happen }}
}
{}
}

\newcommand{\seccommtcpTclose}{\clustersection{(TCP only)}{Close Functions}
\seccomm{
Closing a connection, updating the socket and TCP control block
appropriately.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{tcp\_close}$
&
&  close the socket and remove the TCPCB \\
$\tsrule{tcp\_drop\_and\_close}$
&
&  drop TCP connection, reporting the specified error.  If synchronised, send RST to peer \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntcpTclose}{\ddefnc{tcpTclose}{\iA{tcp\_close}}{\subddefnA[{ close the socket and remove the TCPCB }]{tcp\_close}{\tsaux{tcp\_close} \;\tstype{arch} \;\tsunknown{sock} = \tsunknown{sock} \;{}\\{}
 \Mmagiclrec  \tsvar{cantrcvmore} \Mass  \Mtrue ; \tscomm{ MF doesn't believe this is correct for Linux or WinXP }{}\\{}
 \tsvar{cantsndmore} \Mass  \Mtrue ;{}\\{}
 \tsvar{is}_{1} \Mass  \Mif  \;\tsaux{bsd\_arch} \;\tstype{arch} \;\Mthen  \;* \;\Melse  \;\tsunknown{sock}.\tsvar{is}_{1};{}\\{}
 \tsvar{ps}_{1} \Mass  \Mif  \;\tsaux{bsd\_arch} \;\tstype{arch} \;\Mthen  \;* \;\Melse  \;\tsunknown{sock}.\tsvar{ps}_{1};{}\\{}
 \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsaux{tcp\_sock\_of} \;\tsunknown{sock} \;{}\\{}
 \Mmagiclrec  \tsvar{st} \Mass  \tscon{CLOSED};{}\\{}
 \tsvar{cb} \Mass  \tsaux{initial\_cb} \; \tscomm{ in reality, it's dropped entirely, but we don't do that }{}\\{}
 \Mmagiclrec  \tsfield{bsd\_cantconnect} \Mass  \Mif  \;\tsaux{bsd\_arch} \;\tstype{arch} \;\Mthen  \;\Mtrue  \;\Melse  \;\Mfalse  \Mmagicrrec  ;{}\\{}
 \tsvar{sndq} \Mass  [\,] \Mmagicrrec ){}\\{}
 \Mmagicbolrrec }
}
{\rulesubsection{Description}
   This is similar to BSD's \wasverb{tcp\textunderscore{}close()}, except
   that we do not actually remove the protocol/control blocks. The quad of the socket is
   cleared, to enable another socket to bind to the port we were previously using --- this
   isn't actually done by BSD, but the effect is the same. The $\tsfield{bsd\_cantconnect}$ flag is
   set to indicate that the socket is in such a detached state.
\rrulepad }
}

\newcommand{\defntcpTdropTandTclose}{\ddefnc{tcpTdropTandTclose}{\iA{tcp\_drop\_and\_close}}{\subddefnA[{ drop TCP connection, reporting the specified error.  If synchronised, send RST to peer }]{tcp\_drop\_and\_close}{\tsaux{tcp\_drop\_and\_close} \;\tstype{arch} \;\tstype{err} \;\tsunknown{sock} (\tsunknown{sock'},\tsunknown{outsegs}) ={}\\{}
 \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsunknown{sock} \;\Min  ({}\\{}
 (\Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} \;\notin  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT}\} \Mthen {}\\{}
\quad\quad (\tsholop{choose} \;\tsunknown{seg} \Mcons  (\tsaux{make\_rst\_segment\_from\_cb} \;\tsunknown{tcp\_sock}.\tsvar{cb}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsholop{THE} \;\tsunknown{sock}.\tsvar{is}_{1}, \tsholop{THE} \;\tsunknown{sock}.\tsvar{is}_{2}, \tsholop{THE} \;\tsunknown{sock}.\tsvar{ps}_{1}, \tsholop{THE} \;\tsunknown{sock}.\tsvar{ps}_{2})).{}\\{}
\quad\quad \tsunknown{outsegs} = [\tscon{TCP} \;\tsunknown{seg}]){}\\{}
\quad \Melse {}\\{}
\quad\quad \tsunknown{outsegs} = [\,]) \Mwedge {}\\{}
 \Mlet  \;\tsvar{es}' ={}\\{}
 \Mif  \;\tstype{err} = \Msome  \;\tscon{ETIMEDOUT} \;\Mthen {}\\{}
\quad (\Mif  \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{t\_softerror} \neq  * \;\Mthen {}\\{}
\quad\quad \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{t\_softerror}{}\\{}
\quad \Melse {}\\{}
\quad\quad \Msome  \;\tscon{ETIMEDOUT}){}\\{}
 \Melse  \;\Mif  \;\tstype{err} \neq  * \;\Mthen  \;\tstype{err}{}\\{}
 \Melse  \;\tsunknown{sock}.\tsvar{es}{}\\{}
 \Min {}\\{}
 \tsunknown{sock'} = \tsaux{tcp\_close} \;\tstype{arch} (\tsunknown{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}' \Mmagicrrec ))}
}
{\rulesubsection{Description}
 BSD calls this \wasverb{tcp\textunderscore{}drop}
\rrulepad }
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPITauxFns}
\showrule{\seccommauxTfiles}
\showrule{\defnsaneTsocket}
\showrule{\seccommauxTbinding}
\showrule{\defnboundTportsTprotocolTautobind}
\showrule{\defnboundTportTallowed}
\showrule{\defnautobind}
\showrule{\defnboundTafter}
\showrule{\defnmatchTscore}
\showrule{\defnlookupTudp}
\showrule{\defntcpTsocketTbestTmatch}
\showrule{\defnlookupTicmp}
\showrule{\seccommmiscTaux}
\showrule{\defndoTtcpToptions}
\showrule{\defncalculateTtcpToptionsTlen}
\showrule{\seccommauxTbuffers}
\showrule{\defncalculateTbufTsizes}
\showrule{\defncalculateTbsdTrcvTwnd}
\showrule{\defnsendTqueueTspace}
\showrule{\seccommauxTbandlim}
\showrule{\defnbandlimTstateTinit}
\showrule{\defnbandlimTrstTokTalways}
\showrule{\defnsimpleTlimit}
\showrule{\defnbandlimTrstTokTsimple}
\showrule{\defnbandlimTrstTok}
\showrule{\defnenqueueToqTbndlimTrst}
\showrule{\seccommauxTudp}
\showrule{\defndosend}
\showrule{\seccommauxTtcptime}
\showrule{\defntcpTbackoffs}
\showrule{\defntcpTsynTbackoffs}
\showrule{\defnmodeTof}
\showrule{\defnshiftTof}
\showrule{\defncomputedTrto}
\showrule{\defncomputedTrxtcur}
\showrule{\defnstartTttTrexmtTgen}
\showrule{\defnstartTttTrexmt}
\showrule{\defnstartTttTrexmtsyn}
\showrule{\defnstartTttTpersist}
\showrule{\defnupdateTrtt}
\showrule{\defnexpandTcwnd}
\showrule{\seccommauxTpmtu}
\showrule{\defnnextTsmaller}
\showrule{\defnmtuTtab}
\showrule{\seccommauxTreass}
\showrule{\defntcpTreass}
\showrule{\defntcpTreassTprune}
\showrule{\seccomminitialTcb}
\showrule{\defninitialTcb}
\showrule{\chapcommTCPITauxFnsTrelmonad}
\showrule{\seccommauxTrelmonad}
\showrule{\defnandThen}
\showrule{\defncont}
\showrule{\defnstop}
\showrule{\defnassert}
\showrule{\defnassertTfailure}
\showrule{\defnchooseM}
\showrule{\defngetTsock}
\showrule{\defngetTtcpTsock}
\showrule{\defngetTcb}
\showrule{\defnmodifyTsock}
\showrule{\defnmodifyTtcpTsock}
\showrule{\defnmodifyTcb}
\showrule{\defnemitTsegs}
\showrule{\defnemitTsegsTpred}
\showrule{\defnmliftc}
\showrule{\defnmliftcTbndlm}
\showrule{\chapcommTCPmajorAuxFns}
\showrule{\seccommtcpTsynTrstTsegmentTcreation}
\showrule{\defnmakeTsynTsegment}
\showrule{\defnmakeTsynTackTsegment}
\showrule{\defnmakeTackTsegment}
\showrule{\defnbsdTmakeTphantomTsegment}
\showrule{\defnmakeTrstTsegmentTfromTcb}
\showrule{\defnmakeTrstTsegmentTfromTseg}
\showrule{\seccommtcpTsegmentTcreation}
\showrule{\defntcpToutputTrequired}
\showrule{\defntcpToutputTreally}
\showrule{\defntcpToutputTperhaps}
\showrule{\seccommtcpTsegmentTqueueing}
\showrule{\defnrollbackTtcpToutput}
\showrule{\defnenqueueTorTfail}
\showrule{\defnenqueueTorTfailTsock}
\showrule{\defnenqueueTandTignoreTfail}
\showrule{\defnenqueueTeachTandTignoreTfail}
\showrule{\defnmliftTtcpToutputTperhapsTorTfail}
\showrule{\seccommtcpTincomingTsegment}
\showrule{\defnupdateTidle}
\showrule{\seccommtcpTdropTsegment}
\showrule{\defndropwithreset}
\showrule{\defnmliftTdropafterackTorTfail}
\showrule{\defndropwithresetTignoreTfail}
\showrule{\seccommtcpTclose}
\showrule{\defntcpTclose}
\showrule{\defntcpTdropTandTclose}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore hostLTS

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
% TCP1_hostLTSScript.sml:5889:21-28:          WARNING: Empty errors preamble in cluster comment
\def\rulesrcsid{\$Id: alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommsocketTcalls}{\chaptersection{ Host LTS: Socket Calls}
\label{socket_calls}%
\chapcomm{}
}

\newcommand{\seccommaccept}{\clustersection{(TCP only)}{$\tslib{accept}()$}
\seccomm{ \[ \tslib{accept}: \tstype{fd} \Mtotype  \tstype{fd} * (\tstype{ip} * \tstype{port}) \]

  $\tslib{accept}(\tstype{fd})$ returns the next connection available on the completed connections queue for the
  listening TCP socket referenced by file descriptor $\tstype{fd}$.  The returned file descriptor $\tstype{fd}$
  refers to the newly-connected socket; the returned $\tstype{ip}$ and $\tstype{port}$ are its remote address.
  $\tslib{accept}()$ blocks if the completed connections queue is empty and the socket does not have the
  $\tscon{O\_NONBLOCK}$ flag set.

  Any pending errors on the new connection are ignored, except for $\tscon{ECONNABORTED}$ which causes
  $\tslib{accept}()$ to fail with $\tscon{ECONNABORTED}$.

  Calling $\tslib{accept}()$ on a UDP socket fails: UDP is not a connection-oriented protocol.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{accept}()$ can fail with the errors below, in which case the corresponding exception
  is raised:

\par\begin{ltstabular}
$\tscon{EAGAIN}$
&  The socket has the $\tscon{O\_NONBLOCK}$ flag set and no connections are available on
  the completed connections queue.

\\\hline
$\tscon{ECONNABORTED}$
&  The connection at the head of the completed connections queue has been
  aborted; the socket has been shutdown for reading; or the socket has been closed.

\\\hline
$\tscon{EINVAL}$
&  Ths socket is not accepting connections, \ie,  it is not in the $\tscon{LISTEN}$ state,
  or is a UDP socket.

\\\hline
$\tscon{EMFILE}$
&  The maximum number of file descriptors allowed per process are already open for
  this process.

\\\hline
$\tscon{EOPNOTSUPP}$
&  The socket type of the specified socket does not support accepting
  connections. This error is raised if $\tslib{accept}()$ is called on a UDP socket.

\\\hline
$\tscon{ENFILE}$
&  Out of resources.


\\\hline
$\tscon{ENOBUFS}$
&  Out of resources.

\\\hline
$\tscon{ENOMEM}$
&  Out of resources.

\\\hline
$\tscon{EINTR}$
&  The system was interrupted by a caught signal.

\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tslib{accept}()$ is called and immediately returns a connection: $\tsrule{accept\_1}$; $\tsrule{return\_1}$

  $\tslib{accept}()$ is called and blocks; a connection is completed and the call returns: $\tsrule{accept\_2}$;
  $\tsrule{deliver\_in\_99}$; $\tsrule{deliver\_in\_1}$; $\tsrule{accept\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:  &  \wasverb{int accept(int socket, struct sockaddr *restrict address,} \\
            &  \wasverb{           socklen\textunderscore{}t *restrict address\textunderscore{}len);} \\
    FreeBSD:&  \wasverb{int accept(int s, struct sockaddr *addr, socklen\textunderscore{}t *addrlen);} \\
    Linux:  &  \wasverb{int accept(int s, struct sockaddr *addr, socklen\textunderscore{}t *addrlen);} \\
    WinXP:  &  \wasverb{SOCKET accept(SOCKET s, struct sockaddr* addr, int* addrlen);} \\
  \end{tabular}\\

  In the Posix interface:
  \begin{itemize}

    \item \wasverb{socket} is the listening socket's file descriptor, corresponding to the $\tstype{fd}$
     argument of the model;

    \item the returned \wasverb{int} is either non-negative, \ie,  a file descriptor referring to the
     newly-connected socket, or \wasverb{-1} to indicate an error, in which case the error code is
     in \wasverb{errno}.  On WinXP an error is indicated by a return value of
     \wasverb{INVALID\textunderscore{}SOCKET}, not \wasverb{-1}, with the actual error code available through a
     call to \wasverb{WSAGetLastError()}.

    \item \wasverb{address} is a pointer to a \wasverb{sockaddr} structure of length
    \wasverb{address\textunderscore{}len} corresponding to the $\tstype{ip}*\tstype{port}$ returned by the model $\tslib{accept}()$. If
    \wasverb{address} is not a null pointer then it stores the address of the peer for the accepted
    connection. For the model $\tslib{accept}()$ it will actually be a \wasverb{sockaddr\textunderscore{}in} structure;
    the peer IP address will be stored in the \wasverb{sin\textunderscore{}addr.s\textunderscore{}addr} field, and the peer port
    will be stored in the \wasverb{sin\textunderscore{}port} field. If \wasverb{address} is a null pointer then the
    peer address is ignored, but the model $\tslib{accept}()$ always returns the peer address. On input
    the \wasverb{address\textunderscore{}len} is the length of the \wasverb{address} structure, and on output it is
    the length of the stored address.

  \end{itemize}


}\clustersubsection{Model details}
\seccomm{
  If the $\tslib{accept}()$ call blocks then state $\tscon{Accept2}(\tstype{sid})$ is entered, where $\tstype{sid}$ is the index
  of the socket that $\tslib{accept}()$ was called upon.

  The following errors are not included in the model:
  \begin{itemize}

    \item \wasverb{EFAULT} signifies that the pointers passed as either the \wasverb{address} or
     \wasverb{address\textunderscore{}len} arguments were inaccessible.  This is an artefact of the C interface to
     $\tslib{accept}()$ that is excluded by the clean interface used in the model.

    \item \wasverb{EPERM} is a Linux-specific error code described by the Linux man page as
     "Firewall rules forbid connection". This is outside the scope of what is modelled.

    \item \wasverb{EPROTO} is a Linux-specific error code described by the man page as "Protocol
     error". Only TCP and UDP are modelled here; the only sockets that can exist in the model are
     bound to a known protocol.

    \item \wasverb{WSAECONNRESET} is a WinXP-specific error code described in the MSDN page as "An
    incoming connection was indicated, but was subsequently terminated by the remote peer prior to
    accepting the call." This error has not been encountered in exhaustive testing.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


  From the Linux man page:
       Linux $\tslib{accept}()$ passes already-pending network errors on the new socket as
       an error code from accept.  This behaviour differs from other BSD socket implementations.
       For reliable operation the application should detect the network errors defined for the
       protocol after accept and treat them like EAGAIN by retrying. In case of TCP/IP these are
       ENETDOWN, EPROTO, ENOPROTOOPT, EHOSTDOWN, ENONET, EHOSTUNREACH, EOPNOTSUPP, and
       ENETUNREACH.

       This is currently not modelled, but will be looked at when the Linux semantics are
       investigated.



}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{accept\_1}$
& \textbf{tcp: rc}
&  Return new connection; either immediately or from a blocked state. \\
$\tsrule{accept\_2}$
& \textbf{tcp: block}
&  Block waiting for connection \\
$\tsrule{accept\_3}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{EAGAIN}$: no pending connections and non-blocking
     semantics set \\
$\tsrule{accept\_4}$
& \textbf{tcp: rc}
&  Fail with $\tscon{ECONNABORTED}$: the listening socket has $\tsvar{cantsndmore}$ set
     or has become $\tscon{CLOSED}$. Returns either immediately or from a blocked state. \\
$\tsrule{accept\_5}$
& \textbf{tcp: rc}
&  Fail with $\tscon{EINVAL}$: socket not in LISTEN state \\
$\tsrule{accept\_6}$
& \textbf{tcp: rc}
&  Fail with $\tscon{EMFILE}$: out of file descriptors \\
$\tsrule{accept\_7}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{EOPNOTSUPP}$ or $\tscon{EINVAL}$: $\tslib{accept}()$ called on
     a UDP socket \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\acceptTI}{\rrulecc{acceptTI}{accept\_1}{tcp: rc}{\tsholcomm{ Return new connection; either immediately or from a blocked state. }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{t}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds};{}\\{}
 \tsvar{files} \Mass  \tsvar{files};{}\\{}
 \tsvar{socks} \Mass {}\\{}
 \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid} ,\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad [\,],*,[\,],*,\tscon{NO\_OOBDATA})));{}\\{}
 (\tsvar{sid}',\tscon{Sock}(*,\tsvar{sf}',\Msome  \;\tsvar{i}'_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es}',\tsvar{cantsndmore}',\tsvar{cantrcvmore}',{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{ESTABLISHED},\tsvar{cb}',*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\Mtransition{ \tsvar{lbl} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsvar{fd}',(\tsvar{i}_{2},\tsvar{p}_{2})))}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}';{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus  [(\tsvar{fid}',\tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}'),\tsaux{ff\_default}))];{}\\{}
 \tsvar{socks} \Mass {}\\{}
 \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid} ,\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis}',{}\\{}
\quad\quad\quad\quad\quad\quad\quad [\,],*,[\,],*,\tscon{NO\_OOBDATA})));{}\\{}
 (\tsvar{sid}',\tscon{Sock}(\Msome  \;\tsvar{fid}',\tsvar{sf}',\Msome  \;\tsvar{i}'_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es}',{}\\{}
\quad\quad\quad\quad\quad \tsvar{cantsndmore}',\tsvar{cantrcvmore}', \tsaux{TCP\_Sock}(\tscon{ESTABLISHED},\tsvar{cb}',*,\tsvar{sndq},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\Mboxedor{\tsvar{t} = \tscon{Run} \Mwedge {}\\{}
 \tsvar{lbl} = \MLhcall{\tsvar{tid}}{(\tslib{accept} \;\tsvar{fd})} \Mwedge {}\\{}
 \tsvar{rc} = \tscon{fast} \;\tscon{succeed} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}}  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \Mfapply{\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}){}\\{}
 {}\\{}
 }{\tsvar{t} = \tscon{Accept2}(\tsvar{sid}) \Mwedge {}\\{}
\quad \tsvar{lbl} = \MLhtau  \Mwedge {}\\{}
\quad \tsvar{rc} = \tscon{slow} \;\tsaux{urgent} \;\tscon{succeed}{}\\{}
 } \Mwedge {}\\{}
 {}\\{}
 \tsvar{lis}.\tsvar{q} = \Mappend{\tsvar{q}}{[\tsvar{sid}']} \Mwedge {}\\{}
 \tsvar{lis}'.\tsvar{q} = \tsvar{q} \Mwedge {}\\{}
 \tsvar{lis}'.\tsvar{q}_{0} = \tsvar{lis}.\tsvar{q}_{0} \Mwedge  \tsvar{lis}'.\tsvar{qlimit} = \tsvar{lis}.\tsvar{qlimit} \Mwedge  {}\\{}
 (\tsvar{sid} \neq  \tsvar{sid}') \Mwedge  {}\\{}
 \tsvar{es}' \neq  \Msome  \;\tscon{ECONNABORTED} \Mwedge  {}\\{}
 \tsvar{fid}' \;\notin  ((\Mfdom{\tsvar{files}}) \cup  \{\tsvar{fid}\}) \Mwedge {}\\{}
 \tsaux{nextfd} \;\tsvar{h}.\tstype{arch} \;\tsvar{fds} \;\tsvar{fd}' \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \oplus  (\tsvar{fd}', \tsvar{fid}') \Mwedge {}\\{}
 (\forall \tsvar{i}_{1}. \Msome  \;\tsvar{i}_{1} = \tsvar{is}_{1} \implies  \tsvar{i}_{1} = \tsvar{i}'_{1}) }
{\rulesubsection{Description}

   This rule covers two cases: (1) the completed connection queue is non-empty when $\tslib{accept}(\tsvar{fd})$ is
   called from a thread $\tsvar{tid}$ in the $\tscon{Run}$ state, where $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$,
   and (2) a previous call to $\tslib{accept}(\tsvar{fd})$ on socket $\tsvar{sid}$ blocked, leaving its calling thread
   $\tsvar{tid}$ in state $\tscon{Accept2}(\tsvar{sid})$, and a new connection has become available.

   In either case the listening TCP socket $\tsvar{sid}$ has a connection $\tsvar{sid}'$ at the head of its
   completed connections queue $\tsvar{sid}'\Mcons \tsvar{q}$. A socket entry for $\tsvar{sid}'$ already exists in the host's
   finite map of sockets, $\tsvar{socks}$$\oplus\dots$. The socket is $\tscon{ESTABLISHED}$, is not shutdown for
   reading, and is only missing a file description association that would make it accessible via the
   sockets interface.

   A new file description record is created for connection $\tsvar{sid}'$, indexed by a new $\tsvar{fid}'$, and
   this is added to the host's finite map of file descriptions $\tsvar{files}$.  It is assigned a default
   set of file flags, $\tsaux{ff\_default}$. The socket entry $\tsvar{sid}'$ is completed with its file
   association $\Msome  \;\tsvar{fid}'$ and $\tsvar{sid}'$ is removed from the head of the completed connections
   queue.

   When the listening socket $\tsvar{sid}$ is bound to a local IP address $\tsvar{i}_{1}$, the accepted socket
   $\tsvar{sid}'$ is also bound to it.

   Finally, the new file descriptor $\tsvar{fd}'$ is created in an architecture-specific way using the
   auxiliary \ltslink{nextfd}{$\tsaux{nextfd}$}, and an entry mapping $\tsvar{fd}'$ to $\tsvar{fid}'$ is added to the host's finite map
   of file descriptors.  If the calling thread was previously blocked in state $\tscon{Accept2}(\tsvar{sid})$ it
   proceeds via a $\MLhtau $ transition, otherwise by a $\MLhcall{\tsvar{tid}}{ (\tslib{accept} \;\tsvar{fd})}$ transition.
   The thread is left in state $\tscon{Ret} (\tscon{OK} (\tsvar{fd}',(\tsvar{i}_{2},\tsvar{p}_{2})))$ to return the file descriptor and remote
   address of the accepted connection in response to the original $\tslib{accept}()$ call.

   If the new socket $\tsvar{sid}'$ has error $\tscon{ECONNABORTED}$ pending in its error field $\tsvar{es}'$, this is
   handled by rule $\tsrule{accept\_5}$. All other pending errors on $\tsvar{sid}'$ are ignored, but left as the
   socket's pending error.

\rrulepad }
}

\newcommand{\acceptTII}{\rrulecc{acceptTII}{accept\_2}{tcp: block}{\tsholcomm{ Block waiting for connection }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{(\tslib{accept} \;\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Accept2}(\tsvar{sid})}{\tsaux{never\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) = \Mfalse  \Mwedge {}\\{}
 \tsvar{sid} \;\in  \Mfdom{\tsvar{h}.\tsvar{socks}} \Mwedge {}\\{}
 (\exists \tsvar{sf} \;\tsvar{is}_{1} \;\tsvar{p}_{1} \;\tsvar{cb} \;\tsvar{lis} \;\tsvar{es}.{}\\{}
\quad \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis},[\,],*,[\,],*,\tscon{NO\_OOBDATA})) \Mwedge {}\\{}
\quad \tsvar{lis}.\tsvar{q} = [\,])}
{\rulesubsection{Description}

   A blocking $\tslib{accept}()$ call is performed on socket $\tsvar{sid}$ when no completed incoming
   connections are available. The calling thread blocks until a new connection attempt completes
   successfully, the call is interrupted, or the process runs out of file descriptors.

   From thread $\tsvar{tid}$, which is initially in the $\tscon{Run}$ state, $\tslib{accept}(\tsvar{fd})$ is called where
   $\tsvar{fd}$ refers to listening TCP socket $\tsvar{sid}$ which is bound to local port $\tsvar{p}_{1}$, is not
   shutdown for reading and is in blocking mode: $\tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK})=\Mfalse $. The socket's queue of
   completed connections is empty, $\tsvar{q} \Mass  [\,]$, hence the $\tslib{accept}()$ call blocks waiting for a
   successful new connection attempt, leaving the calling thread state $\tscon{Accept2}(\tsvar{sid})$.

   Socket $\tsvar{sid}$ might not be bound to a local IP address, i.e. $\tsvar{is}_{1}$ could be $*$. In this
   case the socket is listening for connection attempts on port $\tsvar{p}_{1}$ for all local IP addresses.

\rrulepad }
}

\newcommand{\acceptTIII}{\rrulecc{acceptTIII}{accept\_3}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{EAGAIN}$: no pending connections and non-blocking
     semantics set }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{(\tslib{accept} \;\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EAGAIN}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} = \tsvar{fid} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) = \Mtrue  \Mwedge {}\\{}
 \tsvar{sid} \;\in  \Mfdom{\tsvar{h}.\tsvar{socks}} \Mwedge {}\\{}
 (\exists \tsvar{sf} \;\tsvar{is}_{1} \;\tsvar{p}_{1} \;\tsvar{cb} \;\tsvar{lis} \;\tsvar{es}.{}\\{}
 \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis},[\,],*,[\,],*,\tscon{NO\_OOBDATA})) \Mwedge {}\\{}
 \tsvar{lis}.\tsvar{q} = [\,])}
{\rulesubsection{Description}

   A non-blocking $\tslib{accept}()$ call is performed on socket $\tsvar{sid}$ when no completed incoming
   connections are available. Error $\tscon{EAGAIN}$ is returned to the calling thread.

   From thread $\tsvar{tid}$, which is initially in the $\tscon{Run}$ state, $\tslib{accept}(\tsvar{fd})$ is called where
   $\tsvar{fd}$ refers to a listening TCP socket $\tsvar{sid}$ which is bound to local port $\tsvar{p}_{1}$, not shutdown
   for writing, and in non-blocking mode: $\tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) = \Mtrue $. The socket's queue of completed
   connections is empty, $\tsvar{q} \Mass  [\,]$, hence the $\tslib{accept}()$ call returns error $\tscon{EAGAIN}$,
   leaving the calling thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EAGAIN}})$ after a $\MLhcall{\tsvar{tid}}{\tslib{accept}(\tsvar{fd})}$
   transition.

   Socket $\tsvar{sid}$ might not be bound to a local IP address, i.e. $\tsvar{is}_{1}$ could be $*$. In this
   case the socket is listening for connection attempts on port $\tsvar{p}_{1}$ for all local IP addresses.

\rrulepad }
}

\newcommand{\acceptTIV}{\rrulecc{acceptTIV}{accept\_4}{tcp: rc}{\tsholcomm{ Fail with $\tscon{ECONNABORTED}$: the listening socket has $\tsvar{cantsndmore}$ set
     or has become $\tscon{CLOSED}$. Returns either immediately or from a blocked state. }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{t}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass {}\\{}
 \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid} ,\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},\Msome  \;\tsvar{lis},[\,],*,[\,],*,\tscon{NO\_OOBDATA})))] \Mmagicrrec }
{\Mtransition{ \tsvar{lbl} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{ECONNABORTED}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass {}\\{}
 \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid} ,\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},\Msome  \;\tsvar{lis},[\,],*,[\,],*,\tscon{NO\_OOBDATA})))] \Mmagicrrec }
{\Mboxedor{\tsvar{t} = \tscon{Run} \Mwedge {}\\{}
 \tsvar{st} = \tscon{LISTEN} \Mwedge {}\\{}
 \tsvar{cantsndmore} = \Mtrue  \Mwedge {}\\{}
 \tsvar{lbl} = \MLhcall{\tsvar{tid}}{\tslib{accept}(\tsvar{fd})} \Mwedge {}\\{}
 \tsvar{rc} = \tscon{fast} \;\tscon{fail} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}){}\\{}
 }{\tsvar{t} = \tscon{Accept2}(\tsvar{sid}) \Mwedge {}\\{}
 ((\tsvar{cantrcvmore} = \Mtrue  \Mwedge  \tsvar{st} = \tscon{LISTEN}) \Mvee {}\\{}
 (\tsvar{st} = \tscon{CLOSED})) \Mwedge {}\\{}
 \tsvar{lbl} = \MLhtau  \Mwedge {}\\{}
 \tsvar{rc} = \tscon{slow} \;\tsaux{urgent} \;\tscon{fail}{}\\{}
 }}
{\rulesubsection{Description}

   This rule covers two cases: (1) an $\tslib{accept}(\tsvar{fd})$ call is made on a listening TCP socket $\tsvar{sid}$,
   referenced by $\tsvar{fd}$, with $\tsvar{cantsndmore}$ set, and (2) a previous call to $\tslib{accept}()$ on socket
   $\tsvar{sid}$ blocked, leaving a thread $\tsvar{tid}$ in state $\tscon{Accept2}(\tsvar{sid})$, but the socket has since
   either entered the $\tscon{CLOSED}$ state, or had $\tsvar{cantrcvmore}$ set. In both cases, $\tscon{ECONNABORTED}$
   is returned.

   This situation will arise only when a thread calls $\tslib{close}()$ on the listening socket while
   another thread is blocking on an $\tslib{accept}()$ call, or if $\tslib{listen}()$ was originally called on a
   socket which already had $\tsvar{cantrcvmore}$ set. The latter can occur in BSD, which allows
   $\tslib{listen}()$ to be called in any (non $\tscon{CLOSED}$ or $\tscon{LISTEN}$) state, though should never happen
   under typical use.

   If the calling thread was previously blocked in state $\tscon{Accept2}(\tsvar{sid})$, it proceeds via an
   $\MLhtau $ transition, otherwise by a $\MLhcall{\tsvar{tid}}{\tslib{accept}(\tsvar{fd})}$ transition. The thread is
   left in state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{ECONNABORTED}})$ to return the error $\tscon{ECONNABORTED}$ in response to
   the initial $\tslib{accept}()$ call.

   Note that this rule is not correct when dealing with the FreeBSD behaviour which allows any
   socket to be placed in the $\tscon{LISTEN}$ state.

\rrulepad }
}

\newcommand{\acceptTV}{\rrulecc{acceptTV}{accept\_5}{tcp: rc}{\tsholcomm{ Fail with $\tscon{EINVAL}$: socket not in LISTEN state }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{t}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \tsvar{lbl} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\Mboxedor{\tsvar{t} = \tscon{Run} \Mwedge {}\\{}
 \tsvar{lbl} = \MLhcall{\tsvar{tid}}{\tslib{accept}(\tsvar{fd})} \Mwedge {}\\{}
 \tsvar{rc} = \tscon{fast} \;\tscon{fail} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}){}\\{}
 }{\tsvar{t} = \tscon{Accept2}(\tsvar{sid}) \Mwedge {}\\{}
 \tsvar{lbl} = \MLhtau  \Mwedge {}\\{}
 \tsvar{rc} = \tscon{slow} \;\tsaux{urgent} \;\tscon{fail}{}\\{}
 } \Mwedge {}\\{}
 \tsvar{sid} \;\in  \Mfdom{\tsvar{h}.\tsvar{socks}} \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \neq  \tscon{LISTEN}}
{\rulesubsection{Description}


   It is not valid to call $\tslib{accept}()$ on a socket that is not in the
   $\tscon{LISTEN}$ state.

   This rule covers two cases: (1) on the non-listening TCP socket $\tsvar{sid}$, $\tslib{accept}()$ is called
   from a thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, and (2) a previous call to $\tslib{accept}()$ on
   TCP socket $\tsvar{sid}$ blocked because no completed connections were available, leaving thread
   $\tsvar{tid}$ in state $\tscon{Accept2}(\tsvar{sid})$ and after the $\tslib{accept}()$ call blocked the socket changed to a
   state other than $\tscon{LISTEN}$.

   In the first case the $\tslib{accept}(\tsvar{fd})$ call on socket $\tsvar{sid}$, referenced by file descriptor
   $\tsvar{fd}$, proceeds by a $\MLhcall{\tsvar{tid}}{\tslib{accept}(\tsvar{fd})}$ transition and in the latter by a $\MLhtau $
   transition. In either case, the thread is left in state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})$ to return error
   $\tscon{EINVAL}$ to the caller.

   The second case is subtle: a previous call to $\tslib{accept}()$ may have blocked waiting for a new
   completed connection to arrive and an operation, such as a $\tslib{close}()$ call, in another thread
   caused the socket to change from the $\tscon{LISTEN}$ state.

\rrulepad }
}

\newcommand{\acceptTVI}{\rrulecc{acceptTVI}{accept\_6}{tcp: rc}{\tsholcomm{ Fail with $\tscon{EMFILE}$: out of file descriptors }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{t}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \tsvar{lbl} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EMFILE}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\Mboxedor{\tsvar{t} = \tscon{Run} \Mwedge {}\\{}
 \tsvar{lbl} = \MLhcall{\tsvar{tid}}{\tslib{accept}(\tsvar{fd})} \Mwedge {}\\{}
 \tsvar{rc} = \tscon{fast} \;\tscon{fail} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sid} \;\in  \Mfdom{\tsvar{h}.\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{sock} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}) \Mwedge {}\\{}
 \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tscon{PROTO\_TCP}{}\\{}
 }{\tsvar{t} = \tscon{Accept2}(\tsvar{sid}) \Mwedge {}\\{}
 \tsvar{lbl} = \MLhtau  \Mwedge {}\\{}
 \tsvar{rc} = \tscon{slow} \;\tsaux{nonurgent} \;\tscon{fail}{}\\{}
 } \Mwedge {}\\{}
 \tsholop{CARD} (\Mfdom{\tsvar{h}.\tsvar{fds}}) \geq  \tsaux{OPEN\_MAX}}
{\rulesubsection{Description}

   This rule covers two cases: (1) from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, an
   $\tslib{accept}(\tsvar{fd})$ call is made where $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$, and (2) a previous call
   to $\tslib{accept}()$ blocked leaving thread $\tsvar{tid}$ in the $\tscon{Accept2}(\tsvar{sid})$ state. In either case the
   $\tslib{accept}()$ call fails with $\tscon{EMFILE}$ as the process (see Model Details) already has open its
   maximum number of open file descriptors $\tsaux{OPEN\_MAX}$.

   In the first case the error is returned immediately ($\tscon{fast} \;\tscon{fail}$) by performing an
   $\MLhcall{\tsvar{tid}}{\tslib{accept}(\tsvar{fd})}$ transition, leaving the thread state $\tscon{Ret}(\tscon{FAIL}\;{\tscon{EMFILE}})$. In the
   second, the thread is unblocked, also leaving the thread state $\tscon{Ret}(\tscon{FAIL}\;{\tscon{EMFILE}})$, by
   performing a $\MLhtau $ transition.

\rulesubsection{Model details}

   In real systems, error $\tscon{EMFILE}$ indicates that the calling process already has $\tsaux{OPEN\_MAX}$ file
   descriptors open and is not permitted to open any more. This specification only models one
   single-process host with multiple threads, thus $\tscon{EMFILE}$ is generated when the host exceeds the
   $\tsaux{OPEN\_MAX}$ limit in this model.

\rrulepad }
}

\newcommand{\acceptTVII}{\rrulecc{acceptTVII}{accept\_7}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{EOPNOTSUPP}$ or $\tscon{EINVAL}$: $\tslib{accept}()$ called on
     a UDP socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{accept}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sid} \;\in  \Mfdom{\tsvar{h}.\tsvar{socks}} \Mwedge {}\\{}
 \tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tscon{PROTO\_UDP} \Mwedge {}\\{}
 (\Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{err} = \tscon{EINVAL}{}\\{}
 \Melse  \;\tsvar{err} = \tscon{EOPNOTSUPP})}
{\rulesubsection{Description}

   Calling $\tslib{accept}()$ on a socket for a connectionless protocol (such as UDP) has no defined
   behaviour and is thus an invalid ($\tscon{EINVAL}$) or unsupported ($\tscon{EOPNOTSUPP}$) operation.

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, an $\tslib{accept}(\tsvar{fd})$ call is made where $\tsvar{fd}$
   refers to a UDP socket identified by $\tsvar{sid}$. The call proceeds by a $\MLhcall{\tsvar{tid}}{\tslib{accept}(\tsvar{fd})}$
   transition leaving the thread state $\tscon{Ret}(\tscon{FAIL}\;{\tsvar{err}})$ to return error $\tsvar{err}$. On FreeBSD
   $\tsvar{err}$ is $\tscon{EINVAL}$; on all other systems the error is $\tscon{EOPNOTSUPP}$.


\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   FreeBSD returns error $\tscon{EINVAL}$ if $\tslib{accept}()$ is called on a UDP socket.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommbind}{\clustersection{(TCP and UDP)}{$\tslib{bind}()$}
\seccomm{ \[ \tslib{bind}: (\tstype{fd} * \tstype{ip} \;\;\tstype{option} * \tstype{port} \;\;\tstype{option}) \Mtotype  \tstype{unit} \]

  $\tslib{bind}(\tstype{fd},\tsvar{is},\tsvar{ps})$ assigns a local address to the socket referenced by file descriptor $\tstype{fd}$. The
  local address, $(\tsvar{is},\tsvar{ps})$, may consist of an IP address, a port or both an IP address and port.

  If $\tslib{bind}()$ is called without specifying a port, $\tslib{bind}(\tsunknown{\_},\tsunknown{\_},*)$, the socket's local port
  assignment is autobound, i.e. an unused port for the socket's protocol in the host's ephemeral
  port range is selected and assigned to the socket. Otherwise the port $\tsunknown{p}$ specified in the bind
  call, $\tslib{bind}(\tsunknown{\_},\tsunknown{\_},\Msome  \;\tsunknown{p})$ forms part of the socket's local address.

  On some architectures a range of port values are designated to be privileged, e.g. 0-1023
  inclusive. If a call to $\tslib{bind}()$ requests a port in this range and the caller does not have
  sufficient privileges the call will fail.

  A $\tslib{bind}()$ call may or may not specify the IP address. If an IP address is not specified,
  $\tslib{bind}(\tsunknown{\_},*,\tsunknown{\_})$, the socket's local IP address is set to $*$ and it will receive segments
  or datagrams addressed to any of the host's local IP addresses and port $\tsunknown{p}$. Otherwise, the
  caller specifies a local IP address, $\tslib{bind}(\tsunknown{\_},\Msome  \;\tsunknown{i},\tsunknown{\_})$, the socket's local IP address is set
  to $\Msome  \;\tsunknown{i}$, and it only receives segments or datagrams addressed to IP address $\tsunknown{i}$ and port
  $\tsunknown{p}$.

  A call to $\tslib{bind}()$ may be unsuccessful if the requested IP address or port is unavailable to
  bind to, although in certain situations this can be overrriden by setting the socket option
  $\tscon{SO\_REUSEADDR}$ appropriately: see \ltslink{boundTportTallowed}{$\tsaux{bound\_port\_allowed}$}.

  A socket can only be bound once: it is not possible to rebind it to a different port later. A
  $\tslib{bind}()$ call is not necessary for every socket: sockets may be autobound to an ephemeral port when a
  call requiring a port binding is made, e.g. $\tslib{connect}()$.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{bind}()$ can fail with the errors below, in which case the corresponding exception
  is raised:

\par\begin{ltstabular}
$\tscon{EACCES}$
&  The specified port is in the privileged port range of the host architecture and
  the current thread does not have the required privileges to bind to it.

\\\hline
$\tscon{EADDRINUSE}$
&  The specified address is in use by or conflicts with the address of another
  socket using the same protocol. The error may occur in the following situations only:
    \begin{itemize}

      \item $\tslib{bind}(\tsunknown{\_},\tsunknown{\_},\Msome  \;\tsunknown{p})$ will fail with $\tscon{EADDRINUSE}$ if another socket is bound to port
       $\tsunknown{p}$. This error may be preventable by setting the $\tscon{SO\_REUSEADDR}$ socket option.

      \item $\tslib{bind}(\tsunknown{\_},\Msome  \;\tsunknown{i},\Msome  \;\tsunknown{p})$ will fail with $\tscon{EADDRINUSE}$ if another socket is bound to
       port $\tsunknown{p}$ and IP address $\tsunknown{i}$, or is bound to port $\tsunknown{p}$ and wildcard IP. This error will
       not occur if the $\tscon{SO\_REUSEADDR}$ option is correctly used to allow multiple sockets to be
       bound to the same local port.

    \end{itemize}
  This error is never returned from a call $\tslib{bind}(\tsunknown{\_},\tsunknown{\_},*)$ that requests an autobound port.

\\\hline
$\tscon{EADDRNOTAVAIL}$
&  The specified IP address cannot be bound as it is not local to the host.

\\\hline
$\tscon{EINVAL}$
&  The socket is already bound to an address and the socket's protocol does not
  support rebinding to a new address. Multiple calls to $\tslib{bind}()$ are not permitted.

\\\hline
$\tscon{EISCONN}$
&  The socket is connected and rebinding to a new local address is not
  permitted (TCP ONLY).

\\\hline
$\tscon{ENOBUFS}$
&  A port was not specified in the $\tslib{bind}()$ call and autobinding failed because
  no ephemeral ports for the socket's protocol are currently available. In addition, on WinXP the
  error can signal that the host has insufficient available buffers to complete the operation.

\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  A server application creates a TCP socket and binds it to its local address. It is then put in the
  $\tscon{LISTEN}$ state to accept incoming connections to this address: $\tsrule{socket\_1}$; $\tsrule{return\_1}$;
  $\tsrule{bind\_1}$; $\tsrule{return\_1}$; $\tsrule{listen\_1}$

  A UDP socket is created and bound to its local address. $\tslib{recv}()$ is called and the socket
  blocks, waiting to receive datagrams sent to the local address: $\tsrule{socket\_1}$; $\tsrule{return\_1}$;
  $\tsrule{bind\_1}$; $\tsrule{return\_1}$; $\tsrule{recv\_12}$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:  &  \wasverb{int bind(int socket, const struct sockaddr *address,} \\
            &  \wasverb{           socklen\textunderscore{}t address\textunderscore{}len);} \\
    FreeBSD:&  \wasverb{int bind(int s, struct sockaddr *addr, socklen\textunderscore{}t addrlen);} \\
    Linux:  &  \wasverb{int bind(int sockfd, struct sockaddr *addr, socklen\textunderscore{}t addrlen);} \\
    WinXP:  &  \wasverb{SOCKET bind(SOCKET s, const struct sockaddr* name, int namelen);} \\
  \end{tabular}\\

  In the Posix interface:
  \begin{itemize}

    \item \wasverb{socket} is the socket's file descriptor, corresponding to the $\tstype{fd}$ argument of
     the model.

    \item \wasverb{address} is a pointer to a \wasverb{sockaddr} structure of size
    \wasverb{socklen\textunderscore{}t} containing the local IP address and port to be assigned to the socket,
    corresponding to the $\tsvar{is}$ and $\tsvar{ps}$ arguments of the model. For the \wasverb{AF\textunderscore{}INET}
    sockets used in the model, a \wasverb{sockaddr\textunderscore{}in} structure stores the address. The
    \wasverb{sin\textunderscore{}addr.s\textunderscore{}addr} field holds the IP address; if it is set to \wasverb{0} then the IP
    address is wildcarded: $\tsvar{is}=*$. The \wasverb{sin\textunderscore{}port} field stores the port to bind to; if
    it is set to \wasverb{0} then the port is wildcarded: $\tsvar{ps}=*$. On WinXP a wildcard IP is
    specified by the constant \wasverb{INADDR\textunderscore{}ANY}, not \wasverb{0}

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual
     error code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  The FreeBSD, Linux and WinXP interfaces are similar modulo some argument renaming, except where
  noted above.

  On Windows Socket 2 the \wasverb{name} parameter is not necessarily interpreted as a pointer to a
  \wasverb{sockaddr} structure but is cast this way for compatilibity with Windows Socket 1.1 and
  the BSD sockets interface. The service provider implementing the functionality can choose to
  interpret the pointer as a pointer to any block of memory provided that the first two bytes of the
  block start with the address family used to create the socket. The default WinXP internet family
  provider expects a \wasverb{sockaddr} structure here. This change is purely an interface design
  choice that ultimately achieves the same functionality of providing a name for the socket and is
  not modelled.

}\clustersubsection{Model details}
\seccomm{
  The specification only models the {AF,PF}\_INET address families thus the address family field of
  the \wasverb{struct sockaddr} argument to $\tslib{bind}()$ and those errors specific to other address
  familes, e.g. UNIX domain sockets, are not modelled here.

  In the Posix specification, $\tscon{ENOBUFS}$ may have the additional meaning of "Insufficient resources
  were available to complete the call". This is more general than the use of $\tscon{ENOBUFS}$ in the
  model.

  The following errors are not modelled:
  \begin{itemize}

    \item \wasverb{EAGAIN} is BSD-specific and described in the man page as: "Kernel resources to
     complete the request are temporarily unavailable". This is not modelled here.


    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

    \item \wasverb{EFAULT} signifies that the pointers passed as either the \wasverb{address} or
     \wasverb{address\textunderscore{}len} arguments were inaccessible.  This is an artefact of the C interface to
     $\tslib{bind}()$ that is excluded by the clean interface used in the model. On WinXP, the equivalent
     error \wasverb{WSAEFAULT} in addition signifies that the name address format used in
     \wasverb{name} may be incorrect or the address family in \wasverb{name} does not match that of
     the socket.

    \item \wasverb{ENOTDIR}, \wasverb{ENAMETOOLONG}, \wasverb{ENOENT}, \wasverb{ELOOP},
     \wasverb{EIO} (BSD-only), \wasverb{EROFS}, \wasverb{EISDIR} (BSD-only), \wasverb{ENOMEM},
     \wasverb{EAFNOTSUPPORT} (Posix-only) and \wasverb{EOPNOTSUPP} (Posix-only) are errors specific
     to other address families and are not modelled here. None apply to WinXP as other address
     families are not available by default.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{bind\_1}$
& \textbf{all: fast succeed}
&  Successfully assign a local address to a socket (possibly by
     autobinding the port) \\
$\tsrule{bind\_2}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EADDRINUSE}$: the specified address is already in use \\
$\tsrule{bind\_3}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EADDRNOTAVAIL}$: the specified IP address is not available on the host \\
$\tsrule{bind\_5}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EINVAL}$: the socket is already bound to an address and does not support rebinding; or socket has been shutdown for writing on FreeBSD \\
$\tsrule{bind\_7}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EACCES}$: the specified port is priveleged and the current process does not have permission to bind to it \\
$\tsrule{bind\_9}$
& \textbf{all: fast badfail}
&  Fail with $\tscon{ENOBUFS}$: no ephemeral ports free for autobinding or, on WinXP only, insufficient buffers available. \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\bindTI}{\rrulecc{bindTI}{bind\_1}{all: fast succeed}{\tsholcomm{ Successfully assign a local address to a socket (possibly by
     autobinding the port) }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})} }{1}}
{\tsvar{h}}
{\tsvar{h}_{0} = \tsvar{h}' \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid} ,\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,*,*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tsvar{pr}))]{}\\{}
 \Mmagicbolrrec  \Mwedge {}\\{}
 \tsvar{h}  = \tsvar{h}' \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid} ,\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tsvar{pr}))];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sid} \;\notin  (\Mfdom{\tsvar{socks}}) \Mwedge {}\\{}
 (\forall \tsvar{i}_{1}. \tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \implies  \tsvar{i}_{1} \;\in  \;\tsaux{local\_ips}(\tsvar{h}_{0}.\tsvar{ifds})) \Mwedge {}\\{}
 \tsvar{p}_{1} \;\in  \;\tsaux{autobind}(\tsvar{ps}_{1},(\tsaux{proto\_of} \;\tsvar{pr}),\tsvar{h},\tsvar{socks}) \Mwedge {}\\{}
 \tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \Mwedge {}\\{}
 (\tsvar{h}_{0}.\tsvar{privs} \Mvee  \tsvar{p}_{1} \;\notin  \;\tsaux{privileged\_ports} \;\tsvar{h}_{0}) \Mwedge {}\\{}
 \tsaux{bound\_port\_allowed} \;\tsvar{pr} (\tsvar{h}_{0}.\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}) \tsvar{sf} \;\tsvar{h}_{0}.\tstype{arch} \;\tsvar{is}_{1} \;\tsvar{p}_{1} \Mwedge {}\\{}
 (\Mcase  \;\tsvar{pr} \;\Mof {}\\{}
\quad \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mtotype  \tsunknown{tcp\_sock}  = \tsaux{TCP\_Sock0}(\tscon{CLOSED},\tsvar{cb},*,[\,],*,[\,],*,\tscon{NO\_OOBDATA}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsaux{bsd\_arch} \;\tsvar{h}_{0}.\tstype{arch} \implies  \tsvar{cantsndmore}=\Mfalse  \Mwedge  \tsvar{cb}.\tsfield{bsd\_cantconnect} = \Mfalse ) \Mdpipe {}\\{}
\quad \tscon{UDP\_PROTO}(\tsunknown{udp\_sock}) \Mtotype  \tsunknown{udp\_sock} = \tsaux{UDP\_Sock0}([\,]))}
{\rulesubsection{Description}

   The call $\tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})$ is perfomed on the TCP or UDP socket $\tsvar{sid}$ referenced by file
   descriptor $\tsvar{fd}$ from a thread $\tsvar{tid}$ in the $\tscon{Run}$ state. The socket $\tsvar{sid}$ is currently
   uninitialised, i.e. it has no local or remote address defined $(*,*,*,*)$, and it
   contains an uninitialised TCP or UDP protocol block, $\tsunknown{tcp\_sock}$ and $\tsunknown{udp\_sock}$ as appropriate for the socket's protocol.

   If an IP address is specified in the $\tslib{bind}()$ call, i.e. $\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1}$, the call can only succeed
   if the IP address $\tsvar{i}_{1}$ is one of those belonging to an interface of host $\tsvar{h}$, $\tsvar{i}_{1} \;\in
\tsaux{local\_ips}(\tsvar{h}_{0}.\tsvar{ifds})$.

   The port $\tsvar{p}_{1}$ that the socket will be bound to is determined by the auxiliary function
   $\tsaux{autobind}$ that takes as argument the port option $\tsvar{ps}_{1}$ from the $\tslib{bind}()$ call. If $\tsvar{ps}_{1} =
\Msome  \;\tsunknown{p}$ $\tsaux{autobind}$ simply returns the singleton set $\{\tsunknown{p}\}$, constraining the local port
   binding $\tsvar{p}_{1}$ by $\tsvar{p}_{1} = \tsunknown{p}$. Otherwise, $\tsaux{autobind}$ returns a set of available ephemeral ports
   and $\tsvar{p}_{1}$ is constrained to be a port within the set.

   If a port is specified in the $\tslib{bind}()$ call, i.e. $\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1}$, either the port is not a
   privileged port $\tsvar{p}_{1} \;\notin  \;\tsaux{privileged\_ports}$ or the host (actually, process) must have
   sufficient privileges $\tsvar{h}_{0}.\tsunknown{priv} = \Mtrue $.

   Not all requested bindings are permissible because other sockets in the system may be bound to
   the chosen address or to a conflicting address. To check the binding $\tsvar{is}_{1}, \Msome  \;\tsvar{p}_{1}$ is
   permitted the auxiliary function $\tsaux{bound\_port\_allowed}$ is used. $\tsaux{bound\_port\_allowed}$ is
   architecture dependent and checks not only the other sockets bound locally to port $\tsvar{p}_{1}$ on the
   host, but also the status of the socket flag $\tscon{SO\_REUSEADDR}$ for socket $\tsvar{sid}$ and the
   conflicting sockets. The use of the socket flag $\tscon{SO\_REUSEADDR}$ can permit sockets to share
   bindings under some circumstances, resolving the binding conflict. See \ltslink{boundTportTallowed}{$\tsaux{bound\_port\_allowed}$} for further information.

   The call proceeds by performing a $\MLhcall{\tsvar{tid}}{\tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})}$ transition returning $\tscon{OK}()$
   to the calling thread. Socket $\tsvar{sid}$ is bound to local address $(\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1})$and the host has
   an updated list of bound sockets $\tsvar{bound}$ with socket $\tsvar{sid}$ at its head.

\rulesubsection{Model details}

   The list of bound sockets $\tsvar{bound}$ is used by the model to determine the order in which sockets
   are bound. This is required to model ICMP message and UDP datagram delivery on Linux.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   If $\tsvar{sid}$ is a TCP socket then it cannot be shutdown for writing: $\tsvar{cantsndmore}=\Mfalse $, and its
   $\tsfield{bsd\_cantconnect}$ flag cannot be set.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\bindTII}{\rrulecc{bindTII}{bind\_2}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EADDRINUSE}$: the specified address is already in use }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EADDRINUSE}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}) \Mwedge {}\\{}
 \neg{}(\tsaux{bound\_port\_allowed} \;\tsvar{sock}.\tsvar{pr} (\tsvar{h}.\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}) \tsvar{sock}.\tsvar{sf} \;\tsvar{h}.\tstype{arch} \;\tsvar{is}_{1} \;\tsvar{p}_{1}) \Mwedge {}\\{}
 (\tsholop{option\_case}\Mspiii{\Mtrue }{(\lambda \tsvar{i}_{1}. \tsvar{i}_{1} \;\in  \;\tsaux{local\_ips}(\tsvar{h}.\tsvar{ifds}))}{\tsvar{is}_{1}}  \Mvee  \tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1})$ call is performed
   on the socket $\tsvar{sock}$, which is identified by $\tsvar{sid}$ and referenced by $\tsvar{fd}$.

   If an IP address is specified in the call, $\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1}$, then $\tsvar{i}_{1}$ must be an IP address
   for one of the host's interfaces. The requested local address binding, $(\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1})$, is not
   available as it is already in use: see \ltslink{boundTportTallowed}{$\tsaux{bound\_port\_allowed}$} for details.

   The call proceeds by a $\MLhcall{\tsvar{tid}}{\tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1})}$ transition leaving the thread in
   state $\tscon{Ret}(\tscon{FAIL}\;{\tscon{EADDRINUSE}})$ to return error $\tscon{EADDRINUSE}$ to the caller.

\rrulepad }
}

\newcommand{\bindTIII}{\rrulecc{bindTIII}{bind\_3}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EADDRNOTAVAIL}$: the specified IP address is not available on the host }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{bind}(\tsvar{fd},\Msome  \;\tsvar{i}_{1},\tsvar{ps}_{1})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EADDRNOTAVAIL}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{i}_{1} \;\notin  \;\tsaux{local\_ips}(\tsvar{h}.\tsvar{ifds})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{bind}(\tsvar{fd},\Msome  \;\tsvar{i}_{1},\tsvar{ps}_{1})$ call is made where
   $\tsvar{fd}$ refers to a socket $\tsvar{sid}$.

   The IP address, $\tsvar{i}_{1}$, to be assigned as part of the socket's local address does not belong to
   any of the interfaces on the host, $\tsvar{i}_{1} \;\notin  \;\tsaux{local\_ips}(\tsvar{h}.\tsvar{ifds})$, and therefore can not be
   assigned to the socket.

   The call proceeds by a $\MLhcall{\tsvar{tid}}{\tslib{bind}(\tsvar{fd},\Msome  \;\tsvar{i}_{1},\tsvar{ps}_{1})}$ transition leaving the thread in
   state $\tscon{Ret}(\tscon{FAIL}\;{\tscon{EADDRNOTAVAIL}})$ to return error $\tscon{EADDRNOTAVAIL}$ to the caller.

\rrulepad }
}

\newcommand{\bindTV}{\rrulecc{bindTV}{bind\_5}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EINVAL}$: the socket is already bound to an address and does not support rebinding; or socket has been shutdown for writing on FreeBSD }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} = \tsvar{sock} \Mwedge {}\\{}
 (\tsvar{sock}.\tsvar{ps}_{1} \neq  * \Mvee {}\\{}
 (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad (\tsvar{sock}.\tsvar{cantsndmore} \Mvee {}\\{}
\quad \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{bsd\_cantconnect}) ))}
{\rulesubsection{Description}
   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})$ call is made where
   $\tsvar{fd}$ refers to a socket $\tsvar{sock}$. The socket already has a local port binding: $\tsvar{sock}.\tsvar{ps}_{1} \neq
*$, and rebinding is not supported.

    A $\MLhcall{\tsvar{tid}}{\tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule also applies if $\tsvar{fd}$ refers to a TCP socket which is either shut down for writing or
    has its $\tsfield{bsd\_cantconnect}$ flag set.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\bindTVII}{\rrulecc{bindTVII}{bind\_7}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EACCES}$: the specified port is priveleged and the current process does not have permission to bind to it }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EACCES}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\neg{}\tsvar{h}.\tsvar{privs} \Mwedge  \tsvar{p}_{1} \;\in  \;\tsaux{privileged\_ports} \;\tsvar{h})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1})$ call is made where
   $\tsvar{fd}$ refers to a socket $\tsvar{sid}$.  The port specified in the $\tslib{bind}$ call, $\tsvar{p}_{1}$, lies in the
   host's range of privileged ports, $\tsvar{p}_{1} \;\in  \;\tsaux{privileged\_ports}$, and the current host (actually,
   process) does not have sufficient permissions to bind to it: $\neg{}\tsvar{h}.\tsvar{privs}$.

   The call proceeds by a $\MLhcall{\tsvar{tid}}{\tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1})}$ transition leaving the thread in
   state $\tscon{Ret}(\tscon{FAIL}\;{\tscon{EACCES}})$ to return the access violation error $\tscon{EACCES}$ to the caller.

\rrulepad }
}

\newcommand{\bindTIX}{\rrulecc{bindTIX}{bind\_9}{all: fast badfail}{\tsholcomm{ Fail with $\tscon{ENOBUFS}$: no ephemeral ports free for autobinding or, on WinXP only, insufficient buffers available. }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOBUFS}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{ps}_{1} = * \Mwedge {}\\{}
 ((\tsaux{autobind}(\tsvar{ps}_{1},(\tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr}),\tsvar{h},\tsvar{h}.\tsvar{socks}) = \emptyset ) \Mvee {}\\{}
 \tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})$ call is made where
   $\tsvar{fd}$ refers to a socket $\tsvar{sid}$.

   A port is not specifed in the $\tslib{bind}$ call, i.e. $\tsvar{ps}_{1} = *$, and calling $\tsaux{autobind}$ returns
   the $\emptyset $ set rather than a set of free ephemeral ports that the socket could choose
   from. This occurs only when there are no remaining ephemeral ports available for autobinding.

   The call proceeds by a $\MLhcall{\tsvar{tid}}{\tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})}$ transition leaving the thread state
   $\tscon{Ret}(\tscon{FAIL}\;{\tscon{ENOBUFS}})$ to return the out of resources error $\tscon{ENOBUFS}$ to the caller.

\rulesubsection{Model details}

   Posix reports $\tscon{ENOBUFS}$ to signify that "Insufficient resources were available to complete the
   call". This is not modelled here.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
   On WinXP this error can occur non-deterministically when insufficient buffers are available.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommclose}{\clustersection{(TCP and UDP)}{$\tslib{close}()$}
\seccomm{ \[ \tslib{close}: \tstype{fd} \Mtotype  \tstype{unit} \]

  A call $\tslib{close}(\tstype{fd})$ closes file descriptor $\tstype{fd}$ so that it no longer refers to a file
  description and associated socket. The closed file descriptor is made available for reuse by the
  process. If the file descriptor is the last file descriptor referencing a file description the
  file description itself is deleted and the underlying socket is closed. If the socket is a UDP
  socket it is removed.

  It is important to note the distinction drawn above: only closing the last file descriptor of a
  socket has an effect on the state of the file description and socket.

  The following behaviour may occur when closing the last file descriptor of a TCP socket:

  \begin{itemize}

   \item A TCP socket may have the $\tscon{SO\_LINGER}$ option set which specifies a maximum duration in
    seconds that a $\tslib{close}(\tstype{fd})$ call is permitted to block.
    \begin{itemize}

      \item In the normal case the $\tscon{SO\_LINGER}$ option is not set, the close call returns
       immediately and asynchronously sends any remaining data and gracefully closes the connection.

      \item If $\tscon{SO\_LINGER}$ is set to a non-zero duration, the $\tslib{close}(\tstype{fd})$ call will block while
       the TCP implementation attempts to successfully send any remaining data in the socket's send
       buffer and gracefully close the connection. If the sending of remaining data and the graceful
       close are successful within the set duration, $\tslib{close}(\tstype{fd})$ returns successfully, otherwise
       the linger timer expires, $\tslib{close}(\tstype{fd})$ returns an error $\tscon{EAGAIN}$, and the close operation
       continues asychronously, attempting to send the remaining data.

      \item The $\tscon{SO\_LINGER}$ option may be set to zero to indicate that $\tslib{close}(\tstype{fd})$ should be
       abortive. A call to $\tslib{close}(\tstype{fd})$ tears down the connection by emitting a reset segment to
       the remote end (abandoning any data remaining in the socket's send queue) and returns
       successfully without blocking.


    \end{itemize}

   \item If $\tslib{close}(\tstype{fd})$ is called on a TCP socket in a pre-established state the file description
    and socket are simply closed and removed, regardless of how $\tscon{SO\_LINGER}$ is set, except on
    Linux platforms where $\tscon{SYN\_RECEIVED}$ is dealt with as an established state for the purposes of
    $\tslib{close}(\tstype{fd})$.

   \item Calling $\tslib{close}(\tstype{fd})$ on a listening TCP socket closes and removes the socket and aborts
    each of the connections on the socket's pending and completed connection queues.

  \end{itemize}

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{close}()$ can fail with the errors below, in which case the corresponding exception is
  raised:

\par\begin{ltstabular}
$\tscon{EAGAIN}$
&  The linger timer expired for a lingering $\tslib{close}()$ call and the socket has not
  yet been successfully closed.

\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\\\hline
$\tscon{EINTR}$
&  The system was interrupted by a caught signal.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  A TCP socket is created and connected to a peer; other socket calls are made, most likely $\tslib{send}()$ and
  $\tslib{recv}()$, but the $\tscon{SO\_LINGER}$ option is not set. $\tslib{close}()$ is then called and the connection
  is gracefully closed: $\tsrule{socket\_1}$; $\dots $; $\tsrule{close\_2}$

  A UDP socket is created and socket calls are made on it, mostly $\tslib{send}()$ and $\tslib{recv}()$ calls;
  the socket is then closed: $\tsrule{socket\_1}$; $\dots $; $\tsrule{close\_10}$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:  &  \wasverb{int close(int fildes);} \\
    FreeBSD:&  \wasverb{int close(int d);} \\
    Linux:  &  \wasverb{int close(int fd);} \\
    WinXP:  &  \wasverb{int closesocket(SOCKET s);} \\
  \end{tabular}\\

  In the Posix interface:
  \begin{itemize}

    \item \wasverb{fildes} is the file descriptor to close, corresponding to the $\tstype{fd}$ argument of
    the model $\tslib{close}()$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
    indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
    indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual
    error code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  The FreeBSD, Linux and WinXP interfaces are similar modulo argument renaming, except where
  noted above.

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item In Posix and on FreeBSD and Linux, \wasverb{EIO} means an I/O error occurred while reading from or
    writing to the file system.  Since we model only sockets, not file systems, we do not model this
    error.

    \item On FreeBSD, \wasverb{ENOSPC} means the underlying object did not fit, cached data was
    lost.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{close\_1}$
& \textbf{all: fast succeed}
&  Successfully close a file descriptor that is not the last file descriptor for a socket \\
$\tsrule{close\_2}$
& \textbf{tcp: fast succeed}
&  Successfully perform a graceful close on the last file descriptor of a synchronised socket \\
$\tsrule{close\_3}$
& \textbf{tcp: fast succeed}
&  Successful abortive close of a synchronised socket \\
$\tsrule{close\_4}$
& \textbf{tcp: block}
&  Block on a lingering close on the last file descriptor of a synchronised socket \\
$\tsrule{close\_5}$
& \textbf{tcp: slow urgent succeed}
&  Successful completion of a lingering close on a synchronised socket \\
$\tsrule{close\_6}$
& \textbf{tcp: slow nonurgent fail}
&  Fail with $\tscon{EAGAIN}$: unsuccessful completion of a lingering close on a synchronised socket \\
$\tsrule{close\_7}$
& \textbf{tcp: fast succeed}
&  Successfully close the last file descriptor for a socket in the $\tscon{CLOSED}$, $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$ states. \\
$\tsrule{close\_8}$
& \textbf{tcp: fast succeed}
&  Successfully close the last file descriptor for a listening TCP socket \\
$\tsrule{close\_10}$
& \textbf{udp: fast succeed}
&  Successfully close the last file descriptor of a UDP socket \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\closeTI}{\rrulecc{closeTI}{close\_1}{all: fast succeed}{\tsholcomm{ Successfully close a file descriptor that is not the last file descriptor for a socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{close}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}' \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsaux{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) > 1 \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd}}
{\rulesubsection{Description}

    A $\tslib{close}(\tsvar{fd})$ call is performed where $\tsvar{fd}$ refers to either a TCP or UDP socket. At least
    two file descriptors refer to file description $\tsvar{fid}$, $\tsaux{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) > 1$, of which
    one is $\tsvar{fd}$, $\tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}}$.

    The $\tslib{close}(\tsvar{fd})$ call proceeds by a $\MLhcall{\tsvar{tid}}{\tslib{close}(\tsvar{fd})}$ transition leaving the host in
    the successful return state $\tscon{Ret} (\tscon{OK}())$. In the final host state, the mapping of file
    descriptor $\tsvar{fd}$ to file descriptor index $\tsvar{fid}$ is removed from the file descriptors finite
    map $\tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd}$ , effectively reducing the reference count of the file description by
    one. The $\tslib{close}()$ call does not alter the socket's state as other file descriptors still
    refer to the socket through file description $\tsvar{fid}$.

\rrulepad }
}

\newcommand{\closeTII}{\rrulecc{closeTII}{close\_2}{tcp: fast succeed}{\tsholcomm{ Successfully perform a graceful close on the last file descriptor of a synchronised socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds};{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus {}\\{}
\quad\quad [(\tsvar{fid},\tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}))];{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{close}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}';{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \backslash{}\backslash{} \tsvar{fid};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(*,\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\Mtrue ,\Mtrue ,{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},[\,],\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{(\tsvar{st} \;\in  \{\tscon{ESTABLISHED};\tscon{FIN\_WAIT\_1};\tscon{CLOSING};\tscon{FIN\_WAIT\_2};{}\\{}
\quad\quad\quad\quad \tscon{TIME\_WAIT};\tscon{CLOSE\_WAIT};\tscon{LAST\_ACK}\} \Mvee {}\\{}
 \tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge  \tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge  {}\\{}
 (\tsvar{sf}.\tsvar{t}(\tscon{SO\_LINGER}) = \infty \Mvee {}\\{}
 \tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) = \Mtrue  \Mwedge  \tsvar{sf}.\tsvar{t}(\tscon{SO\_LINGER}) \neq  0 \Mwedge  \neg{}\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsaux{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1 \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd} \Mwedge {}\\{}
 \tsvar{fid} \;\notin  (\Mfdom{\tsvar{files}})}
{\rulesubsection{Description}

    A $\tslib{close}(\tsvar{fd})$ call is performed on the TCP socket $\tsvar{sid}$ referenced by file descriptor $\tsvar{fd}$
    which is the only file descriptor referencing the socket's file description:
    $\tsaux{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1$. The TCP socket $\tsvar{sid}$ is in a synchronised state, i.e. a state
    $\geq  \tscon{ESTABLISHED}$, or on Linux it may be in the $\tscon{SYN\_RECEIVED}$ state.

    In the common case the socket's linger option is not set, $\tsvar{sf}.\tsvar{t}(\tscon{SO\_LINGER}) = \infty$, and
    regardless of whether the socket is in non-blocking mode or not, i.e. $\tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK})$ is
    unconstrained, the call to $\tslib{close}()$ proceeds successfully without blocking.

    On all platforms except for Linux, if the socket is in non-blocking mode $\tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) =
\Mtrue $ the linger option may be set with a positive duration: $\tsvar{sf}.\tsvar{t}(\tscon{SO\_LINGER}) \neq  0)$. In
    this case the option is ignored giving precedence to the socket's non-blocking semantics. The
    $\tslib{close}()$ call succeeds without blocking.

    The $\tslib{close}(\tsvar{fd})$ call proceeds by a $\MLhcall{\tsvar{tid}}{\tslib{close}(\tsvar{fd})}$ transition leaving the host in
    the successful return state $\tscon{Ret} (\tscon{OK}())$. The final socket is marked as unable to send and
    receive further data, $\tsvar{cantsndmore} = \Mtrue  \Mwedge  \tsvar{cantrcvmore} = \Mtrue $, eventually causing TCP to transmit
    all remaining data in the socket's send queue and perform a graceful close.

    In the final host state, the mapping of file descriptor $\tsvar{fd}$ to file descriptor index $\tsvar{fid}$
    is removed from the file descriptors finite map $\tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd}$ and the file description
    entry $\tsvar{fid}$ is removed from the finite map of file descriptors $\tsvar{files} \backslash{}\backslash{} \tsvar{fid}$. The socket
    entry itself, $(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},$$\dots $,$))$ is not destroyed at this point; it remains
    until the TCP connection has been successfully closed.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    The socket can be in the $\tscon{SYN\_RECEIVED}$ state or in one of the synchronised states $\geq
\tscon{ESTABLISHED}$.

    On Linux, non-blocking semantics do not take precedence over the $\tscon{SO\_LINGER}$ option, i.e. if
    the socket is non-blocking, $\tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) = \Mtrue $ and a linger option is set to a non-zero
    value, $\tsvar{sf}.\tsvar{t}(\tscon{SO\_LINGER}) \neq  0$, the socket may block on a call to $\tslib{close}()$. See also
    \ltslink{closeTIV}{$\tsrule{close\_4}$}.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\closeTIII}{\rrulecc{closeTIII}{close\_3}{tcp: fast succeed}{\tsholcomm{ Successful abortive close of a synchronised socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds};{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus {}\\{}
\quad\quad [(\tsvar{fid},\tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}))];{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{close}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}';{}\\{}
 \tsvar{files} \Mass  \tsvar{files};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{(\tsvar{st} \;\in  \{\tscon{ESTABLISHED};\tscon{FIN\_WAIT\_1};\tscon{CLOSING};\tscon{FIN\_WAIT\_2};{}\\{}
\quad\quad\quad \tscon{TIME\_WAIT};\tscon{CLOSE\_WAIT};\tscon{LAST\_ACK}\} \Mvee {}\\{}
 \tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge  \tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge  {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 \tsvar{sf}.\tsvar{t}(\tscon{SO\_LINGER}) = 0 \Mwedge   {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsaux{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1 \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd} \Mwedge {}\\{}
 \tsvar{fid} \;\notin  (\Mfdom{\tsvar{files}}) \Mwedge {}\\{}
 \tsvar{sid} \;\notin  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{sock}' = (\tsaux{tcp\_close} \;\tsvar{h}.\tstype{arch} \;\tsvar{sock})  \Mmagiclrec  \tsvar{fid} \Mass  * \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{seg} \;\in  \;\tsaux{make\_rst\_segment\_from\_cb} \;\tsvar{cb} (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) \Mwedge {}\\{}
 \tsaux{enqueue\_and\_ignore\_fail} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} [\tscon{TCP} \;\tsvar{seg}] \tsvar{oq} \;\tsvar{oq}'}
{\rulesubsection{Description}

    A $\tslib{close}(\tsvar{fd})$ call is performed on the TCP socket $\tsvar{sid}$ referenced by file descriptor $\tsvar{fd}$
    which is the only file descriptor referencing the socket's file description:
    $\tsaux{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1$. The TCP socket $\tsvar{sid}$ is in a synchronised state, i.e. a state >=
    $\tscon{ESTABLISHED}$, except on Linux platforms where it may be in the $\tscon{SYN\_RECEIVED}$ state.

    The socket's linger option is set to a duration of zero, $\tsvar{sf}.\tsvar{t}(\tscon{SO\_LINGER}) = 0$, to signify
    that an abortive closure of socket $\tsvar{sid}$ is required.

    The $\tslib{close}(\tsvar{fd})$ call proceeds by a $\MLhcall{\tsvar{tid}}{\tslib{close}(\tsvar{fd})}$ transition leaving the host in
    the successful return state $\tscon{Ret} (\tscon{OK}())$. A reset segment $\tsvar{seg}$ is constructed from the
    socket's control block $\tsvar{cb}$ and address quad $(\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2})$ and is appended to the host's
    output queue, $\tsvar{oq}$, by the function \ltslink{enqueueTandTignoreTfail}{$\tsaux{enqueue\_and\_ignore\_fail}$}, to create new output queue
    $\tsvar{oq}'$. The $\tsaux{enqueue\_and\_ignore\_fail}$ function always succeeds; if it is not possible to add
    the reset segment $\tsvar{seq}$ to the output queue the corresponding error code is ignored and the
    reset segment is not queued for transmission.

    The mapping of file descriptor $\tsvar{fd}$ to index $\tsvar{fid}$ is removed from the file descriptors
    finite map $\tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd}$ and the file description entry indexed by $\tsvar{fid}$ is removed
    from the finite map of file descriptions. The socket is put in the $\tscon{CLOSED}$ state, shutdown
    for reading and writing, has its control block reset, and its send and receive queues emptied;
    this is done by the auxiliary function \ltslink{tcpTclose}{$\tsaux{tcp\_close}$}. Additionally, its file description
    field is cleared.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    The socket can be in the $\tscon{SYN\_RECEIVED}$ state or in one of the synchronised states $\geq
\tscon{ESTABLISHED}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\closeTIV}{\rrulecc{closeTIV}{close\_4}{tcp: block}{\tsholcomm{ Block on a lingering close on the last file descriptor of a synchronised socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds};{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus {}\\{}
\quad\quad [(\tsvar{fid},\tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}))];{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{close}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Close2}(\tsvar{sid})}{\tsaux{slow\_timer} (\tsvar{sf}.\tsvar{t}(\tscon{SO\_LINGER}))}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}';{}\\{}
 \tsvar{files} \Mass  \tsvar{files};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(*,\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\Mtrue ,\Mtrue ,{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},[\,],\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{(\tsvar{st} \;\in  \{\tscon{ESTABLISHED};\tscon{FIN\_WAIT\_1};\tscon{CLOSING};\tscon{FIN\_WAIT\_2};{}\\{}
\quad\quad\quad \tscon{TIME\_WAIT};\tscon{CLOSE\_WAIT};\tscon{LAST\_ACK}\} \Mvee {}\\{}
 \tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge  \tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge  {}\\{}
 \tsvar{sf}.\tsvar{t}(\tscon{SO\_LINGER}) \notin  \{0; \infty\} \Mwedge {}\\{}
 (\tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) = \Mfalse  \Mvee  (\tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) = \Mtrue  \Mwedge  \tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch})) \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsaux{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1 \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd} \Mwedge {}\\{}
 \tsvar{fid} \;\notin  (\Mfdom{\tsvar{files}})}
{\rulesubsection{Description}

    A $\tslib{close}(\tsvar{fd})$ call is performed on the TCP socket $\tsvar{sid}$ referenced by file descriptor $\tsvar{fd}$
    which is the only file descriptor referencing the socket's file description:
    $\tsaux{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1$. The TCP socket $\tsvar{sid}$ has a blocking mode of operation,
    $\tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) = \Mfalse $, and is in a synchronised state, i.e. a state $\geq  \tscon{ESTABLISHED}$.

    On Linux, the socket is also permitted to be in the $\tscon{SYN\_RECEIVED}$ state and it may have
    non-blocking semantics $\tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) = \Mtrue $, because the linger option takes precedence over
    non-blocking semantics.

    The socket's linger option is set to a positive duration and is neither zero (which signifies an
    immediate abortive close of the socket) nor infinity (which signifies that the linger option has
    not been set), $\tsvar{sf}.\tsvar{t}(\tscon{SO\_LINGER}) \notin  \{0; \infty\}$. The close call blocks for a
    maximum duration that is the linger option duration in seconds, during which time TCP attempts
    to send all remaining data in the socket's send buffer and gracefully close the connection.

    The $\tslib{close}(\tsvar{fd})$ call proceeds by a $\MLhcall{\tsvar{tid}}{\tslib{close}(\tsvar{fd})}$ transition leaving the host in
    the blocked state $\tscon{Close2}(\tsvar{sid})$.  The socket is marked as unable to send and receive
    further data, $\tsvar{cantsndmore} = \Mtrue  \Mwedge  \tsvar{cantrcvmore} = \Mtrue $; this eventually causes TCP to send all
    remaining data in the socket's send queue and perform a graceful close.

    In the final host state, the mapping of file descriptor $\tsvar{fd}$ to file descriptor index $\tsvar{fid}$
    is removed from the file descriptors finite map $\tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd}$ and file description entry
    $\tsvar{fid}$ is removed from the finite map of file descriptors. The socket entry itself,
    $(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},$$\dots$$))$, is not destroyed at this point; it remains until the TCP
    socket has been successfully closed by future asychronous events.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    The socket can be in the $\tscon{SYN\_RECEIVED}$ state or in one of the synchronised states $\geq
\tscon{ESTABLISHED}$.

    On Linux, non-blocking semantics do not take precedence over the $\tscon{SO\_LINGER}$ option, i.e. if
    the socket is non-blocking, $\tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) = \Mtrue $ and a linger option is set to a non-zero
    value, $\tsvar{sf}.\tsvar{t}(\tscon{SO\_LINGER}) \neq  0$ the socket may block on a call to $\tslib{close}()$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\closeTV}{\rrulecc{closeTV}{close\_5}{tcp: slow urgent succeed}{\tsholcomm{ Successful completion of a lingering close on a synchronised socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Close2}(\tsvar{sid})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(*,\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\Mtrue ,\Mtrue ,{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,[\,],\tsvar{sndurp},[\,],\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(*,\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\Mtrue ,\Mtrue ,{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,[\,],\tsvar{sndurp},[\,],\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\tsvar{st} \;\in  \{\tscon{TIME\_WAIT};\tscon{CLOSED};\tscon{FIN\_WAIT\_2}\}{}\\{}
 }
{\rulesubsection{Description}

    A previous call to $\tslib{close}()$ with the linger option set on the socket blocked leaving thread
    $\tsvar{tid}$ in the $\tscon{Close2}(\tsvar{sid})$ state. The socket $\tsvar{sid}$ has successfully transmitted all the
    data in its send queue, $\tsvar{sndq} = [\,]$, and has completed a graceful close of the connection: $\tsvar{st}
\in  \{\tscon{TIME\_WAIT}; \tscon{CLOSED}; \tscon{FIN\_WAIT\_2}\}$.

    The rule proceeds via a $\MLhtau $ transition leaving thread $\tsvar{tid}$ in the $\tscon{Ret}(\tscon{OK} ())$
    state to return successfully from the blocked $\tslib{close}()$ call. The socket remains in a closed state.

    Note that the asychronous sending of any remaining data in the send queue and graceful closing of
    the connection is handled by other rules. This rule applies once these events have reached a
    successful conclusion.

\rrulepad }
}

\newcommand{\closeTVI}{\rrulecc{closeTVI}{close\_6}{tcp: slow nonurgent fail}{\tsholcomm{ Fail with $\tscon{EAGAIN}$: unsuccessful completion of a lingering close on a synchronised socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Close2}(\tsvar{sid})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})]{}\\{}
 \Mmagicbolrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EAGAIN}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})]{}\\{}
 \Mmagicbolrrec }
{\tsvar{sock} = \tscon{Sock}(*,\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\Mtrue ,\Mtrue ,{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},[\,],\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 \tsaux{timer\_expires} \;\tsvar{d} \Mwedge {}\\{}
 \tsvar{st} \;\notin  \{\tscon{TIME\_WAIT}; \tscon{CLOSED}\}}
{\rulesubsection{Description}

    A previous call to $\tslib{close}()$ with the linger option set on the socket blocked, leaving thread
    $\tsvar{tid}$ in the $\tscon{Close2}(\tsvar{sid})$ state. The linger timer has expired, $\tsaux{timer\_expires} \;\tsvar{d}$, before
    the socket has been successfully closed: $\tsvar{st} \;\notin  \{\tscon{TIME\_WAIT}; \tscon{CLOSED}\}$.

    The rule proceeds via a $\MLhtau $ transition leaving thread $\tsvar{tid}$ in the $\tscon{Ret}(\tscon{FAIL}\;{\tscon{EAGAIN}})$
    state to return error $\tscon{EAGAIN}$ from the blocked $\tslib{close}()$ call. The socket remains in a
    synchronised state and is not destroyed until the socket has been successfully closed by future
    asychronous events.


    The asychronous transmission of any remaining data in the send queue and the graceful closing of
    the connection is handled by other rules. This rule is only predicated on the unsuccessfulness
    of these operations, i.e. $\tsvar{st} \;\notin  \{\tscon{TIME\_WAIT}; \tscon{CLOSED}\}$. When the linger timer expires the
    socket could be (a) still attempting to successfully transmit the data in the send queue, or (b)
    be someway through the graceful close operation. The exact state of the socket is not important
    here, explaining the relatively unconstrained socket state in the rule.

\rrulepad }
}

\newcommand{\closeTVII}{\rrulecc{closeTVII}{close\_7}{tcp: fast succeed}{\tsholcomm{ Successfully close the last file descriptor for a socket in the $\tscon{CLOSED}$, $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$ states. }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds};{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus  [(\tsvar{fid},\tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}))];{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{close}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{ \tsaux{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}';{}\\{}
 \tsvar{files} \Mass  \tsvar{files};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks}\Mmagicrrec }
{(\tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{CLOSED}; \tscon{SYN\_SENT}\} \Mvee {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge  \neg{}\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = \tsvar{sock}.\tsvar{pr} \Mwedge {}\\{}
 \tsvar{fid} \;\notin  (\Mfdom{\tsvar{files}}) \Mwedge {}\\{}
 \tsvar{sid} \;\notin  (\Mfdom{\tsvar{socks}}) \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsaux{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1 \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd}}
{\rulesubsection{Description}

    A $\tslib{close}(\tsvar{fd})$ call is performed on the TCP socket $\tsvar{sock}$, identified by $\tsvar{sid}$ and
    referenced by file descriptor $\tsvar{fd}$ which is the only file descriptor referencing the socket's
    file description: $\tsaux{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1$. The TCP socket $\tsvar{sock}$ is not in a
    synchronised state: $\tsvar{st} \;\in  \{\tscon{CLOSED}; \tscon{SYN\_SENT}\}$.

    The $\tslib{close}(\tsvar{fd})$ call proceeds by a $\MLhcall{\tsvar{tid}}{\tslib{close}(\tsvar{fd})}$ transition leaving the host in
    the successful return state $\tscon{Ret} (\tscon{OK} ())$.

    The mapping of file descriptor $\tsvar{fd}$ to file descriptor index $\tsvar{fid}$ is removed from the
    host's finite map of file descriptors; the file description entry for $\tsvar{fid}$ is removed from
    the host's finite map of file descriptors; and the socket entry $(\tsvar{sid},\tsvar{sock})$ is removed from
    the host's finite map of sockets.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    The rule does not apply if the socket is in state $\tscon{SYN\_RECEIVED}$: for the purposes of
    $\tslib{close}()$ this is treated as a synchronised state on Linux.


    Note that the socket $\tsvar{sock}$ is not in a synchronised state and thus has no data in its send queue ready
    for transmission. Closing an unsynchronised socket simply involves deleting the socket entry and
    removing all references to it. These operations are performed immediately by the rule, hence the
    socket's $\tscon{SO\_LINGER}$ option is not constrained because it has no effect regardless of how it
    may be set.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\closeTVIII}{\rrulecc{closeTVIII}{close\_8}{tcp: fast succeed}{\tsholcomm{ Successfully close the last file descriptor for a listening TCP socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds};{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus  [(\tsvar{fid},\tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}))];{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tslib{listen} \Mass  \tslib{listen};{}\\{}
 \tsvar{oq}    \Mass  \tsvar{oq} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{close}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{ \tsaux{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}';{}\\{}
 \tsvar{files} \Mass  \tsvar{files};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks}';{}\\{}
 \tslib{listen} \Mass  \tsvar{listen}';{}\\{}
 \tsvar{oq}    \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis},\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsaux{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1 \Mwedge {}\\{}
 \tsvar{fid} \;\notin  (\Mfdom{\tsvar{files}}) \Mwedge {}\\{}
 \tsvar{sid} \;\notin  (\Mfdom{\tsvar{socks}}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ cantrcvmore/cantsndmore unconstrained under BSD, as may have previously called shutdown }{}\\{}
 \tsholcomm{ MS: this is more of an assertion than a condition, so we could get away without it }{}\\{}
 (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mvee  (\tsvar{cantsndmore} = \Mfalse  \Mwedge  \tsvar{cantrcvmore} = \Mfalse )) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ BSD and Linux do not send RSTs to sockets on $\tsvar{lis}.\tsvar{q}_{0}$. }{}\\{}
 \tsunknown{socks\_to\_rst} = \{ (\tsvar{sock}',\tsunknown{tcp\_sock'}) \mid  \exists \tsvar{sid}'. \tsvar{sid}' \;\in  \;\tsvar{lis}.\tsvar{q} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{socks} \Mfapply{}{\tsvar{sid}'} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) = \tsvar{sock}'.\tsvar{pr} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock'}.\tsvar{st} \;\notin  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT}\} \} \Mwedge {}\\{}
 {}\\{}
 \tsunknown{socks\_to\_rst\_list} \;\in  \;\tsaux{ORDERINGS} \;\tsunknown{socks\_to\_rst} \Mwedge {}\\{}
 {}\\{}
 \tsholop{CARD} \;\tsunknown{socks\_to\_rst} = \tsholop{LENGTH} \;\tsvar{segs} \Mwedge  {}\\{}
 {}\\{}
 (\Mlet  \;\tsunknown{make\_rst\_seg} = \lambda  (\tsvar{sock}',\tsunknown{tcp\_sock'}).{}\\{}
\quad\quad \tsaux{make\_rst\_segment\_from\_cb} \;\tsunknown{tcp\_sock'}.\tsvar{cb} (\tsholop{THE} \;\tsvar{sock}'.\tsvar{is}_{1},\tsholop{THE} \;\tsvar{sock}'.\tsvar{is}_{2},\tsholop{THE} \;\tsvar{sock}'.\tsvar{ps}_{1},\tsholop{THE} \;\tsvar{sock}'.\tsvar{ps}_{2}){}\\{}
 \Min {}\\{}
 {}\\{}
 \tsholop{EVERY} \;\MI  (\tsholop{MAP2} (\lambda  \tsvar{s}' \;\tsvar{seg}'. \tsvar{seg}' \;\in  \;\tsunknown{make\_rst\_seg} \;\tsvar{s}') \tsunknown{socks\_to\_rst\_list} \;\tsvar{segs})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Note this is a clear example of where fuzzy timing is needed: should these really all have exactly
        the same time always? }{}\\{}
 \tsaux{enqueue\_each\_and\_ignore\_fail} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} (\tsholop{MAP} \;\tscon{TCP} \;\tsvar{segs}) \tsvar{oq} \;\tsvar{oq}' \Mwedge {}\\{}
 {}\\{}
 \tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd} \Mwedge {}\\{}
 \tsvar{listen}' = \tsholop{FILTER} (\lambda \tsvar{sid}'. \tsvar{sid}' \neq  \tsvar{sid}) \tslib{listen} \Mwedge {}\\{}
 \tsvar{socks}' = \Mdrestrict{\tsvar{socks}}{\{ \tsvar{sid}' \mid   \tsvar{sid}' \;\notin  \Mappend{\tsvar{lis}.\tsvar{q}_{0}}{\tsvar{lis}.\tsvar{q}}\}}}
{\rulesubsection{Description}

    A $\tslib{close}(\tsvar{fd})$ call is performed on the TCP socket $\tsvar{sock}$ referenced by file descriptor
    $\tsvar{fd}$ which is the only file descriptor referencing the socket's file description $\tsvar{fid}$,
    $\tsaux{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1$. Socket $\tsvar{sock}$ is locally bound to port $\tsvar{p}_{1}$ and one or more
    local IP addresses $\tsvar{is}_{1}$, and is in the $\tscon{LISTEN}$ state.

    The listening socket $\tsvar{sock}$ may have $\tscon{ESTABLISHED}$ incoming connections on its connection
    queue $\tsvar{lis}.\tsvar{q}$ and incomplete incoming connection attempts on queue $\tsvar{lis}.\tsvar{q}_{0}$. Each
    connection, regardless of whether it is complete or not, is represented by a $\tslib{socket}$
    entry in $\tsvar{h}.\tsvar{socks}$ and its corresponding index $\tsvar{sid}$ is on the respective queue. These
    connections have not been accepted by any thread through a call to $\tslib{accept}()$ and are dropped
    on the closure of socket $\tsvar{sock}$.

    A set of reset seqments $\tsunknown{rsts\_to\_go}$ is created using the auxiliary function
    \ltslink{makeTrstTsegmentTfromTcb}{$\tsaux{make\_rst\_segment\_from\_cb}$} for each of the sockets referenced by both queues. This is
    performed by looking up each socket $\tsvar{sock}'$ for every $\tsvar{sid}'$ in the concatentation of both
    queues, $\Mappend{\tsvar{lis}.\tsvar{q}_{0}}{\tsvar{lis}.\tsvar{q}}$, and extracting their address quads
    $(\tsvar{sock}'.\tsvar{is}_{1},\tsvar{sock}'.\tsvar{is}_{2},\tsvar{sock}'.\tsvar{ps}_{1},\tsvar{sock}'.\tsvar{ps}_{2})$ and control blocks $\tsvar{cb}$ for use by
    $\tsaux{make\_rst\_segment\_from\_cb}$.

    The set of reset segments $\tsunknown{rsts\_to\_go}$ is constrained to a list, $\tsvar{segs}$, and  queued by
    the auxiliary function $\tsaux{enqueue\_each\_and\_ignore\_fail}$ on the hosts output queue $\tsvar{h}.\tsvar{oq}$.  The
    $\tsaux{enqueue\_each\_and\_ignore\_fail}$ function always succeeds; if it is not possible to add any of
    the reset segments $\tsvar{segs}$ to the output queue $\tsvar{h}.\tsvar{oq}$, the corresponding error codes are
    ignored and the reset segments in error are ultimately not queued for transmission. This is
    sensible behaviour as the sockets for these connections are about to be deleted: if a reset
    segment does not successfully abort the remote end of the connection, perhaps because it could
    not be transmitted in the first place, any future incoming segments should not match any other
    socket in the system and will be dropped.

    The $\tslib{close}(\tsvar{fd})$ call proceeds by a $\MLhcall{\tsvar{tid}}{\tslib{close}(\tsvar{fd})}$ transition leaving the host in
    the successful return state $\tscon{Ret} (\tscon{OK} ())$.

    In the final host state, the mapping of file descriptor $\tsvar{fd}$ to file descriptor index $\tsvar{fid}$
    is removed from the file descriptors finite map $\tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd}$ and file description entry
    $\tsvar{fid}$ is removed from the finite map of file descriptors $\tsvar{h}.\tsvar{files}$. The socket entry
    $\tsvar{sock}$ is removed from the hosts finite map of sockets $\tsvar{h}.\tsvar{socks}$ and the socket's $\tsvar{sid}$
    value is removed from the host's list of listening sockets $\tsvar{h}.\tslib{listen}$ by $\tsvar{listen}' = \tsholop{FILTER}
(\lambda \tsvar{sid}'. \tsvar{sid}' \neq  \tsvar{sid}) \tslib{listen}$. Finally, all the sockets in $\tsvar{h}.\tsvar{socks}$ that were referenced on
    one of the queues $\tsvar{lis}.\tsvar{q}_{0}$ and $\tsvar{lis}.\tsvar{q}$, are removed by $\tsvar{socks}' = \Mdrestrict{\tsvar{socks}}{\{ \tsvar{sid}' \mid  \tsvar{sid}' \;\notin  \Mappend{\tsvar{lis}.\tsvar{q}_{0}}{\tsvar{lis}.\tsvar{q}}\}}$ as they were not accepted by any thread before socket $\tsvar{sock}$
    was closed.

\rulesubsection{Model details}

    The local IP address option $\tsvar{is}_{1}$ of the socket $\tsvar{sock}$ is not constrained in this
    rule. Instead it is constrained by other rules for $\tslib{bind}()$ and $\tslib{listen}()$ prior to the
    socket entering the $\tscon{LISTEN}$ state.

\rrulepad }
}

\newcommand{\closeTX}{\rrulecc{closeTX}{close\_10}{udp: fast succeed}{\tsholcomm{ Successfully close the last file descriptor of a UDP socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds};{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus  [(\tsvar{fid},\tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}))];{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{close}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}';{}\\{}
 \tsvar{files} \Mass  \tsvar{files};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsaux{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1 \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd} \Mwedge {}\\{}
 \tsvar{fid} \;\notin  (\Mfdom{\tsvar{files}}) \Mwedge {}\\{}
 \tsvar{sid} \;\notin  (\Mfdom{\tsvar{socks}})}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, with a file description record indexed by
    $\tsvar{fid}$. $\tsvar{fd}$ is the only open file descriptor referring to the file description record
    indexed by $\tsvar{fid}$, $\tsaux{fid\_ref\_count}(\tsvar{fds},\tsvar{fid}) = 1$. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$
    state, a $\tslib{close}(\tsvar{fd})$ call is made and succeeds.

    A $\MLhcall{\tsvar{tid}}{\tslib{close}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}())$. The
    socket $\tsvar{sid}$ is removed from the host's finite map of sockets $\tsvar{socks}$$\oplus\dots$, the
    file description record indexed by $\tsvar{fid}$ is removed from the host's finite map of file
    descriptions $\tsvar{files}$$\oplus\dots$, and $\tsvar{fd}$ is removed from the host's finite map of file
    descriptors $\tsvar{fds}' = \tsvar{fds} \backslash{}\backslash{} \tsvar{fd}$.

\rrulepad }
}

\newcommand{\seccommconnect}{\clustersection{(TCP and UDP)}{$\tslib{connect}()$}
\seccomm{ \[ \tslib{connect}: \tstype{fd} * \tstype{ip} * \tstype{port} \;\;\tstype{option} \Mtotype  \tstype{unit} \]

  A call to $\tslib{connect}(\tstype{fd},\tstype{ip},\tstype{port})$ attempts to connect a TCP socket to a peer, or to set the peer
  address of a UDP socket.
  Here $\tstype{fd}$ is a file descriptor referring to a socket,
  $\tstype{ip}$ is the peer IP address to connect to, and $\tstype{port}$ is the peer port.

  If $\tstype{fd}$ refers to a TCP socket then TCP's connection establishment protocol, often called the
  \textit{three-way handshake}, will be used to connect the socket to the peer specified by
  $(\tstype{ip},\tstype{port})$. A peer port must be specified: $\tstype{port}$ cannot be set to $*$. There must be a
  listening TCP socket at the peer address, otherwise the connection attempt will fail with an
  $\tscon{ECONNRESET}$ or $\tscon{ECONNREFUSED}$ error. The local socket must be in the $\tscon{CLOSED}$ state: attempts to
  $\tslib{connect}()$ to a peer when already synchronised with another peer will fail. To start
  the connection establishment attempt, a $\tsvar{SYN}$ segment will be constructed, specifying the
  initial sequeunce number and window size for the connection, and possibly the maximum segment
  size, window scaling, and timestamping.  The segment is then
  enqueued on the host's out-queue; if this fails then the $\tslib{connect}()$ call fails, otherwise
  connection establishment proceeds.

  If the socket is a blocking one (the $\tscon{O\_NONBLOCK}$ flag for $\tstype{fd}$ is not set), then the call
  will block until the connection is established, or a timeout expires in which case the error
  $\tscon{ETIMEDOUT}$ is returned.

  If the socket is non-blocking (the $\tscon{O\_NONBLOCK}$ flag is set for $\tstype{fd}$), then the $\tslib{connect}()$
  call will fail with an $\tscon{EINPROGRESS}$ error (or $\tscon{EALREADY}$ on WinXP), and connection
  establishment will proceed asynchronously.

  Calling $\tslib{connect}()$ again will indicate the current status of the connection establishment in
  the returned error: it will fail with $\tscon{EALREADY}$ if the connection has not been established,
  $\tscon{EISCONN}$ once the connection has been established, or if the connection establishment failed,
  an error describing why. Alternatively, $\tslib{pselect}([\,],[\tstype{fd}],[\,],*,\tsunknown{\_})$ can be used; it will return
  when $\tstype{fd}$ is ready for writing which will be when connection establishment is complete, either
  successfully or not. On Linux or BSD, unsetting the $\tscon{O\_NONBLOCK}$ flag for $\tstype{fd}$ and then calling
  $\tslib{connect}()$ will block until the connection is established or fails; for WinXP the call will
  fail with $\tscon{EALREADY}$ and the connection establishment will be performed asynchronously still;
  for FreeBSD the call will fail with $\tscon{EISCONN}$ even if the connection has not been established.

  Upon completion of connection establishment the socket will be in state $\tscon{ESTABLISHED}$, ready to
  send and receive data, or $\tscon{CLOSE\_WAIT}$ if it received a FIN segment during connection
  establishment.

  On FreeBSD, if connection establishment fails having sent a $\tsvar{SYN}$ then further connection
  establishment attempts are not allowed; on Linux and WinXP further attempts are possible.

  If $\tstype{fd}$ refers to a UDP socket then the peer address of the socket is set, but no connection is
  made. The peer address is then the default destination address for subsequent $\tslib{send}()$ calls
  (and the only possible destination address on FreeBSD), and only datagrams with this source
  address will be delivered to the socket. On FreeBSD the peer port must be specified: a call to
  $\tslib{connect}(\tstype{fd},\tstype{ip},*)$ will fail with an $\tscon{EADDRNOTAVAIL}$ error; on Linux and WinXP such a call
  succeeds: datagrams from any port on the host with IP address $\tstype{ip}$ will be delivered to the
  socket. Calling $\tslib{connect}()$ on a UDP socket that already has a peer address set is allowed: the
  peer address will be replaced with the one specified in the call. On FreeBSD if the socket has a
  pending error, that may be returned when the call is made, and the peer address will also be set.

  In order for a socket to connect to a peer or have its peer address set, it must be bound to a
  local IP and port. If it is not bound to a local port when the $\tslib{connect}()$ call is made, then it
  will be autobound: an unused port for the socket's protocol in the host's ephemeral port range is
  selected and assigned to the socket. If the socket does not have its local IP address set then it
  will be bound to the primary IP address of an interface which has a route to the peer. If the
  socket does have a local IP address set then the interface that this IP address will be the
  one used to connect to the peer; if this interface does not have a route to the peer then for a
  TCP socket the $\tslib{connect}()$ call will fail when the SYN is enqueued on the host's outqueue; for a
  UDP socket the call will  fail on FreeBSD, whereas on Linux and WinXP the $\tslib{connect}()$ call will
  succeed but later $\tslib{send}()$ calls to the peer will fail.

  For a TCP socket, its binding quad must be unique: there can be no other socket in the host's
  finite map of sockets with the same binding quad. If the $\tslib{connect}()$ call would result in two
  sockets having the same binding quad then it will fail with an $\tscon{EADDRINUSE}$ error. For UDP
  sockets the same is true on FreeBSD, but on Linux and WinXP multiple sockets may have the same
  address quad. The socket that matching datagrams are delivered to is architecture-dependent: see
  \ltslink{lookup}{$\tsunknown{lookup}$}.


}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{connect}()$ can fail with the errors below, in which case the corresponding exception
  is raised:

\par\begin{ltstabular}
$\tscon{EADDRNOTAVAIL}$
&  There is no route to the peer; a port must be specified ($\tstype{port} \neq  *$); or
  there are no ephemeral ports left.

\\\hline
$\tscon{EADDRINUSE}$
&  The address quad that would result if the connection was successful is in
  use by another socket of the same protocol.

\\\hline
$\tscon{EAGAIN}$
&  On WinXP, the socket is non-blocking and the connection cannot be established
  immediately: it will be established asynchronously. [TCP ONLY]

\\\hline
$\tscon{EALREADY}$
&  A connection attempt is already in progress on the socket but not
  yet complete: it is in state $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$. [TCP ONLY]

\\\hline
$\tscon{ECONNREFUSED}$
&  Connection rejected by peer. [TCP ONLY]

\\\hline
$\tscon{ECONNRESET}$
&  Connection rejected by peer. [TCP ONLY]

\\\hline
$\tscon{EHOSTUNREACH}$
&  No route to the peer.

\\\hline
$\tscon{EINPROGRESS}$
&  The socket is non-blocking and the connection cannot be established
  immediately: it will be established asynchronously. [TCP ONLY]

\\\hline
$\tscon{EINVAL}$
&  On WinXP, socket is listening. [TCP ONLY]

\\\hline
$\tscon{EISCONN}$
&  Socket already connected. [TCP ONLY]

\\\hline
$\tscon{ENETDOWN}$
&  The interface used to reach the peer is down.

\\\hline
$\tscon{ENETUNREACH}$
&  No route to the peer.

\\\hline
$\tscon{EOPNOTSUPP}$
&  On FreeBSD, socket is listening. [TCP ONLY]

\\\hline
$\tscon{ETIMEDOUT}$
&   The connection attempt timed out before a connection was established for a socket. [TCP ONLY]

\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\\\hline
$\tscon{EINTR}$
&  The system was interrupted by a caught signal.

\\\hline
$\tscon{ENOBUFS}$
&  Out of resources.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  TCP: $\tsrule{socket\_1}$; $\tsrule{connect\_1}$; $\dots$

  UDP: $\tsrule{socket\_1}$; $\tsrule{bind\_1}$; $\tsrule{connect\_8}$; $\dots$


}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:  &  \wasverb{int connect(int socket, const struct sockaddr *address, socklen\textunderscore{}t address\textunderscore{}len);} \\
    FreeBSD:&  \wasverb{int connect(int s, const struct sockaddr *name, socklen\textunderscore{}t namelen);} \\
    Linux:  &  \wasverb{int connect(int sockfd, constr struct sockaddr *serv\textunderscore{}addr, socklen\textunderscore{}t addrlen);} \\
    WinXP:  &  \wasverb{int connect(SOCKET s, const struct sockaddr* name, int namelen);} \\
  \end{tabular}\\

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is a file descriptor referring to the socket to make a connection on,
    corresponding to the $\tstype{fd}$ argument of the model $\tslib{connect}()$.

    \item \wasverb{address} is a pointer to a \wasverb{sockaddr} structure of length
    \wasverb{address\textunderscore{}len} specifying the peer to connect to. \wasverb{sockaddr} is a generic socket
    address structure: what is used for the model $\tslib{connect}()$ is an internet socket
    address structure \wasverb{sockaddr\textunderscore{}in}. The \wasverb{sin\textunderscore{}family} member is set to
    \wasverb{AF\textunderscore{}INET}; the \wasverb{sin\textunderscore{}port} is the port to connect to, corresponding to the
    $\tstype{port}$ argument of the model $\tslib{connect}()$: \wasverb{sin\textunderscore{}port = 0} corresponds to
    $\tstype{port}=*$ and \wasverb{sin\textunderscore{}port=p} corresponds to $\tstype{port} = \Msome  \;\tsunknown{p}$; the
    \wasverb{sin\textunderscore{}addr.s\textunderscore{}addr} member of the structure corresponds to the $\tstype{ip}$ argument of the
    model $\tslib{connect}()$.

   \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual
     error code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  The FreeBSD, Linux and WinXP interfaces are similar modulo argument renaming, except where
  noted above.

  Note: For UDP sockets, the Winsock Reference says "The default destination can be changed by
  simply calling connect again, even if the socket is already connected. Any datagrams queued for
  receipt are discarded if name is different from the previous connect." This is not the
  case.

}\clustersubsection{Model details}
\seccomm{
  If the call blocks then the thread enters state $\tscon{Connect2}(\tstype{sid})$ where $\tstype{sid}$ is the identifier
  of the socket attempting to establish a connection.

  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EAFNOSUPPORT} means that the specified address is not a valid address for the
    address family of the specified socket. The model $\tslib{connect}()$ only models the
    \wasverb{AF\textunderscore{}INET} family of addresses so this error cannot occur.

    \item \wasverb{EFAULT} signifies that the pointers passed as either the \wasverb{address} or
     \wasverb{address\textunderscore{}len} arguments were inaccessible.  This is an artefact of the C interface to
     $\tslib{connect}()$ that is excluded by the clean interface used in the model.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

    \item \wasverb{EINVAL} is a Posix-specific error signifying that the \wasverb{address\textunderscore{}len}
    argument is not a valid length for the socket's address family or invalid address family in the
    \wasverb{sockaddr} structure. The length of the address to connect to is implicit in the model
    $\tslib{connect}()$, and only the \wasverb{AF\textunderscore{}INET} family of addresses is modelled so this error
    cannot occur.

   \item \wasverb{EPROTOTYPE} is a Posix-specific error meaning that the specified address has a
   different type than the socket bound to the specified peer address. This error does not occur in
   any of the implementations as TCP and UDP sockets are dealt with seperately.

   \item \wasverb{EACCES}, \wasverb{ELOOP}, and \wasverb{ENAMETOOLONG} are errors dealing with Unix
   domain sockets which are not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{connect\_1}$
& \textbf{tcp: rc}
&  Begin connection establishment by creating a SYN and trying to enqueue it on host's outqueue \\
$\tsrule{connect\_2}$
& \textbf{tcp: slow urgent succeed}
&  Successfully return from blocking state after connection is successfully established \\
$\tsrule{connect\_3}$
& \textbf{tcp: slow urgent fail}
&  Fail with the pending error on a socket in the $\tscon{CLOSED}$ state \\
$\tsrule{connect\_4}$
& \textbf{tcp: slow urgent fail}
&  Fail: socket has pending error \\
$\tsrule{connect\_4a}$
& \textbf{tcp: fast fail}
&  Fail with pending error \\
$\tsrule{connect\_5}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{EALREADY}$, $\tscon{EINVAL}$, $\tscon{EISCONN}$, $\tscon{EOPNOTSUPP}$: socket already in use \\
$\tsrule{connect\_5a}$
& \textbf{all: fast fail}
&  Fail: no route to host \\
$\tsrule{connect\_5b}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EADDRINUSE}$: address already in use \\
$\tsrule{connect\_5c}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EADDRNOTAVAIL}$: no ephemeral ports left \\
$\tsrule{connect\_5d}$
& \textbf{tcp: block}
&  Block, entering state $\tscon{Connect2}$: connection attempt already in progress and connect called with blocking semantics \\
$\tsrule{connect\_6}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{EINVAL}$: socket has been shutdown for writing \\
$\tsrule{connect\_7}$
& \textbf{udp: fast succeed}
&  Set peer address on socket with binding quad $*,\tsvar{ps}_{1},*,*$ \\
$\tsrule{connect\_8}$
& \textbf{udp: fast succeed}
&  Set peer address on socket with local address set \\
$\tsrule{connect\_9}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{EADDRNOTAVAIL}$: port must be specified in $\tslib{connect}()$ call on FreeBSD \\
$\tsrule{connect\_10}$
& \textbf{udp: fast fail}
&  Fail with pending error on FreeBSD, but still set peer address \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\connectTI}{\rrulecc{connectTI}{connect\_1}{tcp: rc}{\tsholcomm{ Begin connection establishment by creating a SYN and trying to enqueue it on host's outqueue }}
{\tsvar{h}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} }{1}}
{\tsvar{h}'}
{{}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Thread $\tsvar{tid}$ is in state $\tscon{Run}$ and TCP socket $\tsvar{sid}$ has binding quad $(\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2})$.  }{}\\{}
 \tsvar{h}  = \tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsunknown{ts\_}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,[\,],*,[\,],*,\tscon{NO\_OOBDATA})))] ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Thread $\tsvar{tid}$ ends in state $\tsvar{t}'$ with updated host sockets and output queue }{}\\{}
 \tsvar{h}' = \tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsunknown{ts\_}}{\tsvar{tid}}{\tsvar{t}'};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}'_{1},\Msome  \;\tsvar{p}'_{1},\tsvar{is}'_{2},\tsvar{ps}'_{2},\tsvar{es}'',\Mfalse ,\Mfalse ,{}\\{}
\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st}',\tsvar{cb}''',*,[\,],*,[\,],*,\tscon{NO\_OOBDATA})))] ;{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ File descriptor $\tsvar{fd}$ refers to TCP socket $\tsvar{sid}$ }{}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{h}_{0}.\tsvar{files} \Mfapply{}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Either $\tsvar{sid}$ is bound to a local IP address or one of the host's interface has a route to
     $\tsvar{i}_{2}$ and $\tsvar{i}'_{1}$ is one of its IP addresses.  If it is not routable, then we will fail below,
     when we try to enqueue the segment. }{}\\{}
 {}\\{}
 \tsvar{i}'_{1} \;\in  \;\tsaux{auto\_outroute}(\tsvar{i}_{2},\tsvar{is}_{1},\tsvar{h}.\tsvar{rttab},\tsvar{h}.\tsvar{ifds}) \Mwedge {}\\{}
\quad \tsholcomm{ Notice that $\tsaux{auto\_outroute}$ never fails if $\tsvar{is}_{1}\neq *$ (i.e., is specified in the socket). }{}\\{}
 {}\\{}
 \tsholcomm{ The socket is either bound to a local port $\tsvar{p}'_{1}$ or can be autobound to an ephemeral port $\tsvar{p}'_{1}$ }{}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{ps}_{1},\tscon{PROTO\_TCP},\tsvar{h},\tsvar{h}.\tsvar{socks}) \Mwedge {}\\{}
 \tsholcomm{ If autobinding occurs then $\tsvar{sid}$ is added to the head of the host's list of bound sockets. }{}\\{}
 (\Mif  \;\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}.\tsvar{bound}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ The socket can be in one of two states: (1) it is in state $\tscon{CLOSED}$ in which case its
         peer address is not set; it has no pending error; it is not shutdown for writing; and it is
         not shutdown for reading on non-FreeBSD architectures. Otherwise, (2) on FreeBSD the socket
         is in state $\tscon{TIME\_WAIT}$, and either $\tsvar{is}_{2}$ and $\tsvar{ps}_{2}$ are both set or both are not set.
       The fact that BSD allows a $\tscon{TIME\_WAIT}$ socket to be reconnected means that some
       fields may contain old data, so we leave them unconstrained here. This is particularly
       important in the $\tsvar{cb}$.
     }{}\\{}
 {}\\{}
 ((\tsvar{st} = \tscon{CLOSED} \Mwedge  \tsvar{is}_{2} = * \Mwedge  \tsvar{ps}_{2} = * \Mwedge {}\\{}
\quad \tsvar{es} = * \Mwedge  \tsvar{cantsndmore} = \Mfalse  \Mwedge  (\tsvar{cantrcvmore} = \Mfalse  \Mvee  \tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch})) \Mvee {}\\{}
 (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsvar{st} = \tscon{TIME\_WAIT} \Mwedge {}\\{}
\quad (\tsvar{is}_{2} \neq  * \implies  \tsvar{ps}_{2} \neq  *) \Mwedge {}\\{}
\quad\quad (\tsvar{ps}_{2} \neq  * \implies  \tsvar{is}_{2} \neq  *))) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ No other TCP sockets on the host have the address quad $(\Msome  \;\tsvar{i}'_{1},\Msome  \;\tsvar{p}'_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$. }{}\\{}
 \neg{}(\exists  (\tsvar{sid}', \tsunknown{s}) \Mcons  (\tsvar{h}.\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}).{}\\{}
\quad\quad\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}'_{1} \Mwedge  \tsunknown{s}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}'_{1} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2}  \Mwedge  \tsunknown{s}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}  \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{proto\_of} \;\tsunknown{s}.\tsvar{pr} = \tscon{PROTO\_TCP}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Pick an initial sequence number non-deterministically.
     This allows accidental spoofing of our own connections, but it is unclear how a tighter specification should be expressed. }{}\\{}
 \tsvar{iss} \;\in  \{ \tsvar{n} \mid  \Mtrue  \} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ If windows-scaling is to be requested for the connection then $\tsfield{request\_r\_scale}=\Msome  \;\tsvar{n}$
     where $\tsvar{n}$ is a valid window scale; otherwise, $\tsfield{request\_r\_scale}=*$. $\tsunknown{rcv\_wnd0}$ is a
     valid receive window size. If window scaling is to be requested then the socket's receive
     window is set to $\tsunknown{rcv\_wnd0}$ scaled by the window scale factor $\tsvar{n}$; otherwise it is set to
     $\tsunknown{rcv\_wnd0}$. The socket's receive window is not greater than the size of the socket's receive
     buffer.
     We must allow
     implementations to either (a) not implement window scaling, or (b)
     choose on a per-connection basis whether to do window scaling or
     not. This permits both.
     }{}\\{}
 (\tsfield{request\_r\_scale}:\tstype{num} \;\;\tstype{option}) \in  \{*\} \cup  \{\Msome  \;\tsvar{n} \mid  \tsvar{n} \geq  0 \Mwedge  \tsvar{n} \leq  \tsaux{TCP\_MAXWINSCALE} \} \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 (\tsfield{rcv\_wnd}:\tstype{num}) \in  \{ \tsvar{n} \mid  \tsvar{n} > 0 \Mwedge  \tsvar{n} \leq  (\tsaux{TCP\_MAXWIN} \ll  (\tsholop{option\_case}\Mspiii{0}{\MI }{\tsfield{request\_r\_scale}})) \} \Mwedge {}\\{}
 {}\\{}
 \tsfield{rcv\_wnd} \leq  \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Either advertise a maximum segment size, $\tsvar{advmss}$, that is between $1$ and
     $65535-40$, or advertise no maximum segment size. If one is advertised, $\tsvar{advmss}'=\Msome  \;\tsvar{advmss}$; otherwise, $\tsvar{advmss}'=*$. }{}\\{}
 {}\\{}
 \tsvar{advmss} \;\in  \{ \tsvar{n} \mid  \tsvar{n} \geq  1 \Mwedge  \tsvar{n} \leq  (65535 - 40) \} \Mwedge {}\\{}
 \tsvar{advmss}' \;\in  \{*;\Msome  \;\tsvar{advmss}\} \Mwedge {}\\{}
\quad {}\\{}
\quad {}\\{}
\quad {}\\{}
 {}\\{}
 \tsholcomm{ If time-stamping is to be requested for the connection, then $\tsunknown{tf\_req\_tstmp'}=\Mtrue $; otherwise
     $\tsunknown{tf\_req\_tstmp'}=\Mfalse $. }{}\\{}
 {}\\{}
 \tsunknown{tf\_req\_tstmp'} \;\in  \{\Mfalse ; \Mtrue \} \Mwedge  \tsholcomm{ do timestamp? }{}\\{}
 {}\\{}
 \tsholcomm{ If there is no segment currently being timed for this socket (the expected case) then the SYN segment will be
     timed, with $\tsunknown{t\_rttseg'}$ set to the current time and the initial sequence number for the
     connection, $\tsvar{iss}$. }{}\\{}
 {}\\{}
 (\Mlet  \;\tsunknown{t\_rttseg'} = \Mif  \;\tsunknown{IS\_NONE} \;\tsvar{cb}.\tsfield{t\_rttseg} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}, \tsvar{iss}  ){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{t\_rttseg} \;\Min  {}\\{}
 {}\\{}
 \tsholcomm{ Update the socket's control block to $\tsvar{cb}'$, which is $\tsvar{cb}$ except we: (1) start the
     retransmit and connection establishment timers; (2) set the $\tsfield{snd\_una}$, $\tsfield{snd\_nxt}$,
     $\tsfield{snd\_max}$, $\tsvar{iss}$ fields based on the initial sequence number chosen; (3) set the
     $\tsfield{rcv\_wnd}$, $\tsfield{rcv\_adv}$, and $\tsfield{tf\_rxwin0sent}$ fields based on the receive window chosen; (4)
     record whether or not to do windows scaling, time-stamping, and what the advertised maximum
     segment size is; and (5) store the segment to time. }{}\\{}
 \tsvar{cb}' = \tsvar{cb} \; \Mmagiclrec  \tsfield{tt\_rexmt}          \Mass  \tsaux{start\_tt\_rexmtsyn} \;\tsvar{h}.\tstype{arch} \;0 \;\Mfalse  \;\tsvar{cb}.\tsfield{t\_rttinf};{}\\{}
 \tsfield{tt\_conn\_est}       \Mass  \Msome  (\Mtimed{()}{\tsaux{slow\_timer} \;\tsaux{TCPTV\_KEEP\_INIT}});{}\\{}
 {}\\{}
  {}\\{}
 \tsfield{snd\_una}           \Mass  \tsvar{iss};{}\\{}
 \tsfield{snd\_nxt}           \Mass  \tsvar{iss} + 1;{}\\{}
 \tsfield{snd\_max}           \Mass  \tsvar{iss} + 1;{}\\{}
 \tsvar{iss}               \Mass  \tsvar{iss};{}\\{}
 \tsfield{rcv\_wnd}           \Mass  \tsfield{rcv\_wnd};{}\\{}
 \tsfield{rcv\_adv}           \Mass  \tsvar{cb}.\tsfield{rcv\_nxt} + \tsfield{rcv\_wnd};{}\\{}
 \tsholcomm{ since $\tsfield{rcv\_nxt}$ is $0$ at this point (since we do not yet know), this is a bit
                         odd.  But it models BSD behaviour. }{}\\{}
 {}\\{}
 \tsfield{tf\_rxwin0sent}     \Mass  (\tsfield{rcv\_wnd} = 0);   {}\\{}
 \tsfield{request\_r\_scale}   \Mass  \tsfield{request\_r\_scale}; \tsholcomm{ store whether we requested WS and if so what }{}\\{}
 \tsfield{t\_maxseg}          \Mass  \tsvar{cb}.\tsfield{t\_maxseg};     \tsholcomm{ do not change this }{}\\{}
 {\tsvar{t}}_{\tsvar{advmss}}          \Mass  \tsvar{advmss}';         \tsholcomm{ store what mss we advertised; $*$ or $\Msome  \;\tsunknown{v}$ }{}\\{}
 \tsfield{tf\_req\_tstmp}      \Mass  \tsunknown{tf\_req\_tstmp'};{}\\{}
 \tsfield{last\_ack\_sent}     \Mass  \tsaux{tcp\_seq\_foreign} \;0w;{}\\{}
 \tsfield{t\_rttseg}          \Mass  \tsunknown{t\_rttseg'}{}\\{}
 {}\\{}
 {}\\{}
 \Mmagicbolrrec ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ now build the segment (using an auxiliary, since we might have to retransmit it) }{}\\{}
 {}\\{}
 \tsholcomm{ Make a $\tsvar{SYN}$ segment based on the updated control block and the socket's address quad;
     see \ltslink{makeTsynTsegment}{$\tsaux{make\_syn\_segment}$} for details. }{}\\{}
 \tsholop{choose} \;\tsunknown{seg} \Mcons  \tsaux{make\_syn\_segment} \;\tsvar{cb}' (\tsvar{i}'_{1},\tsvar{i}_{2},\tsvar{p}'_{1},\tsvar{p}_{2}) (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}).{}\\{}
 {}\\{}
 \tsholcomm{ and send it out... }{}\\{}
 {}\\{}
 \tsholcomm{ If possible, enqueue the segment $\tsunknown{seg}$ on the host's outqueue. The auxiliary function
     \ltslink{rollbackTtcpToutput}{$\tsaux{rollback\_tcp\_output}$} is used for this; if the segment is a well-formed segment,
     there is a route to the peer from $\tsvar{i}'_{1}$, and there are no buffer allocation failures,
     $\tsvar{outsegs}' \neq  [\,]$, then the segment is enqueued on the host's outqueue, $\tsvar{oq}$, resulting in a
     new outqueue, $\tsvar{oq}'$. The socket's control block is left as $\tsvar{cb}'$ which is described
     above. Otherwise an error may have occurred; possible errors are: (1) $\tscon{ENOBUFS}$ indicating a
     buffer allocation failure; (2) a routing error; or (3) $\tscon{EADDRNOTAVAIL}$ on FreeBSD or
     $\tscon{EINVAL}$ on Linux indicating that the segment would cause a loopback packet to appear on the
     wire (on WINXP the segment is silently dropped with no error in this case). If an error does
     occur then the socket's control block reverts to $\tsvar{cb}$, the control block when the call was
     made. }{}\\{}
 \exists \tsvar{outsegs}'.  {}\\{}
 \tsaux{rollback\_tcp\_output} \;\Mfalse  (\tscon{TCP} \;\tsunknown{seg}) \tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} \;\Mtrue {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{cb} \; \Mmagiclrec  \tsfield{snd\_nxt}       \Mass  \tsvar{iss};{}\\{}
 \tsfield{snd\_max}       \Mass  \tsvar{iss};{}\\{}
 \tsfield{tt\_delack}     \Mass  *;{}\\{}
 \tsfield{last\_ack\_sent} \Mass  \tsaux{tcp\_seq\_foreign} \;0w;{}\\{}
 \tsfield{rcv\_adv}       \Mass  \tsaux{tcp\_seq\_foreign} \;0w{}\\{}
 \Mmagicbolrrec ) \tsvar{cb}' (\tsvar{cb}'',\tsvar{es}',\tsvar{outsegs}') \Mwedge {}\\{}
 \tsvar{cb}''' = (\Mif  (\tsvar{outsegs}' \neq  [\,] \Mvee  \tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}) \Mthen  \;\tsvar{cb}'' \;\Melse  \;\tsvar{cb}) \Mwedge {}\\{}
 \tsaux{enqueue\_oq\_list\_qinfo} (\tsvar{oq},\tsvar{outsegs}',\tsvar{oq}') \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ If the socket is a blocking one, its $\tscon{O\_NONBLOCK}$ flag is not set, then the call will
         block, entering state $\tscon{Connect2}(\tsvar{sid})$ and leaving the socket in state $\tscon{SYN\_SENT}$ with
         peer address $(\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ and, if the segment could not be enqueued, its pending
         error set to the error resulting from the attempt to enqueue the segment.

	 If the socket is non-blocking, its $\tscon{O\_NONBLOCK}$ flag is set, and the segment was enqueued
	 on the host's outqueue, then the call will fail with an $\tscon{EINPROGRESS}$ error (or $\tscon{EAGAIN}$
	 on WinXP). The socket will be left in state $\tscon{SYN\_SENT}$ with peer address $(\Msome  \;\tsvar{i}_{2},\Msome
\tsvar{p}_{2})$. Otherwise, if the segment was not enqueued, then the call will fail with the error
	 resulting from attempting to enqueue it, $\Msome  \;\tsvar{err}$; the socket will be left in state
	 $\tscon{CLOSED}$ with no peer address set.
     }{}\\{}
 {}\\{}
 \tsholcomm{ In the case of BSD, if we connect via the loopback interface, then the segment exchange
         occurs so fast that the socket has connected before the connect-calling thread regains control.
         When it does, it sees that the socket has been connected, and therefore returns with success
         rather than $\tscon{EINPROGRESS}$. Since this behaviour is due to timing, however, it may be possible
         for the connect call to return before all the segments have been sent, for example if there
         was an artificially imposed delay on the loopback interface. This behaviour is therefore
         made nondeterministic, for a BSD non-blocking socket connecting via loopback, in that it may
         either fail immediately, or be blocked for a short time.
         Linux does not exhibit this behaviour.}{}\\{}
 {}\\{}
 (\tsholcomm{ blocking socket, or BSD and using loopback interface }{}\\{}
 ((\neg{}\tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) \Mvee  (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsvar{i}_{2} \;\in  \;\tsaux{local\_ips} \;\tsvar{h}.\tsvar{ifds})) \Mwedge {}\\{}
\quad\quad \tsvar{t}' = \Mtimed{\tscon{Connect2}(\tsvar{sid})}{\tsaux{never\_timer}} \Mwedge  \tsvar{rc} = \tscon{block} \Mwedge {}\\{}
\quad\quad \tsvar{es}''=\tsvar{es}' \Mwedge  \tsvar{st}' = \tscon{SYN\_SENT} \Mwedge  \tsvar{is}'_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}'_{2} = \Msome  \;\tsvar{p}_{2}) \Mvee {}\\{}
 \tsholcomm{ non-blocking socket }{}\\{}
 (\tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) \Mwedge {}\\{}
\quad\quad \tsvar{es} = * \Mwedge {}\\{}
\quad\quad (\tsvar{err} = (\Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tscon{EAGAIN} \;\Melse  \;\tscon{EINPROGRESS}) \Mvee  \Msome  \;\tsvar{err} = \tsvar{es}') \Mwedge {}\\{}
\quad\quad \tsvar{t}' = \Mtimed{\tscon{Ret}(\tscon{FAIL}\;{\tsvar{err}})}{\tsaux{sched\_timer}} \Mwedge  \tsvar{rc} = \tscon{fast} \;\tscon{fail} \Mwedge  \tsvar{es}''=* \Mwedge {}\\{}
\quad\quad \Mif  \;\tsvar{oq}=\tsvar{oq}' \;\Mthen {}\\{}
\quad\quad\quad\quad \tsvar{st}' = \tscon{CLOSED} \Mwedge  \tsvar{is}'_{2} = * \Mwedge  \tsvar{ps}'_{2} = *{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad\quad \tsvar{st}' = \tscon{SYN\_SENT} \Mwedge  \tsvar{is}'_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}'_{2} = \Msome  \;\tsvar{p}_{2}){}\\{}
 )}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, a $\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ call is made where $\tsvar{fd}$ refers to a TCP
   socket. The socket is in state $\tscon{CLOSED}$ with no peer address set, no pending error, and not
   shutdown for reading or writing. A $\tsvar{SYN}$ segment is created to being connection establishment,
   and is enqueued on the host's out-queue.

   If the socket is a blocking one (its $\tscon{O\_NONBLOCK}$ flag is not set) then the call will block: a
   $\MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread state
   $\tscon{Connect2}(\tsvar{sid})$. If the socket is non-blocking (its $\tscon{O\_NONBLOCK}$ flag is set) and the segment
   enqueuing was successful then the call will fail: a $\MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$
   transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINPROGRESS}})$ (or $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EAGAIN}})$ on WinXP); connection establishment will proceed asynchronously. Otherwise, if the enqueueing did not succeed, the call will fail with an
   error $\tsvar{err}$: a $\MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread
   in state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$.

   For further details see the in-line comments above.


\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   The socket may also be in state $\tscon{TIME\_WAIT}$ when the $\tslib{connect}()$ call is made, with either
   both its peer IP and port set, or neither set.

   The socket may be shutdown for reading when the $\tslib{connect}()$ call is made.

\\\hline
WinXP
&
   If there is an early buffer allocation failure when enqueuing the segment, then it will not be
   placed on the host's out-queue and $\tsvar{es}' = \tscon{ENOBUFS}$; the socket's control block will be $\tsvar{cb}'$
   with its $\tsfield{snd\_nxt}$ and $\tsfield{snd\_max}$ fields set to the intial sequence number, its
   $\tsunknown{last\_ack\_seen}$ and $\tsfield{rcv\_adv}$ fields set to $0$, its $\tsfield{tt\_delack}$ option set to $*$,
   its $\tsfield{tt\_rexmt}$ timer stopped, and its $\tsfield{tf\_rxwin0sent}$ and $\tsfield{t\_rttseg}$ fields reset.

   If there is no route from an interface specified by the local IP address $\tsvar{i}_{1}$ to the foreign IP
   address $\tsvar{i}_{2}$ then the socket's control block will be $\tsvar{cb}'$ with its $\tsunknown{snd\_next}$ field set to the
   initial sequence number, its $\tsfield{last\_ack\_sent}$ and $\tsfield{rcv\_adv}$ fields set to $0$, and its
   $\tsfield{tt\_delack}$ option set to $*$.

   If the segment would case a loopback packet to be sent on the wire then the socket's control
   block will be $\tsvar{cb}'$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTII}{\rrulecc{connectTII}{connect\_2}{tcp: slow urgent succeed}{\tsholcomm{ Successfully return from blocking state after connection is successfully established }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Connect2} \;\tsvar{sid}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{ESTABLISHED};\tscon{CLOSE\_WAIT}\} \Mwedge {}\\{}
 (\neg{}\exists \tsvar{tid}' \;\tsvar{d}'. (\tsvar{tid}' \;\in  \Mfdom{\tsvar{ts}}) \Mwedge  (\tsvar{tid}' \neq  \tsvar{tid}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{ts} \Mfapply{}{\tsvar{tid}'} = \Mtimed{\tscon{Connect2} \;\tsvar{sid}}{\tsvar{d}'})}
{\rulesubsection{Description}

   Thread $\tsvar{tid}$ is blocked in state $\tscon{Connect2}(\tsvar{sid})$ where $\tsvar{sid}$ identifies a TCP socket which
   is in state $\tscon{ESTABLISHED}$: the connection establishment has been successfully completed; or
   $\tscon{CLOSE\_WAIT}$: connection establishment successfully completed but a $\tsvar{FIN}$ was received during
   establishment. $\tsvar{tid}$ is the only thread which is blocked waiting for the socket $\tsvar{sid}$ to
   establish a connection. As connection establishment has now completed, the thread can
   successfully return from the blocked state.

   A $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK} ())$.

\rrulepad }
}

\newcommand{\connectTIII}{\rrulecc{connectTIII}{connect\_3}{tcp: slow urgent fail}{\tsholcomm{ Fail with the pending error on a socket in the $\tscon{CLOSED}$ state }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Connect2} \;\tsvar{sid}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsvar{e} \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  * \Mmagicrrec )] \Mmagicrrec }
{\tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = \tsvar{sock}.\tsvar{pr} \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSED} \Mwedge {}\\{}
 (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \implies  \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{bsd\_cantconnect} = \Mtrue )}
{\rulesubsection{Description}

   Thread $\tsvar{tid}$ is blocked in the $\tscon{Connect2}(\tsvar{sid})$ state where $\tsvar{sid}$ identifies a TCP socket
   $\tsvar{sock}$ that is in the $\tscon{CLOSED}$ state: connection establishment has failed, leaving the socket
   in a pending error state $\Msome  \;\tsvar{e}$. Usually this occurs when there is no listening TCP socket at
   the peer address, giving an error of $\tscon{ECONNREFUSED}$ or $\tscon{ECONNRESET}$; or when the connection
   establishment timer expired, giving an error of $\tscon{ETIMEDOUT}$. The call now returns, failing with
   the error $\tsvar{e}$, and clearing the pending error field of the socket.

   A $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   When connection establishment failed, the $\tsfield{bsd\_cantconnect}$ flag in the control block would
   have been set, the socket's $\tsvar{cantsndmore}$ and $\tsvar{cantrcvmore}$ flags would have been set and its
   local address binding would have been removed. This renders the sockets useless: call to
   $\tslib{bind}()$, $\tslib{connect}()$, and $\tslib{listen}()$ will all fail.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTIV}{\rrulecc{connectTIV}{connect\_4}{tcp: slow urgent fail}{\tsholcomm{ Fail: socket has pending error }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Connect2} \;\tsvar{sid}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock}')] \Mmagicrrec }
{\tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\tsvar{ps}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\Msome  \;\tsvar{err},\Mfalse ,\Mfalse ,{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{SYN\_SENT},\tsvar{cb},*,[\,],*,[\,],*,\tscon{NO\_OOBDATA})) \Mwedge {}\\{}
 \tsholcomm{ On WinXP if the error is from routing to an unavailable address,
       the error is not returned and the socket is left alone. The
       rexmtsyn timer will retry the SYN transmission and eventually fail. }{}\\{}
 \neg{}(\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsvar{err} = \tscon{EINVAL}) \Mwedge {}\\{}
 (\Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad (\Mif  (\tsvar{err} = \tscon{EADDRNOTAVAIL}) \Mthen {}\\{}
\quad\quad\quad {}\\{}
\quad\quad\quad \tsvar{sock}' = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\tsvar{ps}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\Mfalse ,{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{SYN\_SENT},\tsvar{cb},*,[\,],*,[\,],*,\tscon{NO\_OOBDATA})){}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad \tsvar{sock}' = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\tsvar{ps}_{1},*,*,*,\Mfalse ,\Mfalse ,{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{CLOSED},\tsaux{initial\_cb},*,[\,],*,[\,],*,\tscon{NO\_OOBDATA}))){}\\{}
 \Melse {}\\{}
\quad \tsholcomm{ close the socket, but do not shutdown for reading/writing }{}\\{}
\quad \tsvar{sock}' = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\tsvar{ps}_{1},*,*,*,\Mfalse ,\Mfalse ,{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{CLOSED},\tsvar{cb}',*,[\,],*,[\,],*,\tscon{NO\_OOBDATA})) \Mwedge {}\\{}
\quad \tsvar{cb}' = \tsaux{initial\_cb}{}\\{}
 )}
{\rulesubsection{Description}

   Thread $\tsvar{tid}$ is blocked in the $\tscon{Connect2}(\tsvar{sid})$ state waiting for a connection to be
   established. $\tsvar{sid}$ identifies a TCP socket $\tsvar{sock}$ that has not been shutdown for reading or
   writing, and has binding quad $(\Msome  \;\tsvar{i}_{1},\tsvar{ps}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ and pending error $\tsvar{err}$. The
   socket is in state $\tscon{SYN\_SENT}$, is not listening, has empty send and receive queues, and no
   urgent marks set. The call fails, returning the pending error.

   A $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$. The socket is
   left in state $\tscon{CLOSED}$ with its peer address not set, its pending error cleared, and its control
   block reset to the initial control block, $\tsaux{initial\_cb}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   If the pending error is $\tscon{EADDRNOTAVAIL}$ then the error is cleared and returned but the rest of
   the socket stays the same: it is in state $\tscon{SYN\_SENT}$ so the $\tsvar{SYN}$ will be retransmitted until
   it times out.

   If the pending error is not $\tscon{EADDRNOTAVAIL}$ then the socket is reset as above except that the
   the socket's local ip and port are cleared

\\\hline
WinXP
&
   If the error is $\tscon{EINVAL}$ then this rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTIVa}{\rrulecc{connectTIVa}{connect\_4a}{tcp: fast fail}{\tsholcomm{ Fail with pending error }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsvar{err} \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsaux{sched\_timer}}} ;{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  * \Mmagicrrec )] \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = \tsvar{sock}.\tsvar{pr} \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{CLOSED}  \}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ call is
    made. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sock}$, identified by $\tsvar{sid}$, with pending error $\tsvar{err}$
    and in state $\tscon{CLOSED}$. The call fails with the pending error.

    A $\MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tstype{ip},\tstype{port})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsvar{err}})$ and the socket's pending error clear.

    The most likely cause of this behaviour is for a non-blocking $\tslib{connect}(\tsvar{fd},\tsunknown{\_},\tsunknown{\_})$ call to have
    previously been made. The call fails, setting the pending error on the socket, and when
    $\tslib{connect}()$ is called to check the status of connection establishment the error is
    returned. In such a case $\tsvar{err}$ is most likely to be $\tscon{ECONNREFUSED}$, $\tscon{ECONNRESET}$, or
    $\tscon{ETIMEDOUT}$.


\rrulepad }
}

\newcommand{\connectTV}{\rrulecc{connectTV}{connect\_5}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{EALREADY}$, $\tscon{EINVAL}$, $\tscon{EISCONN}$, $\tscon{EOPNOTSUPP}$: socket already in use }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} \Mwedge {}\\{}
 \Mcase  \;\tsunknown{tcp\_sock}.\tsvar{st} \;\Mof {}\\{}
\quad\quad \tscon{SYN\_SENT}     \Mtotype  \Mif      \;\tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) = \Mtrue  \;\Mthen  \;\tsvar{err} = \tscon{EALREADY} \tsholcomm{ connection already in progress }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{err} = \tscon{EALREADY} \tsholcomm{ connection already in progress }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsaux{bsd\_arch}     \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{err} = \tscon{EISCONN}  \tsholcomm{ connection being established }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsaux{ASSERTION\_FAILURE} \text{``connect\textunderscore{}5:1''} \Mdpipe  \tsholcomm{ never happen }{}\\{}
\quad\quad \tscon{SYN\_RECEIVED} \Mtotype  \Mif      \;\tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) = \Mtrue  \;\Mthen  \;\tsvar{err} = \tscon{EALREADY} \tsholcomm{ connection already in progress }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{err} = \tscon{EALREADY}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsaux{bsd\_arch}     \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{err} = \tscon{EISCONN}  \tsholcomm{ connection being established }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsaux{ASSERTION\_FAILURE} \text{``connect\textunderscore{}5:2''} \Mdpipe  \tsholcomm{ never happen }{}\\{}
\quad\quad \tscon{LISTEN}      \Mtotype  \Mif       \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{err} = \tscon{EINVAL}  \tsholcomm{ socket is listening }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsaux{bsd\_arch}     \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{err} = \tscon{EOPNOTSUPP}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsaux{linux\_arch}   \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{err} = \tscon{EISCONN}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsaux{ASSERTION\_FAILURE} \text{``connect\textunderscore{}5:3''} \Mdpipe  \tsholcomm{ never happen }{}\\{}
\quad\quad \tscon{ESTABLISHED} \Mtotype  \tsvar{err} = \tscon{EISCONN} \Mdpipe   \tsholcomm{ socket already connected }{}\\{}
\quad\quad \tscon{FIN\_WAIT\_1} \Mtotype  \tsvar{err} = \tscon{EISCONN} \Mdpipe    \tsholcomm{ socket already connected }{}\\{}
\quad\quad \tscon{FIN\_WAIT\_2} \Mtotype  \tsvar{err} = \tscon{EISCONN} \Mdpipe    \tsholcomm{ socket already connected }{}\\{}
\quad\quad \tscon{CLOSING} \Mtotype  \tsvar{err} = \tscon{EISCONN} \Mdpipe       \tsholcomm{ socket already connected }{}\\{}
\quad\quad \tscon{CLOSE\_WAIT} \Mtotype  \tsvar{err} = \tscon{EISCONN} \Mdpipe    \tsholcomm{ socket already connected }{}\\{}
\quad\quad \tscon{LAST\_ACK} \Mtotype  \tsvar{err} = \tscon{EISCONN} \Mdpipe      \tsholcomm{ socket already connected; seems that fd is valid in this state }{}\\{}
\quad\quad \tscon{TIME\_WAIT} \Mtotype  (\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mvee  \tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge  \tsvar{err} = \tscon{EISCONN} \Mdpipe {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ BSD allows a $\tscon{TIME\_WAIT}$ socket to be reconnected }{}\\{}
\quad\quad \tscon{CLOSED} \Mtotype  \tsvar{err} = \tscon{EINVAL} \Mwedge  \tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{bsd\_cantconnect} = \Mtrue }
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ call is made
   where $\tsvar{fd}$ refers to a TCP socket identified by $\tsvar{sid}$. The call fails with an error $\tsvar{err}$:
   if the socket is in state $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$ and the socket is non-blocking or the
   host is a WinXP architecture then $\tsvar{err}=\tscon{EALREADY}$ ($\tscon{EISCONN}$ on FreeBSD); if it is in state $\tscon{LISTEN}$ then on WinXP
   $\tsvar{err}=\tscon{EINVAL}$, on FreeBSD $\tsvar{err}=\tscon{EOPNOTSUPP}$, and on Linux $\tsvar{err}=\tscon{EISCONN}$; if it is in state
   $\tscon{ESTABLISHED}$, $\tscon{FIN\_WAIT\_1}$, $\tscon{FIN\_WAIT\_2}$, $\tscon{CLOSING}$, $\tscon{CLOSE\_WAIT}$, or $\tscon{TIME\_WAIT}$ on
   Linux and WinXP, $\tsvar{err}=\tscon{EISCONN}$; if it is in state $\tscon{CLOSED}$ on FreeBSD and has its
   $\tsfield{bsd\_cantconnect}$ flag set then $\tsvar{err}=\tscon{EINVAL}$.

   A $\MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsvar{err}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   If the socket is in state $\tscon{TIME\_WAIT}$ then the call does not fail: the socket may be
   reconnected by \ltslink{connectTI}{$\tsrule{connect\_1}$}.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTVa}{\rrulecc{connectTVa}{connect\_5a}{all: fast fail}{\tsholcomm{ Fail: no route to host }}
{\tsvar{h}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{1} \Mass  \tsvar{is}'_{1}; \tsvar{ps}_{1} \Mass  \tsvar{ps}'_{1} \Mmagicrrec )];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec }
{\tsvar{h}.\tsvar{ts} = \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mwedge {}\\{}
 \tsvar{h}.\tsvar{socks} = \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{1} \Mass  *; \tsvar{ps}_{1} \Mass  \tsvar{ps}_{1} \Mmagicrrec )] \Mwedge {}\\{}
 {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{h}.\tsvar{files} \Mfapply{}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tscon{PROTO\_TCP} \;\Mthen {}\\{}
\quad\quad \tsvar{is}'_{1} = \Msome  \;\tsvar{i}'_{1} \Mwedge  \tsvar{i}'_{1} \;\in  \;\tsaux{local\_primary\_ips} \;\tsvar{h}.\tsvar{ifds} \Mwedge {}\\{}
\quad\quad \tsvar{ps}'_{1} = \Msome  \;\tsvar{p}'_{1} \Mwedge  \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{ps}_{1},\tscon{PROTO\_TCP},\tsvar{h},\tsvar{h}.\tsvar{socks}) \Mwedge {}\\{}
\quad\quad (\Mif  \;\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}.\tsvar{bound}){}\\{}
 \Melse  \;\tsvar{is}'_{1} = * \Mwedge  \tsvar{ps}'_{1} = \tsvar{ps}_{1} \Mwedge  \tsvar{bound} = \tsvar{h}.\tsvar{bound}) \Mwedge {}\\{}
 \Mcase  \;\tsaux{test\_outroute\_ip}(\tsvar{i}_{2},\tsvar{h}.\tsvar{rttab},\tsvar{h}.\tsvar{ifds},\tsvar{h}.\tstype{arch}) \Mof {}\\{}
\quad\quad \Msome  \;\tsvar{e}   \Mtotype  \tsvar{err} = \tsvar{e}{}\\{}
 \Mdpipe   \tsunknown{\_other29} \Mtotype  \Mfalse    \Mwedge {}\\{}
 (\tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tscon{PROTO\_UDP} \implies  \neg{}\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ call is
   made. $\tsvar{fd}$ refers to a socket identified by $\tsvar{sid}$ which does not have a local IP address
   set. The \ltslink{testToutrouteTip}{$\tsaux{test\_outroute\_ip}$} function is used to check if there is a route from the host
   to $\tsvar{i}_{2}$. There is no route so the call will fail with a routing error $\tsvar{err}$. If there is no
   interface with a route to the host then on Linux the call fails with $\tscon{ENETUNREACH}$ and on
   FreeBSD and WinXP it fails with $\tscon{EHOSTUNREACH}$. If there are interfaces with a route to the
   host but none of these are up then the call fails with $\tscon{ENETDOWN}$.

   A $\MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tsvar{err}})$, where $\tsvar{err}$ is one of the above errors.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   This rule does not apply to UDP sockets on FreeBSD. Additionally, if the socket is not bound to a
   local port then it will be autobound to one and $\tsvar{sid}$ will be appended to the head of the
   host's list of bound sockets, $\tsvar{bound}$. The socket's local IP address may be set to $\Msome  \;\tsvar{i}_{1}$
   even though there is no route from $\tsvar{i}_{1}$ to $\tsvar{i}_{2}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTVb}{\rrulecc{connectTVb}{connect\_5b}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EADDRINUSE}$: address already in use }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EADDRINUSE}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{1} \Mass  \tsvar{is}'_{1}; \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}'_{1}; \tsvar{is}_{2} \Mass  \tsvar{is}'_{2}; \tsvar{ps}_{2} \Mass  \tsvar{ps}'_{2} \Mmagicrrec  )];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound}' \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{i}'_{1} \;\in  \;\tsaux{auto\_outroute}(\tsvar{i}_{2},\tsvar{sock}.\tsvar{is}_{1},\tsvar{h}.\tsvar{rttab},\tsvar{h}.\tsvar{ifds}) \Mwedge {}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{sock}.\tsvar{ps}_{1},(\tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr}),\tsvar{h},\tsvar{h}.\tsvar{socks}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{sock}.\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound}' = \tsvar{sid}\Mcons \tsvar{bound} \;\Melse  \;\tsvar{bound}' = \tsvar{bound}) \Mwedge {}\\{}
 (\tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tscon{PROTO\_UDP} \implies  \neg{}(\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \Mvee  \tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch})) \Mwedge {}\\{}
 (\exists (\tsvar{sid}',\tsunknown{s}) \Mcons  \tsvar{socks} \backslash{}\backslash{} \tsvar{sid}.{}\\{}
\quad \tsunknown{s}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}'_{1} \Mwedge  \tsunknown{s}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}'_{1} \Mwedge {}\\{}
\quad \tsunknown{s}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2}  \Mwedge  \tsunknown{s}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}  \Mwedge {}\\{}
\quad \tsaux{proto\_eq} \;\tsvar{sock}.\tsvar{pr} \;\tsunknown{s}.\tsvar{pr}) \Mwedge {}\\{}
 (\Mif  \;\tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tscon{PROTO\_UDP} \;\Mthen {}\\{}
\quad\quad \Mif  \;\tsvar{sock}.\tsvar{is}_{2} = * \;\Mthen  \;\tsvar{is}'_{1} = \tsvar{sock}.\tsvar{is}_{1} \Mwedge  \tsvar{is}'_{2} = * \Mwedge  \tsvar{ps}'_{2} = *{}\\{}
\quad\quad \Melse                     \;\tsvar{is}'_{1} = *  \Mwedge  \tsvar{is}'_{2} = * \Mwedge  \tsvar{ps}'_{2} = *{}\\{}
 \Melse  \;\tsvar{is}'_{1} = \tsvar{sock}.\tsvar{is}_{1} \Mwedge  \tsvar{is}'_{2} = \tsvar{sock}.\tsvar{is}_{2} \Mwedge  \tsvar{ps}'_{2} = \tsvar{sock}.\tsvar{ps}_{2}) }
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ call is made
   where $\tsvar{fd}$ refers to a socket $\tsvar{sock}$ identified by $\tsvar{sid}$. The socket is either bound to
   local port $\Msome  \;\tsvar{p}'_{1}$, or can be autobound to port $\Msome  \;\tsvar{p}'_{1}$. The socket either has its
   local IP address set to $\Msome  \;\tsvar{i}'_{1}$ or else its local IP address is unset but there exists an IP
   address $\tsvar{i}'_{1}$ for one of the host's interfaces which has a route to $\tsvar{i}_{2}$. There exists
   another socket $\tsunknown{s}$ in the host's finite map of sockets, identified by $\tsvar{sid}'$, that has as its
   binding quad $(\Msome  \;\tsvar{i}'_{1},\Msome  \;\tsvar{p}'_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$.

   A $\MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tscon{EADDRINUSE}})$: there is already another socket with the same local address connected to the
   peer address $(\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$. The socket's local port is set to $\Msome  \;\tsvar{p}'_{1}$; if this was
   accomplished by autobinding then $\tsvar{sid}$ is appended to the head of $\tsvar{bound}$, the host's list of
   bound sockets, to create a new list $\tsvar{bound}'$. If $\tsvar{sock}$ is a TCP socket then its $\tsvar{is}_{1}$,
   $\tsvar{is}_{2}$, and $\tsvar{ps}_{2}$ fields are unchanged. If $\tsvar{sock}$ is a UDP socket on FreeBSD then if its
   peer IP address was set, its local IP address will be unset: $\tsvar{is}'_{1}=*$, otherwise its local
   IP address will stay as it was: $\tsvar{is}'_{1}=\tsvar{sock}.\tsvar{is}_{1}$; its peer IP address and port will both be
   unset: $\tsvar{is}'_{2}=* \Mwedge  \tsvar{ps}'_{2}=*$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
   This rule does not apply to UDP sockets: Linux allows two UDP sockets to have the same binding quad.

\\\hline
WinXP
&
   This rule does not apply to UDP sockets: WinXP allows two UDP sockets to have the same binding quad.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTVc}{\rrulecc{connectTVc}{connect\_5c}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EADDRNOTAVAIL}$: no ephemeral ports left }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EADDRNOTAVAIL}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{ps}_{1} = * \Mwedge {}\\{}
 \tsaux{autobind}(*,(\tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr}),\tsvar{h},\tsvar{h}.\tsvar{socks}) = \emptyset }
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ is made. $\tsvar{fd}$
   refers to a socket identified by $\tsvar{sid}$ which is not bound to a local port. There are no
   ephemeral ports available to autobind to so the call fails with an $\tscon{EADDRNOTAVAIL}$ error.

   A $\MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tscon{EADDRNOTAVAIL}})$.

\rrulepad }
}

\newcommand{\connectTVd}{\rrulecc{connectTVd}{connect\_5d}{tcp: block}{\tsholcomm{ Block, entering state $\tscon{Connect2}$: connection attempt already in progress and connect called with blocking semantics }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Connect2}(\tsvar{sid})}{\tsaux{never\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} \Mwedge {}\\{}
 \tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) = \Mfalse  \Mwedge {}\\{}
 (\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \Mvee  \tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}\}}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ call is
   made. $\tsvar{fd}$ refers to a TCP socket identified by $\tsvar{sid}$ which is in state $\tscon{SYN\_SENT}$ or
   $\tscon{SYN\_RECEIVED}$: in other words, a connection attempt is already in progress for the socket
   (this could be an asynchronous connection attempt or one in another thread). The open file
   description referred to by $\tsvar{fd}$ does not have its $\tscon{O\_NONBLOCK}$ flag set so the call blocks,
   awaiting completion of the original connection attempt.

   A $\MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread state
   $\tscon{Connect2}(\tsvar{sid})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
   This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTVI}{\rrulecc{connectTVI}{connect\_6}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{EINVAL}$: socket has been shutdown for writing }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantsndmore} \Mass  \Mtrue ; \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsvar{tcp} \; \Mmagiclrec  \tsvar{st} \Mass  \tscon{CLOSED} \Mmagicrrec ) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantsndmore} \Mass  \Mtrue ; \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsvar{tcp} \; \Mmagiclrec  \tsvar{st} \Mass  \tscon{CLOSED} \Mmagicrrec ) \Mmagicrrec  )] \Mmagicrrec }
{\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{h}.\tsvar{files} \Mfapply{}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff})}
{\rulesubsection{Description}

     On FreeBSD, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$
     call is made. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sock}$ identified by $\tsvar{sid}$ which is in state
     $\tscon{CLOSED}$ and has been shutdown for writing.

     A $\MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tscon{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
     This rule does not apply.

\\\hline
Linux
&
     This rule does not apply.

\\\hline
WinXP
&
     This rule does not apply.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTVII}{\rrulecc{connectTVII}{connect\_7}{udp: fast succeed}{\tsholcomm{ Set peer address on socket with binding quad $*,\tsvar{ps}_{1},*,*$ }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\tsvar{ps}_{2})} }{1}}
{\tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}'_{1},\Msome  \;\tsvar{p}'_{1},\Msome  \;\tsvar{i}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore}',\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound}{}\\{}
 \Mmagicbolrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,\tsvar{ps}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))]{}\\{}
 \Mmagicbolrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{h}_{0}.\tsvar{files} \Mfapply{}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{ps}_{1},\tscon{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound}) \Mwedge {}\\{}
 \tsvar{i}'_{1} \;\in  \;\tsaux{auto\_outroute}(\tsvar{i}_{2},*,\tsvar{h}_{0}.\tsvar{rttab},\tsvar{h}_{0}.\tsvar{ifds}) \Mwedge {}\\{}
 \neg{}(\exists  (\tsvar{sid}', \tsunknown{s}) \Mcons  (\tsvar{h}_{0}.\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}).{}\\{}
\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}'_{1} \Mwedge  \tsunknown{s}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}'_{1} \Mwedge {}\\{}
\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2}  \Mwedge  \tsunknown{s}.\tsvar{ps}_{2} = \tsvar{ps}_{2} \Mwedge {}\\{}
\quad\quad\quad\quad \tsaux{proto\_of} \;\tsunknown{s}.\tsvar{pr} = \tscon{PROTO\_UDP} \Mwedge {}\\{}
\quad\quad\quad\quad \tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge {}\\{}
 (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \implies  \tsvar{ps}_{2} \neq  * \Mwedge  \tsvar{es} = *) \Mwedge {}\\{}
 (\Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{cantsndmore}' = \Mfalse {}\\{}
 \Melse                         \;\tsvar{cantsndmore}' = \tsvar{cantsndmore})}
{\rulesubsection{Description}

      Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, with no local IP or peer address
      set. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\tsvar{ps}_{2})$ call is
      made. The socket's local port is either set to $\tsvar{p}'_{1}$, or it is unset and can be autobound to
      a local ephemeral port $\tsvar{p}'_{1}$. The local IP address can be set to $\tsvar{i}'_{1}$ which is the
      primary IP address for an interface with a route to $\tsvar{i}_{2}$.

      A $\MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\tsvar{ps}_{2})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$. The socket's local address is set to $(\Msome  \;\tsvar{i}'_{1},\Msome  \;\tsvar{p}'_{1})$, and its peer address
      is set to $(\Msome  \;\tsvar{i}_{2},\tsvar{ps}_{2})$. If the socket's local port was autobound then $\tsvar{sid}$ is placed
      at the head of the host's list of bound sockets: $\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
      As above, with the additional conditions that a foreign port is specified in the $\tslib{connect}()$
      call: $\tsvar{ps}_{2} \neq  *$, and there are no pending errors on the socket. Furthermore, there may
      be no other sockets in the host's finite map of sockets with the binding quad $(\Msome  \;\tsvar{i}'_{1},\Msome
\tsvar{p}'_{1},\Msome  \;\tsvar{i}_{2},\tsvar{ps}_{2})$.

\\\hline
WinXP
&
      As above, except that the socket will not be shutdown for writing after the $\tslib{connect}()$ call
      has been made.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTVIII}{\rrulecc{connectTVIII}{connect\_8}{udp: fast succeed}{\tsholcomm{ Set peer address on socket with local address set }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i},\tsvar{ps})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i},\tsvar{ps},\tsvar{es},\tsvar{cantsndmore}',\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec }
{\tsvar{h}_{0} =  \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \implies  \tsvar{ps} \neq  * \Mwedge  \tsvar{es} = *) \Mwedge {}\\{}
 (\Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{cantsndmore}' = \Mfalse {}\\{}
 \Melse                         \;\tsvar{cantsndmore}' = \tsvar{cantsndmore}) \Mwedge {}\\{}
 \neg{}(\exists  (\tsvar{sid}',\tsunknown{s}) \Mcons  (\tsvar{h}_{0}.\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}).{}\\{}
\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsunknown{s}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge {}\\{}
\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}  \Mwedge  \tsunknown{s}.\tsvar{ps}_{2} = \tsvar{ps} \Mwedge {}\\{}
\quad\quad\quad\quad \tsaux{proto\_of} \;\tsunknown{s}.\tsvar{pr} = \tscon{PROTO\_UDP} \Mwedge {}\\{}
\quad\quad\quad\quad \tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch})}
{\rulesubsection{Description}

     Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, with local address set to $(\Msome  \;\tsvar{i}_{1},\Msome
\tsvar{p}_{1})$. Its peer address may or may not be set. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$
     state, a $\tslib{connect}(\tsvar{fd},\tsvar{i},\tsvar{ps})$ call is made.

     The call succeeds: a $\MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i},\tsvar{ps})}$ transition is made, leaving the thread
     in state $\tscon{Ret} (\tscon{OK}())$. The socket has its peer address set to $(\Msome  \;\tsvar{i},\tsvar{ps})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
     As above, with the additional conditions that a foreign port is specified in the $\tslib{connect}()$
     call, $\tsvar{ps} \neq  *$, and there are no pending errors on the socket. Furthermore, there may be
     no other sockets in the host's finite map of sockets with the binding quad $(\Msome  \;\tsvar{i}'_{1},\Msome
\tsunknown{p1'},\Msome  \;\tsvar{i},\tsvar{ps})$.

\\\hline
WinXP
&
     As above, with the additional effect that if the socket was shutdown for writing when the
     $\tslib{connect}()$ call was made, it will no longer be shutdown for writing.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTIX}{\rrulecc{connectTIX}{connect\_9}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{EADDRNOTAVAIL}$: port must be specified in $\tslib{connect}()$ call on FreeBSD }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i},*)} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EADDRNOTAVAIL}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{1} \Mass  \tsvar{is}_{1}; \tsvar{is}_{2} \Mass  *; \tsvar{ps}_{2} \Mass  *; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec  )] \Mmagicrrec }
{\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{sock}.\tsvar{is}_{2} \neq  * \;\Mthen  \;\tsvar{is}_{1} = * \;\Melse  \;\tsvar{is}_{1} = \tsvar{sock}.\tsvar{is}_{1})}
{\rulesubsection{Description}

    On FreeBSD, consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in
    the $\tscon{Run}$ state, a $\tslib{connect}(\tsvar{fd},\tsvar{i},*)$ call is made. Because no port is specified, the call
    fails with an $\tscon{EADDRNOTAVAIL}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i},*)}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tscon{EADDRNOTAVAIL}})$. The socket's peer address is cleared: $\tsvar{is}_{2} \Mass  *$ and $\tsvar{ps}_{2} \Mass
*$. Additionally, if the socket had its peer IP address set, $\tsvar{sock}.\tsvar{is}_{2} \neq  *$, then its
    local IP address will be cleared: $\tsvar{is}_{1} = *$; otherwise it remains the same: $\tsvar{is}_{1} =
\tsvar{sock}.\tsvar{is}_{1}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.

\\\hline
WinXP
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\connectTX}{\rrulecc{connectTX}{connect\_10}{udp: fast fail}{\tsholcomm{ Fail with pending error on FreeBSD, but still set peer address }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i},\tsvar{ps})} }{1}}
{\tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i}; \tsvar{ps}_{2} \Mass  \tsvar{ps}; \tsvar{es} \Mass  *; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec }
{\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{h}_{0} =  \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsvar{err}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{ps} \neq  * \Mwedge {}\\{}
 \neg{}(\exists (\tsvar{sid}',\tsunknown{s}) \Mcons  (\tsvar{h}_{0}.\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}).{}\\{}
\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{1} = \tsvar{sock}.\tsvar{is}_{1} \Mwedge  \tsunknown{s}.\tsvar{ps}_{1} = \tsvar{sock}.\tsvar{ps}_{1} \Mwedge {}\\{}
\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}  \Mwedge  \tsunknown{s}.\tsvar{ps}_{2} = \tsvar{ps} \Mwedge {}\\{}
\quad\quad\quad\quad \tsaux{proto\_of} \;\tsunknown{s}.\tsvar{pr} = \tscon{PROTO\_UDP})}
{\rulesubsection{Description}

     On FreeBSD, consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, with pending error
     $\tsvar{err}$. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{connect}(\tsvar{fd},\tsvar{i},\tsvar{ps})$ call is
     made with $\tsvar{ps} \neq  *$. There is no other UDP socket on the host which has the same local
     address $\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{ps}_{1}$ as $\tsvar{sid}$, and its peer address set to $\Msome  \;\tsvar{i}, \tsvar{ps}$. The call
     fails, returning the pending error $\tsvar{err}$.

     A $\MLhcall{\tsvar{tid}}{\tslib{connect}(\tsvar{fd},\tsvar{i},\tsvar{ps})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$. The socket's peer address is set to $(\Msome  \;\tsvar{i},\tsvar{ps})$, and the error is cleared from the
     socket.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
     This rule does not apply.

\\\hline
WinXP
&
     This rule does not apply.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommdisconnect}{\clustersection{(TCP and UDP)}{$\tslib{disconnect}()$}
\seccomm{  \[ \tslib{disconnect}: \tstype{fd} \Mtotype  \tstype{unit} \]

   A call to $\tslib{disconnect}(\tstype{fd})$, where $\tstype{fd}$ is a file descriptor referring to a socket, removes
   the peer address for a UDP socket. If a UDP socket has peer address set to $(\Msome  \;\tsvar{i}_{2}, \Msome  \;\tsvar{p}_{2})$
   then it can only receive datagrams with source address $(\tsvar{i}_{2},\tsvar{p}_{2})$. Calling $\tslib{disconnect}()$ on
   the socket resets its peer address to $(*,*)$, and so it will be able to receive
   datagrams with any source address.

   It does not make sense to disconnect a TCP socket in this way.  Most supported architectures
   simply disallow $\tslib{disconnect}$ on such a socket; however, Linux implements it as an abortive
   close (see \ltslink{closeTIII}{$\tsrule{close\_3}$}).

}\clustersubsection{Errors}
\seccomm{
   A call to $\tslib{disconnect}()$ can fail with the errors below, in which case the corresponding
   exception is raised:

\par\begin{ltstabular}
$\tscon{EADDRNOTAVAIL}$
&  There are no ephemeral ports left for autobinding to.

\\\hline
$\tscon{EAFNOSUPPORT}$
&  The address family \wasverb{AF\textunderscore{}UNSPEC} is not supported. This can be the
   result for a successful $\tslib{disconnect}()$ for a UDP socket.

\\\hline
$\tscon{EAGAIN}$
&  There are no ephemeral ports left for autobinding to.

\\\hline
$\tscon{EALREADY}$
&  A connection is already in progress.

\\\hline
$\tscon{EBADF}$
&  The file descriptor $\tstype{fd}$ is an invalid file descriptor.

\\\hline
$\tscon{EISCONN}$
&  The socket is already connected.

\\\hline
$\tscon{ENOBUFS}$
&  No buffer space is available.

\\\hline
$\tscon{EOPNOTSUPP}$
&  The socket is listening and cannot be connected.

\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
   $\tsrule{disconnect\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tslib{disconnect}()$ is a Posix $\tslib{connect}()$ call with the address family set to
  \wasverb{AF\textunderscore{}UNSPEC}.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int connect(int socket, const struct sockaddr *address,}\\
             & \wasverb{            socklen\textunderscore{}t address\textunderscore{}len);} \\
    FreeBSD: & \wasverb{int connect(int s, const struct sockaddr *name, }\\
             & \wasverb{            socklen\textunderscore{}t namelen);} \\
    Linux:   & \wasverb{int connect(int  sockfd,  const  struct sockaddr *serv\textunderscore{}addr,}\\
               \wasverb{            socklen\textunderscore{}t addrlen);} \\
    WinXP:   & \wasverb{int connect(SOCKET s, const struct sockaddr* name,} \\
             & \wasverb{            int namelen);}\\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

  \item \wasverb{socket} is a file descriptor referring to a socket. This corresponds to the $\tstype{fd}$
   argument of the model $\tslib{disconnect}()$.

  \item \wasverb{address} is a pointer to a location of size \wasverb{address\textunderscore{}len} containing a
   \wasverb{sockaddr} structure which specifies the address to connect to. For a $\tslib{disconnect}()$
   call, the \wasverb{sin\textunderscore{}family} field of the \wasverb{sockaddr} family must be set to
   \wasverb{AF\textunderscore{}UNSPEC}; other fields can be set to anything.

  \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
   indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
   indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
   code available through a call to \wasverb{WSAGetLastError()}.

   \end{itemize}

  The Linux man-page states: "Unconnecting a socket by calling connect with a AF\_UNSPEC address is
  not yet implemented." As a result, a $\tslib{disconnect}()$ call always returns successfully on Linux.

  The WinXP documentation states: "The default destination can be changed by simply calling
  \wasverb{connect} again, even if the socket is already connected. Any datagrams queued for receipt
  are discarded if \wasverb{name} is different from the previous \wasverb{connect}." This implies
  that calling $\tslib{disconnect}()$ will result in all datagrams on the socket's receive queue; however,
  this is not the case: no datagrams are discarded.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{disconnect\_4}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{EAFNOSUPPORT}$: address family not supported; $\tscon{EOPNOTSUPP}$: operation not supported; $\tscon{EALREADY}$: connection already in progress; or $\tscon{EISCONN}$: socket already connected \\
$\tsrule{disconnect\_5}$
& \textbf{tcp: fast fail}
&  Succeed on Linux, possibly dropping the connection \\
$\tsrule{disconnect\_1}$
& \textbf{udp: fast succeed}
&  Unset socket's peer address \\
$\tsrule{disconnect\_2}$
& \textbf{udp: fast succeed}
&  Unset socket's peer address and autobind local port \\
$\tsrule{disconnect\_3}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{EAGAIN}$, $\tscon{EADDRNOTAVAIL}$, or $\tscon{ENOBUFS}$: there are no ephemeral ports left \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\disconnectTIV}{\rrulecc{disconnectTIV}{disconnect\_4}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{EAFNOSUPPORT}$: address family not supported; $\tscon{EOPNOTSUPP}$: operation not supported; $\tscon{EALREADY}$: connection already in progress; or $\tscon{EISCONN}$: socket already connected }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{disconnect}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} \Mwedge {}\\{}
 \neg{}(\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge {}\\{}
 \Mcase  \;\tsunknown{tcp\_sock}.\tsvar{st} \;\Mof {}\\{}
\quad\quad \tscon{CLOSED}      \Mtotype  \Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mif  \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{bsd\_cantconnect} = \Mtrue  \;\Mthen  \;\tsvar{err} = \tscon{EINVAL}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse   \;\tsvar{err} = \tscon{EAFNOSUPPORT}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsvar{err} = \tscon{EAFNOSUPPORT} \Mdpipe {}\\{}
\quad\quad \tscon{LISTEN}      \Mtotype  \Mif       \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{err} = \tscon{EAFNOSUPPORT}  \tsholcomm{ socket is listening }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsaux{bsd\_arch}     \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{err} = \tscon{EOPNOTSUPP}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsaux{ASSERTION\_FAILURE} \text{``disconnect\textunderscore{}4:1''} \Mdpipe  \tsholcomm{ never happen }{}\\{}
\quad\quad \tscon{SYN\_SENT}    \Mtotype  \tsvar{err} = \tscon{EALREADY} \Mdpipe  \tsholcomm{ connection already in progress }{}\\{}
\quad\quad \tscon{SYN\_RECEIVED} \Mtotype  \tsvar{err} = \tscon{EALREADY} \Mdpipe  \tsholcomm{ connection already in progress }{}\\{}
\quad\quad \tscon{ESTABLISHED}  \Mtotype  \tsvar{err} = \tscon{EISCONN} \Mdpipe   \tsholcomm{ socket already connected }{}\\{}
\quad\quad \tscon{TIME\_WAIT}    \Mtotype  \Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{err} = \tscon{EISCONN}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{err} = \tscon{EAFNOSUPPORT}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsaux{ASSERTION\_FAILURE} \text{``disconnect\textunderscore{}4:2''} \Mdpipe  \tsholcomm{ never happen }{}\\{}
\quad\quad \tsunknown{\_1}           \Mtotype  \tsvar{err} = \tscon{EISCONN} \tsholcomm{ all other states }}
{\rulesubsection{Description}

    Consider a TCP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ on a non-Linux architecture. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$
    state, a $\tslib{disconnect}(\tsvar{fd})$ call is made. The call fails with an error $\tsvar{err}$ which depends on
    the the state of the socket: If the socket is in the $\tscon{CLOSED}$ state then it fails with
    $\tscon{EAFNOSUPPORT}$, except if on FreeBSD its $\tsfield{bsd\_cantconnect}$ flag is set, in which case it
    fails with $\tscon{EINVAL}$;if it is in the $\tscon{LISTEN}$ state the error is $\tscon{EAFNOSUPPORT}$ on WinXP
    and $\tscon{EOPNOTSUPP}$ on FreeBSD; if it is in the $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$ state the error
    is $\tscon{EALREADY}$; if it is in the $\tscon{ESTABLISHED}$ state the error is $\tscon{EISCONN}$; if it is in the
    $\tscon{TIME\_WAIT}$ state the error is $\tscon{EISCONN}$ on WinXP and $\tscon{EAFNOSUPPORT}$ on FreeBSD; in all
    other states the error is $\tscon{EISCONN}$.

    A $\MLhcall{\tsvar{tid}}{\tslib{disconnect}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$ where $\tsvar{err}$ is one of the above errors.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\disconnectTV}{\rrulecc{disconnectTV}{disconnect\_5}{tcp: fast fail}{\tsholcomm{ Succeed on Linux, possibly dropping the connection }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid}, \tsvar{sock})];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}  \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{disconnect}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK}())}{ \tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid}, \tsvar{sock}')];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = \tsvar{sock}.\tsvar{pr} \Mwedge {}\\{}
 (\Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{SYN\_RECEIVED}; \tscon{ESTABLISHED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}; \tscon{CLOSE\_WAIT}\} \Mthen {}\\{}
\quad \tsaux{tcp\_drop\_and\_close} \;\tsvar{h}.\tstype{arch} \;* \;\tsvar{sock} (\tsvar{sock}',\tsvar{outsegs}) \Mwedge {}\\{}
\quad \tsaux{enqueue\_and\_ignore\_fail} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{outsegs} \;\tsvar{oq} \;\tsvar{oq}'{}\\{}
 \Melse {}\\{}
\quad \tsvar{sock} = \tsvar{sock}' \Mwedge {}\\{}
\quad \tsvar{oq} = \tsvar{oq}')}
{\rulesubsection{Description}

    On Linux, consider a TCP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in
    the $\tscon{Run}$ state, a $\tslib{disconnect}(\tsvar{fd})$ call is made and succeeds.

    A $\MLhcall{\tsvar{tid}}{\tslib{disconnect}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$. If the socket is in the $\tscon{SYN\_RECEIVED}$, $\tscon{ESTABLISHED}$, $\tscon{FIN\_WAIT\_1}$,
    $\tscon{FIN\_WAIT\_2}$, or $\tscon{CLOSE\_WAIT}$ state then the connection is dropped, a RST segment is
    constructed, $\tsvar{outsegs}$, which may be placed on the host's outqueue, $\tsvar{oq}$, resulting in new
    outqueue $\tsvar{oq}'$. If the socket is in any other state then it remains unchanged, as does the
    host's outqueue.

\rulesubsection{Model details}

    Note that $\tslib{disconnect}()$ has not been properly implemented on Linux yet so it will always succeed.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    This rule does not apply.

\\\hline
FreeBSD
&
    This rule does not apply.

\\\hline
WinXP
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\disconnectTI}{\rrulecc{disconnectTI}{disconnect\_1}{udp: fast succeed}{\tsholcomm{ Unset socket's peer address }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsunknown{ts\_}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid}, \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))]{}\\{}
 \Mmagicbolrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{disconnect}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsunknown{ts\_}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tsvar{ret})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid}, \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,\Msome  \;\tsvar{p}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))]{}\\{}
 \Mmagicbolrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\Mif  \;\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{ret} = \tscon{OK}(){}\\{}
 \Melse  \;\Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \exists \tsvar{i}'_{2}.\tsvar{is}_{2}=\Msome  \;\tsvar{i}'_{2} \;\Mthen  \;\tsvar{ret} = \tscon{OK}(){}\\{}
 \Melse                       \;\tsvar{ret} = \tscon{FAIL}\;{\tscon{EAFNOSUPPORT}})}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ with $(\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2})$ as its binding
    quad. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{disconnect}(\tsvar{fd})$ call is made. On
    Linux the call succeeds; on WinXP if the socket had its peer IP address set then the call
    succeeds, otherwise it fails with an $\tscon{EAFNOSUPPORT}$ error; on FreeBSD the call fails with an
    $\tscon{EAFNOSUPPORT}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{disconnect}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}())$
    or $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EAFNOSUPPORT}})$. The socket has its peer address set to $(*,*)$, and its
    local IP address set to $*$. The local port, $\tsvar{p}_{1}$, is left in place.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    As above: the call fails with an $\tscon{EAFNOSUPPORT}$ error.

\\\hline
Linux
&
    As above: the call succeeds.

\\\hline
WinXP
&
    As above: the call succeeds if the socket had a peer IP address set, or fails with an
    $\tscon{EAFNOSUPPORT}$ error otherwise.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\disconnectTII}{\rrulecc{disconnectTII}{disconnect\_2}{udp: fast succeed}{\tsholcomm{ Unset socket's peer address and autobind local port }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{disconnect} \;\tsvar{fd}} }{1}}
{\tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsunknown{ts\_}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tsvar{ret})}{ \tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid}, \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,\tsvar{ps}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))];{}\\{}
 \tsvar{bound} \Mass  \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsunknown{ts\_}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid}, \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,*,*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsvar{ps}_{1} = * \Mvee  (\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge  \tsvar{p}_{1} \;\in  \;\tsaux{autobind}(*,\tscon{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}))) \Mwedge {}\\{}
 (\Mif  \;\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{ret} = \tscon{OK}(){}\\{}
 \Melse                       \;\tsvar{ret} = (\tscon{FAIL}\;{\tscon{EAFNOSUPPORT}}))}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ and with binding quad
    $(*,*,*,*)$. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a
    $\tslib{disconnect}(\tsvar{fd})$ call is made. The call succeeds on Linux and fails with an $\tscon{EAFNOSUPPORT}$
    error on FreeBSD and WinXP.

    A $\MLhcall{\tsvar{tid}}{\tslib{disconnect}(\tsvar{fd})}$ transition is made, leaving the thread either in state $\tscon{Ret}
(\tscon{OK}())$, or in state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EAFNOSUPPORT}})$. The socket is autobound to a local ephemeral
    port $\tsunknown{p1'}$, and $\tsvar{sid}$ is placed on the head of the host's list of bound sockets.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    As above: the call fails with an $\tscon{EAFNOSUPPORT}$ error.

\\\hline
Linux
&
    As above: the call succeeds.

\\\hline
WinXP
&
    As above: the call fails with an $\tscon{EAFNOSUPPORT}$ error.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\disconnectTIII}{\rrulecc{disconnectTIII}{disconnect\_3}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{EAGAIN}$, $\tscon{EADDRNOTAVAIL}$, or $\tscon{ENOBUFS}$: there are no ephemeral ports left }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{disconnect} \;\tsvar{fd}} }{1}}
{\tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,*,*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsaux{autobind}(*,\tscon{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) = \emptyset  \Mwedge {}\\{}
 \tsvar{e} \;\in  \{\tscon{EAGAIN}; \tscon{EADDRNOTAVAIL}; \tscon{ENOBUFS}\}}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ and with binding quad
    $*,*,*,*$. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a
    $\tslib{disconnect}(\tsvar{fd})$ call is made. There are no ephemeral ports left, so the socket cannot be
    autobound to a local port. The call fails with an error: $\tscon{EAGAIN}$, $\tscon{EADDRNOTAVAIL}$, or
    $\tscon{ENOBUFS}$.

    A $\MLhcall{\tsvar{tid}}{\tslib{disconnect}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$ where $\tsvar{e}$ is one of the above errors.

\rrulepad }
}

\newcommand{\seccommdup}{\clustersection{(TCP and UDP)}{$\tslib{dup}()$}
\seccomm{  \[ \tslib{dup}: \tstype{fd} \Mtotype  \tstype{fd} \]

  A call to $\tslib{dup}(\tstype{fd})$ creates and returns a new file descriptor referring to the open file
  description referred to by the file descriptor $\tstype{fd}$.
  A successful $\tslib{dup}()$ call will return the least numbered free file descriptor. The call will
  only fail if there are no more free file descriptors, or $\tstype{fd}$ is not a valid file descriptor.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{dup}()$ can fail with the errors below, in which case the corresponding exception is
  raised:

\par\begin{ltstabular}
$\tscon{EMFILE}$
&  There are no more file descriptors available.
\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsrule{dup\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:   & \wasverb{int dup(int fildes);} \\
    FreeBSD: & \wasverb{int dup(int oldd);} \\
    Linux:   & \wasverb{int dup(int oldfd);} \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}
    \item \wasverb{fildes} is a file descriptor referring to the open file description for which
     another file descriptor is to be created for. This corresponds to the $\tstype{fd}$ argument of the
     model $\tslib{dup}()$.

    \item The returned \wasverb{int} is either non-negative to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}. If the call is
     successful then the returned \wasverb{int} is the new file descriptor corresponding to the
     $\tstype{fd}$ return type of the model $\tslib{dup}()$.

  \end{itemize}

  The FreeBSD and Linux interfaces are similar. This call does not exist on WinXP.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{dup\_1}$
& \textbf{all: fast succeed}
&  Successfully duplicate file descriptor \\
$\tsrule{dup\_2}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EMFILE}$: no more file descriptors available \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\dupTI}{\rrulecc{dupTI}{dup\_1}{all: fast succeed}{\tsholcomm{ Successfully duplicate file descriptor }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{dup}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} \;\tsvar{fd}')}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}' \Mmagicrrec }
{\tsaux{unix\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsaux{nextfd} \;\tsvar{h}.\tstype{arch} \;\tsvar{fds} \;\tsvar{fd}' \Mwedge {}\\{}
 \tsvar{fd}' < \tsaux{OPEN\_MAX\_FD} \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \oplus  (\tsvar{fd}', \tsvar{fid})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{dup}(\tsvar{fd})$ call is made where $\tsvar{fd}$ is a
   file descriptor referring to an open file description identified by $\tsvar{fid}$. A new file
   descriptor, $\tsvar{fd}'$ can be created in an architecture-specific way according to the \ltslink{nextfd}{$\tsaux{nextfd}$}
   function. $\tsvar{fd}'$ is less than the maximum open file descriptor, $\tsaux{OPEN\_MAX\_FD}$. The call
   succeeds returning $\tsvar{fd}'$.

   A $\MLhcall{\tsvar{tid}}{\tslib{dup}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK} \;\tsvar{fd}')$. The
   host's finite map of file descriptors, $\tsvar{fds}$, is extended to map the new file descriptor
   $\tsvar{fd}'$ to the file identifier $\tsvar{fid}$, which results in a new finite map of file descriptors
   $\tsvar{fds}'$ for the host.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
   This rule does not apply: there is no $\tslib{dup}()$ call on WinXP.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\dupTII}{\rrulecc{dupTII}{dup\_2}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EMFILE}$: no more file descriptors available }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{dup}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EMFILE}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsaux{unix\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 (\tsholop{CARD} (\Mfdom{\tsvar{h}.\tsvar{fds}}) + 1) \geq  \tsaux{OPEN\_MAX}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{dup}(\tsvar{fd})$ call is made where $\tsvar{fd}$ is
    a valid file descriptor: it has an entry in the host's finite map of file descriptors,
    $\tsvar{h}.\tsvar{fds}$. Creating another file descriptor would cause the number of open file descriptors to
    be greater than or equal to the maximum number of open file descriptors, $\tsaux{OPEN\_MAX}$. The call
    fails with an $\tscon{EMFILE}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{dup}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EMFILE}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    This rule does not apply: there is no $\tslib{dup}()$ call on WinXP.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommdupfd}{\clustersection{(TCP and UDP)}{$\tslib{dupfd}()$}
\seccomm{  \[ \tslib{dupfd}: \tstype{fd} * \tstype{int} \Mtotype  \tstype{fd} \]

  A call to $\tslib{dupfd}(\tstype{fd},\tsvar{n})$ creates and returns a new file desciptor referring to the open file
  description referred to by the file descriptor $\tstype{fd}$.

  A successful $\tslib{dupfd}()$ call will return the least free file descriptor greater than or equal to
  $\tsvar{n}$. The call will fail if $\tsvar{n}$ is negative or greater than the maximum allowed file
  descriptor, $\tsaux{OPEN\_MAX}$; if the file descriptor $\tstype{fd}$ is not a valid file descriptor; or if
  there are no more file descriptors available.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{dupfd}()$ can fail with the errors below, in which case the corresponding exception is
  raised:

\par\begin{ltstabular}
$\tscon{EINVAL}$
&  The requested file descriptor is invalid: it is negative or greater than the maximum allowed.

\\\hline
$\tscon{EMFILE}$
&  There are no more file descriptors available.

\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsrule{dupfd\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tslib{dupfd}()$ is Posix $\tsunknown{fcntl}()$ using the \wasverb{F\textunderscore{}DUPFD} command:

  \begin{tabular}{ll}
  Posix:   & \wasverb{int fcntl(int fildes, int cmd, int arg);} \\
  FreeBSD: & \wasverb{int fcntl(int fd, int cmd, int arg);} \\
  Linux:   & \wasverb{int fcntl(int fd, int cmd, long arg);} \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}
    \item \wasverb{fildes} is a file descriptor referring to the open file description for which
     another file descriptor is to be created for. This corresponds to the $\tstype{fd}$ argument of the
     model $\tslib{dupfd}()$.

    \item \wasverb{cmd} is the command to run on the specified file descriptor. For the model
     $\tslib{dupfd}()$ this command is set to \wasverb{F\textunderscore{}DUPFD}.

    \item The returned \wasverb{int} is either non-negative to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}. If the call was
     successful then the returned \wasverb{int} is the new file descriptor.
  \end{itemize}

  The FreeBSD and Linux interfaces are similar. This call does not exist on WinXP.

}\clustersubsection{Model details}
\seccomm{
  Note that $\tslib{dupfd}()$ is \wasverb{fcntl()} with \wasverb{F\textunderscore{}DUPFD} rather than the similar but
  different \wasverb{dup2()}.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{dupfd\_1}$
& \textbf{all: fast succeed}
&  Successfully create a duplicate file descriptor greater than or equal to $\tsvar{n}$ \\
$\tsrule{dupfd\_3}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EINVAL}$: $\tsvar{n}$ is negative or greater than the maximum allowed file descriptor \\
$\tsrule{dupfd\_4}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EMFILE}$: no more file descriptors available \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\dupfdTI}{\rrulecc{dupfdTI}{dupfd\_1}{all: fast succeed}{\tsholcomm{ Successfully create a duplicate file descriptor greater than or equal to $\tsvar{n}$ }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{dupfd}(\tsvar{fd},\tsvar{n})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} \;\tsvar{fd}')}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}' \Mmagicrrec }
{\tsaux{unix\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{n} \geq  0 \Mwedge {}\\{}
 \tscon{FD} (\tsholop{Num} \;\tsvar{n}) < \tsaux{OPEN\_MAX\_FD} \Mwedge   {}\\{}
 {}\\{}
 \tsvar{fd}' = \tscon{FD} (\tsholop{LEAST} \;\tsvar{n}'. \tsholop{Num} \;\tsvar{n} \leq  \tsvar{n}' \Mwedge  \tscon{FD} \;\tsvar{n}' < \tsaux{OPEN\_MAX\_FD} \Mwedge  \tscon{FD} \;\tsvar{n}' \;\notin  \Mfdom{\tsvar{fds}}) \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \oplus  (\tsvar{fd}', \tsvar{fid})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{dupfd}(\tsvar{fd},\tsvar{n})$ call is made. The host's
   finite map of file descriptors is $\tsvar{fds}$, and $\tsvar{fd}$ is a valid file descriptor in $\tsvar{fds}$,
   referring to an open file description identified by $\tsvar{fid}$. $\tsvar{n}$ is non-negative. A file
   descriptor $\tsvar{fd}'$ can be created, where it is the least free file descriptor greater than or
   equal to $\tsvar{n}$, and less than the maximum allowed file descriptor, $\tsaux{OPEN\_MAX\_FD}$. The call
   succeeds, returning this new file descriptor $\tsvar{fd}'$.

   A $\MLhcall{\tsvar{tid}}{\tslib{dupfd}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}
\tsvar{fd}')$. An entry mapping $\tsvar{fd}'$ to the open file description $\tsvar{fid}$ is added to $\tsvar{fds}$,
   resulting in a new finite map of file descriptors for the host, $\tsvar{fds}'$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
   This rule does not apply: there is no $\tslib{dupfd}()$ call on WinXP.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\dupfdTIII}{\rrulecc{dupfdTIII}{dupfd\_3}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EINVAL}$: $\tsvar{n}$ is negative or greater than the maximum allowed file descriptor }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{dupfd}(\tsvar{fd},\tsvar{n})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsaux{unix\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{n} < 0 \Mvee  \tsholop{Num} \;\tsvar{n} \geq  \tsaux{OPEN\_MAX} \Mwedge {}\\{}
 \tsvar{err} = (\Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tscon{EBADF} \;\Melse  \;\tscon{EINVAL})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{dupfd}(\tsvar{fd},\tsvar{n})$ call is made. $\tsvar{n}$ is
   either negative or greater than the maximum number of open file descriptors, $\tsaux{OPEN\_MAX}$. The
   call fails with an $\tscon{EINVAL}$ error.

   A $\MLhcall{\tsvar{tid}}{\tslib{dupfd}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
   This call does not apply: there is no $\tslib{dupfd}()$ call on WinXP.

\\\hline
FreeBSD
&
   On BSD the error $\tscon{EBADF}$ is returned.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\dupfdTIV}{\rrulecc{dupfdTIV}{dupfd\_4}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EMFILE}$: no more file descriptors available }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{dupfd}(\tsvar{fd},\tsvar{n})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EMFILE}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsaux{unix\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{n} \geq  0 \Mwedge {}\\{}
 {}\\{}
 \tsvar{fd}' = \tscon{FD} (\tsholop{LEAST} \;\tsvar{n}'. \tsholop{Num} \;\tsvar{n} \leq  \tsvar{n}' \Mwedge  \tsaux{OPEN\_MAX\_FD} \leq  \tscon{FD} \;\tsvar{n}' \Mwedge  \tscon{FD} \;\tsvar{n}' \;\notin  \Mfdom{\tsvar{h}.\tsvar{fds}})}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{dupfd}(\tsvar{fd},\tsvar{n})$ call is made. $\tsvar{fd}$ is a
   file descriptor referring to open file description $\tsvar{fid}$ and $\tsvar{n}$ is non-negative. The least
   file descriptor $\tsvar{fd}'$ that is greater than or equal to $\tsvar{n}$ is greater than or equal to the
   maximum open file descriptor, $\tsaux{OPEN\_MAX\_FD}$. The call fails with an $\tscon{EMFILE}$ error.

   A $\MLhcall{\tsvar{tid}}{\tslib{dupfd}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EMFILE}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
   This rule does not apply: there is no $\tslib{dupfd}()$ call on WinXP.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommgetfileflags}{\clustersection{(TCP and UDP)}{$\tslib{getfileflags}()$}
\seccomm{ \[ \tslib{getfileflags}: \tstype{fd} \Mtotype  \tstype{filebflag} \;\tstype{list} \]

   A call to $\tslib{getfileflags}(\tstype{fd})$ returns a list of the file flags currently set for the file which
   $\tstype{fd}$ refers to.

   The possible file flags are:
   \begin{itemize}
     \item $\tscon{O\_ASYNC}$ Reports whether signal driven I/O is enabled.
     \item $\tscon{O\_NONBLOCK}$ Reports whether a socket is non-blocking.
   \end{itemize}

}\clustersubsection{Errors}
\seccomm{
   A call to $\tslib{getfileflags}()$ can fail with the error below, in which case the corresponding
   exception is raised:

\par\begin{ltstabular}
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  A call to $\tslib{getfileflags}()$ is made, returning the flags set: $\tsrule{getfileflags\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tslib{getfileflags}()$ is Posix \wasverb{fcntl(fd,F\textunderscore{}GETFL)}. On WinXP it is \wasverb{ioctlsocket()}
  with the \wasverb{FIONBIO} command.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int fcntl(int fildes, int cmd, ...);}\\
    FreeBSD: & \wasverb{int fcntl(int fd, int cmd, ...);}\\
    Linux:   & \wasverb{int fcntl(int fd, int cmd);}\\
    WinXP:   & \wasverb{int ioctlsocket(SOCKET s, long cmd, u\textunderscore{}long* argp)}
  \end{tabular}

   In the Posix interface:

   \begin{itemize}
     \item \wasverb{fildes} is a file descriptor for the file to retrieve flags from. It corresponds
      to the $\tstype{fd}$ argument of the model $\tslib{getfileflags}()$. On WinXP the \wasverb{s} is a socket
      descriptor corresponding to the $\tstype{fd}$ argument of the model $\tslib{getfileflags}()$.

     \item \wasverb{cmd} is a command to perform an operation on the file. This is set to
      \wasverb{F\textunderscore{}GETFL} for the model $\tslib{getfileflags}()$. On WinXP, \wasverb{cmd} is set to
      \wasverb{FIONBIO} to get the $\tscon{O\_NONBLOCK}$ flag; there is no $\tscon{O\_ASYNC}$ flag on WinXP.

     \item The call takes a variable number of arguments. For the model $\tslib{getfileflags}()$ only the
      two arguments described above are needed.

     \item If the call succeeds the returned \wasverb{int} represents the file flags that are set
      corresponding to the $\tstype{filebflag} \;\tstype{list}$ return type of the model $\tslib{getfileflags}()$. If the
      returned \wasverb{int} is \wasverb{-1} then an error has occurred in which case the error code
      is in \wasverb{errno}. On WinXP an error is indicated by a return value of
      \wasverb{SOCKET\textunderscore{}ERROR} with the actual error code available through a call to
      \wasverb{WSAGetLastError()}.
   \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}
    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

    \item \wasverb{WSAENOTSOCK} is a possible error on WinXP as the \wasverb{ioctlsocket()} call is
     specific to a socket. In the model the $\tslib{getfileflags}()$ call is performed on a file.
  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getfileflags\_1}$
& \textbf{all: fast succeed}
&  Return list of file flags currently set for an open file description \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getfileflagsTI}{\rrulecc{getfileflagsTI}{getfileflags\_1}{all: fast succeed}{\tsholcomm{ Return list of file flags currently set for an open file description }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getfileflags}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} \;\tsvar{flags})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsvar{ft},\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{flags} \;\in  \;\tsaux{ORDERINGS} \;\tsvar{ff}.\tsvar{b}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{getfileflags}(\tsvar{fd})$ call is made. $\tsvar{fd}$
    refers to a file description $\tscon{File}(\tsvar{ft},\tsvar{ff})$ where $\tsvar{ff}$ is the file flags that are set. The
    call succeeds, returning $\tsvar{flags}$ which is a list representing some ordering of the boolean
    file flags $\tsvar{ff}.\tsvar{b}$ in $\tsvar{ff}$.

    A $\MLhcall{\tsvar{tid}}{\tslib{getfileflags}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}(\tsvar{flags}))$.

\rrulepad }
}

\newcommand{\seccommgetifaddrs}{\clustersection{(TCP and UDP)}{$\tslib{getifaddrs}()$}
\seccomm{ \[ \tslib{getifaddrs}: \tstype{unit} \Mtotype  (\tsvar{ifid} * \tstype{ip} * \tstype{ip} \;\tstype{list} * \tsvar{netmask}) \tstype{list} \]

  A call to $\tslib{getifaddrs}()$ returns the interface information for a host. For each interface a
  tuple is constructed consisting of: the interface name, the primary IP address for the interface,
  the auxiliary IP addresses for the interface, and the subnet mask for the interface. A list is
  constructed with one tuple for each interface, and this is the return value of the call to
  $\tslib{getifaddrs}()$.

}\clustersubsection{Errors}
\seccomm{\par\begin{ltstabular}
$\tscon{EINTR}$
&  The system was interrupted by a caught signal.

\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsrule{getifaddrs\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tslib{getifaddrs}()$ is two calls to Posix \wasverb{ioctl()}: one with the \wasverb{SIOCGIFCONF}
  request and one with the \wasverb{SIOCGIFNETMASK} request. On FreeBSD there is a specific
  \wasverb{getifaddrs()} call. On WinXP the $\tslib{getifaddrs}()$ call does not exist.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int ioctl(int fildes, int request, ... /* arg */);} \\
    FreeBSD: & \wasverb{int getifaddrs(struct ifaddrs **ifap);} \\
    Linux:   & \wasverb{int ioctl(int d, int request, ...);}
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{fildes} is a file descriptor. There is no corresponding argument in the model
     $\tslib{getifaddrs}()$.

    \item \wasverb{request} is the operation to perform on the file. When \wasverb{request} is
     \wasverb{SIOCGIFCONF} the list of all interfaces is returned; when it is \wasverb{SIOCNETMASK}
     the subnet mask is returned for an interface.

    \item The function takes a variable number of arguments. When \wasverb{request} is
     \wasverb{SIOCGIFCONF} there is a third argument: a pointer to a location to store a linked-list
     of the interfaces; when it is \wasverb{SIOCGIFNETMASK} it is a pointer to a structure
     containing the interface and it is filled in with the subnet mask for that interface.

    \item The returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.

  \end{itemize}

  To construct the return value of type $(\tsvar{ifid} * \tstype{ip} * \tstype{ip} \;\tstype{list} * \tsvar{netmask}) \tstype{list}$, the interface name
  and the IP addresses associated with it are obtained from the call to \wasverb{ioctl()} using
  \wasverb{SIOCGIFCONF}, and then the subnet mask for each interface is obtained from a call to
  \wasverb{ioctl()} using \wasverb{SIOCGIFNETMASK}.

  On FreeBSD the \wasverb{ifap} argument to \wasverb{getifaddrs()} is a pointer to a location to store
  a linked list of the interface information in, corresponding to the return type of the model
  $\tslib{getifaddrs}()$.

}\clustersubsection{Model details}
\seccomm{
  Any of the errors possible when making an \wasverb{ioctl()} call are possible: $\tscon{EIO}$, $\tscon{ENOTTY}$,
  $\tscon{ENXIO}$, and $\tscon{ENODEV}$. None of these are modelled.

  Note that the Posix interface admits the possibility that the interfaces will change between the
  two calls, whereas in the model interface the $\tslib{getifaddrs}()$ call is atomic.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getifaddrs\_1}$
& \textbf{all: fast succeed}
&  Successfully return host interface information \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getifaddrsTI}{\rrulecc{getifaddrsTI}{getifaddrs\_1}{all: fast succeed}{\tsholcomm{ Successfully return host interface information }}
{\tsvar{h} \; \;\tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getifaddrs} ()} }{1}}
{\tsvar{h} \; \;\tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{OK} \;\tsvar{iflist})}{\tsaux{sched\_timer}}}}
{\tsvar{ifidlist} \;\in  \;\tsaux{ORDERINGS} \;\tsvar{ifidset} \Mwedge {}\\{}
 \tsholop{LENGTH} \;\tsvar{ifidlist} = \tsholop{LENGTH} \;\tsvar{iflist} \Mwedge {}\\{}
 {}\\{}
 \tsvar{ifidset} = \{ (\tsvar{ifid}, \tsunknown{hifd}) \mid {}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{ifid} \;\in  \Mfdom{\tsvar{h}.\tsvar{ifds}} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsunknown{hifd} = \tsvar{h}.\tsvar{ifds} \Mfapply{}{\tsvar{ifid}} \} \Mwedge {}\\{}
 {}\\{}
 \tsholop{EVERY} \;\MI  (\tsholop{MAP2} (\lambda  (\tsvar{ifid},\tsunknown{hifd}) (\tsvar{ifid}',\tsvar{primary},\tsunknown{ipslist},\tsvar{netmask}). (\tsvar{ifid}' = \tsvar{ifid} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{primary} = \tsunknown{hifd}.\tsvar{primary} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{ipslist} \;\in  \;\tsaux{ORDERINGS} \;\tsunknown{hifd}.\tsvar{ipset} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{netmask} = \tsunknown{hifd}.\tsvar{netmask})){}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{ifidlist} \;\tsvar{iflist})}
{\rulesubsection{Description}

     On a Unix architecture, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{getifaddrs}()$
     call is made. The call succeeds, returning $\tsvar{iflist}$ which is a list of tuples: one for each
     interface on the host. Each tuple consists of: the interface name; the primary IP address for
     the interface; a list of the other IP addresses for the interface; and the netmask for the
     interface.

     A $\MLhcall{\tsvar{tid}}{\tslib{getifaddrs}()}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}
\tsvar{iflist})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
     This call does not exist on WinXP.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommgetpeername}{\clustersection{(TCP and UDP)}{$\tslib{getpeername}()$}
\seccomm{  \[ \tslib{getpeername}: \tstype{fd} \Mtotype  (\tstype{ip} * \tstype{port}) \]

  A call to $\tslib{getpeername}(\tstype{fd})$ returns the peer address of the socket referred to by file
  descriptor $\tstype{fd}$. If the file descriptor refers to a socket $\tsunknown{sock}$ then a successful call will
  return $(\tsvar{i}_{2},\tsvar{p}_{2})$ where $\tsunknown{sock}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2}$, and $\tsunknown{sock}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}$.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{getpeername}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tscon{ENOTCONN}$
&  Socket not connected to a peer.
\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsrule{getpeername\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:    & \wasverb{int getpeername(int socket, struct sockaddr *restrict address,} \\
              & \wasverb{                socklen\textunderscore{}t *restrict address\textunderscore{}len);} \\
    FreeBSD:  & \wasverb{int getpeername(int s, struct sockaddr *name, } \\
              & \wasverb{                socklen\textunderscore{}t *namelen);} \\
    Linux:    & \wasverb{int getpeername(int s, struct sockaddr *name, } \\
              & \wasverb{                socklen\textunderscore{}t *namelen);} \\
    WinXP:    & \wasverb{int getpeername(SOCKET s,struct sockaddr* name,} \\
              & \wasverb{                int* namelen);} \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is a file descriptor referring to the socket to get the peer address of,
     corresponding to the $\tstype{fd}$ argument in the model $\tslib{getpeername}()$.

    \item \wasverb{address} is a pointer to a \wasverb{sockaddr} structure of length
     \wasverb{address\textunderscore{}len}, which contains the peer address of the socket upon return. These two
     correspond to the $(\tstype{ip} * \tstype{port})$ return type of the model $\tslib{getpeername}()$. The
     \wasverb{sin\textunderscore{}addr.s\textunderscore{}addr} field of the \wasverb{address} structure holds the peer IP address,
     corresponding to the $\tstype{ip}$ in the return tuple; the \wasverb{sin\textunderscore{}port} field of the
     \wasverb{address} structure holds the peer port, corresponding to the $\tstype{port}$ in the return
     tuple.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item According to the FreeBSD man page for $\tslib{getpeername}()$, $\tscon{ECONNRESET}$ can be returned if
     the connection has been reset by the peer. This behaviour has not been observed in any tests.

    \item On FreeBSD, Linux, and WinXP, $\tscon{EFAULT}$ can be returned if the \wasverb{name} parameter
     points to memory not in a valid part of the process address space. This is an artefact of the C
     interface to \wasverb{getpeername()} that is excluded by the clean interface used in the model
     $\tslib{getpeername}()$.

    \item In Posix, $\tscon{EINVAL}$ can be returned if the socket has been shutdown; none of the
    implementations in the model return this error from a $\tslib{getpeername}()$ call.

    \item In Posix, $\tscon{EOPNOTSUPP}$ is returned if the $\tslib{getpeername}()$ operation is not supported
     by the protocol. Both TCP and UDP support this operation.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getpeername\_1}$
& \textbf{all: fast succeed}
&  Successfully return socket's peer address \\
$\tsrule{getpeername\_2}$
& \textbf{all: fast fail}
&  Fail with $\tscon{ENOTCONN}$: socket not connected to a peer \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getpeernameTI}{\rrulecc{getpeernameTI}{getpeername\_1}{all: fast succeed}{\tsholcomm{ Successfully return socket's peer address }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getpeername}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsvar{i}_{2},\tsvar{p}_{2}))}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge {}\\{}
 (\tsvar{sock}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2} \Mvee  (\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsvar{sock}.\tsvar{ps}_{2} = * \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{p}_{2} = \tscon{Port} \;0) \Mwedge  \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tscon{PROTO\_UDP}) ) \Mwedge {}\\{}
 ((\forall \tsunknown{tcp\_sock}. \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \implies {}\\{}
\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{CLOSE\_WAIT}; \tscon{LAST\_ACK};{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscon{FIN\_WAIT\_1}; \tscon{CLOSING}\} \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad (\neg{}\tsvar{sock}.\tsvar{cantrcvmore} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{FIN\_WAIT\_2}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad (\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad \tsholcomm{ BSD listen bug }{}\\{}
\quad\quad\quad\quad\quad\quad (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{LISTEN}) ) \Mvee {}\\{}
 \tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}){}\\{}
 {}\\{}
 {}\\{}
 }
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{getpeername}(\tsvar{fd})$ call is made. $\tsvar{fd}$
    refers to a socket $\tsvar{sock}$, identified by $\tsvar{sid}$, which has its peer IP address set to $\Msome
\tsvar{i}_{2}$ and its peer port address set to $\Msome  \;\tsvar{p}_{2}$. If $\tsvar{sock}$ is a TCP socket then either it is
    in state $\tscon{ESTABLISHED}$, $\tscon{CLOSE\_WAIT}$, $\tscon{LAST\_ACK}$, $\tscon{FIN\_WAIT\_1}$, or $\tscon{CLOSING}$; or it is
    in state $\tscon{FIN\_WAIT\_2}$ and is not shutdown for reading. The call succeeds, returning
    $(\tsvar{i}_{2},\tsvar{p}_{2})$, the socket's peer address.

    A $\MLhcall{\tsvar{tid}}{\tslib{getpeername}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret}( \tscon{OK}
(\tsvar{i}_{2},\tsvar{p}_{2}))$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    If $\tsvar{sock}$ is a TCP socket then it may be in state $\tscon{LISTEN}$; this is due to the FreeBSD bug
    that allows $\tslib{listen}()$ to be called on a synchronised socket.

\\\hline
Linux
&
    If $\tsvar{sock}$ is a TCP socket then it may also be in state $\tscon{SYN\_RECEIVED}$.

\\\hline
WinXP
&
    If $\tsvar{sock}$ is a UDP socket and has no peer port set, $\tsvar{sock}.\tsvar{ps}_{2} = *$ then the call may
    still succeed with $\tsvar{p}_{2} = \tscon{Port} \;0$. Additionally, if $\tsvar{sock}$ is a TCP socket then it may be in
    any state.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\getpeernameTII}{\rrulecc{getpeernameTII}{getpeername\_2}{all: fast fail}{\tsholcomm{ Fail with $\tscon{ENOTCONN}$: socket not connected to a peer }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getpeername}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOTCONN}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
 \neg{}(\tsvar{sock}.\tsvar{is}_{2} \neq  * \Mwedge {}\\{}
\quad (\tsvar{sock}.\tsvar{ps}_{2} \neq  * \Mvee  (\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tscon{PROTO\_UDP})) \Mwedge {}\\{}
\quad (\forall \tsunknown{tcp\_sock}. \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \implies {}\\{}
\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{CLOSE\_WAIT}; \tscon{LAST\_ACK}; \tscon{FIN\_WAIT\_1}; \tscon{CLOSING} \} \Mvee {}\\{}
\quad\quad\quad (\neg{}\tsvar{sock}.\tsvar{cantrcvmore} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{FIN\_WAIT\_2}) \Mvee {}\\{}
\quad\quad\quad (\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED}) \Mvee {}\\{}
\quad\quad\quad {}\\{}
\quad\quad\quad \tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}))}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{getpeername}(\tsvar{fd})$ call is made where
    $\tsvar{fd}$ refers to a socket $\tsvar{sock}$ identified by $\tsvar{sid}$. The socket does not have both its peer
    IP and port set, If it is a TCP socket then it is not in state $\tscon{ESTABLISHED}$, $\tscon{CLOSE\_WAIT}$,
    $\tscon{LAST\_ACK}$, $\tscon{FIN\_WAIT\_1}$ or $\tscon{CLOSING}$; or in state $\tscon{FIN\_WAIT\_2}$ and not shutdown for
    reading. The call fails with an $\tscon{ENOTCONN}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{getpeername}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOTCONN}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    As above, with the additional condition that if $\tsvar{sock}$ is a TCP socket then it is not in state
    $\tscon{SYN\_RECEIVED}$.

\\\hline
WinXP
&
    As above, except that if $\tsvar{sock}$ is a TCP socket then it does not matter what state it is in
    and if it is a UDP socket then the state of its peer port, whether it is set or unset, does not
    matter.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommgetsockbopt}{\clustersection{(TCP and UDP)}{$\tslib{getsockbopt}()$}
\seccomm{  \[ \tslib{getsockbopt}: (\tstype{fd} * \tstype{sockbflag}) \Mtotype  \tstype{bool} \]

  A call to $\tslib{getsockbopt}(\tstype{fd},\tsunknown{flag})$ returns the value of one of the socket's boolean-valued flags.

  The $\tstype{fd}$ argument is a file descriptor referring to the socket to retrieve a flag's value from,
  and the $\tsunknown{flag}$ argument is the boolean-valued socket flag to get. Possible flags are:

  \begin{itemize}

    \item $\tscon{SO\_BSDCOMPAT}$ Reports whether the BSD semantics for delivery of ICMPs to UDP sockets
     with no peer address set is enabled.

    \item $\tscon{SO\_DONTROUTE}$ Reports whether outgoing messages bypass the standard routing facilities.

    \item $\tscon{SO\_KEEPALIVE}$ Reports whether connections are kept active with periodic transmission of
     messages, if this is supported by the protocol.

    \item $\tscon{SO\_OOBINLINE}$ Reports whether the socket leaves received out-of-band data (data marked
     urgent) inline.

    \item $\tscon{SO\_REUSEADDR}$ Reports whether the rules used in validating addresses supplied to
     $\tslib{bind}()$ should allow reuse of local ports, if this is supported by the protocol.

  \end{itemize}

  The return value of the $\tslib{getsockbopt}()$ call is the boolean-value of the specified socket flag.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{getsockbopt}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tscon{ENOPROTOOPT}$
&  The specified flag is not supported by the protocol.

\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsrule{getsockbopt\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tslib{getsockbopt}()$ is Posix \wasverb{getsockopt()} for boolean-valued socket flags.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int getsockopt(int socket, int level, int option\textunderscore{}name,}\\
             & \wasverb{               void *restrict option\textunderscore{}value, } \\
             & \wasverb{               socklen\textunderscore{}t *restrict option\textunderscore{}len);} \\
    FreeBSD: & \wasverb{int getsockopt(int s, int level, int optname, } \\
             & \wasverb{               void *optval, socklen\textunderscore{}t *optlen); } \\
    Linux:   & \wasverb{int getsockopt(int  s, int level, int optname, } \\
             & \wasverb{               void *optval, socklen\textunderscore{}t *optlen);} \\
    WinXP:   & \wasverb{int getsockopt(SOCKET s,int level,int optname, } \\
             & \wasverb{               char* optval, int* optlen); } \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket on which to get the flag,
     corresponding to the $\tstype{fd}$ argument of the model $\tslib{getsockbopt}()$.

    \item \wasverb{level} is the protocol level at which the flag resides: \wasverb{SOL\textunderscore{}SOCKET} for
     the socket level options, and \wasverb{option\textunderscore{}name} is the flag to be retrieved. These two
     correspond to the $\tsunknown{flag}$ argument to the model $\tslib{getsockbopt}()$ where the possible values of
     \wasverb{option\textunderscore{}name} are limited to: $\tscon{SO\_BSDCOMPAT}$, $\tscon{SO\_DONTROUTE}$, $\tscon{SO\_KEEPALIVE}$,
     $\tscon{SO\_OOBINLINE}$, and $\tscon{SO\_REUSEADDR}$.

    \item \wasverb{option\textunderscore{}value} is a pointer to a location of size \wasverb{option\textunderscore{}len} to store
     the value retrieved by \wasverb{getsockopt()}. These two correspond to the $\tstype{bool}$ return type
     of the model $\tslib{getsockbopt}()$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EFAULT} signifies the pointer passed as \wasverb{option\textunderscore{}value} was
     inaccessible. On WinXP, the error \wasverb{WSAEFAULT} may also signify that the
     \wasverb{optlen} parameter was too small.

    \item \wasverb{EINVAL} signifies the \wasverb{option\textunderscore{}name} was invalid at the specified socket
     \wasverb{level}. In the model, typing prevents an invalid flag from being specified in a call
     to $\tslib{getsockbopt}()$.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getsockbopt\_1}$
& \textbf{all: fast succeed}
&  Successfully retrieve value of boolean socket flag \\
$\tsrule{getsockbopt\_2}$
& \textbf{udp: fast succeed}
&  Fail with $\tscon{ENOPROTOOPT}$: option not valid on WinXP UDP socket \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getsockboptTI}{\rrulecc{getsockboptTI}{getsockbopt\_1}{all: fast succeed}{\tsholcomm{ Successfully retrieve value of boolean socket flag }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getsockbopt}(\tsvar{fd},\tsvar{f})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsvar{sf}.\tsvar{b}(\tsvar{f})))}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sf} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{sf} \Mwedge {}\\{}
 (\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tscon{PROTO\_UDP}{}\\{}
\quad \implies  \tsvar{f} \;\notin  \{\tscon{SO\_KEEPALIVE}; \tscon{SO\_OOBINLINE}\})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{getsockbopt}(\tsvar{fd},\tsvar{f})$ call is made. $\tsvar{fd}$
    refers to a socket $\tsvar{sid}$ with boolean socket flags $\tsvar{sf}.\tsvar{b}$, and $\tsvar{f}$ is a boolean socket
    flag. The call succeeds, returning the value of $\tsvar{f}$: $\Mtrue $ if $\tsvar{f}$ is set, and $\Mfalse $ if $\tsvar{f}$
    is not set in $\tsvar{sf}.\tsvar{b}$.

    A $\MLhcall{\tsvar{tid}}{\tslib{getsockbopt}(\tsvar{fd},\tsvar{f})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}(\tsvar{sf}.\tsvar{b}(\tsvar{f})))$ where $\tsvar{sf}.\tsvar{b}(\tsvar{f})$ is the boolean value of the socket's flag $\tsvar{f}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    As above, except that if $\tsvar{sid}$ is a UDP socket, then $\tsvar{f}$ cannot be $\tscon{SO\_KEEPALIVE}$ or
    $\tscon{SO\_OOBINLINE}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\getsockboptTII}{\rrulecc{getsockboptTII}{getsockbopt\_2}{udp: fast succeed}{\tsholcomm{ Fail with $\tscon{ENOPROTOOPT}$: option not valid on WinXP UDP socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid}, \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getsockbopt}(\tsvar{fd},\tsvar{f})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOPROTOOPT}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec }
{\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{f} \;\in  \{\tscon{SO\_KEEPALIVE}; \tscon{SO\_OOBINLINE}\}}
{\rulesubsection{Description}

    On WinXP, consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in
    the $\tscon{Run}$ state, a $\tslib{getsockbopt}(\tsvar{fd},\tsvar{f})$ call is made, where $\tsvar{f}$ is either $\tscon{SO\_KEEPALIVE}$
    or $\tscon{SO\_OOBINLINE}$. The call fails with an $\tscon{ENOPROTOOPT}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{getsockbopt}(\tsvar{fd},\tsvar{f})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOPROTOOPT}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommgetsockerr}{\clustersection{(TCP and UDP)}{$\tslib{getsockerr}()$}
\seccomm{  \[ \tslib{getsockerr}: \tstype{fd} \Mtotype  \tstype{unit} \]

  A call $\tslib{getsockerr}(\tstype{fd})$ returns the pending error of a socket, clearing it, if there is one.

  $\tstype{fd}$ is a file descriptor referring to a socket. If the socket has a pending error then the
  $\tslib{getsockerr}()$ call will fail with that error, otherwise it will return successfully.

}\clustersubsection{Errors}
\seccomm{
  In addition to failing with the pending error, a call to $\tslib{getsockerr}()$ can fail with the errors
  below, in which case the corresponding exception is raised:

\par\begin{ltstabular}
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsrule{getsockerr\_1}$; $\tsrule{return\_1}$

  $\tsrule{getsockerr\_2}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tslib{getsockerr}()$ is Posix \wasverb{getsockopt()} for the \wasverb{SO\textunderscore{}ERROR} socket option.

  \begin{tabular}{ll}
     Posix:   & \wasverb{int getsockopt(int socket, int level, int option\textunderscore{}name,}\\
              & \wasverb{               void *restrict option\textunderscore{}value, } \\
              & \wasverb{               socklen\textunderscore{}t *restrict option\textunderscore{}len);} \\
     FreeBSD: & \wasverb{int getsockopt(int s, int level, int optname, } \\
              & \wasverb{               void *optval, socklen\textunderscore{}t *optlen); } \\
     Linux:   & \wasverb{int getsockopt(int  s, int level, int optname, } \\
              & \wasverb{               void *optval, socklen\textunderscore{}t *optlen);} \\
     WinXP:   & \wasverb{int getsockopt(SOCKET s,int level,int optname, } \\
              & \wasverb{               char* optval, int* optlen); } \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to get the option on, corresponding
     to the $\tstype{fd}$ argument of the model $\tslib{getsockerr}()$.

    \item \wasverb{level} is the protocol level at which the option resides: \wasverb{SOL\textunderscore{}SOCKET}
     for the socket level options, and \wasverb{option\textunderscore{}name} is the option to be retrieved. For
     $\tslib{getsockerr}()$ \wasverb{option\textunderscore{}name} is set to \wasverb{SO\textunderscore{}ERROR}.

    \item \wasverb{option\textunderscore{}value} is a pointer to a location of size \wasverb{option\textunderscore{}len} to store
     the value retrieved by \wasverb{getsockopt()}. When \wasverb{option\textunderscore{}name} is
     \wasverb{SO\textunderscore{}ERROR} these fields are not used.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate the socket has no pending
     error or \wasverb{-1} to indicate a pending error, in which case the error code is in
     \wasverb{errno}.  On WinXP an error is indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR},
     not \wasverb{-1}, with the actual error code available through a call to
     \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EFAULT} signifies the pointer passed as \wasverb{option\textunderscore{}value} was
     inaccessible. On WinXP, the error \wasverb{WSAEFAULT} may also signify that the
     \wasverb{optlen} parameter was too small.

    \item \wasverb{EINVAL} signifies the \wasverb{option\textunderscore{}name} was invalid at the specified socket
     \wasverb{level}. In the model, the flag for $\tslib{getsockerr}()$ is always \wasverb{SO\textunderscore{}ERROR} so
     this error cannot occur.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getsockerr\_1}$
& \textbf{all: fast succeed}
&  Return successfully: no pending error \\
$\tsrule{getsockerr\_2}$
& \textbf{all: fast fail}
&  Fail with pending error and clear the error \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getsockerrTI}{\rrulecc{getsockerrTI}{getsockerr\_1}{all: fast succeed}{\tsholcomm{ Return successfully: no pending error }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getsockerr}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{es} = *}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{getsockerr}(\tsvar{fd})$ call is made. $\tsvar{fd}$
    refers to a socket $\tsvar{sid}$ which has no pending errors. The call succeeds.

    A $\MLhcall{\tsvar{tid}}{\tslib{getsockerr}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$.

\rrulepad }
}

\newcommand{\getsockerrTII}{\rrulecc{getsockerrTII}{getsockerr\_2}{all: fast fail}{\tsholcomm{ Fail with pending error and clear the error }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getsockerr}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')] \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Msome  \;\tsvar{e} = \tsvar{sock}.\tsvar{es} \Mwedge {}\\{}
 \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  * \Mmagicrrec }
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{getsockerr}(\tsvar{fd})$ call is made. $\tsvar{fd}$
    refers to a socket $\tsvar{sid}$ which has pending error $\tsvar{e}$. The call fails, returning $\tsvar{e}$.

    A $\MLhcall{\tsvar{tid}}{\tslib{getsockerr}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$ and cleaing the error $\tsvar{e}$ from the socket.

\rrulepad }
}

\newcommand{\seccommgetsocklistening}{\clustersection{(TCP and UDP)}{$\tslib{getsocklistening}()$}
\seccomm{ \[ \tslib{getsocklistening}: \tstype{fd} \Mtotype  \tstype{bool} \]

  A call to $\tslib{getsocklistening}(\tstype{fd})$ returns $\Mtrue $ if the socket referenced by $\tstype{fd}$ is listening,
  or $\Mfalse $ otherwise. For TCP a socket is listening if it is in the $\tscon{LISTEN}$ state. For UDP, which
  is not a connection-oriented protocol, a socket can never be listening.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{getsocklistening}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tscon{ENOPROTOOPT}$
&  FreeBSD does not support this socket option, and on Linux and WinXP this
  option is not supported for UDP sockets.

\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsrule{getsocklistening\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tslib{getsocklistening}()$ is Posix \wasverb{getsockopt()} for the \wasverb{SO\textunderscore{}ACCEPTCONN} socket
  option.

  \begin{tabular}{ll}
     Posix:   & \wasverb{int getsockopt(int socket, int level, int option\textunderscore{}name,}\\
              & \wasverb{               void *restrict option\textunderscore{}value, } \\
              & \wasverb{               socklen\textunderscore{}t *restrict option\textunderscore{}len);} \\
     FreeBSD: & \wasverb{int getsockopt(int s, int level, int optname, } \\
              & \wasverb{               void *optval, socklen\textunderscore{}t *optlen); } \\
     Linux:   & \wasverb{int getsockopt(int  s, int level, int optname, } \\
              & \wasverb{               void *optval, socklen\textunderscore{}t *optlen);} \\
     WinXP:   & \wasverb{int getsockopt(SOCKET s,int level,int optname, } \\
              & \wasverb{               char* optval, int* optlen); } \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to get the option on, corresponding
     to the $\tstype{fd}$ argument of the model $\tslib{getsocklistening}()$.

    \item \wasverb{level} is the protocol level at which the option resides: \wasverb{SOL\textunderscore{}SOCKET}
     for the socket level options, and \wasverb{option\textunderscore{}name} is the option to be retrieved. For
     $\tslib{getsocklistening}()$ \wasverb{option\textunderscore{}name} is set to \wasverb{SO\textunderscore{}ACCEPTCONN}.

    \item \wasverb{option\textunderscore{}value} is a pointer to a location of size \wasverb{option\textunderscore{}len} to store
     the value retrieved by \wasverb{getsockopt()}. The value stored in the location corresponds to
     the $\tstype{bool}$ return value of the model $\tslib{getsocklistening}()$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  The Linux and WinXP interfaces are similar except where noted. FreeBSD does not support the
  \wasverb{SO\textunderscore{}ACCEPTCONN} socket option.

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EFAULT} signifies the pointer passed as \wasverb{option\textunderscore{}value} was
     inaccessible. On WinXP, the error \wasverb{WSAEFAULT} may also signify that the
     \wasverb{optlen} parameter was too small.

    \item \wasverb{EINVAL} signifies the \wasverb{option\textunderscore{}name} was invalid at the specified socket
     \wasverb{level}. In the model, the flag for $\tslib{getsocklistening}()$ is always
     \wasverb{SO\textunderscore{}ACCEPTCONN} so this error cannot occur.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getsocklistening\_1}$
& \textbf{tcp: fast succeed}
&  Return successfully: $\Mtrue $ if socket is listening, $\Mfalse $ otherwise \\
$\tsrule{getsocklistening\_3}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{ENOPROTOOPT}$: on FreeBSD operation not supported \\
$\tsrule{getsocklistening\_2}$
& \textbf{udp: rc}
&  Return $\Mfalse $ or fail with $\tscon{ENOPROTOOPT}$: a UDP socket cannot be listening \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getsocklisteningTI}{\rrulecc{getsocklisteningTI}{getsocklistening\_1}{tcp: fast succeed}{\tsholcomm{ Return successfully: $\Mtrue $ if socket is listening, $\Mfalse $ otherwise }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getsocklistening}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} \;\tsvar{b})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} \Mwedge {}\\{}
 \tsvar{b} = (\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{LISTEN}) \Mwedge {}\\{}
 \neg{}(\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{getsocklistening}(\tsvar{fd})$ call is
    made where $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$.

    A $\MLhcall{\tsvar{tid}}{\tslib{getsocklistening}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK} \;\tsvar{b})$ where $\tsvar{b}=\Mtrue $ if the socket is in the $\tscon{LISTEN}$ state, and $\tsvar{b}=\Mfalse $ otherwise.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply: see $\tsrule{getsocklistening\_3}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\getsocklisteningTIII}{\rrulecc{getsocklisteningTIII}{getsocklistening\_3}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{ENOPROTOOPT}$: on FreeBSD operation not supported }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getsocklistening}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOPROTOOPT}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr}}
{\rulesubsection{Description}

    On FreeBSD, a $\tslib{getsocklistening}(\tsvar{fd})$ call is made from thread $\tsvar{tid}$ which is in the $\tscon{Run}$
    state where$\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$. The call fails with an $\tscon{ENOPROTOOPT}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{getsocklistening}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tscon{ENOPROTOOPT}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    This rule does not apply: see $\tsrule{getsocklistening\_1}$.

\\\hline
WinXP
&
    This rule does not apply: see $\tsrule{getsocklistening\_1}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\getsocklisteningTII}{\rrulecc{getsocklisteningTII}{getsocklistening\_2}{udp: rc}{\tsholcomm{ Return $\Mfalse $ or fail with $\tscon{ENOPROTOOPT}$: a UDP socket cannot be listening }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getsocklistening}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tsvar{ret})}{ \tsaux{sched\_timer}}} \Mmagicrrec }
{\tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tscon{PROTO\_UDP} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mif  \;\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{rc} = \tscon{fast} \;\tscon{succeed} \Mwedge  \tsvar{ret} = \tscon{OK} \;\Mfalse {}\\{}
 \Melse                       \;\tsvar{rc} = \tscon{fast} \;\tscon{fail}    \Mwedge  \tsvar{ret} = \tscon{FAIL}\;{\tscon{ENOPROTOOPT}}}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in the
    $\tscon{Run}$ state, a $\tslib{getsocklistening}(\tsvar{fd})$ call is made. On Linux the call succeeds, returning
    $\Mfalse $; on FreeBSD and WinXP the call fails with an $\tscon{ENOPROTOOPT}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{getsocklistening}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}(\Mfalse ))$ on Linux, and $\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOPROTOOPT}})$ on FreeBSD and Linux.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    As above: the call fails with an $\tscon{ENOPROTOOPT}$ error.

\\\hline
FreeBSD
&
    As above: the call fails with an $\tscon{ENOPROTOOPT}$ error.

\\\hline
Linux
&
    As above: the call succeeds, returning $\Mfalse $.

\\\hline
WinXP
&
    As above: the call fails with an $\tscon{ENOPROTOOPT}$ error.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommgetsockname}{\clustersection{(TCP and UDP)}{$\tslib{getsockname}()$}
\seccomm{  \[ \tslib{getsockname}: \tstype{fd} \Mtotype  (\tstype{ip} \;\;\tstype{option} * \tstype{port} \;\;\tstype{option}) \]

  A call to $\tslib{getsockname}(\tstype{fd})$ returns the local address pair of a socket. If the file descriptor
  $\tstype{fd}$ refers to the socket $\tsunknown{sock}$ then the return value of a successfull call will be
  $(\tsunknown{sock}.\tsvar{is}_{1}, \tsunknown{sock}.\tsvar{ps}_{1})$.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{getsockname}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tscon{ECONNRESET}$
&  On FreeBSD, TCP socket has its $\tsvar{cb}.\tsfield{bsd\_cantconnect}$ flag set due to previous connection establishment attempt.
\\\hline
$\tscon{EINVAL}$
&  Socket not bound to local address on WinXP.
\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\\\hline
$\tscon{ENOBUFS}$
&  Out of resources.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsrule{getsockname\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:   & \wasverb{int getsockname(int socket, struct sockaddr *restrict address,} \\
             & \wasverb{                socklen\textunderscore{}t *restrict address\textunderscore{}len);} \\
    FreeBSD: & \wasverb{int getsockname(int s, struct sockaddr *name, } \\
             & \wasverb{                socklen\textunderscore{}t *namelen);} \\
    Linux:   & \wasverb{int getsockname(int s, struct sockaddr *name, } \\
             & \wasverb{                socklen\textunderscore{}t *namelen);} \\
    WinXP:   & \wasverb{int getsockname(SOCKET s, struct sockaddr* name, }\\
             & \wasverb{                int* namelen);} \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is a file descriptor referring to the socket to get the local address of,
     corresponding to the $\tstype{fd}$ argument in the model $\tslib{getsockname}()$.

    \item \wasverb{address} is a pointer to a \wasverb{sockaddr} structure of length
     \wasverb{address\textunderscore{}len}, which contains the local address of the socket upon return. These two
     correspond to the $(\tstype{ip} \;\;\tstype{option}, \tstype{port} \;\;\tstype{option})$ return type of the model $\tslib{getsockname}()$. If
     the \wasverb{sin\textunderscore{}addr.s\textunderscore{}addr} field of the \wasverb{name} structure is set to \wasverb{0} on
     return, then the socket's local IP address is not set: the $\tstype{ip} \;\;\tstype{option}$ member of the return
     tuple is set to $*$; otherwise, if it is set to \wasverb{i} then it corresponds to the
     socket having local IP address and so the $\tstype{ip} \;\;\tstype{option}$ member of the return tuple is$\Msome
\tsunknown{i}$. If the \wasverb{sin\textunderscore{}port} field of the \wasverb{name} structure is set to \wasverb{0} on
     return then the socket does not have a local port set, corresponding to the $\tstype{port} \;\;\tstype{option}$ in
     the return tuple being $*$; otherwise the \wasverb{sin\textunderscore{}port} field is set to \wasverb{p}
     corresponding to the socket having its local port set: the $\tstype{port} \;\;\tstype{option}$ in the return tuple
     is $\Msome  \;\tsunknown{p}$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item On FreeBSD, Linux, and WinXP, $\tscon{EFAULT}$ can be returned if the \wasverb{name} parameter
     points to memory not in a valid part of the process address space. This is an artefact of the C
     interface to \wasverb{getsockname()} that is excluded by the clean interface used in the model
     $\tslib{getsockname}()$.

    \item in Posix, $\tscon{EINVAL}$ can be returned if the socket has been shutdown. None of the
    implementations return $\tscon{EINVAL}$ in this case.

    \item in Posix, $\tscon{EOPNOTSUPP}$ is returned if the $\tslib{getsockname}()$ operation is not supported
     by the protocol. Both UDP and TCP support this operation.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getsockname\_1}$
& \textbf{all: fast succeed}
&  Successfully return socket's local address \\
$\tsrule{getsockname\_2}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{ECONNRESET}$: previous connection attempt has failed on FreeBSD \\
$\tsrule{getsockname\_3}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EINVAL}$: socket not bound on WinXP \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getsocknameTI}{\rrulecc{getsocknameTI}{getsockname\_1}{all: fast succeed}{\tsholcomm{ Successfully return socket's local address }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getsockname}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{ps}_{1}))}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
 (\Mcase  \;\tsvar{sock}.\tsvar{pr} \;\Mof {}\\{}
\quad \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mtotype {}\\{}
\quad\quad \tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \implies  \neg{}(\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{bsd\_cantconnect} = \Mtrue  \Mwedge  \tsvar{sock}.\tsvar{ps}_{1} = *) \Mdpipe {}\\{}
\quad \tscon{UDP\_PROTO}(\tsunknown{\_444}) \Mtotype  \Mtrue ) \Mwedge {}\\{}
 (\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \implies  \tsvar{sock}.\tsvar{is}_{1} \neq  * \Mvee  \tsvar{sock}.\tsvar{ps}_{1} \neq  *)}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{getsockname}(\tsvar{fd})$ call is made where
    $\tsvar{fd}$ refers to socket $\tsvar{sock}$, identified by $\tsvar{sid}$. The socket's local address is returned:
    $(\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{ps}_{1})$.

    A $\MLhcall{\tsvar{tid}}{\tslib{getsockname}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}
(\tsvar{sock}.\tsvar{is}_{1}, \tsvar{sock}.\tsvar{ps}_{1}))$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply if the socket's $\tsfield{bsd\_cantconnect}$ flag is set in its control block
    and its local port is not set.

\\\hline
WinXP
&
    As above with the additional condition that either the socket's local IP address or local port
    must be set.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\getsocknameTII}{\rrulecc{getsocknameTII}{getsockname\_2}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{ECONNRESET}$: previous connection attempt has failed on FreeBSD }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getsockname}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{ECONNRESET}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec }
{\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 (\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{bsd\_cantconnect} = \Mtrue  \Mwedge  \tsvar{sock}.\tsvar{ps}_{1} = *) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{h}.\tsvar{files} \Mfapply{}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff})}
{\rulesubsection{Description}

    On FreeBSD, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{getsockname}(\tsvar{fd})$ call is
    made where $\tsvar{fd}$ refers to a TCP socket $\tsvar{sock}$, identified by $\tsvar{sid}$, which has its
    $\tsfield{bsd\_cantconnect}$ flag set and is not bound to a local port.

    A $\MLhcall{\tsvar{tid}}{\tslib{getsockname}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{ECONNRESET}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    This rule does not apply.

\\\hline
WinXP
&
    This rule does not apply.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\getsocknameTIII}{\rrulecc{getsocknameTIII}{getsockname\_3}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EINVAL}$: socket not bound on WinXP }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{1} \Mass  *; \tsvar{ps}_{1} \Mass  * \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getsockname}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{1} \Mass  *; \tsvar{ps}_{1} \Mass  * \Mmagicrrec )] \Mmagicrrec }
{\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff})}
{\rulesubsection{Description}

    On WinXP, a $\tslib{getsockname}(\tsvar{fd})$ call is made from thread $\tsvar{tid}$ which is in the $\tscon{Run}$
    state. $\tsvar{fd}$ refers to a socket $\tsvar{sid}$ which has neither its local IP address nor its local
    port set. The call fails with an $\tscon{EINVAL}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{getsockname}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    This rule does not apply.

\\\hline
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommgetsocknopt}{\clustersection{(TCP and UDP)}{$\tslib{getsocknopt}()$}
\seccomm{ \[ \tslib{getsocknopt}: (\tstype{fd} * \tstype{socknflag}) \Mtotype  \tstype{int} \]

  A call to $\tslib{getsocknopt}(\tstype{fd},\tsunknown{flag})$ returns the value of one of the socket's numeric flags.  The
  $\tstype{fd}$ argument is a file descriptor referring to the socket to retrieve a flag's value from. The
  $\tsunknown{flag}$ argument is a numeric socket flag. Possible flags are:

  \begin{itemize}
    \item $\tscon{SO\_RCVBUF}$ Reports receive buffer size information.
    \item $\tscon{SO\_RCVLOWAT}$ Reports the minimum number of bytes to process for socket input
     operations.
    \item $\tscon{SO\_SNDBUF}$ Reports send buffer size information.
    \item $\tscon{SO\_SNDLOWAT}$ Reports the minimum number of bytes to process for socket output
     operations.
  \end{itemize}

  The return value of the $\tslib{getsocknopt}()$ call is the numeric-value of the specified $\tsunknown{flag}$.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{getsocknopt}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tscon{ENOPROTOOPT}$
&  The specified flag is not supported by the protocol.
\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsrule{getsocknopt\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tslib{getsocknopt}()$ is Posix \wasverb{getsockopt()} for numeric socket flags.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int getsockopt(int socket, int level, int option\textunderscore{}name,}\\
             & \wasverb{               void *restrict option\textunderscore{}value, } \\
             & \wasverb{               socklen\textunderscore{}t *restrict option\textunderscore{}len);} \\
    FreeBSD: & \wasverb{int getsockopt(int s, int level, int optname, } \\
             & \wasverb{               void *optval, socklen\textunderscore{}t *optlen); } \\
    Linux:   & \wasverb{int getsockopt(int  s, int level, int optname, } \\
             & \wasverb{               void *optval, socklen\textunderscore{}t *optlen);} \\
    WinXP:   & \wasverb{int getsockopt(SOCKET s,int level,int optname, } \\
             & \wasverb{               char* optval, int* optlen); } \\
  \end{tabular}

  In the Posix interface:
  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to set the option on, corresponding
     to the $\tstype{fd}$ argument of the model $\tslib{getsocknopt}()$.

    \item \wasverb{level} is the protocol level at which the option resides: \wasverb{SOL\textunderscore{}SOCKET}
     for the socket level options, and \wasverb{option\textunderscore{}name} is the option to be retrieved. These
     two correspond to the $\tsunknown{flag}$ argument to the model $\tslib{getsocknopt}()$ where the possible
     values of \wasverb{option\textunderscore{}name} are limited to $\tscon{SO\_RCVBUF}$, $\tscon{SO\_RCVLOWAT}$, $\tscon{SO\_SNDBUF}$
     and $\tscon{SO\_SNDLOWAT}$.

    \item \wasverb{option\textunderscore{}value} is a pointer to a location of size \wasverb{option\textunderscore{}len} to store
     the value retrieved by \wasverb{getsockopt()}. They correspond to the $\tstype{int}$ return type of
     the model $\tslib{getsocknopt}()$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EFAULT} signifies the pointer passed as \wasverb{option\textunderscore{}value} was
     inaccessible. On WinXP, the error \wasverb{WSAEFAULT} may also signify that the
     \wasverb{optlen} parameter was too small.

    \item \wasverb{EINVAL} signifies the \wasverb{option\textunderscore{}name} was invalid at the specified socket
     \wasverb{level}. In the model, typing prevents an invalid flag from being specified in a call
     to $\tslib{getsocknopt}()$.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getsocknopt\_1}$
& \textbf{all: fast succeed}
&  Successfully retrieve value of a numeric socket flag \\
$\tsrule{getsocknopt\_4}$
& \textbf{all: fast fail}
&  Fail with $\tscon{ENOPROTOOPT}$: value of $\tscon{SO\_RCVLOWAT}$ and $\tscon{SO\_SNDLOWAT}$ not retrievable \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getsocknoptTI}{\rrulecc{getsocknoptTI}{getsocknopt\_1}{all: fast succeed}{\tsholcomm{ Successfully retrieve value of a numeric socket flag }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getsocknopt}(\tsvar{fd},\tsvar{f})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsholop{int\_of\_num} (\tsvar{sf}.\tsvar{n}(\tsvar{f}))))}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sf} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{sf} \Mwedge {}\\{}
 (\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \implies  \tsvar{f} \;\notin  \{\tscon{SO\_RCVLOWAT}; \tscon{SO\_SNDLOWAT}\})}
{\rulesubsection{Description}

    Consider the socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, with socket flags $\tsvar{sf}$. From thread
    $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{getsocknopt}(\tsvar{fd},\tsvar{f})$ call is made. $\tsvar{f}$ is a numeric
    socket flag whose value is to be returned. The call succeeds, returning $\tsvar{sf}.\tsvar{n}(\tsvar{f})$, the numeric
    value of flag $\tsvar{f}$ for socket $\tsvar{sid}$.

    A $\MLhcall{\tsvar{tid}}{\tslib{getsocknopt}(\tsvar{fd},\tsvar{f})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}
(\tsholop{int\_of\_num} (\tsvar{sf}.\tsvar{n}(\tsvar{f}))))$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    The flag $\tsvar{f}$ is not $\tscon{SO\_RCVLOWAT}$ or $\tscon{SO\_SNDLOWAT}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\getsocknoptTIV}{\rrulecc{getsocknoptTIV}{getsocknopt\_4}{all: fast fail}{\tsholcomm{ Fail with $\tscon{ENOPROTOOPT}$: value of $\tscon{SO\_RCVLOWAT}$ and $\tscon{SO\_SNDLOWAT}$ not retrievable }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getsocknopt}(\tsvar{fd},\tsvar{f})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOPROTOOPT}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{f} \;\in  \{\tscon{SO\_RCVLOWAT}; \tscon{SO\_SNDLOWAT}\}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{getsocknopt}(\tsvar{fd},\tsvar{f})$ call is made where
    $\tsvar{fd}$ is a file descriptor. $\tsvar{f}$ is a numeric socket flag: either $\tscon{SO\_RCVLOWAT}$ or
    $\tscon{SO\_SNDLOWAT}$, both flags whose value is non-retrievable. The call fails with an
    $\tscon{ENOPROTOOPT}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{getsocknopt}(\tsvar{fd},\tsvar{f})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOPROTOOPT}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommgetsocktopt}{\clustersection{(TCP and UDP)}{$\tslib{getsocktopt}()$}
\seccomm{ \[ \tslib{getsocktopt}: (\tstype{fd} * \tstype{socktflag}) \Mtotype  (\tstype{int} * \tstype{int}) \;\tstype{option} \]

  A call to $\tslib{getsocktopt}(\tstype{fd},\tsunknown{flag})$ returns the value of one of the socket's time-option flags.

  The $\tstype{fd}$ argument is a file descriptor referring to the socket to retrieve a flag's value
  from. The $\tsunknown{flag}$ argument is a time option socket flag. Possible flags are:

  \begin{itemize}
    \item $\tscon{SO\_RCVTIMEO}$ Reports the timeout value for input operations.

    \item $\tscon{SO\_SNDTIMEO}$ Reports the timeout value specifying the amount of time that an output
     function blocks because flow control prevents data from being sent.
  \end{itemize}

  The return value of the $\tslib{getsocktopt}()$ call is the time-value of the specified $\tsunknown{flag}$. A
  return value of $*$ means the timeout is disabled. A return value of $\Msome (\tsunknown{s},\tsunknown{ns})$ means the
  timeout value is $\tsunknown{s}$ seconds and $\tsunknown{ns}$ nano-seconds.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{getsocktopt}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tscon{ENOPROTOOPT}$
&  The specified flag is not supported by the protocol.
\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsrule{getsocktopt\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tslib{getsocktopt}()$ is Posix \wasverb{getsockopt()} for time-valued socket options.

  \begin{tabular}{ll}
     Posix:   & \wasverb{int getsockopt(int socket, int level, int option\textunderscore{}name,}\\
              & \wasverb{               void *restrict option\textunderscore{}value, } \\
              & \wasverb{               socklen\textunderscore{}t *restrict option\textunderscore{}len);} \\
     FreeBSD: & \wasverb{int getsockopt(int s, int level, int optname, } \\
              & \wasverb{               void *optval, socklen\textunderscore{}t *optlen); } \\
     Linux:   & \wasverb{int getsockopt(int  s, int level, int optname, } \\
              & \wasverb{               void *optval, socklen\textunderscore{}t *optlen);} \\
     WinXP:   & \wasverb{int getsockopt(SOCKET s,int level,int optname, } \\
              & \wasverb{               char* optval, int* optlen); } \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to set the option on, corresponding
     to the $\tstype{fd}$ argument of the model $\tslib{getsocktopt}()$.

    \item \wasverb{level} is the protocol level at which the option resides: \wasverb{SOL\textunderscore{}SOCKET}
     for the socket level options, and \wasverb{option\textunderscore{}name} is the option to be retrieved. These
     two correspond to the $\tsunknown{flag}$ argument to the model $\tslib{getsocktopt}()$ where the possible
     values of \wasverb{option\textunderscore{}name} are limited to $\tscon{SO\_RCVTIMEO}$ and $\tscon{SO\_SNDTIMEO}$.

    \item \wasverb{option\textunderscore{}value} is a pointer to a location of size \wasverb{option\textunderscore{}len} to store
     the value retrieved by \wasverb{getsockopt()}. They correspond to the $(\tstype{int} * \tstype{int}) \;\tstype{option}$
     return type of the model $\tslib{getsocktopt}()$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EFAULT} signifies the pointer passed as \wasverb{option\textunderscore{}value} was
     inaccessible. On WinXP, the error \wasverb{WSAEFAULT} may also signify that the
     \wasverb{optlen} parameter was too small.

    \item \wasverb{EINVAL} signifies the \wasverb{option\textunderscore{}name} was invalid at the specified socket
     \wasverb{level}. In the model, typing prevents an invalid flag from being specified in a call
     to $\tslib{getsocktopt}()$.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{getsocktopt\_1}$
& \textbf{all: fast succeed}
&  Successfully retrieve value of time-option socket flag \\
$\tsrule{getsocktopt\_4}$
& \textbf{all: fast fail}
&  Fail with $\tscon{ENOPROTOOPT}$: on WinXP $\tscon{SO\_LINGER}$ not retrievable for UDP sockets \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\getsocktoptTI}{\rrulecc{getsocktoptTI}{getsocktopt\_1}{all: fast succeed}{\tsholcomm{ Successfully retrieve value of time-option socket flag }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getsocktopt}(\tsvar{fd},\tsvar{f})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} \;\tsvar{t})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sf} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{sf} \Mwedge {}\\{}
 \tsvar{t} = \tsaux{tltimeopt\_of\_time} (\tsvar{sf}.\tsvar{t}(\tsvar{f})) \Mwedge {}\\{}
 \neg{}(\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tscon{PROTO\_UDP} \Mwedge {}\\{}
\quad \tsvar{f} = \tscon{SO\_LINGER})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{getsocktopt}(\tsvar{fd},\tsvar{f})$ call is made. $\tsvar{fd}$
    is a file descriptor referring to the socket $\tsvar{sid}$ which has socket flags $\tsvar{sf}$, and $\tsvar{f}$ is
    a time-option flag. The call succeeds, returning $\tscon{OK} (\tsvar{t})$ where $\tsvar{t}$ is the value of the
    socket's flag $\tsvar{f}$.

    A $\MLhcall{\tsvar{tid}}{\tslib{getsocktopt}(\tsvar{fd},\tsvar{f})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}
\tsvar{t})$.

\rulesubsection{Model details}

    The return type is $(\tstype{int} * \tstype{int}) \;\tstype{option}$, but the type of a time-option socket flag is
    $\tstype{time}$. The auxiliary function $\tsaux{tltimeopt\_of\_time}$ is used to do the conversion.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    As above but in addition if $\tsvar{fd}$ refers to a UDP socket then the flag is not $\tscon{SO\_LINGER}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\getsocktoptTIV}{\rrulecc{getsocktoptTIV}{getsocktopt\_4}{all: fast fail}{\tsholcomm{ Fail with $\tscon{ENOPROTOOPT}$: on WinXP $\tscon{SO\_LINGER}$ not retrievable for UDP sockets }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{getsocktopt}(\tsvar{fd},\tsvar{f})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOPROTOOPT}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tscon{PROTO\_UDP} \Mwedge {}\\{}
 \tsvar{f} = \tscon{SO\_LINGER}}
{\rulesubsection{Description}

    On WinXP, from thread $\tsvar{tid}$ which is in the $\tscon{Run}$ state, a $\tslib{getsocktopt}(\tsvar{fd},\tsvar{f})$ call is
    made. $\tsvar{fd}$ is a file descriptor referring to a UDP socket $\tsvar{sid}$ and $\tsvar{f}$ is the socket flag
    $\tscon{SO\_LINGER}$.  The flag $\tsvar{f}$ is not retrievable so the call fails with an $\tscon{ENOPROTOOPT}$
    error.

    A $\MLhcall{\tsvar{tid}}{\tslib{getsocktopt}(\tsvar{fd},\tsvar{f})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{ENOPROTOOPT})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommlisten}{\clustersection{(TCP only)}{$\tslib{listen}()$}
\seccomm{  \[ \tslib{listen}: \tstype{fd} * \tstype{int} \Mtotype  \tstype{unit}  \]

   A call to $\tslib{listen}(\tstype{fd},\tsvar{n})$ puts a TCP socket that is in the $\tscon{CLOSED}$ state into the $\tscon{LISTEN}$
   state, making it a passive socket, so that incoming connections for the socket will be accepted
   by the host and placed on its listen queue.  Here $\tstype{fd}$ is a file descriptor referring to the
   socket to put into the $\tscon{LISTEN}$ state and $\tsvar{n}$ is the \textit{backlog} used to calculate the
   maximum lengths of the two components of the socket's listen queue: its pending connections
   queue, $\tsvar{lis}.\tsvar{q}_{0}$, and its complete connection queue, $\tsvar{lis}.\tsvar{q}$.  The details of this calculation
   very between architectures.  The maximum useful value of $\tsvar{n}$ is $\tsaux{SOMAXCONN}$: if $\tsvar{n}$ is
   greater than this then it will be truncated without generating an error. The minimum value of
   $\tsvar{n}$ is $0$: if it a negative integer then it will be set to $0$.

   Once a socket is in the $\tscon{LISTEN}$ state, $\tslib{listen}()$ can be called again to change the backlog
   value.

}\clustersubsection{Errors}
\seccomm{
   A call to $\tslib{listen}()$ can fail with the errors below, in which case the corresponding exception
   is raised:

\par\begin{ltstabular}
$\tscon{EADDRINUSE}$
&  Another socket is listening on this local port.

\\\hline
$\tscon{EINVAL}$
&  On FreeBSD the socket has been shutdown for writing; on Linux the socket is not
   in the $\tscon{CLOSED}$ or $\tscon{LISTEN}$ state; or on WinXP the socket is not bound,

\\\hline
$\tscon{EISCONN}$
&  On WinXP the socket is already connected: it is not in the $\tscon{CLOSED}$ or
   $\tscon{LISTEN}$ state.

\\\hline
$\tscon{EOPNOTSUPP}$
&  The $\tslib{listen}()$ operation is not supported for UDP.

\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
   A TCP socket is created, has its local address and port set by $\tslib{bind}()$, and then is put into
   the $\tscon{LISTEN}$ state which can accept new incoming connections: $\tsrule{socket\_1}$; $\tsrule{return\_1}$;
   $\tsrule{bind\_1}$ $\tsrule{return\_1}$; $\tsrule{listen\_1}$; $\tsrule{return\_1}$; $\dots$

}\clustersubsection{API}
\seccomm{
   \begin{tabular}{ll}
     Posix:   & \wasverb{int listen(int socket, int backlog);} \\
     FreeBSD: & \wasverb{int listen(int s, int backlog);} \\
     Linux:   & \wasverb{int listen(int s, int backlog);} \\
     WinXP:   & \wasverb{int listen(SOCKET s, int backlog);} \\
   \end{tabular}

   In the Posix interface:

   \begin{itemize}

     \item \wasverb{socket} is a file descriptor referring to the socket to put into the $\tscon{LISTEN}$
      state, corresponding to the $\tstype{fd}$ argument of the model $\tslib{listen}()$.

     \item \wasverb{backlog} is an \wasverb{int} on which the maximum permitted length of the
      socket's listen queue depends. It corresponds to the $\tsvar{n}$ argument of the model $\tslib{listen}()$.

     \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
      indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
      indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual
      error code available through a call to \wasverb{WSAGetLastError()}.

    \end{itemize}

}\clustersubsection{Model details}
\seccomm{
   The following errors are not modelled:

   \begin{itemize}

     \item In Posix, $\tscon{EACCES}$ may be returned if the calling process does not have the appropriate
      privileges. This is not modelled here.

     \item In Posix, $\tscon{EDESTADDRREQ}$ shall be returned if the socket is not bound to a local
      address and the protocol does not support listening on an unbound socket. WinXP returns an
      $\tscon{EINVAL}$ error in this case; FreeBSD and Linux autobind the socket if $\tslib{listen}()$ is called
      on an unbound socket.

     \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
      Windows Sockets 1.1 call is in progress, or the service provider is still processing a
      callback function". This is not modelled here.

   \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{listen\_1}$
& \textbf{tcp: fast succeed}
&  Successfully put socket in $\tscon{LISTEN}$ state \\
$\tsrule{listen\_1b}$
& \textbf{tcp: fast succeed}
&  Successfully update backlog value \\
$\tsrule{listen\_1c}$
& \textbf{tcp: fast succeed}
&  Successfully put socket in the $\tscon{LISTEN}$ state from any non-$\{\tscon{CLOSED};\tscon{LISTEN}\}$ state on FreeBSD \\
$\tsrule{listen\_2}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{EINVAL}$ on WinXP: socket not bound to local port \\
$\tsrule{listen\_3}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{EINVAL}$ on Linux or $\tscon{EISCONN}$ on WinXP: socket not in $\tscon{CLOSED}$ or $\tscon{LISTEN}$ state \\
$\tsrule{listen\_4}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{EADDRINUSE}$ on Linux: another socket already listening on local port \\
$\tsrule{listen\_5}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{EINVAL}$ on BSD: socket shutdown for writing or $\tsfield{bsd\_cantconnect}$ flag set \\
$\tsrule{listen\_7}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{EOPNOTSUPP}$: $\tslib{listen}()$ called on UDP socket \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\listenTI}{\rrulecc{listenTI}{listen\_1}{tcp: fast succeed}{\tsholcomm{ Successfully put socket in $\tscon{LISTEN}$ state }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{CLOSED},\tsvar{cb},*,[\,],*,[\,],*,\tscon{NO\_OOBDATA})))] ;{}\\{}
 \tslib{listen} \Mass  \tsvar{listen}_{0} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{listen}(\tsvar{fd},\tsvar{n})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis},[\,],*,[\,],*,\tscon{NO\_OOBDATA})))] ;{}\\{}
 \tslib{listen} \Mass  \tsvar{sid} \Mcons  \tsvar{listen}_{0};{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mvee  \tsvar{cantrcvmore} = \Mfalse ) \Mwedge {}\\{}
 \neg{}(\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsunknown{IS\_NONE} \;\tsvar{ps}_{1}) \Mwedge {}\\{}
 (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \implies  \tsvar{cb}.\tsfield{bsd\_cantconnect} = \Mfalse ) \Mwedge {}\\{}
 \tsvar{p}_{1} \;\in  \;\tsaux{autobind}(\tsvar{ps}_{1},\tscon{PROTO\_TCP},\tsvar{h},\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}.\tsvar{bound}) \Mwedge {}\\{}
 \tsvar{lis} = \Mmagiclrec  \tsvar{q}_{0} \Mass  [\,];{}\\{}
 \tsvar{q}  \Mass  [\,];{}\\{}
 \tsvar{qlimit} \Mass  \tsvar{n} \Mmagicrrec }
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is currently in the $\tscon{Run}$ state, a $\tslib{listen}(\tsvar{fd},\tsvar{n})$ call is
   made. $\tsvar{fd}$ is a file descriptor referring to a TCP socket identified by $\tsvar{sid}$ which is not
   shutdown for writing, is in the $\tscon{CLOSED}$ state, has an empty send and receive queue, and does
   not have its send or receive urgent pointers set. The host's list of listening sockets is
   $\tsvar{listen}_{0}$. Either the socket is bound to a local port $\tsvar{p}_{1}$, or it can be autobound to a local
   port $\tsvar{p}_{1}$.

   The call succeeds: a $\MLhcall{\tsvar{tid}}{\tslib{listen}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread in
   state $\tscon{Ret} (\tscon{OK}())$. The socket is put in the $\tscon{LISTEN}$ state, with an empty listen queue,
   $\tsvar{lis}$, with $\tsvar{n}$ as its backlog. $\tsvar{sid}$ is added to the host's list of listening sockets,
   $\tslib{listen} \Mass  \tsvar{sid}\Mcons \tsvar{listen}_{0}$, and if autobinding occurred, it is also added to the host's list of
   bound sockets, $\tsvar{h}.\tsvar{bound}$, to create a new list $\tsvar{bound}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   The $\tsfield{bsd\_cantconnect}$ flag in the control block must not be set to $\Mtrue $ (from an earlier
   connection establishment attempt).

\\\hline
WinXP
&
   As above, except that the socket must be bound to a local port $\tsvar{p}_{1}$. If it is not bound then
   autobinding will not occur: the call will fail with an $\tscon{EINVAL}$ error. See also \ltslink{listenTII}{$\tsrule{listen\_2}$}.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\listenTIb}{\rrulecc{listenTIb}{listen\_1b}{tcp: fast succeed}{\tsholcomm{ Successfully update backlog value }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis},[\,],*,[\,],*,\tscon{NO\_OOBDATA})))] ;{}\\{}
 \tslib{listen} \Mass  \tsvar{listen}_{0} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{listen}(\tsvar{fd},\tsvar{n})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis}',[\,],*,[\,],*,\tscon{NO\_OOBDATA})))] ;{}\\{}
 \tslib{listen} \Mass  \tsvar{sid} \Mcons  \tsvar{listen}_{0} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mvee  \tsvar{cantrcvmore} = \Mfalse ) \Mwedge {}\\{}
 \tsvar{lis}' = \tsvar{lis} \; \Mmagiclrec  \tsvar{qlimit} \Mass  \tsvar{n} \Mmagicrrec }
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{listen}(\tsvar{fd},\tsvar{n})$ call is made. $\tsvar{fd}$
   refers to a TCP socket identified by $\tsvar{sid}$ which is currently in the $\tscon{LISTEN}$ state. The host
   has a list of listening sockets, $\tsvar{listen}_{0}$. The call succeeds.

   A $\MLhcall{\tsvar{tid}}{\tslib{listen}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$. The backlog value of the socket's listen queue, $\tsvar{lis}.\tsvar{qlimit}$ is updated to be $\tsvar{n}$,
   resulting in a new listen queue $\tsvar{lis}'$ for the socket. $\tsvar{sid}$ is added to the head of the
   host's listen queue, $\tslib{listen} \Mass  \tsvar{sid}\Mcons \tsvar{listen}_{0}$.

\rrulepad }
}

\newcommand{\listenTIc}{\rrulecc{listenTIc}{listen\_1c}{tcp: fast succeed}{\tsholcomm{ Successfully put socket in the $\tscon{LISTEN}$ state from any non-$\{\tscon{CLOSED};\tscon{LISTEN}\}$ state on FreeBSD }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tslib{listen} \Mass  \tsvar{listen}_{0} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{listen}(\tsvar{fd},\tsvar{n})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock}')];{}\\{}
 \tslib{listen} \Mass  \tsvar{sid} \Mcons  \tsvar{listen}_{0} \Mmagicrrec }
{\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{TCP\_PROTO}(\tsunknown{tcp\_sock})) \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \;\notin  \{\tscon{CLOSED}; \tscon{LISTEN}\} \Mwedge {}\\{}
 \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{st} \Mass  \tscon{LISTEN}; \tsvar{lis} \Mass  \Msome  \;\tsvar{lis} \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{lis} = \Mmagiclrec  \tsvar{q}_{0} \Mass  [\,];{}\\{}
 \tsvar{q}  \Mass  [\,];{}\\{}
 \tsvar{qlimit} \Mass  \tsvar{n} \Mmagicrrec }
{\rulesubsection{Description}

   On BSD, calling $\tslib{listen}()$ always succeeds on a socket regardless of its state: the state of the
   socket is just changed to $\tscon{LISTEN}$.

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{listen}(\tsvar{fd},\tsvar{n})$ call is made. $\tsvar{fd}$
   refers to a TCP socket identified by $\tsvar{sid}$ which is currently in any non-$\{\tscon{CLOSED};\tscon{LISTEN}\}$
   state. The call succeeds.

   A $\MLhcall{\tsvar{tid}}{\tslib{listen}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$. The socket state is updated to $\tscon{LISTEN}$, with empty listen queues.


\rrulepad }
}

\newcommand{\listenTII}{\rrulecc{listenTII}{listen\_2}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{EINVAL}$ on WinXP: socket not bound to local port }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{listen}(\tsvar{fd},\tsvar{n})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge   {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{socks}}{\tsvar{sid}} = \tsvar{sock} \Mwedge {}\\{}
 \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tscon{PROTO\_TCP} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{ps}_{1} = *}
{\rulesubsection{Description}

   On WinXP, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{listen}(\tsvar{fd},\tsvar{n})$ call is
   made. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sock}$, identified by $\tsvar{sid}$, which is not bound to a
   local port: $\tsvar{sock}.\tsvar{ps}_{1} = *$. The call fails with an $\tscon{EINVAL}$ error.

   A $\MLhcall{\tsvar{tid}}{\tslib{listen}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   This rule does not apply.

\\\hline
Linux
&
   This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\listenTIII}{\rrulecc{listenTIII}{listen\_3}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{EINVAL}$ on Linux or $\tscon{EISCONN}$ on WinXP: socket not in $\tscon{CLOSED}$ or $\tscon{LISTEN}$ state }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{listen}(\tsvar{fd},\tsvar{n})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{socks}}{\tsvar{sid}} = \tsvar{sock} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \;\notin  \{\tscon{CLOSED}; \tscon{LISTEN}\} \Mwedge {}\\{}
 \neg{}(\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge   {}\\{}
 (\Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad \tsvar{err} = \tscon{EISCONN}{}\\{}
 \Melse  \;\Mif  \;\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad \tsvar{err} = \tscon{EINVAL}{}\\{}
 \Melse {}\\{}
\quad \Mfalse )}
{\rulesubsection{Description}

   From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{listen}(\tsvar{fd},\tsvar{n})$ call is made. $\tsvar{fd}$
   refers to a TCP socket $\tsvar{sock}$, identified by $\tsvar{sid}$, which is not in the $\tscon{CLOSED}$ or
   $\tscon{LISTEN}$ state. On Linux the call fails with an $\tscon{EINVAL}$ error; on WinXP it fails with an
   $\tscon{EISCONN}$ error.

   A $\MLhcall{\tsvar{tid}}{\tslib{listen}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$ where $\tsvar{err}$ is one of the above errors.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   This rule does not apply: $\tslib{listen}()$ can be called from any state.

\\\hline
Linux
&
   As above: the call fails with an $\tscon{EINVAL}$ error.

\\\hline
WinXP
&
   As above: the call fails with an $\tscon{EISCONN}$ error.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\listenTIV}{\rrulecc{listenTIV}{listen\_4}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{EADDRINUSE}$ on Linux: another socket already listening on local port }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{listen}(\tsvar{fd},\tsvar{n})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EADDRINUSE}})}{ \tsaux{sched\_timer}}} \Mmagicrrec }
{\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} = \tsvar{sock} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSED} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge {}\\{}
 (\exists \tsvar{sid}' \;\tsvar{sock}' \;\tsunknown{tcp\_sock'}. \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}'} = \tsvar{sock}' \Mwedge  \tsvar{sock}'.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock'}.\tsvar{st} = \tscon{LISTEN} \Mwedge  \tsvar{sock}'.\tsvar{ps}_{1} = \tsvar{sock}.\tsvar{ps}_{1} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \neg{}(\exists \tsvar{i}_{1} \;\tsvar{i}'_{1}. \tsvar{i}_{1} \neq  \tsvar{i}'_{1} \Mwedge  \tsvar{sock}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsvar{sock}'.\tsvar{is}_{1} = \Msome  \;\tsvar{i}'_{1}))}
{\rulesubsection{Description}

     On Linux, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{listen}(\tsvar{fd},\tsvar{n})$ call is
     made. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sock}$, identified by $\tsvar{sid}$, in state $\tscon{CLOSED}$ and
     bound to local port $\tsvar{p}_{1}$. There is another TCP socket, $\tsvar{sock}'$, in the host's finite map of
     sockets, $\tsvar{h}.\tsvar{socks}$ that is also bound to local port $\tsvar{p}_{1}$, and is in the $\tscon{LISTEN}$
     state. The two sockets, $\tsvar{sock}$ and $\tsvar{sock}'$, are not bound to different IP addresses: either
     they are both bound to the same IP address, one is bound to an IP address and the other is not
     bound to an IP address, or neither is bound to an IP address. The call fails with an
     $\tscon{EADDRINUSE}$ error.

     A $\MLhcall{\tsvar{tid}}{\tslib{listen}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EADDRINUSE}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
     This rule does not apply.

\\\hline
WinXP
&
     This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\listenTV}{\rrulecc{listenTV}{listen\_5}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{EINVAL}$ on BSD: socket shutdown for writing or $\tsfield{bsd\_cantconnect}$ flag set }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantsndmore} \Mass  \tsvar{cantsndmore}; \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{st} \Mass  \tsvar{st} \Mmagicrrec ) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{listen}(\tsvar{fd},\tsvar{n})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})}{ \tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantsndmore} \Mass  \tsvar{cantsndmore}; \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{st} \Mass  \tsvar{st} \Mmagicrrec ) \Mmagicrrec )] \Mmagicrrec }
{\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{st} \;\in  \{\tscon{CLOSED}; \tscon{LISTEN}\} \Mwedge  {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsvar{cantsndmore} = \Mtrue  \Mvee  \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{bsd\_cantconnect} = \Mtrue )}
{\rulesubsection{Description}

    On FreeBSD, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{listen}(\tsvar{fd},\tsvar{n})$ call is
    made. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sock}$, identified by $\tsvar{sid}$, which is in the $\tscon{CLOSED}$
    or $\tscon{LISTEN}$ state. The socket is either shutdown for writing or has its $\tsfield{bsd\_cantconnect}$
    flag set due to an earlier connection-establishment attempt. The call fails with an $\tscon{EINVAL}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{listen}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    This rule does not apply.

\\\hline
WinXP
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\listenTVII}{\rrulecc{listenTVII}{listen\_7}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{EOPNOTSUPP}$: $\tslib{listen}()$ called on UDP socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{listen}(\tsvar{fd},\tsvar{n})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EOPNOTSUPP}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tscon{PROTO\_UDP}}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in the
    $\tscon{Run}$ state, a $\tslib{listen}(\tsvar{fd},\tsvar{n})$ call is made. The call fails with an $\tscon{EOPNOTSUPP}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{listen}(\tsvar{fd},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EOPNOTSUPP}})$.

    Calling $\tslib{listen}()$ on a socket for a connectionless protocol (such as UDP) is meaningless
    and is thus an unsupported ($\tscon{EOPNOTSUPP}$) operation.

\rrulepad }
}

\newcommand{\seccommpselect}{\clustersection{(TCP and UDP)}{$\tslib{pselect}()$}
\seccomm{  \[ \tslib{pselect}: (\tstype{fd} \;\tstype{list} * \tstype{fd} \;\tstype{list} * \tstype{fd} \;\tstype{list} * (\tstype{int} * \tstype{int}) \;\tstype{option} * \tstype{signal} \;\tstype{list} \;\;\tstype{option}) \Mtotype  (\tstype{fd} \;\tstype{list} * (\tstype{fd} \;\tstype{list} * \tstype{fd} \;\tstype{list})) \]

  A call to $\tslib{pselect}(\tsunknown{readfds},\tsunknown{writefds},\tsunknown{exceptfds},\tsunknown{timeout},\tsunknown{sigmask})$ waits for one of the file
  descriptors in $\tsunknown{readfds}$ to be ready for reading, $\tsunknown{writefds}$ to be ready for writing,
  $\tsunknown{exceptfds}$ to have a pending error, or for $\tsunknown{timeout}$ to expire.

  The $\tsunknown{readfds}$ argument is a set of file descriptors to be checked for being ready to read. Broadly, a
  file descriptor $\tstype{fd}$ is ready for reading if a $\tslib{recv}(\tstype{fd},\tsunknown{\_},\tsunknown{\_})$ call on the socket would not
  block, i.e.~if there is data present or a pending error.

  The $\tsunknown{writefds}$ argument is a set of file descriptors to be checked for being ready to write. Broadly, a
  file descriptor $\tstype{fd}$ is ready for writing if a $\tslib{send}(\tstype{fd},\tsunknown{\_},\tsunknown{\_},\tsunknown{\_})$ call would not block.

  The $\tsunknown{exceptfds}$ argument is a set of file descriptors to be checked for exception conditions
  pending. A file descriptor $\tstype{fd}$ has an exception condition pending if there exists out-of-band
  data for the socket it refers to or the socket is still at the out-of-band mark.

  The $\tsunknown{timeout}$ argument specifies how long the $\tslib{pselect}()$ call should block waiting for a file
  descriptor to be ready. If $\tsunknown{timeout}=*$ then the call should block until one of the file
  descriptors in the $\tsunknown{readfds}$, $\tsunknown{writefds}$, or $\tsunknown{exceptfds}$ becomes ready. If
  $\tsunknown{timeout}=\Msome (\tsunknown{s},\tsunknown{ns})$ then the call should block for at most $\tsunknown{s}$ seconds and $\tsunknown{ns}$
  nanoseconds. However, system activity can lengthen the timeout interval by an indeterminate
  amount.

  The $\tsunknown{sigmask}$ argument is used to set the signal mask, the set of signals to be blocked. In the
  implementations, if $\tsunknown{sigmask}=\Msome (\tsunknown{siglist})$ then $\tslib{pselect}()$ first replaces the current signal
  mask by $\tsunknown{siglist}$ before proceeding with the call, and then restores the original signal mask
  upon return.  This specification does not model the dynamic behaviour of signals, however, and so
  we specify the behaviour of $\tslib{pselect}()$ only for an empty signal mask.

  A return value of $(\tsunknown{readfds'},(\tsunknown{writefds'},\tsunknown{exceptfds'}))$ from a $\tslib{pselect}()$ call signifies that:
  the file descriptors in $\tsunknown{readfds'}$ are ready for reading; the file descriptors in $\tsunknown{writefds'}$
  are reading for writing; and the file descriptors in $\tsunknown{exceptfds'}$ have exceptional conditions
  pending.

  If a $\tslib{pselect}([\,],[\,],[\,],\tsunknown{Some}(\tsunknown{s},\tsunknown{ns}),\tsunknown{sigmask})$ call is made then the call will block for $\tsunknown{s}$
  seconds and $\tsunknown{ns}$ nano-seconds or until a signal occurs.

  To perform a poll, a $\tslib{pselect}(\tsunknown{readfds},\tsunknown{writefds},\tsunknown{exceptfds},\tsunknown{Some}(0,0),\tsunknown{sigmask})$ call should be
  made.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{pselect}()$ can fail with the errors below, in which case the corresponding exception
  is raised:

\par\begin{ltstabular}
$\tscon{EBADF}$
&  One or more of the file descriptors in a set is not a valid file descriptor.

\\\hline
$\tscon{EINVAL}$
&  Time-out not well-formed, file descriptor out of range, or on WinXP all file descriptor sets are empty.

\\\hline
$\tscon{ENOTSOCK}$
&  One or more of the file descriptors in a set is not a valid socket.

\\\hline
$\tscon{EINTR}$
&  The system was interrupted by a caught signal.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
\

$\tslib{pselect}()$ is called and returns immediately:
  $\tsrule{pselect\_1}$; $\tsrule{return\_1}$

$\tslib{pselect}()$ blocks and then times out before any of the file descriptors become ready:
  $\tsrule{pselect\_2}$; $\tsrule{pselect\_3}$; $\tsrule{return\_1}$

$\tslib{pselect}()$ blocks, TCP data is received from the network and processed, making a file descriptor ready for reading, and then $\tslib{pselect}()$ returns:
  $\tsrule{pselect\_1}$; $\tsrule{deliver\_in\_99}$; $\tsrule{deliver\_in\_3}$; $\tsrule{pselect\_2}$; $\tsrule{return\_1}$

$\tslib{pselect}()$ blocks, UDP data is received from the network and processed, making a file descriptor ready for reading, and then $\tslib{pselect}()$ returns:
  $\tsrule{pselect\_1}$; $\tsrule{deliver\_in\_99}$; $\tsrule{deliver\_in\_udp\_1}$; $\tsrule{pselect\_2}$; $\tsrule{return\_1}$

$\tslib{pselect}()$ blocks, TCP data is sent to the network, an acknowledgement is received and processed, making a file descriptor ready for writing, and then $\tslib{pselect}()$ returns:
  $\tsrule{pselect\_1}$; $\tsrule{deliver\_out\_1}$; $\tsrule{deliver\_out\_99}$; $\tsrule{deliver\_in\_99}$; $\tsrule{deliver\_in\_3}$;
  $\tsrule{pselect\_2}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:   &\wasverb{int pselect(int nfds, fd\textunderscore{}set *restrict readfds,} \\
             &\wasverb{            fd\textunderscore{}set *restrict writefds, fd\textunderscore{}set *restrict errorfds,} \\
             &\wasverb{            const struct timespec *restrict timeout,} \\
             &\wasverb{            const sigset\textunderscore{}t *restrict sigmask);} \\
    FreeBSD: &\wasverb{int select(int nfds, fd\textunderscore{}set *readfds, fd\textunderscore{}set *writefds,} \\
             &\wasverb{           fd\textunderscore{}set *exceptfds, struct timeval *timeout);} \\
    Linux:   &\wasverb{int pselect(int n, fd\textunderscore{}set *readfds, fd\textunderscore{}set *writefds,}\\
             &\wasverb{            fd\textunderscore{}set *exceptfds, const struct timespec *timeout,} \\
             &\wasverb{            const sigset\textunderscore{}t *sigmask);} \\
    WinXP:   &\wasverb{int select(int nfds, fd\textunderscore{}set* readfds, fd\textunderscore{}set* writefds,} \\
             &\wasverb{           fd\textunderscore{}set* exceptfds, const struct timeval* timeout);}\\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{nfds} specifies the range of file descriptors to be tested. The first
     \wasverb{nfds} file descriptors shall be checked in each set. This is not necessary in the
     model $\tslib{pselect}()$ as the file descriptor sets are implemented as a $\tstype{list}$ rather than the
     integer arrays in Posix \wasverb{pselect()}.

    \item \wasverb{readfds} on input specifies the file descriptors to be checked for being ready to
     read, corresponding to the $\tsunknown{readfds}$ argument of the model $\tslib{pselect}()$. On output
     \wasverb{readfds} indicates which of the file descriptors specified on input are ready to read,
     corresponding to the first $\tstype{fd} \;\tstype{list}$ in the return type of the model $\tslib{pselect}()$. An
     \wasverb{fd\textunderscore{}set} is an integer array, where each bit of each integer corresponds to a file
     descriptor. If that bit is set then that file descriptor should be
     checked. \wasverb{FD\textunderscore{}CLR()}, \wasverb{FD\textunderscore{}ISSET()}, \wasverb{FD\textunderscore{}SET()}, and
     \wasverb{FD\textunderscore{}ZERO()} are provided to set bits in an \wasverb{fd\textunderscore{}set}.

    \item \wasverb{writefds} on input specifies the file descriptors to be checked for being ready
     to write, corresponding to the $\tsunknown{writefds}$ argument of the model $\tslib{pselect}()$. On output
     \wasverb{writefds} indicates which of the file descriptors specified on input are ready to
     write, corresponding to the second $\tstype{fd} \;\tstype{list}$ in the return type of the model $\tslib{pselect}()$.

    \item \wasverb{errorfds} on input specifies the file descriptors to be checked for pending error
     conditions, corresponding to the $\tsunknown{exceptfds}$ argument of the model $\tslib{pselect}()$. On output
     \wasverb{exceptfds} indicated which of the file descriptors specified on input have pending
     error conditions, corresponding to the third $\tstype{fd} \;\tstype{list}$ in the return type of the model
     $\tslib{pselect}()$.

    \item \wasverb{timeout} specifies how long the \wasverb{pselect()} call shall block before
     timing out, corresponding to the $\tsunknown{timeout}$ argument of the model $\tslib{pselect}()$. If the
     \wasverb{timeout} parameter is a null pointer this corresponds to $\tsunknown{timeout}=*$; if the
     \wasverb{timeout} parameter is not a null pointer, then its two fields,
     \wasverb{timeout.tv\textunderscore{}sec} (the number of seconds) and \wasverb{timeout.tv\textunderscore{}nsec} (the number of
     nano-seconds), correspond to $\tsunknown{timeout}=\Msome (\tsunknown{s},\tsunknown{ns})$ where $\tsunknown{s}$ is the number of seconds, and
     $\tsunknown{ns}$ is the number of nano-seconds.

    \item \wasverb{sigmask} is the signal-mask to be used when examining the file descriptors,
     corresponding to the $\tsunknown{sigmask}$ argument of the model $\tslib{pselect}()$. If \wasverb{sigmask} is a
     null pointer then $\tsunknown{sigmask} = *$ in the model; if \wasverb{sigmask} is not a null pointer
     then $\tsunknown{sigmask} = \Msome  \;\tsunknown{sigs}$ in the model where $\tsunknown{sigs}$ is the signal-mask to use.

    \item if the call is successful then the returned \wasverb{int} is the number of bits set in the
     three \wasverb{fd\textunderscore{}set} arguments: the total number of file descriptors ready for reading,
     writing, or having exceptional conditions pending. Otherwise, the returned \wasverb{int} is
     \wasverb{-1} to indicate an error, in which case the error code is in \wasverb{errno}.  On
     WinXP an error is indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1},
     with the actual error code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  The Linux interface is similar. On FreeBSD and WinXP there is no \wasverb{pselect()} call, only a
  \wasverb{select()} call which is the same as the interface described above, except without the
  \wasverb{sigmask} argument. The \wasverb{select()} call corresponds to calling the model
  $\tslib{pselect}()$ with $\tsunknown{sigmask}=*$. Additionally, the \wasverb{timeout} argument is a pointer to
  a \wasverb{timeval} structure which has two members \wasverb{tv\textunderscore{}sec} and \wasverb{tv\textunderscore{}usec},
  specifying the seconds and micro-seconds to block for, rather than seconds and nano-seconds.

  The FreeBSD man page for \wasverb{select()} warns of the following bug: "Version 2 of the Single
  UNIX Specification ("SUSv2") allows systems to modify the original timeout in place.  Thus, it is
  unwise to assume that the timeout value will be unmodified by the select() call."

}\clustersubsection{Model details}
\seccomm{
  If the $\tslib{pselect}()$ call blocks then the thread enters state $\tscon{PSelect2}(\tsunknown{readfds},\tsunknown{writefds},\tsunknown{exceptfds})$ where:

  \begin{itemize}

  \item $\tsunknown{readfds} : \tstype{fd} \;\tstype{list}$ is the list of file descriptors to be checked for being ready to read.

  \item $\tsunknown{writefds} : \tstype{fd} \;\tstype{list}$ is the list of file descriptors to be checked for being ready to
  write.

  \item $\tsunknown{exceptfds} : \tstype{fd} \;\tstype{list}$ is the list of file descriptors to be checked for pending
  exceptional conditions.

  \end{itemize}

  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{pselect\_1}$
& \textbf{all: fast succeed}
&  One or more file descriptors immediately ready, or no timeout set \\
$\tsrule{soreadable}$
&
&  check whether a socket is readable \\
$\tsrule{sowriteable}$
&
&  check whether a socket is writable \\
$\tsrule{soexceptional}$
&
&  check whether a socket is exceptional \\
$\tsrule{pselect\_2}$
& \textbf{all: block}
&  Normal case \\
$\tsrule{pselect\_3}$
& \textbf{all: slow nonurgent succeed}
&  Something becomes ready or pselect times out \\
$\tsrule{pselect\_4}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EINVAL}$: Timeout not well-formed \\
$\tsrule{pselect\_5}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EINVAL}$: File descriptor out of range \\
$\tsrule{pselect\_6}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EBADF}$ or $\tscon{ENOTSOCK}$: Bad file descriptor \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\pselectTI}{\rrulecc{pselectTI}{pselect\_1}{all: fast succeed}{\tsholcomm{ One or more file descriptors immediately ready, or no timeout set }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{pselect}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds},\tsvar{timeout},\tsvar{sigmask})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK}(\tsvar{readfds}'',\tsvar{writefds}'',\tsvar{exceptfds}''))}{ \tsaux{sched\_timer}}} \Mmagicrrec }
{(\tsaux{tltimeopt\_wf} \;\tsvar{timeout} \Mvee  \tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch})\Mwedge {}\\{}
 \tsvar{sigmask} = * \Mwedge {}\\{}
 \neg{}(\exists \tsvar{fd} \;\tsvar{n}. (\tsvar{fd} \;\in  \;\tsvar{readfds} \Mvee  \tsvar{fd} \;\in  \;\tsvar{writefds} \Mvee  \tsvar{fd} \;\in  \;\tsvar{exceptfds}) \Mwedge {}\\{}
\quad\quad\quad\quad \Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}{}\\{}
\quad\quad\quad\quad \Mthen  \;\tsvar{n} = (\tsholop{MAX} (\tsholop{LENGTH} \;\tsvar{readfds}) (\tsholop{MAX} (\tsholop{LENGTH} \;\tsvar{writefds}) (\tsholop{LENGTH} \;\tsvar{exceptfds}))) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{n} \geq  (\tsaux{FD\_SETSIZE} \;\tsvar{h}.\tstype{arch}){}\\{}
\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad \tsvar{fd} = \tscon{FD} \;\tsvar{n} \Mwedge {}\\{}
\quad\quad\quad\quad \tsvar{n} \geq  \tsaux{FD\_SETSIZE} \;\tsvar{h}.\tstype{arch}) \Mwedge {}\\{}
 \tsvar{badreadfds} = \tsholop{FILTER} (\lambda \tsvar{fd}. \tsvar{fd} \;\notin  \Mfdom{\tsvar{h}.\tsvar{fds}}) \tsvar{readfds} \Mwedge {}\\{}
 \tsvar{badwritefds} = \tsholop{FILTER} (\lambda \tsvar{fd}. \tsvar{fd} \;\notin  \Mfdom{\tsvar{h}.\tsvar{fds}}) \tsvar{writefds} \Mwedge {}\\{}
 \tsvar{badexceptfds} = \tsholop{FILTER} (\lambda \tsvar{fd}. \tsvar{fd} \;\notin  \Mfdom{\tsvar{h}.\tsvar{fds}}) \tsvar{exceptfds} \Mwedge {}\\{}
 (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mvee  {}\\{}
 (\tsvar{badreadfds} = [\,] \Mwedge  \tsvar{badwritefds} = [\,] \Mwedge  \tsvar{badexceptfds} = [\,])) \Mwedge {}\\{}
 \neg{}(\exists \tsvar{fd}.   (\tsvar{fd} \;\in  \;\tsvar{readfds} \Mvee  \tsvar{fd} \;\in  \;\tsvar{writefds} \Mvee  \tsvar{fd} \;\in  \;\tsvar{exceptfds}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{fd} \;\notin  \Mfdom{\tsvar{h}.\tsvar{fds}}) \Mwedge {}\\{}
 \tsvar{readfds}' = \tsholop{FILTER} (\lambda \tsvar{fd}. \exists \tsvar{fid} \;\tsvar{ff} \;\tsvar{sid} \;\tsvar{sock}.{}\\{}
\quad \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
\quad \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
\quad \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
\quad \tsvar{sock} = \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
\quad \tsaux{soreadable} \;\tsvar{h}.\tstype{arch} \;\tsvar{sock}) \tsvar{readfds} \Mwedge {}\\{}
 \tsvar{writefds}' = \tsholop{FILTER} (\lambda \tsvar{fd}. \exists \tsvar{fid} \;\tsvar{ff} \;\tsvar{sid} \;\tsvar{sock}.{}\\{}
\quad \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
\quad \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
\quad \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
\quad \tsvar{sock} = \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
\quad \tsaux{sowriteable} \;\tsvar{h}.\tstype{arch} \;\tsvar{sock}) \tsvar{writefds} \Mwedge {}\\{}
 \tsvar{exceptfds}' = \tsholop{FILTER} (\lambda \tsvar{fd}. \exists \tsvar{fid} \;\tsvar{ff} \;\tsvar{sid} \;\tsvar{sock}.{}\\{}
\quad \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
\quad \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
\quad \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
\quad \tsvar{sock} = \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
\quad \tsaux{soexceptional} \;\tsvar{h}.\tstype{arch} \;\tsvar{sock}) \tsvar{exceptfds} \Mwedge {}\\{}
 (\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \implies  \tsvar{readfds} \neq  [\,] \Mwedge  \tsvar{writefds} \neq  [\,] \Mwedge  \tsvar{exceptfds} \neq  [\,]) \Mwedge {}\\{}
 (\tsvar{readfds}' \neq  [\,] \Mvee  \tsvar{writefds}' \neq  [\,] \Mvee  \tsvar{exceptfds}' \neq  [\,] \Mvee  \tsvar{timeout}=\Msome (0,0)) \Mwedge {}\\{}
 \Mif  \;\tsaux{windows\_arch}  \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad\quad \tsvar{readfds}''=\tsvar{readfds}' \Mwedge  \tsvar{writefds}''=\tsvar{writefds}' \Mwedge  \tsvar{exceptfds}''=\tsvar{exceptfds}'{}\\{}
 \Melse {}\\{}
\quad\quad \tsvar{readfds}'' = \tsaux{INSERT\_ORDERED} \;\tsvar{readfds}' \;\tsvar{readfds} \;\tsvar{badreadfds} \Mwedge {}\\{}
\quad\quad \tsvar{writefds}'' = \tsaux{INSERT\_ORDERED} \;\tsvar{writefds}' \;\tsvar{writefds} \;\tsvar{badwritefds} \Mwedge {}\\{}
\quad\quad \tsvar{exceptfds}'' = \tsaux{INSERT\_ORDERED} \;\tsvar{exceptfds}' \;\tsvar{exceptfds} \;\tsvar{badexceptfds}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a
    $\tslib{pselect}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds},\tsvar{timeout},\tsvar{sigmask})$ call is made. The time-out is
    well-formed and no signal mask was set: $\tsvar{sigmask}=*$. All of the file descriptors in the
    sets $\tsvar{readfds}$, $\tsvar{writefds}$, and $\tsvar{exceptfds}$ are greater than the maximum allowed file
    descriptor in a set for the architecure, $\tsaux{FD\_SETSIZE}$, and all of them are valid file
    descriptors: they are in the host's finite map of file descriptors, $\tsvar{h}.\tsvar{fds}$.

    The call returns, without blocking, three sets: $\tsvar{readfds}''$, $\tsvar{writefds}''$, and
    $\tsvar{exceptfds}''$. $\tsvar{readfds}''$ is the set of valid file descriptors in $\tsvar{readfds}$ that are
    ready for reading: a blocking $\tslib{recv}(\tsvar{fd},\tsunknown{\_},\tsunknown{\_})$ call would not block; see \ltslink{soreadable}{$\tsaux{soreadable}$}
    for details. $\tsvar{writefds}''$ is the set of valid file descriptors in $\tsvar{writefds}$ that are ready
    for writing: a blocking $\tslib{send}(\tsvar{fd},\tsunknown{\_},\tsunknown{\_})$ call would not block; see \ltslink{sowriteable}{$\tsaux{sowriteable}$} for
    details. $\tsvar{exceptfds}''$ is the set of valid file descriptors in $\tsvar{exceptfds}$ that have pending
    exceptional conditions; see \ltslink{soexceptional}{$\tsaux{soexceptional}$} for details.

    One of these three sets must be non-empty or else a zero timeout was specified, $\tsvar{timeout}=\Msome (0,0)$. A
    $\MLhcall{\tsvar{tid}}{\tslib{pselect}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds},\tsvar{timeout},\tsvar{sigmask})}$ transition is made, leaving
    the thread state $\tscon{Ret} (\tscon{OK}(\tsvar{readfds}'',\tsvar{writefds}'',\tsvar{exceptfds}''))$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    Invalid file descriptors (ones not in the host's finite map of file descriptors, $\tsvar{h}.\tsvar{fds}$) may
    be present in the sets $\tsvar{readfds}$, $\tsvar{writefds}$, and $\tsvar{exceptfds}$, and all such file
    descriptors will then be included in the return sets $\tsvar{readfds}''$, $\tsvar{writefds}''$, and
    $\tsvar{exceptfds}''$.

\\\hline
WinXP
&
    On WinXP $\tsaux{FD\_SETSIZE}$ is the maximum number of file descriptors in a set, so none of the sets
    $\tsvar{readfds}$, $\tsvar{writefds}$, and $\tsvar{exceptfds}$ has more than $\tsaux{FD\_SETSIZE}$ members. Additionally,
    all three sets may not be empty.

    The time-out need not be well-formed because one or more file descriptors is immediately ready.



\end{ltstabular}\par
\rrulepad }
}

\newcommand{\defnsoreadable}{\ddefnc{soreadable}{\iA{soreadable}}{\subddefnA[{ check whether a socket is readable }]{soreadable}{\tsaux{soreadable} \;\tstype{arch} \;\tsunknown{sock} ={}\\{}
 \Mcase  \;\tsunknown{sock}.\tsvar{pr} \;\Mof {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp}) \Mtotype {}\\{}
\quad (\tsholop{LENGTH} \;\tsunknown{tcp}.\tsvar{rcvq} \geq  \tsunknown{sock}.\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT}) \Mvee {}\\{}
\quad \tsunknown{sock}.\tsvar{cantrcvmore} \Mvee {}\\{}
\quad (\tsaux{linux\_arch} \;\tstype{arch} \Mwedge  \tsunknown{tcp}.\tsvar{st} = \tscon{CLOSED}) \Mvee {}\\{}
\quad (\tsunknown{tcp}.\tsvar{st} = \tscon{LISTEN} \Mwedge {}\\{}
\quad\quad \exists \tsvar{lis}. \tsunknown{tcp}.\tsvar{lis} = \Msome  \;\tsvar{lis} \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{lis}.\tsvar{q} \neq  [\,]) \Mvee {}\\{}
\quad \tsunknown{sock}.\tsvar{es} \neq  *) \Mdpipe {}\\{}
 \tscon{UDP\_PROTO}(\tsunknown{udp}) \Mtotype {}\\{}
\quad (\tsunknown{udp}.\tsvar{rcvq} \neq  [\,] \Mvee  \tsunknown{sock}.\tsvar{es} \neq  * \Mvee  (\tsunknown{sock}.\tsvar{cantrcvmore} \Mwedge  \neg{}\tsaux{windows\_arch} \;\tstype{arch}))}
}
{\rulesubsection{Description}

A TCP socket $\tsunknown{sock}$ is readable if: (1) the length of its receive queue is greater than or equal
to the minimum number of bytes for socket input operations, $\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})$; (2) it has been
shut down for reading; (3) on Linux, it is in the $\tscon{CLOSED}$ state; it is in the $\tscon{LISTEN}$ state
and has at least one connection on its completed connection queue; or (4) it has a pending error.

A UDP socket $\tsunknown{sock}$ is readable if its receive queue is not empty, it has a pending error, or it
has been shutdown for reading.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
On all OSes, attempting to read from a closed socket yields an immediate error.  Only on Linux,
however, does $\tsaux{soreadable}$ return $\Mtrue $ in this case.

\\\hline
WinXP
&
The socket will not be readable if it has been shutdown for reading.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\defnsowriteable}{\ddefnc{sowriteable}{\iA{sowriteable}}{\subddefnA[{ check whether a socket is writable }]{sowriteable}{\tsaux{sowriteable} \;\tstype{arch} \;\tsunknown{sock} ={}\\{}
 \Mcase  \;\tsunknown{sock}.\tsvar{pr} \;\Mof {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp}) \Mtotype {}\\{}
\quad ((\tsunknown{tcp}.\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{CLOSE\_WAIT}\} \Mwedge {}\\{}
\quad\quad \tsunknown{sock}.\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDBUF}) - \tsholop{LENGTH} \;\tsunknown{tcp}.\tsvar{sndq}  \geq  \tsunknown{sock}.\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDLOWAT})) \Mvee  \tscomm{ change to send\textunderscore{}buffer\textunderscore{}space }{}\\{}
\quad (\Mif  \;\tsaux{linux\_arch} \;\tstype{arch} \;\Mthen  \neg{}\tsunknown{sock}.\tsvar{cantsndmore} \;\Melse  \;\tsunknown{sock}.\tsvar{cantsndmore}) \Mvee {}\\{}
\quad (\tsaux{linux\_arch} \;\tstype{arch} \Mwedge  \tsunknown{tcp}.\tsvar{st} = \tscon{CLOSED}) \Mvee {}\\{}
\quad \tsunknown{sock}.\tsvar{es} \neq  *) \Mdpipe {}\\{}
 \tscon{UDP\_PROTO}(\tsunknown{udp}) \Mtotype  \Mtrue }
}
{\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
On all OSes, attempting to write to a closed socket yields an immediate error.  Only on Linux,
however, does $\tsaux{sowriteable}$ return $\Mtrue $ in this case.

On Linux, if the outgoing half of the connection has been closed by the application, the socket
becomes non-writeable, whereas on other OSes it becomes writeable (because an immediate error would
result from writing).

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\defnsoexceptional}{\ddefnc{soexceptional}{\iA{soexceptional}}{\subddefnA[{ check whether a socket is exceptional }]{soexceptional}{\tsaux{soexceptional} \;\tstype{arch} \;\tsunknown{sock} ={}\\{}
 \Mcase  \;\tsunknown{sock}.\tsvar{pr} \;\Mof {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp}) \Mtotype {}\\{}
\quad (\tsunknown{tcp}.\tsvar{st} = \tscon{ESTABLISHED} \Mwedge {}\\{}
\quad (\tsunknown{tcp}.\tsvar{rcvurp} = \Msome  \;0 \Mvee {}\\{}
\quad\quad (\exists \tsvar{c}. \tsunknown{tcp}.\tsvar{iobc} = \tscon{OOBDATA} \;\tsvar{c}))) \Mdpipe {}\\{}
 \tscon{UDP\_PROTO}(\tsunknown{udp}) \Mtotype  \Mfalse }
}
{\rulesubsection{Description}

A TCP socket has a pending exceptional condition if it is in state $\tscon{ESTABLISHED}$ and has a pending
byte of out-of-band data.

A UDP socket never has a pending exceptional condition.

\rrulepad }
}

\newcommand{\pselectTII}{\rrulecc{pselectTII}{pselect\_2}{all: block}{\tsholcomm{ Normal case }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{pselect}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds},\tsvar{timeout},\tsvar{sigmask})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{PSelect2}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds})}{\tsaux{kern\_timer} \;\tsvar{d}'}} \Mmagicrrec }
{\tsaux{tltimeopt\_wf} \;\tsvar{timeout} \Mwedge {}\\{}
 \tsvar{d}' = \tsholop{MIN} (\tsaux{time\_of\_tltimeopt} \;\tsvar{timeout}) \tsaux{pselect\_timeo\_t\_max} \Mwedge {}\\{}
 \tsvar{sigmask} = * \Mwedge {}\\{}
 \neg{}(\exists \tsvar{fd} \;\tsvar{n}. (\tsvar{fd} \;\in  \;\tsvar{readfds} \Mvee  \tsvar{fd} \;\in  \;\tsvar{writefds} \Mvee  \tsvar{fd} \;\in  \;\tsvar{exceptfds}) \Mwedge {}\\{}
\quad\quad\quad\quad \Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}{}\\{}
\quad\quad\quad\quad \Mthen  \;\tsvar{n} = \tsholop{MAX} (\tsholop{LENGTH} \;\tsvar{readfds}) (\tsholop{MAX} (\tsholop{LENGTH} \;\tsvar{writefds}) (\tsholop{LENGTH} \;\tsvar{exceptfds})) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{n} \geq  \tsaux{FD\_SETSIZE} \;\tsvar{h}.\tstype{arch}{}\\{}
\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad \tsvar{fd} = \tscon{FD} \;\tsvar{n} \Mwedge {}\\{}
\quad\quad\quad\quad \tsvar{n} \geq  \tsaux{FD\_SETSIZE} \;\tsvar{h}.\tstype{arch}) \Mwedge {}\\{}
 \neg{}(\exists \tsvar{fd}.   (\tsvar{fd} \;\in  \;\tsvar{readfds} \Mvee  \tsvar{fd} \;\in  \;\tsvar{writefds} \Mvee  \tsvar{fd} \;\in  \;\tsvar{exceptfds}) \Mwedge {}\\{}
\quad\quad\quad\quad \tsvar{fd} \;\notin  \Mfdom{\tsvar{h}.\tsvar{fds}}) \Mwedge {}\\{}
 (\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \implies  \tsvar{readfds} \neq  [\,] \Mwedge  \tsvar{writefds} \neq  [\,] \Mwedge  \tsvar{exceptfds} \neq  [\,])}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a
    $\tslib{pselect}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds},\tsvar{timeout},\tsvar{sigmask})$ call is made. The time-out is
    well-formed and no signal mask was set: $\tsvar{sigmask}=*$. All of the file descriptors in the
    sets $\tsvar{readfds}$, $\tsvar{writefds}$, and $\tsvar{exceptfds}$ are greater than the maximum allowed file
    descriptor in a set for the architecure, $\tsaux{FD\_SETSIZE}$, and all of them are valid file
    descriptors: they are in the host's finite map of file descriptors, $\tsvar{h}.\tsvar{fds}$.

    The call blocks: a $\MLhcall{\tsvar{tid}}{\tslib{pselect}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds},\tsvar{timeout},\tsvar{sigmask})}$
    transition is made, leaving the thread state $\tscon{PSelect2}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    On WinXP $\tsaux{FD\_SETSIZE}$ is the maximum number of file descriptors in a set, so none of the sets
    $\tsvar{readfds}$, $\tsvar{writefds}$, and $\tsvar{exceptfds}$ has more than $\tsaux{FD\_SETSIZE}$ members. Additionally,
    all three sets may not be empty.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\pselectTIII}{\rrulecc{pselectTIII}{pselect\_3}{all: slow nonurgent succeed}{\tsholcomm{ Something becomes ready or pselect times out }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{PSelect2}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds})}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsvar{readfds}'',\tsvar{writefds}'',\tsvar{exceptfds}''))}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{readfds}' = \tsholop{FILTER} (\lambda \tsvar{fd}. \exists \tsvar{fid} \;\tsvar{ff} \;\tsvar{sid} \;\tsvar{sock}.{}\\{}
\quad \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
\quad \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
\quad \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
\quad \tsvar{sock} = \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
\quad \tsaux{soreadable} \;\tsvar{h}.\tstype{arch} \;\tsvar{sock}) \tsvar{readfds} \Mwedge {}\\{}
 \tsvar{writefds}' = \tsholop{FILTER} (\lambda \tsvar{fd}. \exists \tsvar{fid} \;\tsvar{ff} \;\tsvar{sid} \;\tsvar{sock}.{}\\{}
\quad \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
\quad \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
\quad \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
\quad \tsvar{sock} = \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
\quad \tsaux{sowriteable} \;\tsvar{h}.\tstype{arch} \;\tsvar{sock}) \tsvar{writefds} \Mwedge {}\\{}
 \tsvar{exceptfds}' = \tsholop{FILTER} (\lambda \tsvar{fd}. \exists \tsvar{fid} \;\tsvar{ff} \;\tsvar{sid} \;\tsvar{sock}.{}\\{}
\quad \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
\quad \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
\quad \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
\quad \tsvar{sock} = \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
\quad \tsaux{soexceptional} \;\tsvar{h}.\tstype{arch} \;\tsvar{sock}) \tsvar{exceptfds} \Mwedge {}\\{}
 (\tsvar{readfds}' \neq  [\,] \Mvee  \tsvar{writefds}' \neq  [\,] \Mvee  \tsvar{exceptfds}' \neq  [\,] \Mvee  \tsaux{timer\_expires} \;\tsvar{d}) \Mwedge {}\\{}
 \tsvar{badreadfds} = \tsholop{FILTER} (\lambda \tsvar{fd}. \tsvar{fd} \;\notin  \Mfdom{\tsvar{h}.\tsvar{fds}}) \tsvar{readfds} \Mwedge {}\\{}
 \tsvar{badwritefds} = \tsholop{FILTER} (\lambda \tsvar{fd}. \tsvar{fd} \;\notin  \Mfdom{\tsvar{h}.\tsvar{fds}}) \tsvar{writefds} \Mwedge {}\\{}
 \tsvar{badexceptfds} = \tsholop{FILTER} (\lambda \tsvar{fd}. \tsvar{fd} \;\notin  \Mfdom{\tsvar{h}.\tsvar{fds}}) \tsvar{exceptfds} \Mwedge {}\\{}
 \Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad\quad \tsvar{readfds}''=\tsvar{readfds}' \Mwedge  \tsvar{writefds}''=\tsvar{writefds}' \Mwedge  \tsvar{exceptfds}''=\tsvar{exceptfds}'{}\\{}
 \Melse {}\\{}
\quad\quad \tsvar{readfds}'' = \tsaux{INSERT\_ORDERED} \;\tsvar{readfds}' \;\tsvar{readfds} \;\tsvar{badreadfds} \Mwedge {}\\{}
\quad\quad \tsvar{writefds}'' = \tsaux{INSERT\_ORDERED} \;\tsvar{writefds}' \;\tsvar{writefds} \;\tsvar{badwritefds} \Mwedge {}\\{}
\quad\quad \tsvar{exceptfds}'' = \tsaux{INSERT\_ORDERED} \;\tsvar{exceptfds}' \;\tsvar{exceptfds} \;\tsvar{badexceptfds}}
{\rulesubsection{Description}

    Thread $\tsvar{tid}$ is blocked in state $\tscon{PSelect2}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds})$. The call now
    returns three sets: $\tsvar{readfds}''$, $\tsvar{writefds}''$, and $\tsvar{exceptfds}''$. $\tsvar{readfds}''$ is the set
    of valid file descriptors in $\tsvar{readfds}$ that are ready for reading: a blocking $\tslib{recv}(\tsvar{fd},\tsunknown{\_},\tsunknown{\_})$
    call would not block; see \ltslink{soreadable}{$\tsaux{soreadable}$} for details. $\tsvar{writefds}''$ is the set of valid
    file descriptors in $\tsvar{writefds}$ that are ready for writing: a blocking $\tslib{send}(\tsvar{fd},\tsunknown{\_},\tsunknown{\_})$ call
    would not block; see \ltslink{sowriteable}{$\tsaux{sowriteable}$} for details. $\tsvar{exceptfds}''$ is the set of valid
    file descriptors in $\tsvar{exceptfds}$ that have pending exceptional conditions; see \ltslink{soexceptional}{$\tsaux{soexceptional}$} for details.

    Either one of these three sets is not empty or the timer $\tsvar{d}$, which was set to the timeout value
    specified when the $\tslib{pselect}()$ call was made, has expired.

    A $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}(\tsvar{readfds}'',\tsvar{writefds}'',\tsvar{exceptfds}''))$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    Invalid file descriptors (ones not in the host's finite map of file descriptors, $\tsvar{h}.\tsvar{fds}$) may
    be present in the sets $\tsvar{readfds}$, $\tsvar{writefds}$, and $\tsvar{exceptfds}$, and all such file
    descriptors will then be included in the return sets $\tsvar{readfds}''$, $\tsvar{writefds}''$, and
    $\tsvar{exceptfds}''$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\pselectTIV}{\rrulecc{pselectTIV}{pselect\_4}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EINVAL}$: Timeout not well-formed }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{pselect}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds},\tsvar{timeout},\tsvar{sigmask})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\neg{}(\tsaux{tltimeopt\_wf} \;\tsvar{timeout})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a
    $\tslib{pselect}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds},\tsvar{timeout},\tsvar{sigmask})$ call is made. The $\tsvar{timeout}$ value is
    not well-formed: $\tsvar{timeout}=\Msome (\tsunknown{s},\tsunknown{ns})$ where either $\tsunknown{s}$ is negative; $\tsunknown{ns}$ is negative; or
    $\tsunknown{ns} > 1000000000$. The call fails with an $\tscon{EINVAL}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{pselect}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds},\tsvar{timeout},\tsvar{sigmask})}$ transition is made,
    leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})$.

\rulesubsection{Model details}

    Such negative values are not admitted by the POSIX interface type but are by the model interface
    type (with $(\tstype{int} * \tstype{int}) \;\tstype{option}$ timeouts), so we check and generate $\tscon{EINVAL}$ in the wrapper.

\rrulepad }
}

\newcommand{\pselectTV}{\rrulecc{pselectTV}{pselect\_5}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EINVAL}$: File descriptor out of range }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{pselect}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds},\tsvar{timeout},\tsvar{sigmask})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{(\exists \tsvar{fd} \;\tsvar{n}. (\tsvar{fd} \;\in  \;\tsvar{readfds} \Mvee  \tsvar{fd} \;\in  \;\tsvar{writefds} \Mvee  \tsvar{fd} \;\in  \;\tsvar{exceptfds}) \Mwedge {}\\{}
\quad\quad\quad\quad \Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}{}\\{}
\quad\quad\quad\quad \Mthen  \;\tsvar{n} = \tsholop{MAX} (\tsholop{LENGTH} \;\tsvar{readfds}) (\tsholop{MAX} (\tsholop{LENGTH} \;\tsvar{writefds}) (\tsholop{LENGTH} \;\tsvar{exceptfds})) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{n} \geq  \tsaux{FD\_SETSIZE} \;\tsvar{h}.\tstype{arch}{}\\{}
\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad \tsvar{fd} = \tscon{FD} \;\tsvar{n} \Mwedge {}\\{}
\quad\quad\quad\quad \tsvar{n} \geq  \tsaux{FD\_SETSIZE} \;\tsvar{h}.\tstype{arch}) \Mvee {}\\{}
 (\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsvar{readfds} = [\,] \Mwedge  \tsvar{writefds} = [\,] \Mwedge  \tsvar{exceptfds} = [\,])}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a
    $\tslib{pselect}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds},\tsvar{timeout},\tsvar{sigmask})$ call is made. One or more of the file
    descriptors in $\tsvar{readfds}$, $\tsvar{writefds}$, or $\tsvar{exceptfds}$ is greater than the architecure
    dependent $\tsaux{FD\_SETSIZE}$, the maximum file descriptor that can be specified in a $\tslib{pselect}()$
    call. The call fails with an $\tscon{EINVAL}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{pselect}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds},\tsvar{timeout},\tsvar{sigmask})}$ transition is made,
    leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    On WinXP $\tsaux{FD\_SETSIZE}$ is the maximum number of file descriptors in a set, so one of the sets
    $\tsvar{readfds}$, $\tsvar{writefds}$, or $\tsvar{exceptfds}$ has more than $\tsaux{FD\_SETSIZE}$ members.

    Also, the call will fail with $\tscon{EINVAL}$ if the sets $\tsvar{readfds}$, $\tsvar{writefds}$, and
    $\tsvar{exceptfds}$ are all empty.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\pselectTVI}{\rrulecc{pselectTVI}{pselect\_6}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EBADF}$ or $\tscon{ENOTSOCK}$: Bad file descriptor }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{pselect}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds},\tsvar{timeout},\tsvar{sigmask})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\neg{}\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  {}\\{}
 (\exists \tsvar{fd}. (\tsvar{fd} \;\in  \;\tsvar{readfds} \Mvee  \tsvar{fd} \;\in  \;\tsvar{writefds} \Mvee  \tsvar{fd} \;\in  \;\tsvar{exceptfds}) \Mwedge {}\\{}
\quad\quad\quad \tsvar{fd} \;\notin  \Mfdom{\tsvar{h}.\tsvar{fds}}) \Mwedge {}\\{}
 (\Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{err}=\tscon{ENOTSOCK}{}\\{}
 \Melse                         \;\tsvar{err}=\tscon{EBADF})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a
    $\tslib{pselect}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds},\tsvar{timeout},\tsvar{sigmask})$ call is made. There exists a file
    descriptor $\tsvar{fd}$ in $\tsvar{readfds}$, $\tsvar{writefds}$, or $\tsvar{exceptfds}$ that is not a valid file
    descriptor. The call fails with an $\tscon{EBADF}$ error on FreeBSD and Linux and an $\tscon{ENOTSOCK}$ error
    on WinXP.

    A $\MLhcall{\tsvar{tid}}{\tslib{pselect}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds},\tsvar{timeout},\tsvar{sigmask})}$ transition is made,
    leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$ where $\tsvar{err}$ is one of the above errors.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    As above: the call fails with an $\tscon{EBADF}$ error.

\\\hline
WinXP
&
    As above: the call fails with an $\tscon{ENOTSOCK}$ error.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommtcpTrecv}{\clustersection{(TCP only)}{$\tslib{recv}()$}
\seccomm{ \[ \tslib{recv}: \tstype{fd} * \tstype{int} * \tstype{msgbflag} \;\tstype{list} \Mtotype  (\tstype{string} * ((\tstype{ip} * \tstype{port}) * \tstype{bool}) \;\tstype{option})  \]

  A call to $\tslib{recv}(\tstype{fd},\tsvar{n},\tsunknown{opts})$ reads data from a socket's receive queue.  This section describes
  the behaviour for TCP sockets.
  Here
  $\tstype{fd}$ is a file descriptor referring to a TCP socket to read data from,
  $\tsvar{n}$ is the number of bytes of data to read, and
  $\tsunknown{opts}$ is a list of message flags. Possible flags are:

  \begin{itemize}

  \item $\tscon{MSG\_DONTWAIT}$: Do not block if there is no data available.

  \item $\tscon{MSG\_OOB}$: Return out-of-band data.

  \item $\tscon{MSG\_PEEK}$: Read data but do not remove it from the socket's receive queue.

  \item $\tscon{MSG\_WAITALL}$: Block until all $\tsvar{n}$ bytes of data are available.

  \end{itemize}

  The returned $\tstype{string}$ is the data read from the socket's receive queue. The $((\tstype{ip} * \tstype{port}) *
\tstype{bool}) \;\tstype{option}$ is always returned as $*$ for a TCP socket.

  In order to receive data, a TCP socket must be connected to a peer; otherwise, the $\tslib{recv}()$ call
  will fail with an $\tscon{ENOTCONN}$ error.  If the socket has a pending error then the $\tslib{recv}()$ call
  will fail with this error even if there is data available.

  If there is no data available and non-blocking behaviour is not enabled (the socket's
  $\tscon{O\_NONBLOCK}$ flag is not set and the $\tscon{MSG\_DONTWAIT}$ flag was not used) then the $\tslib{recv}()$ call
  will block until data arrives or an error occurs. If non-blocking behaviour is enabled and there is no
  data or error then the call will fail with an $\tscon{EAGAIN}$ error.

  The $\tscon{MSG\_OOB}$ flag can be set in order to receive out-of-band data; for this,
the socket's $\tscon{SO\_OOBINLINE}$ cannot be set (i.e.~out-of-band data must not be being returned inline).

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{recv}()$ can fail with the errors below, in which case the corresponding exception
  is raised:

\par\begin{ltstabular}
$\tscon{EAGAIN}$
&  Non-blocking $\tslib{recv}()$ call made and no data available; or out-of-band data
  requested and none is available.

\\\hline
$\tscon{EINVAL}$
&  Out-of-band data requested and $\tscon{SO\_OOBINLINE}$ flag set or the out-of-band
  data has already been read.

\\\hline
$\tscon{ENOTCONN}$
&  Socket not connected.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{EINTR}$
&  The system was interrupted by a caught signal.

\\\hline
$\tscon{ENOBUFS}$
&  Out of resources.

\\\hline
$\tscon{ENOMEM}$
&  Out of resources.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  A TCP socket is created and then connected to a peer; a $\tslib{recv}()$ call is made to receive data
  from that peer: $\tsrule{socket\_1}$; $\tsrule{return\_1}$; $\tsrule{connect\_1}$; $\tsrule{return\_1}$; $\tsrule{recv\_1}$; $\dots $

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:  &  \wasverb{ssize\textunderscore{}t recv(int socket, void *buffer, size\textunderscore{}t length, int flags); } \\
    FreeBSD:&  \wasverb{ssize\textunderscore{}t recv(int s, void *buf, size\textunderscore{}t len, int flags);} \\
    Linux:  &  \wasverb{int recv(int s, void *buf, size\textunderscore{}t len, int flags);} \\
    WinXP:  &  \wasverb{int recv(SOCKET s, char* buf, int len, int flags);} \\
  \end{tabular}\\

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to receive from, corresponding to
     the $\tstype{fd}$ argument of the model $\tslib{recv}()$.

    \item \wasverb{buffer} is a pointer to a buffer to place the received data in, which upon return
     contains the data received on the socket. This corresponds to the $\tstype{string}$ return value of
     the model $\tslib{recv}()$.

    \item \wasverb{length} is the amount of data to be read from the socket, corresponding to the $\tstype{int}$
     argument of the model $\tslib{recv}()$; it should be at most the length of \wasverb{buffer}.

    \item \wasverb{flags} is a disjunction of the message flags that are set for the call, corresponding to
     the $\tstype{msgbflag}$ $\tstype{list}$ argument of the model $\tslib{recv}()$.

    \item the returned \wasverb{ssize\textunderscore{}t} is either non-negative, in which case it is the the amount
     of data that was received by the socket, or it is \wasverb{-1} to indicate an error, in which
     case the error code is in \wasverb{errno}. On WinXP an error is indicated by a return value of
     \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error code available through a
     call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  The FreeBSD, Linux and WinXP interfaces are similar modulo argument renaming, except where
  noted above.

  There are other functions used to receive data on a socket. \wasverb{recvfrom()} is similar to
  \wasverb{recv()} except it returns the source address of the data; this is used for UDP but is not
  necessary for TCP as the source address will always be the peer the socket has connected
  to. \wasverb{recvmsg()}, another input function, is a more general form of \wasverb{recv()}.


}\clustersubsection{Model details}
\seccomm{
  If the call blocks then the thread enters state $\tscon{Recv2}(\tstype{sid},\tsvar{n},\tsunknown{opts})$ where:

  \begin{itemize}

    \item $\tstype{sid} : \tstype{sid}$ is the identifier of the socket that the $\tslib{recv}()$ call was made on,

    \item $\tsvar{n} : \tstype{num}$ is the number of bytes to be read, and

    \item $\tsunknown{opts} : \tstype{msgbflag} \;\tstype{list}$ is the list of message flags.

  \end{itemize}

  The following errors are not modelled:

  \begin{itemize}

   \item On FreeBSD, Linux, and WinXP, $\tscon{EFAULT}$ can be returned if the \wasverb{buffer}
    parameter points to memory not in a valid part of the process address space. This is an artefact
    of the C interface to \wasverb{ioctl()} that is excluded by the clean interface used in the
    model $\tslib{recv}()$.

    \item In Posix, \wasverb{EIO} may be returned to indicated that an I/O error occurred while
    reading from or writing to the file system; this is not modelled here.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}

  The following Linux message flags are not modelled: \wasverb{MSG\textunderscore{}NOSIGNAL}, \wasverb{MSG\textunderscore{}TRUNC}, and
  \wasverb{MSG\textunderscore{}ERRQUEUE}.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{recv\_1}$
& \textbf{tcp: fast succeed}
&  Successfully return data from the socket without blocking \\
$\tsrule{recv\_2}$
& \textbf{tcp: block}
&  Block, entering state $\tscon{Recv2}$ as not enough data is available \\
$\tsrule{recv\_3}$
& \textbf{tcp: slow nonurgent succeed}
&  Blocked call returns from $\tscon{Recv2}$ state \\
$\tsrule{recv\_4}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{EAGAIN}$: non-blocking call would block waiting for data \\
$\tsrule{recv\_5}$
& \textbf{tcp: fast succeed}
&  Successfully read non-inline out-of-band data \\
$\tsrule{recv\_6}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{EAGAIN}$ or $\tscon{EINVAL}$: $\tslib{recv}()$ called with $\tscon{MSG\_OOB}$ set and out-of-band data is not available  \\
$\tsrule{recv\_7}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{ENOTCONN}$: socket not connected \\
$\tsrule{recv\_8}$
& \textbf{tcp: fast fail}
&  Fail with pending error \\
$\tsrule{recv\_8a}$
& \textbf{tcp: slow urgent fail}
&  Fail with pending error from blocked state \\
$\tsrule{recv\_9}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{ESHUTDOWN}$: socket shut down for reading on WinXP \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\recvTI}{\rrulecc{recvTI}{recv\_1}{tcp: fast succeed}{\tsholcomm{ Successfully return data from the socket without blocking }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsholop{IMPLODE} \;\tsvar{str},*))}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq}'',\tsvar{rcvurp}',\tsvar{iobc})))] \Mmagicrrec }
{((\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}; \tscon{CLOSING};{}\\{}
\quad \tscon{TIME\_WAIT}; \tscon{CLOSE\_WAIT}; \tscon{LAST\_ACK}\} \Mwedge {}\\{}
\quad \tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge  \tsvar{is}_{2}=\Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}_{2}=\Msome  \;\tsvar{p}_{2}) \Mvee {}\\{}
 (\tsvar{st} = \tscon{CLOSED}) ) \Mwedge {}\\{}
 \tsvar{n} = \tsaux{clip\_int\_to\_num} \;\tsvar{n}_{0} \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{MSG\_OOB} \;\notin  \;\tsvar{opts} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ We return now if we can fill the buffer, or we can reach the low-water mark (usually
         ignored if $\tscon{MSG\_WAITALL}$ is set), or we can reach EOF or the next urgent-message boundary.
         Pending errors are not checked. }{}\\{}
 \Mlet  \;\tsunknown{have\_all\_data}     = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{n}) \Min  {}\\{}
 \Mlet  \;\tsunknown{have\_enough\_data}  = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})) \Min {}\\{}
 \Mlet  \;\tsunknown{partial\_data\_ok}   = (\tscon{MSG\_WAITALL} \;\notin  \;\tsvar{opts} \Mvee  \tsvar{n} > \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\neg{}(\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge  \tscon{MSG\_PEEK} \;\in  \;\tsvar{opts})) \Min {}\\{}
 \Mlet  \;\tsunknown{urgent\_data\_ahead} = (\exists \tsvar{om}.\tsvar{rcvurp} = \Msome  \;\tsvar{om} \Mwedge  0 < \tsvar{om} \Mwedge  \tsvar{om} \leq  \tsholop{LENGTH} \;\tsvar{rcvq})  \Min {}\\{}
 (\tsunknown{have\_all\_data} \Mvee  (\tsunknown{have\_enough\_data} \Mwedge  \tsunknown{partial\_data\_ok}) \Mvee  \tsunknown{urgent\_data\_ahead} \Mvee  \tsvar{cantrcvmore}) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 ((\tsvar{str},\tsvar{rcvq}') = \tsaux{SPLIT} (\tsholop{MIN} \;\tsvar{n}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mcase  \;\tsvar{rcvurp} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad * \Mtotype  \tsholop{LENGTH} \;\tsvar{rcvq} \Mdpipe {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  \;\tsvar{om} \Mtotype  \Mif  \;\tsvar{om} = 0 \;\Mthen  (\tsholop{LENGTH} \;\tsvar{rcvq}) {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsholop{MIN} \;\tsvar{om} (\tsholop{LENGTH} \;\tsvar{rcvq}))){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{rcvq}) \Mwedge {}\\{}
 \tsvar{rcvq}'' = (\Mif  \;\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \;\Mthen  \;\tsvar{rcvq} \;\Melse  \;\tsvar{rcvq}') \Mwedge {}\\{}
 \tsvar{rcvurp}' = (\Mcase  \;\tsvar{rcvurp} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad * \Mtotype  * \Mdpipe {}\\{}
\quad\quad\quad\quad\quad\quad\quad \Msome  \;\tsvar{om} \Mtotype  \Mif  \;\tsvar{om} = 0 \;\Mthen  \;*{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsvar{om} \leq  \tsholop{LENGTH} \;\tsvar{str} \;\Mthen  \;\Msome  \;0 \;\Melse  \;\Msome  (\tsvar{om}-\tsholop{LENGTH} \;\tsvar{str}))}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made where
    out-of-band data is not requested. $\tsvar{fd}$ refers to a synchronised TCP socket $\tsvar{sid}$ with
    binding quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ and no pending error. Alternatively the
    socket is uninitialised and in state $\tscon{CLOSED}$.

    The call can return immediately because either: (1) there are at least $\tsvar{n}$ bytes of data in
    the socket's receive queue (the $\tsunknown{have\_all\_data}$ case above); (2) the length of the socket's
    receive queue is greater than or equal to the minimum number of bytes for socket $\tslib{recv}()$
    operations, $\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})$, and the call does not have to return all $\tsvar{n}$ bytes of data;
    either because (i) the $\tscon{MSG\_WAITALL}$ flag is not set in $\tsvar{opts}_{0}$, (ii) the number of bytes requested
    is greater than the number of bytes in the socket's receive queue, or (iii) on non-FreeBSD
    architectures the $\tscon{MSG\_PEEK}$ flag is set in $\tsvar{opts}_{0}$ (the $\tsunknown{have\_enough\_data} \Mwedge
\tsunknown{partial\_data\_ok}$ case above); (3) there is urgent data available in the socket's receive queue
    (the $\tsunknown{urgent\_data\_ahead}$ case above); or (4) the socket has been shutdown for reading.

    The call succeeds, returning a string, $\tsholop{IMPLODE} \;\tsvar{str}$, which is either: (5) the smaller of the first
    $\tsvar{n}$ bytes of the socket's receive queue or its entire receive queue, if the urgent pointer is
    not set or the socket is at the urgent mark; or (6) the smaller of the first $\tsvar{n}$ bytes of the
    the socket's receive queue, the data in its receive queue up to the urgent mark, and its entire
    receive queue, if the urgent mark is set and the socket is not at the urgent mark.

    A $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made leaving the thread state $\tscon{Ret}
(\tscon{OK}(\tsholop{IMPLODE} \;\tsvar{str},*))$. If the $\tscon{MSG\_PEEK}$ flag was set in $\tsvar{opts}_{0}$ then the socket's
    receive queue remains unchanged; otherwise, the data $\tsvar{str}$ is removed from the head of the
    socket's receive queue, $\tsvar{rcvq}$, to leave the socket with new receive queue $\tsvar{rcvq}'$. If the
    receive urgent pointer was not set or was set to $\Msome  \;0$ then it will be set to $*$; if it
    was set to $\Msome  \;\tsvar{om}$ and  $\tsvar{om}$ is less than the length of the returned string then it will be
    set to $\Msome  \;0$ (because the returned string was the data in the receive queue up to the
    urgent mark); otherwise it will be set to $\Msome (\tsvar{om}-\tsholop{LENGTH} \;\tsvar{str})$.

\rulesubsection{Model details}

    The amount of data requested, $\tsvar{n}_{0}$, is clipped to a natural number from an integer, using
    $\tsaux{clip\_int\_to\_num}$. POSIX specifies an unsigned type for $\tsvar{n}_{0}$ and this is one possible model
    thereof.

    The $\tsvar{opts}_{0}$ argument to $\tslib{recv}()$ is of type $\tstype{msgbflag} \;\tstype{list}$, but it is converted to a set,
    $\tsvar{opts}$, using $\tsholop{LIST\_TO\_SET}$.

    The data itself is represented as a $\tstype{byte} \;\tstype{list}$ in the datagram but is returned a $\tstype{string}$:
    the $\tsholop{IMPLODE}$ function is used to do the conversion.

\rrulepad }
}

\newcommand{\recvTII}{\rrulecc{recvTII}{recv\_2}{tcp: block}{\tsholcomm{ Block, entering state $\tscon{Recv2}$ as not enough data is available }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})}{\tsaux{never\_timer}}} \Mmagicrrec }
{\tsvar{n} = \tsaux{clip\_int\_to\_num} \;\tsvar{n}_{0} \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{socks}}{\tsvar{sid}} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 \tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}\} \Mwedge {}\\{}
 \tscon{MSG\_OOB} \;\notin  \;\tsvar{opts} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ We block if not enough (see \ltslink{recvTI}{$\tsrule{recv\_1}$}) data is available and there is no pending error. }{}\\{}
 \Mlet  \;\tsunknown{blocking}          = \neg{}(\tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts} \Mvee  \tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK})) \Min {}\\{}
 \Mlet  \;\tsunknown{have\_all\_data}     = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{n}) \Min  {}\\{}
 \Mlet  \;\tsunknown{have\_enough\_data}  = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})) \Min {}\\{}
 \Mlet  \;\tsunknown{partial\_data\_ok}   = (\tscon{MSG\_WAITALL} \;\notin  \;\tsvar{opts} \Mvee  \tsvar{n} > \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\neg{}(\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge  \tscon{MSG\_PEEK} \;\in  \;\tsvar{opts})) \Min {}\\{}
 \Mlet  \;\tsunknown{urgent\_data\_ahead} = (\exists \tsvar{om}.\tsvar{rcvurp} = \Msome  \;\tsvar{om} \Mwedge  0 < \tsvar{om} \Mwedge  \tsvar{om} \leq  \tsholop{LENGTH} \;\tsvar{rcvq})  \Min {}\\{}
 \tsunknown{blocking} \Mwedge {}\\{}
 \neg{}(\tsunknown{have\_all\_data} \Mvee  (\tsunknown{have\_enough\_data} \Mwedge  \tsunknown{partial\_data\_ok}) \Mvee  \tsunknown{urgent\_data\_ahead} \Mvee  \tsvar{cantrcvmore}) \Mwedge {}\\{}
 \tsvar{es} = *  }
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made where
    out-of-band data is not requested. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$ in state
    $\tscon{ESTABLISHED}$, $\tscon{SYN\_SENT}$, $\tscon{SYN\_RECEIVED}$, $\tscon{FIN\_WAIT\_1}$, or $\tscon{FIN\_WAIT\_2}$, with binding
    quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ and no pending error. The call is blocking: the
    $\tscon{MSG\_DONTWAIT}$ flag is not set in $\tsvar{opts}_{0}$ and the socket's $\tscon{O\_NONBLOCK}$ flag is not set.

    The call cannot return immediately because: (1) there are less than $\tsvar{n}$ bytes of data in the
    socket's receive queue; (2) there are less than $\tsvar{sf}.\tsvar{n}(\tsunknown{SO\_RVCLOWAT})$ (the minimum number of
    bytes for socket $\tslib{recv}()$ operations) bytes of data in the socket's receive queue or the call
    must return all $\tsvar{n}$ bytes of data: (i) the $\tscon{MSG\_WAITALL}$ flag is set in $\tsvar{opts}_{0}$, (ii) the
    number of bytes requested is greater than the length of the socket's receive queue, and (iii)
    the $\tscon{MSG\_PEEK}$ flag is not set in $\tsvar{opts}_{0}$; (3) there is no urgent data ahead in the socket's
    receive queue; and (4) the socket is not shutdown for reading.

    The call blocks in state $\tscon{Recv2}$ waiting for data; a $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$
    transition is made, leaving the thread state $\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})$.

\rulesubsection{Model details}

    The amount of data requested, $\tsvar{n}_{0}$, is clipped to a natural number from an integer, using
    $\tsaux{clip\_int\_to\_num}$. POSIX specifies an unsigned type for $\tsvar{n}_{0}$, whereas the model uses $\tstype{int}$.

    The $\tsvar{opts}_{0}$ argument to $\tslib{recv}()$ is of type $\tstype{msgbflag} \;\tstype{list}$, but it is converted to a set,
    $\tsvar{opts}$, using $\tsholop{LIST\_TO\_SET}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    In case (iii) above, the $\tscon{MSG\_PEEK}$ flag may be set in $\tsvar{opts}_{0}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTIII}{\rrulecc{recvTIII}{recv\_3}{tcp: slow nonurgent succeed}{\tsholcomm{ Blocked call returns from $\tscon{Recv2}$ state }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsholop{IMPLODE} \;\tsvar{str}, *))}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq}'',\tsvar{rcvurp}',\tsvar{iobc})))] \Mmagicrrec }
{((\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}; \tscon{CLOSING};{}\\{}
\quad\quad\quad\quad \tscon{TIME\_WAIT}; \tscon{CLOSE\_WAIT}; \tscon{LAST\_ACK}\} \Mwedge  {}\\{}
\quad \tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge  \tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}) \Mvee {}\\{}
 \tsvar{st} = \tscon{CLOSED}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ We return at last if we now have enough (see \ltslink{recvTI}{$\tsrule{recv\_1}$}) data available.  Pending errors are not checked. }{}\\{}
 \Mlet  \;\tsunknown{have\_all\_data}     = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{n}) \Min  {}\\{}
 \Mlet  \;\tsunknown{have\_enough\_data}  = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})) \Min {}\\{}
 \Mlet  \;\tsunknown{partial\_data\_ok}   = (\tscon{MSG\_WAITALL} \;\notin  \;\tsvar{opts} \Mvee  \tsvar{n} > \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\neg{}(\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge  \tscon{MSG\_PEEK} \;\in  \;\tsvar{opts})) \Min {}\\{}
 \Mlet  \;\tsunknown{urgent\_data\_ahead} = (\exists \tsvar{om}.\tsvar{rcvurp} = \Msome  \;\tsvar{om} \Mwedge  0 < \tsvar{om} \Mwedge  \tsvar{om} \leq  \tsholop{LENGTH} \;\tsvar{rcvq})  \Min {}\\{}
 (\tsunknown{have\_all\_data} \Mvee  (\tsunknown{have\_enough\_data} \Mwedge  \tsunknown{partial\_data\_ok}) \Mvee  \tsunknown{urgent\_data\_ahead} \Mvee  \tsvar{cantrcvmore}) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 (\tsvar{str},\tsvar{rcvq}') = \tsaux{SPLIT} (\tsholop{MIN} \;\tsvar{n}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mcase  \;\tsvar{rcvurp} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad * \Mtotype  \tsholop{LENGTH} \;\tsvar{rcvq} \Mdpipe {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  \;\tsvar{om} \Mtotype  \Mif  \;\tsvar{om} = 0 \;\Mthen  (\tsholop{LENGTH} \;\tsvar{rcvq}) {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsholop{MIN} \;\tsvar{om} (\tsholop{LENGTH} \;\tsvar{rcvq}))){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{rcvq} \Mwedge {}\\{}
 \tsvar{rcvq}'' = (\Mif  \;\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \;\Mthen  \;\tsvar{rcvq} \;\Melse  \;\tsvar{rcvq}') \Mwedge {}\\{}
 \tsvar{rcvurp}' = (\Mcase  \;\tsvar{rcvurp} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad * \Mtotype  * \Mdpipe {}\\{}
\quad\quad\quad\quad\quad\quad\quad \Msome  \;\tsvar{om} \Mtotype  \Mif  \;\tsvar{om} = 0 \;\Mthen  \;*{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsvar{om} \leq  \tsholop{LENGTH} \;\tsvar{str} \;\Mthen  \;\Msome  \;0 \;\Melse  \;\Msome  (\tsvar{om}-\tsholop{LENGTH} \;\tsvar{str}))}
{\rulesubsection{Description}

    Thread $\tsvar{tid}$ is in the $\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})$ state after a previous $\tslib{recv}()$ call
    blocked. $\tsvar{sid}$ refers either to a synchronised TCP socket with binding quad $(\Msome  \;\tsvar{i}_{1},\Msome
\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$; or to a TCP socket in state $\tscon{CLOSED}$.

    Sufficient data is not available on the socket for the call to return: either (1) there is at
    least $\tsvar{n}$ bytes of data in the socket's receive queue (the $\tsunknown{have\_all\_data}$ case above); (2)
    the length of the socket's receive queue is greater than or equal to the minimum number of bytes
    for socket $\tslib{recv}()$ operations, $\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})$, and the call does not have to return
    all $\tsvar{n}$ bytes of data (the $\tsunknown{partial\_data\_ok}$ case): either (i) the $\tscon{MSG\_WAITALL}$ flag is
    not set in $\tsvar{opts}$, (ii) the number of bytes requested is greater than the number of bytes in
    the socket's receive queue, or (iii) on non-FreeBSD architectures the $\tscon{MSG\_PEEK}$ flag is set
    in $\tsvar{opts}$ (the $\tsunknown{have\_enough\_data} \Mwedge  \tsunknown{partial\_data\_ok}$ case above); (3) there is urgent data
    available in the socket's receive queue (the $\tsunknown{urgent\_data\_ahead}$ cae above); or (4) the socket
    has been shutdown for reading.

    The data returned, $\tsvar{str}$, is either: (1) the smaller of the first $\tsvar{n}$ bytes of the socket's
    receive queue or its entire receive queue, if the urgent pointer is not set or the socket is at
    the urgent mark; or (2) the smaller of the first $\tsvar{n}$ bytes of the the socket's receive queue,
    the data in its receive queue up to the urgent mark, and its entire receive queue, if the urgent
    mark is set and the socket is not at the urgent mark.

    A $\MLhtau $ transition is made leaving the thread state $\tscon{Ret} (\tscon{OK}(\tsholop{IMPLODE} \;\tsvar{str},*))$. If
    the $\tscon{MSG\_PEEK}$ flag was set in $\tsvar{opts}$ then the socket's receive queue remains unchanged;
    otherwise, the data $\tsvar{str}$ is removed from the head of the socket's receive queue, $\tsvar{rcvq}$, to
    leave the socket with new receive queue $\tsvar{rcvq}'$. If the receive urgent pointer was not set or was
    set to $\Msome  \;0$ then it will be set to $*$; if it was set to $\Msome  \;\tsvar{om}$ and $\tsvar{om}$ is
    less than the length of the returned string then it will be set to $\Msome  \;0$ (because the
    returned string was the data in the receive queue up to the urgent mark); otherwise it will be
    set to $\Msome (\tsvar{om}-\tsholop{LENGTH} \;\tsvar{str})$.

\rulesubsection{Model details}

    The data itself is represented as a $\tstype{byte} \;\tstype{list}$ in the datagram but is returned a $\tstype{string}$:
    the $\tsholop{IMPLODE}$ function is used to do the conversion.

\rrulepad }
}

\newcommand{\recvTIV}{\rrulecc{recvTIV}{recv\_4}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{EAGAIN}$: non-blocking call would block waiting for data }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EAGAIN}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{n} = \tsaux{clip\_int\_to\_num} \;\tsvar{n}_{0} \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{socks}}{\tsvar{sid}} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 \tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}\} \Mwedge {}\\{}
 \tscon{MSG\_OOB} \;\notin  \;\tsvar{opts} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ We fail if we would otherwise block (see \ltslink{recvTII}{$\tsrule{recv\_2}$}; these conditions are identical). }{}\\{}
 \Mlet  \;\tsunknown{blocking}          = \neg{}(\tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts} \Mvee  \tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK})) \Min {}\\{}
 \Mlet  \;\tsunknown{have\_all\_data}     = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{n}) \Min  {}\\{}
 \Mlet  \;\tsunknown{have\_enough\_data}  = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})) \Min {}\\{}
 \Mlet  \;\tsunknown{partial\_data\_ok}   = (\tscon{MSG\_WAITALL} \;\notin  \;\tsvar{opts} \Mvee  \tsvar{n} > \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\neg{}(\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge  \tscon{MSG\_PEEK} \;\in  \;\tsvar{opts})) \Min {}\\{}
 \Mlet  \;\tsunknown{urgent\_data\_ahead} = (\exists \tsvar{om}.\tsvar{rcvurp} = \Msome  \;\tsvar{om} \Mwedge  0 < \tsvar{om} \Mwedge  \tsvar{om} \leq  \tsholop{LENGTH} \;\tsvar{rcvq})  \Min {}\\{}
 \neg{}\tsunknown{blocking} \Mwedge {}\\{}
 \neg{}(\tsunknown{have\_all\_data} \Mvee  (\tsunknown{have\_enough\_data} \Mwedge  \tsunknown{partial\_data\_ok}) \Mvee  \tsunknown{urgent\_data\_ahead} \Mvee  \tsvar{cantrcvmore}) \Mwedge {}\\{}
 (\tsvar{rcvq} = [\,] \implies  \tsvar{es} = *)  {}\\{}
 }
{\rulesubsection{Description}

    From thead $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made where
    out-of-band data is not requested. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$ with binding quad
    $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ and no pending error, which is in state $\tscon{ESTABLISHED}$,
    $\tscon{SYN\_SENT}$, $\tscon{SYN\_RECEIVED}$, $\tscon{FIN\_WAIT\_1}$, or $\tscon{FIN\_WAIT\_2}$. The $\tslib{recv}()$ call is
    non-blocking: either the $\tscon{MSG\_DONTWAIT}$ flag was set in $\tsvar{opts}_{0}$ or the socket's
    $\tscon{O\_NONBLOCK}$ flag is set.

    The call would block because: (1) there are less than $\tsvar{n}$ bytes of data in the socket's
    receive queue; (2) there are less than $\tsvar{sf}.\tsvar{n}(\tsunknown{SO\_RVCLOWAT})$ (the minimum number of bytes for
    socket $\tslib{recv}()$ operations) bytes of data in the socket's receive queue or the call must
    return all $\tsvar{n}$ bytes of data: (i) the $\tscon{MSG\_WAITALL}$ flag is set in $\tsvar{opts}_{0}$, (ii) the
    number of bytes requested is greater than the length of the socket's receive queue, and (iii)
    the $\tscon{MSG\_PEEK}$ flag is not set in $\tsvar{opts}_{0}$; (3) there is no urgent data ahead in the socket's
    receive queue; (4) the socket is not shutdown for reading; and (5) if the socket's receive queue
    is empty then it has no pending error.

    The call fails with an $\tscon{EAGAIN}$ error. A $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is
    made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EAGAIN}})$.


\rulesubsection{Model details}

    The amount of data requested, $\tsvar{n}_{0}$, is clipped to a natural number from an integer, using
    $\tsaux{clip\_int\_to\_num}$. POSIX specifies an unsigned type for $\tsvar{n}_{0}$ and this is one possible model
    thereof.

    The $\tsvar{opts}_{0}$ argument to $\tslib{recv}()$ is of type $\tstype{msgbflag} \;\tstype{list}$, but it is converted to a set,
    $\tsvar{opts}$, using $\tsholop{LIST\_TO\_SET}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    In case (iii) above, the $\tscon{MSG\_PEEK}$ flag may be set in $\tsvar{opts}_{0}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTV}{\rrulecc{recvTV}{recv\_5}{tcp: fast succeed}{\tsholcomm{ Successfully read non-inline out-of-band data }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsholop{IMPLODE} \;\tsvar{str}, *))}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc}')))] \Mmagicrrec }
{\tsvar{n} = \tsaux{clip\_int\_to\_num} \;\tsvar{n}_{0} \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{MSG\_OOB} \;\in  \;\tsvar{opts} \Mwedge {}\\{}
 \neg{}\tsvar{sf}.\tsvar{b}(\tscon{SO\_OOBINLINE}) \Mwedge {}\\{}
 \tsvar{iobc} = \tscon{OOBDATA} \;\tsvar{c} \Mwedge {}\\{}
 \tsvar{str} = (\Mif  \;\tsvar{n} = 0 \;\Mthen  [\,] \Melse  [\tsvar{c}]) \Mwedge {}\\{}
 \tsvar{iobc}' = (\Mif  \;\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \;\Mthen  \;\tsvar{iobc} \;\Melse  \;\tscon{HAD\_OOBDATA})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made. $\tsvar{fd}$
    refers to a TCP socket $\tsvar{sid}$ with binding quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$ and no
    pending error. Out-of-band data is requested: the $\tscon{MSG\_OOB}$ flag is set in $\tsvar{opts}_{0}$, and
    out-of-band data is not being returned inline: $\neg{}\tsvar{sf}.\tsvar{b}(\tscon{SO\_OOBINLINE})$. There is a byte $\tsvar{c}$ of
    out-of-band data on the socket; if zero bytes of data were requested, $\tsvar{n}_{0}=0$, then the empty
    string is returned, otherwise $\tsvar{c}$ is returned.

    A $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}
(\tsholop{IMPLODE} \;\tsvar{str},*))$ where $\tsholop{IMPLODE} \;\tsvar{str}$ is the returned out-of-band data. If the
    $\tscon{MSG\_PEEK}$ flag was set in $\tsvar{opts}_{0}$ then the byte of out-of-band data is left in place,
    $\tsvar{iobc}'=\tsvar{iobc}$; otherwise it is removed and marked as read: $\tsvar{iobc}'=\tscon{HAD\_OOBDATA}$.

\rulesubsection{Model details}

    The amount of data requested, $\tsvar{n}_{0}$, is clipped to a natural number from an integer, using
    $\tsaux{clip\_int\_to\_num}$. POSIX specifies an unsigned type for $\tsvar{n}_{0}$, whereas the model uses $\tstype{int}$.

    The $\tsvar{opts}_{0}$ argument to $\tslib{recv}()$ is of type $\tstype{msgbflag} \;\tstype{list}$, but it is converted to a set,
    $\tsvar{opts}$, using $\tsholop{LIST\_TO\_SET}$.

    The data itself is represented as a $\tstype{byte} \;\tstype{list}$ in the datagram but is returned a $\tstype{string}$:
    the $\tsholop{IMPLODE}$ function is used to do the conversion.


\rrulepad }
}

\newcommand{\recvTVI}{\rrulecc{recvTVI}{recv\_6}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{EAGAIN}$ or $\tscon{EINVAL}$: $\tslib{recv}()$ called with $\tscon{MSG\_OOB}$ set and out-of-band data is not available  }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{n} = \tsaux{clip\_int\_to\_num} \;\tsvar{n}_{0} \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{socks}}{\tsvar{sid}} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 \tscon{MSG\_OOB} \;\in  \;\tsvar{opts} \Mwedge {}\\{}
 (\Mif  \;\tsvar{sf}.\tsvar{b}(\tscon{SO\_OOBINLINE}){}\\{}
 \Mthen  (\tsvar{e} = \tscon{EINVAL}){}\\{}
 \Melse  \;\Mcase  \;\tsvar{iobc} \;\Mof {}\\{}
\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad \tscon{NO\_OOBDATA} \Mtotype  (\tsvar{e} = \Mif  \;\tsvar{rcvurp} = * \;\Mthen  \;\tscon{EINVAL} \;\Melse  \;\tscon{EAGAIN}) \Mdpipe {}\\{}
\quad\quad\quad\quad \tscon{OOBDATA} \;\tsunknown{c} \Mtotype  \Mfalse  \Mdpipe {}\\{}
\quad\quad\quad\quad \tscon{HAD\_OOBDATA} \Mtotype  (\tsvar{e} = \tscon{EINVAL}))}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made. $\tsvar{fd}$
    refers to a TCP socket identified by $\tsvar{sid}$ with binding quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome
\tsvar{p}_{2})$ and no pending error. The $\tscon{MSG\_OOB}$ flag is set in $\tsvar{opts}_{0}$, indicating that
    out-of-band data should be returned, but no out-of-band data is available because either: (1)
    out-of-band data is being returned in-line (the $\tsvar{sf}.\tsvar{b}(\tscon{SO\_OOBINLINE})$ flag is set); (2) the
    out-of-band data on the socket has already been read; (3) there is no out-of-band data and the
    receive urgent pointer is set; or (4) there is no out-of-band data but the urgent pointer is
    set, corresponding to the case where the peer has advertised urgent data but that data has yet
    to arrive. The call fails with an $\tscon{EINVAL}$ error in cases (1), (2), and (3); and a $\tscon{EAGAIN}$
    error in case (4) indicating that the $\tslib{recv}()$ call should be made again to see if the data
    has now arrived.

    A $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$ where $\tsvar{e}$ is one of the above errors.

\rrulepad }
}

\newcommand{\recvTVII}{\rrulecc{recvTVII}{recv\_7}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{ENOTCONN}$: socket not connected }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOTCONN}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = \tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = \tsvar{sock}.\tsvar{pr} \Mwedge {}\\{}
 (\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{LISTEN} \Mvee  {}\\{}
 (\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSED} \Mwedge  \tsvar{sock}.\tsvar{cantrcvmore}=\Mfalse ){}\\{}
   {}\\{}
 {}\\{}
 )}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made. $\tsvar{fd}$
    refers to a TCP socket $\tsvar{sock}$ identified by $\tsvar{sid}$ which is either in the $\tscon{LISTEN}$ state or
    is not shutdown for reading in the $\tscon{CLOSED}$ state. The call fails with an $\tscon{ENOTCONN}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tscon{ENOTCONN}})$.

\rrulepad }
}

\newcommand{\recvTVIII}{\rrulecc{recvTVIII}{recv\_8}{tcp: fast fail}{\tsholcomm{ Fail with pending error }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\Msome  \;\tsvar{e},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{TCP\_PROTO}(\tsunknown{tcp\_sock})))] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{TCP\_PROTO}(\tsunknown{tcp\_sock})))] \Mmagicrrec }
{\tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 \tsvar{n} = \tsaux{clip\_int\_to\_num} \;\tsvar{n}_{0} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 ((\tsunknown{tcp\_sock}.\tsvar{st} \;\notin  \{\tscon{CLOSED}; \tscon{LISTEN}\} \Mwedge  \tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}) \Mvee {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSED}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ We fail immediately if there is a pending error and we could not otherwise return data (see \ltslink{recvTI}{$\tsrule{recv\_1}$}). }{}\\{}
 \Mlet  \;\tsvar{rcvq} = \tsunknown{tcp\_sock}.\tsvar{rcvq} \;\Min {}\\{}
 \Mlet  \;\tsvar{rcvurp} = \tsunknown{tcp\_sock}.\tsvar{rcvurp} \;\Min {}\\{}
 \Mlet  \;\tsunknown{blocking}          = \neg{}(\tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts} \Mvee  \tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK})) \Min {}\\{}
 \Mlet  \;\tsunknown{have\_all\_data}     = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{n}) \Min  {}\\{}
 \Mlet  \;\tsunknown{have\_enough\_data}  = (\tsholop{LENGTH} \;\tsvar{rcvq} \geq  \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})) \Min {}\\{}
 \Mlet  \;\tsunknown{partial\_data\_ok}   = (\tscon{MSG\_WAITALL} \;\notin  \;\tsvar{opts} \Mvee  \tsvar{n} > \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\neg{}(\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge  \tscon{MSG\_PEEK} \;\in  \;\tsvar{opts})) \Min {}\\{}
 \Mlet  \;\tsunknown{urgent\_data\_ahead} = (\exists \tsvar{om}.\tsvar{rcvurp} = \Msome  \;\tsvar{om} \Mwedge  0 < \tsvar{om} \Mwedge  \tsvar{om} \leq  \tsholop{LENGTH} \;\tsvar{rcvq})  \Min {}\\{}
 \neg{}(\tsunknown{have\_all\_data} \Mvee  (\tsunknown{have\_enough\_data} \Mwedge  \tsunknown{partial\_data\_ok}) \Mvee  \tsunknown{urgent\_data\_ahead}) \Mwedge {}\\{}
 (\tsunknown{blocking} \Mvee  \tsvar{rcvq} = [\,]) \Mwedge  {}\\{}
 {}\\{}
 \tsvar{es} = \Mif  \;\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \;\Mthen  \;\Msome  \;\tsvar{e} \;\Melse  \;*}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made. $\tsvar{fd}$
    refers to a TCP socket that either is in state $\tscon{CLOSED}$ or is in state other than $\tscon{CLOSED}$
    or $\tscon{LISTEN}$ with peer address set to $(\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$. The socket has a pending error
    $\tsvar{e}$.

    The call cannot immediately return data because: (1) there are less than $\tsvar{n}$ bytes of data in
    the socket's receive queue; (2) there are less than $\tsvar{sf}.\tsvar{n}(\tsunknown{SO\_RVCLOWAT})$ (the minimum number of
    bytes for socket $\tslib{recv}()$ operations) bytes of data in the socket's receive queue or the call
    must return all $\tsvar{n}$ bytes of data: (i) the $\tscon{MSG\_WAITALL}$ flag is set in $\tsvar{opts}_{0}$, (ii) the
    number of bytes requested is greater than the length of the socket's receive queue, and (iii)
    the $\tscon{MSG\_PEEK}$ flag is not set in $\tsvar{opts}_{0}$; (3) there is no urgent data ahead in the socket's
    receive queue; and (4) either the call is a blocking
    one: the $\tscon{MSG\_DONTWAIT}$ flag is set in $\tsvar{opts}_{0}$ or the socket's $\tscon{O\_NONBLOCK}$ flag is set,
    or the socket's receive queue is empty.

    The call fails, returning the pending error. A $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is
    made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$. If the $\tscon{MSG\_PEEK}$ flag was set in
    $\tsvar{opts}_{0}$ then the socket's pending error remains, otherwise it is cleared.

\rulesubsection{Model details}

    The $\tsvar{opts}_{0}$ argument to $\tslib{recv}()$ is of type $\tstype{msgbflag} \;\tstype{list}$, but it is converted to a
    set, $\tsvar{opts}$, using $\tsholop{LIST\_TO\_SET}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    In case (iii) above, the $\tscon{MSG\_PEEK}$ flag may be set in $\tsvar{opts}_{0}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTVIIIa}{\rrulecc{recvTVIIIa}{recv\_8a}{tcp: slow urgent fail}{\tsholcomm{ Fail with pending error from blocked state }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid}, \tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsvar{e}; \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid}, \tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mmagicrrec )] \Mmagicrrec }
{{}\\{}
 {}\\{}
 \tsholcomm{ We fail now if there is a pending error and we could not otherwise return data (see \ltslink{recvTI}{$\tsrule{recv\_1}$}). }{}\\{}
 \Mlet  \;\tsunknown{have\_all\_data}     = (\tsholop{LENGTH} \;\tsunknown{tcp\_sock}.\tsvar{rcvq} \geq  \tsvar{n}) \Min  {}\\{}
 \Mlet  \;\tsunknown{have\_enough\_data}  = (\tsholop{LENGTH} \;\tsunknown{tcp\_sock}.\tsvar{rcvq} \geq  \tsvar{sock}.\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVLOWAT})) \Min {}\\{}
 \Mlet  \;\tsunknown{partial\_data\_ok}   = (\tscon{MSG\_WAITALL} \;\notin  \;\tsvar{opts} \Mvee  \tsvar{n} > \tsvar{sock}.\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\neg{}(\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge  \tscon{MSG\_PEEK} \;\in  \;\tsvar{opts})) \Min {}\\{}
 \Mlet  \;\tsunknown{urgent\_data\_ahead} = (\exists \tsvar{om}.\tsunknown{tcp\_sock}.\tsvar{rcvurp} = \Msome  \;\tsvar{om} \Mwedge  0 < \tsvar{om} \Mwedge  \tsvar{om} \leq  \tsholop{LENGTH} \;\tsunknown{tcp\_sock}.\tsvar{rcvq})  \Min {}\\{}
 \neg{}(\tsunknown{have\_all\_data} \Mvee  (\tsunknown{have\_enough\_data} \Mwedge  \tsunknown{partial\_data\_ok}) \Mvee  \tsunknown{urgent\_data\_ahead}) \Mwedge {}\\{}
 {}\\{}
 (\tsvar{es} = \Mif  \;\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \;\Mthen  \;\Msome  \;\tsvar{e} \;\Melse  \;*)}
{\rulesubsection{Description}

    Thread $\tsvar{tid}$ is blocked in state $\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})$ where $\tsvar{sid}$ identifies a socket with
    pending error $\Msome  \;\tsvar{e}$. The call fails, returning the pending error. Data cannot be returned
    because: (1) there are less than $\tsvar{n}$ bytes of data in the socket's receive queue; (2) there
    are less than $\tsvar{sf}.\tsvar{n}(\tsunknown{SO\_RVCLOWAT})$ (the minimum number of bytes for socket $\tslib{recv}()$
    operations) bytes of data in the socket's receive queue or the call must return all $\tsvar{n}$ bytes
    of data: (i) the $\tscon{MSG\_WAITALL}$ flag is set in $\tsvar{opts}$, (ii) the number of bytes requested is
    greater than the length of the socket's receive queue, and (iii) the $\tscon{MSG\_PEEK}$ flag is not
    set in $\tsvar{opts}$; and (3) there is no urgent data ahead in the socket's receive queue.

    The thread returns from the blocked state, returning the pending error. A $\MLhtau $ transition
    is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$. If the $\tscon{MSG\_PEEK}$ flag was set in
    $\tsvar{opts}$ then the socket's pending error remains, otherwise it is cleared.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    In case (iii) above, the $\tscon{MSG\_PEEK}$ flag may be set in $\tsvar{opts}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTIX}{\rrulecc{recvTIX}{recv\_9}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{ESHUTDOWN}$: socket shut down for reading on WinXP }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantrcvmore} \Mass  \Mtrue ; \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{ESHUTDOWN}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantrcvmore} \Mass  \Mtrue ; \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mmagicrrec )] \Mmagicrrec }
{\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff})}
{\rulesubsection{Description}

     On WinXP, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts})$ call is
     made where $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$ which is shut down for reading. The call fails
     with an $\tscon{ESHUTDOWN}$ error.

     A $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tscon{ESHUTDOWN}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
     This rule does not apply.

\\\hline
Linux
&
     This rule does not apply.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommudpTrecv}{\clustersection{(UDP only)}{$\tslib{recv}()$}
\seccomm{ \[ \tslib{recv}: (\tstype{fd} * \tstype{int} * \tstype{msgbflag} \;\tstype{list}) \Mtotype  (\tstype{string} * ((\tstype{ip} * \tstype{port}) * \tstype{bool}) \;\tstype{option}) \]

  A call to $\tslib{recv}(\tstype{fd},\tsvar{n},\tsunknown{opts})$ returns data from the datagram on the head of a socket's receive
  queue.
   This section describes
  the behaviour for UDP sockets.
  Here the $\tstype{fd}$ argument is a file descriptor referring to the socket to receive data from,   $\tsvar{n}$ specifies the number of
  bytes of data to read from that socket, and the $\tsunknown{opts}$ argument is a list of flags for the $\tslib{recv}()$ call.  The possible flags are:

  \begin{itemize}

    \item $\tscon{MSG\_DONTWAIT}$: non-blocking behaviour is requested for this call. This flag only has
     effect on Linux. FreeBSD and WinXP ignore it. See rules $\tsrule{recv\_12}$ and $\tsrule{recv\_13}$.

    \item $\tscon{MSG\_PEEK}$: return data from the datagram on the head of the receive queue, without
     removing that datagram from the receive queue.

    \item $\tscon{MSG\_WAITALL}$: do not return until all $\tsvar{n}$ bytes of data have been read. Linux and
     FreeBSD ignore this flag. WinXP fails with $\tscon{EOPNOTSUPP}$ as this is not meaningful for UDP
     sockets: the returned data is from only one datagram.

    \item $\tscon{MSG\_OOB}$: return out-of-band data. This flag is ignored on Linux. On WinXP and FreeBSD
     the call fails with $\tscon{EOPNOTSUPP}$ as out-of-band data is not meaningful for UDP sockets.

  \end{itemize}

  The returned value of the $\tslib{recv}()$ call, $(\tstype{string} * ((\tstype{ip} * \tstype{port}) * \tstype{bool}) \;\tstype{option})$, consists of
  the data read from the socket (the $\tstype{string}$), the source address of the data (the $\tstype{ip} *
\tstype{port}$), and a flag specifying whether or not all of the datagram's data was read (the
  $\tstype{bool}$). The latter two components are wrapped in an $\;\tstype{option}$ type (for type compatibility with the TCP $\tslib{recv}()$) but are always returned for UDP. The
  flag only has meaning on WinXP and should be ignored on FreeBSD and Linux.

  For a socket to receive data, it must be bound to a local port. On Linux and FreeBSD, if the
  socket is not bound to a local port, then it is autobound to an ephemeral port when the $\tslib{recv}()$
  call is made. On WinXP, calling $\tslib{recv}()$ on a socket that is not bound to a local port is an
  $\tscon{EINVAL}$ error.

  If a non-blocking $\tslib{recv}()$ call is made (the socket's $\tscon{O\_NONBLOCK}$ flag is set) and there are
  no datagrams on the socket's receive queue, then the call will fail with $\tscon{EAGAIN}$. If the call
  is a blocking one and the socket's receive queue is empty then the call will block, returning when
  a datagram arrives or an error occurs.

  If the socket has a pending error then on FreeBSD and Linux, the call will fail with that
  error. On WinXP, errors from ICMP messages are placed on the socket's receive queue, and so the
  error will only be returned when that message is at the head of the receive queue.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{recv}()$ can fail with the errors below, in which case the corresponding exception is
  raised.

\par\begin{ltstabular}
$\tscon{EAGAIN}$
&  The call would block and non-blocking behaviour is requested. This is done
   either via the $\tscon{MSG\_DONTWAIT}$ flag being set in the $\tslib{recv}()$ flags or the socket's
   $\tscon{O\_NONBLOCK}$ flag being set.

\\\hline
$\tscon{EMSGSIZE}$
&  The amount of data requested in the $\tslib{recv}()$ call on WinXP is less than the
   amount of data in the datagram on the head of the receive queue.

\\\hline
$\tscon{EOPNOTSUPP}$
&  Operation not supported: out-of-band data is requested on FreeBSD and WinXP,
   or the $\tscon{MSG\_WAITALL}$ flag is set on a $\tslib{recv}()$ call on WinXP.

\\\hline
$\tscon{ESHUTDOWN}$
&  On WinXP, a $\tslib{recv}()$ call is made on a socket that has been shutdown for
   reading.

\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\\\hline
$\tscon{EINTR}$
&  The system was interrupted by a caught signal.

\\\hline
$\tscon{ENOBUFS}$
&  Out of resources.

\\\hline
$\tscon{ENOMEM}$
&  Out of resources.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
   \

  A UDP socket is created and bound to a local address. Other calls are made and datagrams are
  delivered to the socket; $\tslib{recv}()$ is called to read from a datagram: $\tsrule{socket\_1}$; $\tsrule{return\_1}$;
  $\tsrule{bind\_1}$; $ \ldots $ $\tsrule{recv\_11}$; $\tsrule{return\_1}$;

  A UDP socket is created and bound to a local address. $\tslib{recv}()$ is called and blocks; a datagram
  arrives addressed to the socket's local address and is placed on its receive queue; the call
  returns: $\tsrule{socket\_1}$; $\tsrule{return\_1}$; $\tsrule{bind\_1}$; $ \ldots $ $\tsrule{recv\_12}$; $\tsrule{deliver\_in\_99}$;
  $\tsrule{deliver\_in\_udp\_1}$; $\tsrule{recv\_15}$; $\tsrule{return\_1}$;

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:   & \wasverb{ssize\textunderscore{}t recvfrom(int socket, void *restrict buffer, size\textunderscore{}t length,}\\
             & \wasverb{                  int flags, struct sockaddr *restrict address,}\\
             & \wasverb{                 socklen\textunderscore{}t *restrict address\textunderscore{}len);}\\
    FreeBSD: & \wasverb{ssize\textunderscore{}t recvfrom(int s, void *buf, size\textunderscore{}t len, int flags,} \\
             & \wasverb{                 struct sockaddr *from, socklen\textunderscore{}t *fromlen);} \\
    Linux:   & \wasverb{int  recvfrom(int  s, void *buf, size\textunderscore{}t len, int flags,} \\
             & \wasverb{              struct sockaddr *from, socklen\textunderscore{}t *fromlen);} \\
    WinXP:   & \wasverb{int recvfrom(SOCKET s, char* buf, int len, int flags,} \\
             & \wasverb{             struct sockaddr* from, int* fromlen);} \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to receive from, corresponding to
     the $\tstype{fd}$ argument of the model $\tslib{recv}()$.

    \item \wasverb{buffer} is a pointer to a buffer to place the received data in, which upon return
     contains the data received on the socket. This corresponds to the $\tstype{string}$ return value of
     the model $\tslib{recv}()$.


    \item \wasverb{length} is the amount of data to be read from the socket, corresponding to the $\tstype{int}$
     argument of the model $\tslib{recv}()$; it should be at most the length of \wasverb{buffer}.

    \item \wasverb{flags} is a disjunction of the message flags that are set for the call, corresponding to
     the $\tstype{msgbflag}$ $\tstype{list}$ argument of the model $\tslib{recv}()$.

    \item \wasverb{address} is a pointer to a \wasverb{sockaddr} structure of length
     \wasverb{address\textunderscore{}len}, which upon return contains the source address of the data received by
     the socket corresponding to the $(\tstype{ip} * \tstype{port})$ in the return value of the model
     $\tslib{recv}()$. For the \wasverb{AF\textunderscore{}INET} sockets used in the model, it is actually a
     \wasverb{sockaddr\textunderscore{}in} that is used: the \wasverb{in\textunderscore{}addr.s\textunderscore{}addr} field corresponds to the
     $\tstype{ip}$ and the \wasverb{sin\textunderscore{}port} field corresponds to the $\tstype{port}$.

    \item the returned \wasverb{ssize\textunderscore{}t} is either non-negative, in which case it is the the amount
     of data that was received by the socket, or it is \wasverb{-1} to indicate an error, in which
     case the error code is in \wasverb{errno}. On WinXP an error is indicated by a return value of
     \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error code available through a
     call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  On WinXP, if the data from a datagram is not all read then the call fails with $\tscon{EMSGSIZE}$,
  but still fills the \wasverb{buffer} with data. This is modelled by the $\tstype{bool}$ flag in the model
  $\tslib{recv}()$: if it is set to $\Mtrue $ then the call succeeded and read all of the datagrams's data; if
  it is set to $\Mfalse $ then the call failed with $\tscon{EMSGSIZE}$ but still returned data.

  There are other functions used to receive data on a socket. \wasverb{recv()} is similar to
  \wasverb{recvfrom()} except it does not have the \wasverb{address} and \wasverb{address\textunderscore{}len}
  arguments. It is used when the source address of the data does not need to be returned from the
  call. \wasverb{recvmsg()}, another input function, is a more general form of \wasverb{recvfrom()}.

}\clustersubsection{Model details}
\seccomm{
  If the call blocks then the thread enters state $\tscon{Recv2}(\tstype{sid},\tsvar{n},\tsunknown{opts})$ where:

  \begin{itemize}

    \item $\tstype{sid} : \tstype{sid}$ is the identifier of the socket that the $\tslib{recv}()$ call was made on,

    \item $\tsvar{n} : \tstype{num}$ is the number of bytes to be read, and

    \item $\tsunknown{opts} : \tstype{msgbflag} \;\tstype{list}$ is the set of message flags.

  \end{itemize}

  The following errors are not modelled:

  \begin{itemize}

    \item On FreeBSD, Linux, and WinXP, $\tscon{EFAULT}$ can be returned if the \wasverb{buffer}
    parameter points to memory not in a valid part of the process address space. This is an artefact
    of the C interface to \wasverb{ioctl()} that is excluded by the clean interface used in the
    model $\tslib{recv}()$.

    \item In Posix, \wasverb{EIO} may be returned to indicated that an I/O error occurred while
    reading from or writing to the file system; this is not modelled here.

    \item \wasverb{EINVAL} may be returned if the $\tscon{MSG\_OOB}$ flag is set and no out-of-band data is
    available; out-of-band data does not exist for UDP so this does not apply.

    \item \wasverb{ENOTCONN} may be returned if the socket is not connected; this does not apply for
    UDP as the socket need not have a peer specified to receive datagrams.

    \item \wasverb{ETIMEDOUT} can be returned due to a transmission timeout on a connection; UDP is
    not connection-oriented so this does not apply.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}

   The following Linx message flags are not modelled: \wasverb{MSG\textunderscore{}NOSIGNAL}, \wasverb{MSG\textunderscore{}TRUNC}, and
  \wasverb{MSG\textunderscore{}ERRQUEUE}.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{recv\_11}$
& \textbf{udp: fast succeed}
&  Receive data successfully without blocking \\
$\tsrule{recv\_12}$
& \textbf{udp: block}
&  Block, entering $\tscon{Recv2}$ state as no datagrams available on socket \\
$\tsrule{recv\_13}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{EAGAIN}$: call would block and socket is non-blocking or, on Linux, non-blocking behaviour has been requested with the $\tscon{MSG\_DONTWAIT}$ flag \\
$\tsrule{recv\_14}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{EAGAIN}$, $\tscon{EADDRNOTAVAIL}$, or $\tscon{ENOBUFS}$: there are no ephemeral ports left \\
$\tsrule{recv\_15}$
& \textbf{udp: slow urgent succeed}
&  Blocked call returns from $\tscon{Recv2}$ state with data \\
$\tsrule{recv\_16}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{EOPNOTSUPP}$: $\tscon{MSG\_WAITALL}$ flag not supported on WinXP, or $\tscon{MSG\_OOB}$ flag not supported on FreeBSD and WinXP \\
$\tsrule{recv\_17}$
& \textbf{udp: rc}
&  Socket shutdown for reading: fail with $\tscon{ESHUTDOWN}$ on WinXP or succeed on Linux and FreeBSD \\
$\tsrule{recv\_20}$
& \textbf{udp: rc}
&  Successful partial read of datagram on head of socket's receive queue on WinXP \\
$\tsrule{recv\_21}$
& \textbf{udp: fast succeed}
&  Read zero bytes of data from an empty receive queue on FreeBSD \\
$\tsrule{recv\_22}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{EINVAL}$ on WinXP: socket is unbound \\
$\tsrule{recv\_23}$
& \textbf{udp: rc}
&  Read ICMP error from receive queue and fail with that error on WinXP \\
$\tsrule{recv\_24}$
& \textbf{udp: fast fail}
&  Fail with pending error \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\recvTXI}{\rrulecc{recvTXI}{recv\_11}{udp: fast succeed}{\tsholcomm{ Receive data successfully without blocking }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{ \tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{OK}(\tsholop{IMPLODE} \;\tsvar{data}',\Msome ((\tsvar{i}_{3},\tsvar{ps}_{3}),\tsvar{b})))}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec }
{{}\\{}
\quad \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
\quad \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
\quad \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
\quad \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},*,\tsvar{cantsndmore},\tsvar{cantrcvmore},\tsaux{UDP\_Sock}(\tsvar{rcvq}')) \Mwedge {}\\{}
\quad (\neg{}(\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch}) \implies  \tsvar{cantrcvmore} = \Mfalse ) \Mwedge {}\\{}
\quad \tsvar{rcvq} = (\tscon{Dgram\_msg}(\Mmagiclrec  \tsvar{is} \Mass  \tsvar{i}_{3}; \tsvar{ps} \Mass  \tsvar{ps}_{3}; \tsvar{data} \Mass  \tsvar{data} \Mmagicrrec ))\Mcons \tsvar{rcvq}'' \Mwedge {}\\{}
\quad \tsvar{n} = \tsaux{clip\_int\_to\_num} \;\tsvar{n}_{0} \Mwedge {}\\{}
\quad ((\tsholop{LENGTH} \;\tsvar{data} \leq  \tsvar{n} \Mwedge  \tsvar{data} = \tsvar{data}') \Mvee {}\\{}
\quad\quad (\tsholop{LENGTH} \;\tsvar{data} > \tsvar{n} \Mwedge  \tsvar{data}' = \tsaux{TAKE} \;\tsvar{n} \;\tsvar{data} \Mwedge  \tsholop{LENGTH} \;\tsvar{data}' = \tsvar{n} \Mwedge  \neg{}(\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}))) \Mwedge {}\\{}
\quad (\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \implies  \tsvar{b} = \Mtrue ) \Mwedge {}\\{}
\quad \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
\quad \tsvar{rcvq}' = (\Mif  \;\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \;\Mthen  \;\tsvar{rcvq} \;\Melse  \;\tsvar{rcvq}'')}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$. It is not shutdown for reading, has no
    pending errors, and is bound to local port $\tsvar{p}_{1}$. Thread $\tsvar{tid}$ is in the $\tscon{Run}$ state.

    The socket's receive queue has a datagram at its head with data $\tsvar{data}$ and source address
    $\tsvar{i}_{3},\tsvar{ps}_{3}$. A call $\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$, from thread $\tsvar{tid}$, succeeds.

    A $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made. The thread is left in state $\tscon{Ret}
(\tscon{OK}(\tsholop{IMPLODE} \;\tsvar{data}',\Msome (\tsvar{i}_{3},\tsvar{ps}_{3})))$, where $\tsvar{data}'$ is either:

    \begin{itemize}

      \item all of the data in the datagram, $\tsvar{data}$, if the amount of data requested $\tsvar{n}_{0}$ is
       greater than or equal to the amount of data in the datagram, or

      \item the first $\tsvar{n}_{0}$ bytes of $\tsvar{data}$ if $\tsvar{n}_{0}$ is less than the amount of data in the
       datagram, unless the architecture is WinXP (see below).

    \end{itemize}

    If the $\tscon{MSG\_PEEK}$ option is set in $\tsvar{opts}_{0}$ then the entire datagram stays on the receive
    queue; the next call to $\tslib{recv}()$ will be able to access this datagram. Otherwise, the entire
    datagram is discarded from the receive queue, even if all of its data has not been read.

\rulesubsection{Model details}

    The amount of data requested, $\tsvar{n}_{0}$, is clipped to a natural number from an integer, using
    $\tsaux{clip\_int\_to\_num}$. POSIX specifies an unsigned type for $\tsvar{n}_{0}$ and this is one possible model
    thereof.

    The $\tsvar{opts}_{0}$ argument to $\tslib{recv}()$ is of type $\tstype{msgbflag} \;\tstype{list}$, but it is converted to a set,
    $\tsvar{opts}$, using $\tsholop{LIST\_TO\_SET}$.

    The data itself is represented as a $\tstype{byte} \;\tstype{list}$ in the datagram but is returned a $\tstype{string}$:
    the $\tsholop{IMPLODE}$ function is used to do the conversion.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    The amount of data in bytes requested, $\tsvar{n}_{0}$, must be greater than or equal to the number of
    bytes of data in the datagram on the head of the receive queue. The boolean $\tsvar{b}$ equals $\Mtrue $,
    indicating that all of the datagram's data has been read. Otherwise refer to rule $\tsrule{recv\_20}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXII}{\rrulecc{recvTXII}{recv\_12}{udp: block}{\tsholcomm{ Block, entering $\tscon{Recv2}$ state as no datagrams available on socket }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{\tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})}{\tsaux{never\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{h}_{0}.\tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}'_{1} \Mmagicrrec )];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec   \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},*,\tsvar{cantsndmore},\Mfalse ,\tsaux{UDP\_Sock}([\,])) \Mwedge {}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{sock}.\tsvar{ps}_{1},\tscon{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{sock}.\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound}) \Mwedge {}\\{}
 \neg{}((\tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts} \Mwedge  \tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch}) \Mvee  \tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK})) \Mwedge {}\\{}
 (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \implies  \neg{}(\tsvar{n}=0)) \Mwedge {}\\{}
 \tsvar{n} = \tsaux{clip\_int\_to\_num} \;\tsvar{n}_{0} \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0}}
{\rulesubsection{Description}

     Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, that has no pending errors, is not
     shutdown for reading, has an empty receive queue, and does not have its $\tscon{O\_NONBLOCK}$ flag
     set. The socket is either bound to a local port $\Msome  \;\tsvar{p}'_{1}$ or can be autobound to a local
     port $\Msome  \;\tsvar{p}'_{1}$. From thread $\tsvar{tid}$, which in the $\tscon{Run}$ state, a $\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call
     is made. Because there are no datagrams on the socket's receive queue, the call will block.

     A $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition will be made, leaving the thread state
     $\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})$. If autobinding occurred then $\tsvar{sid}$ will be placed on the head of the
     host's list of bound sockets: $\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound}$.

\rulesubsection{Model details}

     The amount of data requested, $\tsvar{n}_{0}$, is clipped to a natural number $\tsvar{n}$ from an integer, using
     $\tsaux{clip\_int\_to\_num}$. POSIX specifies an unsigned type for $\tsvar{n}_{0}$ and this is one possible model
     thereof.

     The $\tsvar{opts}_{0}$ argument to $\tslib{recv}()$ is of type $\tstype{msgbflag} \;\tstype{list}$, but it is converted to a
     set, $\tsvar{opts}$, using $\tsholop{LIST\_TO\_SET}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
     As above, with the added condition that the number of bytes requested to be read is not zero.

\\\hline
Linux
&
     As above, with the added condition that the $\tscon{MSG\_DONTWAIT}$ flag is not set in $\tsvar{opts}_{0}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXIII}{\rrulecc{recvTXIII}{recv\_13}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{EAGAIN}$: call would block and socket is non-blocking or, on Linux, non-blocking behaviour has been requested with the $\tscon{MSG\_DONTWAIT}$ flag }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EAGAIN}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{s} \; \Mmagiclrec  \tsvar{es} \Mass  *; \tsvar{pr} \Mass  \tsaux{UDP\_Sock}([\,]) \Mmagicrrec )] \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{s} \; \Mmagiclrec  \tsvar{es} \Mass  *; \tsvar{pr} \Mass  \tsaux{UDP\_Sock}([\,]) \Mmagicrrec )] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 ((\tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts} \Mwedge  \tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch}) \Mvee  \tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}))}
{\rulesubsection{Description}

     Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. It has no pending errors, and an empty
     receive queue. The socket is non-blocking: its $\tscon{O\_NONBLOCK}$ flag has been set. From thread
     $\tsvar{tid}$, in the $\tscon{Run}$ state, a $\tslib{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts}_{0})$ call is made. The call would block
     because the socket has an empty receive queue, so the call fails with an $\tscon{EAGAIN}$ error.

     A $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts}_{0})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tscon{EAGAIN}})$.

\rulesubsection{Model details}

     The $\tsvar{opts}_{0}$ argument is of type $\tstype{list}$. In the model it is converted to a $\tstype{set}$ $\tsvar{opts}$
     using $\tsholop{LIST\_TO\_SET}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
     As above, but the rule also applies if the socket's $\tscon{O\_NONBLOCK}$ flag is not set but the
     $\tscon{MSG\_DONTWAIT}$ flag is set in $\tsvar{opts}_{0}$. Also, note that $\tscon{EWOULDBLOCK}$ and $\tscon{EAGAIN}$ are
     aliased on Linux.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXIV}{\rrulecc{recvTXIV}{recv\_14}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{EAGAIN}$, $\tscon{EADDRNOTAVAIL}$, or $\tscon{ENOBUFS}$: there are no ephemeral ports left }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts})} }{1}}
{\tsvar{h}_{0} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid}, \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,*,*,*,*,\tsvar{cantsndmore},\tsvar{cantrcvmore},\tsaux{UDP\_Sock}([\,])))] \Mmagicrrec  \Mwedge {}\\{}
 \tsaux{autobind}(*,\tscon{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) = \emptyset  \Mwedge {}\\{}
 \tsvar{e} \;\in  \{\tscon{EAGAIN}; \tscon{EADDRNOTAVAIL}; \tscon{ENOBUFS}\} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff})}
{\rulesubsection{Description}

     Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$. The socket has no pending errors, an empty
     receive queue, and binding quad $*,*,*,*$. From thread $\tsvar{tid}$, which is in the
     $\tscon{Run}$ state, a $\tslib{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts})$ call is made. There is no ephemeral port to autobind the
     socket to, so the call fails with either $\tscon{EAGAIN}$, $\tscon{EADDRNOTAVAIL}$ or $\tscon{ENOBUFS}$.

     A $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$ where e is one of the above errors.

\rrulepad }
}

\newcommand{\recvTXV}{\rrulecc{recvTXV}{recv\_15}{udp: slow urgent succeed}{\tsholcomm{ Blocked call returns from $\tscon{Recv2}$ state with data }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}_{1}; \tsvar{es} \Mass  *; \tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{OK}(\tsholop{IMPLODE} \;\tsvar{data}',\Msome  ((\tsvar{i}_{3},\tsvar{ps}_{3}),\tsvar{b})))}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid}, \tsvar{sock} \; \Mmagiclrec  \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}_{1}; \tsvar{es} \Mass  *; \tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}') \Mmagicrrec )] \Mmagicrrec }
{\tsvar{rcvq} = (\tscon{Dgram\_msg}(\Mmagiclrec  \tsvar{is} \Mass  \tsvar{i}_{3}; \tsvar{ps} \Mass  \tsvar{ps}_{3}; \tsvar{data} \Mass  \tsvar{data} \Mmagicrrec ))\Mcons \tsvar{rcvq}'' \Mwedge {}\\{}
 (\tsvar{rcvq}' = \Mif  \;\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \;\Mthen  \;\tsvar{rcvq} \;\Melse  \;\tsvar{rcvq}'') \Mwedge {}\\{}
 ((\tsholop{LENGTH} \;\tsvar{data} \leq  \tsvar{n} \Mwedge  \tsvar{data}=\tsvar{data}') \Mvee {}\\{}
\quad (\tsholop{LENGTH} \;\tsvar{data} > \tsvar{n} \Mwedge  \neg{}(\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge  \tsvar{data}' = \tsaux{TAKE} \;\tsvar{n} \;\tsvar{data}' \Mwedge  \tsholop{LENGTH} \;\tsvar{data}' = \tsvar{n} )) \Mwedge {}\\{}
 (\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \implies  \tsvar{b}=\Mtrue )}
{\rulesubsection{Description}

     Consider a UDP socket $\tsvar{sid}$ with no pending errors and bound to local port $\tsvar{p}_{1}$. At the
     head of the socket's receive queue, $\tsvar{rcvq}$, is a UDP datagram with source address
     $(\tsvar{i}_{3},\tsvar{ps}_{3})$ and data $\tsvar{data}$. Thread $\tsvar{tid}$ is blocked in state $\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})$.

     The blocked call successfully returns $(\tsholop{IMPLODE} \;\tsvar{data}',\Msome ((\tsvar{i}_{3},\tsvar{ps}_{3},\tsvar{b})))$. If the number of
     bytes requested, $\tsvar{n}$, is greater than or equal to the number of bytes of data in the
     datagram, $\tsvar{data}$, then all of $\tsvar{data}$ is returned. If $\tsvar{n}$ is less than the number of bytes
     in the datagram, then the first $\tsvar{n}$ bytes of data are returned.

     A $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}(\tsholop{IMPLODE}
\tsvar{data}',\Msome ((\tsvar{i}_{3},\tsvar{ps}_{3}),\tsvar{b})))$. If the $\tscon{MSG\_PEEK}$ flag was set in $\tsvar{opts}$ then the datagram
     stays on the head of the socket's receive queue; otherwise, it is discarded from the receive
     queue.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
     As above, except the number of bytes of data requested $\tsvar{n}$, must be greater than or equal to
     the length in bytes of $\tsvar{data}$. The boolean $\tsvar{b}$ equals $\Mtrue $, indicating that all of the
     datagram's data was read.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXVI}{\rrulecc{recvTXVI}{recv\_16}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{EOPNOTSUPP}$: $\tscon{MSG\_WAITALL}$ flag not supported on WinXP, or $\tscon{MSG\_OOB}$ flag not supported on FreeBSD and WinXP }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EOPNOTSUPP}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 ((\tscon{MSG\_OOB} \;\in  \;\tsvar{opts} \Mwedge  \neg{}(\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch})) \Mvee  (\tscon{MSG\_WAITALL} \;\in  \;\tsvar{opts} \Mwedge  \tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}))}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, in the $\tscon{Run}$ state, a
    $\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made. The $\tscon{MSG\_OOB}$ or $\tscon{MSG\_WAITALL}$ flags are set in
    $\tsvar{opts}_{0}$. The call fails with an $\tscon{EOPNOTSUPP}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EOPNOTSUPP}})$.

\rulesubsection{Model details}

    The $\tsvar{opts}_{0}$ argument is of type $\tstype{list}$. In the model it is converted to a $\tstype{set}$ $\tsvar{opts}$
    using $\tsholop{LIST\_TO\_SET}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    As above, except the rule only applies when $\tscon{MSG\_OOB}$ is set in $\tsvar{opts}_{0}$.

\\\hline
FreeBSD
&
    As above, except the rule only applies when $\tscon{MSG\_OOB}$ is set in $\tsvar{opts}_{0}$.

\\\hline
Linux
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXVII}{\rrulecc{recvTXVII}{recv\_17}{udp: rc}{\tsholcomm{ Socket shutdown for reading: fail with $\tscon{ESHUTDOWN}$ on WinXP or succeed on Linux and FreeBSD }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts}\Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantrcvmore} \Mass  \Mtrue ; \tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{ \tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tsvar{ret})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantrcvmore} \Mass  \Mtrue ; \tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}) \Mmagicrrec )] \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mif       \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{ret} = \tscon{FAIL}\;{(\tscon{ESHUTDOWN})} \Mwedge  \tsvar{rc} = \tscon{fast} \;\tscon{fail}{}\\{}
 \Melse  \;\Mif  \;\tsaux{bsd\_arch}     \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{ret} = \tscon{OK}(\text{``''},\Msome ((*,*),\tsvar{b})) \Mwedge  \tsvar{rc} = \tscon{fast} \;\tscon{succeed} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{es} = *{}\\{}
 \Melse  \;\Mif  \;\tsaux{linux\_arch}   \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad \tsvar{rcvq} = [\,] \Mwedge  \tsvar{ret} = \tscon{OK}(\text{``''},\Msome ((*,*),\tsvar{b})) \Mwedge  \tsvar{rc} = \tscon{fast} \;\tscon{succeed} \Mwedge  \tsvar{sock}.\tsvar{es} = *{}\\{}
 \Melse  \;\tsaux{ASSERTION\_FAILURE} \text{``recv\textunderscore{}17''} }
{\rulesubsection{Description}

   Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, that has been shutdown for reading. From
   thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made. On FreeBSD
   and Linux, if the socket has no pending error the call is successfully, returning
   $(\text{``''},\Msome ((*,*),\tsvar{b}))$; on WinXP the call fails with an $\tscon{ESHUTDOWN}$ error.

   A $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}(\text{``''},\Msome ((*,*),\tsvar{b})))$ on FreeBSD and Linux, or $\tscon{Ret} (\tscon{FAIL}\;{\tscon{ESHUTDOWN}})$ on WinXP.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
   As above: the call succeeds.

\\\hline
Linux
&
   As above: the call succeeds with the additional condition that the socket has an empty receive
   queue.

\\\hline
WinXP
&
   As above: the call fails with an $\tscon{ESHUTDOWN}$ error.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXX}{\rrulecc{recvTXX}{recv\_20}{udp: rc}{\tsholcomm{ Successful partial read of datagram on head of socket's receive queue on WinXP }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{t}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \tsvar{lbl} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK}(\tsholop{IMPLODE} \;\tsvar{data}',\Msome ((\tsvar{i}_{3},\tsvar{ps}_{3}),\Mfalse )))}{ \tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec }
{\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{rcvq} = (\tscon{Dgram\_msg}(\Mmagiclrec  \tsvar{is} \Mass  \tsvar{i}_{3}; \tsvar{ps} \Mass  \tsvar{ps}_{3}; \tsvar{data} \Mass  \tsvar{data} \Mmagicrrec ))\Mcons \tsvar{rcvq}'' \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},*,\tsvar{cantsndmore},\tsvar{cantrcvmore},\tsaux{UDP\_Sock}(\tsvar{rcvq}')) \Mwedge {}\\{}
 ((\exists \tsvar{fd} \;\tsvar{ff} \;\tsvar{n} \;\tsvar{n}_{0} \;\tsvar{opts}_{0}.{}\\{}
\quad\quad \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
\quad\quad \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
\quad\quad \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
\quad\quad (\tsvar{rcvq}' = \Mif  \;\tscon{MSG\_PEEK} \;\in  (\tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0}) \Mthen  \;\tsvar{rcvq} \;\Melse  \;\tsvar{rcvq}'') \Mwedge {}\\{}
\quad\quad \tsvar{n} = \tsaux{clip\_int\_to\_num} \;\tsvar{n}_{0} \Mwedge {}\\{}
\quad\quad \tsvar{n} < \tsholop{LENGTH} \;\tsvar{data} \Mwedge {}\\{}
\quad\quad \tsvar{data}' = \tsaux{TAKE} \;\tsvar{n} \;\tsvar{data} \Mwedge {}\\{}
\quad\quad \tsvar{t} = \tscon{Run} \Mwedge {}\\{}
\quad\quad \tsvar{rc} = \tscon{fast} \;\tscon{succeed} \Mwedge {}\\{}
\quad\quad \tsvar{lbl} = \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}) \Mvee {}\\{}
 (\exists \tsvar{n} \;\tsvar{opts}.{}\\{}
\quad\quad \tsvar{lbl} = \MLhtau   \Mwedge {}\\{}
\quad\quad \tsvar{t} = \tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts}) \Mwedge {}\\{}
\quad\quad \tsvar{rc} = \tscon{slow} \;\tsaux{urgent} \;\tscon{succeed} \Mwedge {}\\{}
\quad\quad \tsvar{data}' = \tsaux{TAKE} \;\tsvar{n} \;\tsvar{data} \Mwedge {}\\{}
\quad\quad \tsvar{n} < \tsholop{LENGTH} \;\tsvar{data} \Mwedge {}\\{}
\quad\quad \tsvar{rcvq}' = \Mif  \;\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \;\Mthen  \;\tsvar{rcvq} \;\Melse  \;\tsvar{rcvq}''))}
{\rulesubsection{Description}

   On WinXP, consider a UDP socket $\tsvar{sid}$ bound to a local port $\tsvar{p}_{1}$ and with no pending
   errors. At the head of the socket's receive queue is a datagram with source address $\tsvar{is} \Mass  \tsvar{i}_{3};
\tsvar{ps} \Mass  \tsvar{ps}_{3}$ and data $\tsvar{data}$. This rule covers two cases:

   In the first, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is
   made where $\tsvar{fd}$ refers to the socket $\tsvar{sid}$. The amount of data to be read, $\tsvar{n}_{0}$ bytes, is
   less than the number of bytes of data in the datagram, $\tsvar{data}$. The call successfully returns
   the first $\tsvar{n}_{0}$ bytes of data from the datagram, $\tsvar{data}'$. A $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$
   transition is made leaving the thread state $\tscon{Ret} (\tscon{OK}(\tsholop{IMPLODE} \;\tsvar{data}',\Msome ((\tsvar{i}_{3},\tsvar{ps}_{3}),\Mfalse )))$ where
   the $\Mfalse $ indicates that not all of the datagram's data was read. The datagram is discarded from
   the socket's receive queue unless the $\tscon{MSG\_PEEK}$ flag was set in $\tsvar{opts}_{0}$, in which case the
   whole datagram remains on the socket's receive queue.

   In the second case, thread $\tsvar{tid}$ is blocked in state $\tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts})$ where the number of
   bytes to be read, $\tsvar{n}$, is less than the number of bytes of data in the datagram. There is now
   data to be read so a $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}(\tsholop{IMPLODE}
\tsvar{data}',\Msome ((\tsvar{i}_{3},\tsvar{ps}_{3}),\Mfalse )))$ where the $\Mfalse $ indicated that not all of the datagram's data was
   read. The datagram is discarded from the socket's receive queue unless the $\tscon{MSG\_PEEK}$ flag was
   set in $\tsvar{opts}$, in which case the whole datagram remains on the socket's receive queue.

\rulesubsection{Model details}

   The amount of data requested, $\tsvar{n}_{0}$, is clipped to a natural number from an integer, using
   $\tsaux{clip\_int\_to\_num}$. POSIX specifies an unsigned type for $\tsvar{n}_{0}$ and this is one possible model
   thereof.

   The data itself is represented as a $\tstype{byte} \;\tstype{list}$ in the datagram but is returned a $\tstype{string}$,
   so the $\tsholop{IMPLODE}$ function is used to do the conversion.

   In the model the return value is $\tscon{OK}(\tsholop{IMPLODE} \;\tsvar{data}',\Msome ((\tsvar{i}_{3},\tsvar{p}_{3}),\Mfalse ))$ where the $\Mfalse $ represents
   not all the data in the datagram at the head of the socket's receive queue being read. What
   actually happens is that an $\tscon{EMSGSIZE}$ error is returned, and the data is put into the read
   buffer specified when the $\tslib{recv}()$ call was made.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
   This rule does not apply.

\\\hline
FreeBSD
&
   This rule does not apply.

\\\hline
Linux
&
   This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXXI}{\rrulecc{recvTXXI}{recv\_21}{udp: fast succeed}{\tsholcomm{ Read zero bytes of data from an empty receive queue on FreeBSD }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tsaux{UDP\_Sock}([\,]) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK}(\text{``''},\Msome ((*,*),\tsvar{b})))}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tsaux{UDP\_Sock}([\,]) \Mmagicrrec )] \Mmagicrrec }
{\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 0 = \tsaux{clip\_int\_to\_num} \;\tsvar{n}_{0}}
{\rulesubsection{Description}

    On FreeBSD, consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, with an empty receive
    queue. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made
    where $\tsvar{n}_{0} = 0$. The call succeeds, returning the empty string and not specifying an address:
    $\tscon{OK}(\text{``''},\Msome ((*,*),\tsvar{b}))$.

    A $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made, leaving the thread  state
    $\tscon{Ret} (\tscon{OK}(\text{``''},\Msome ((*,*),\tsvar{b})))$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    This rule does not apply: see rules $\tsrule{recv\_12}$ and $\tsrule{recv\_13}$.

\\\hline
Linux
&
    This rule does not apply: see rules $\tsrule{recv\_12}$ and $\tsrule{recv\_13}$.

\\\hline
WinXP
&
    This rule does not apply: see rules $\tsrule{recv\_12}$ and $\tsrule{recv\_13}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXXII}{\rrulecc{recvTXXII}{recv\_22}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{EINVAL}$ on WinXP: socket is unbound }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{ps}_{1} \Mass  *; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec  )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{ps}_{1} \Mass  *; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec  )] \Mmagicrrec }
{\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff})}
{\rulesubsection{Description}

    On WinXP, consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ that is not bound to a local
    port. A $\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0}$ call is made from thread $\tsvar{tid}$ which is in the $\tscon{Run}$ state. The
    call fails with an $\tscon{EINVAL}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is made, leaving the thread state
    $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    This rule does not apply.

\\\hline
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXXIII}{\rrulecc{recvTXXIII}{recv\_23}{udp: rc}{\tsholcomm{ Read ICMP error from receive queue and fail with that error on WinXP }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{t}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \tsvar{lbl} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{ \tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}') \Mmagicrrec )] \Mmagicrrec }
{\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{rcvq} = (\tscon{Dgram\_error}(\Mmagiclrec  \tsvar{e} \Mass  \tsvar{err} \Mmagicrrec ))\Mcons \tsvar{rcvq}' \Mwedge {}\\{}
 ((\exists \tsvar{fd} \;\tsvar{n}_{0} \;\tsvar{opts}_{0} \;\tsvar{fid} \;\tsvar{ff}. \tsvar{t} = \tscon{Run} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{lbl} = \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{rc} = \tscon{fast} \;\tscon{fail} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff})) \Mvee {}\\{}
 (\exists \tsvar{n} \;\tsvar{opts}. \tsvar{t} = \tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{lbl} = \MLhtau  \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{rc} = \tscon{slow} \;\tsaux{urgent} \;\tscon{fail}))}
{\rulesubsection{Description}

    On WinXP, consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. At the head of the socket's
    receive queue, $\tsvar{rcvq}$, is an ICMP message with error $\tsvar{err}$. This rule covers two cases.

    In the first, thread $\tsvar{tid}$ is in the $\tscon{Run}$ state and a $\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is
    made. The call fails with error $\tsvar{err}$, making a $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition.
    This leaves the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$, and the socket with the ICMP message removed
    from its receive queue.

    In the second case, thread $\tsvar{tid}$ is blocked in state $\tscon{Recv2}(\tsvar{sid},\tsvar{n}_{0},\tsvar{opts}_{0})$. A $\MLhtau $
    transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$, and the socket with the ICMP
    message removed from its receive queue.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    This rule does not apply.

\\\hline
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\recvTXXIV}{\rrulecc{recvTXXIV}{recv\_24}{udp: fast fail}{\tsholcomm{ Fail with pending error }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\Msome  \;\tsvar{e},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 (\neg{}\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \implies  \exists \tsvar{p}_{2}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}) \Mwedge {}\\{}
 \tsvar{es} = \Mif  \;\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \;\Mthen  \;\Msome  \;\tsvar{e} \;\Melse  \;*}
{\rulesubsection{Description}

     From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})$ call is made.
     $\tsvar{fd}$ refers to a UDP socket that has local address $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1})$, has its peer port
     set: $\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}$, and has pending error $\Msome  \;\tsvar{e}$.

     The call fails returning the pending error: a $\MLhcall{\tsvar{tid}}{\tslib{recv}(\tsvar{fd},\tsvar{n}_{0},\tsvar{opts}_{0})}$ transition is
     made leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EAGAIN}})$. If the $\tscon{MSG\_PEEK}$ flag was set in
     $\tsvar{opts}_{0}$ then the socket's pending error remains, otherwise it is cleared.

\rulesubsection{Model details}

     The $\tsvar{opts}_{0}$ argument to $\tslib{recv}()$ is of type $\tstype{msgbflag} \;\tstype{list}$, but it is converted to a
     set, $\tsvar{opts}$, using $\tsholop{LIST\_TO\_SET}$.



\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
     The socket need not have its peer port set.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommtcpTsend}{\clustersection{(TCP only)}{$\tslib{send}()$}
\seccomm{ \[ \tslib{send}: \tstype{fd} * (\tstype{ip} * \tstype{port}) \;\tstype{option} * \tstype{string} * \tstype{msgbflag} \;\tstype{list} \Mtotype  \tstype{string}  \]

  This section describes
  the behaviour of $\tslib{send}()$ for TCP sockets.
  A call to $\tslib{send}(\tstype{fd},*,\tsvar{data},\tsunknown{flags})$ enqueues data on the TCP socket's send queue.
  Here
  $\tstype{fd}$ is a file descriptor referring to the TCP socket to enqueue data on.
  The second argument, of type $(\tstype{ip} * \tstype{port}) \;\tstype{option}$, is the destination address of the data for UDP, but for
  a TCP socket it should be set to $*$ (the socket must be
  connected to a peer before $\tslib{send}()$ can be called).
  The   $\tsvar{data}$ is the data to be sent.
  Finally, $\tsunknown{flags}$ is a list of flags for the $\tslib{send}()$ call; possible flags are: $\tscon{MSG\_OOB}$, specifying
  that the data to be sent is out-of-band data, and $\tscon{MSG\_DONTWAIT}$, specifying that non-blocking
  behaviour is to be used for this call. The $\tscon{MSG\_WAITALL}$ and $\tscon{MSG\_PEEK}$ flags may also be set,
  but as they are meaningless for $\tslib{send}()$ calls, FreeBSD ignores them, and Linux and WinXP fail
  with $\tscon{EOPNOTSUPP}$.
  The returned $\tstype{string}$ is any data that was not sent.

  For a successful $\tslib{send}()$ call, the socket must be in a synchronised state, must not be shutdown
  for writing, and must not have a pending error.

  If there is not enough room on a socket's send queue then a $\tslib{send}()$ call may block until space
  becomes available. For a successful blocking $\tslib{send}()$ call on FreeBSD the entire string will be
  enqueued on the socket's send queue.

}\clustersubsection{Errors}
\seccomm{
  In addition to errors returned via ICMP (see \ltslink{deliverTinTicmpTIII}{$\tsrule{deliver\_in\_icmp\_3}$}), a call to $\tslib{send}()$
  can fail with the errors below, in which case the corresponding exception is raised:

\par\begin{ltstabular}
$\tscon{EAGAIN}$
&  Non-blocking $\tslib{send}()$ call would block.

\\\hline
$\tscon{ENOTCONN}$
&  Socket not connected on FreeBSD and WinXP.

\\\hline
$\tscon{EOPNOTSUPP}$
&  Message flags $\tscon{MSG\_PEEK}$ and $\tscon{MSG\_WAITALL}$ not supported. Linux and WinXP.

\\\hline
$\tscon{EPIPE}$
&  Socket not connected on Linux; or socket shutdown for writing on FreeBSD and Linux.

\\\hline
$\tscon{ESHUTDOWN}$
&  Socket shutdown for writing on WinXP.

\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{EINTR}$
&  The system was interrupted by a caught signal.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  A TCP socket is created and successfully connects with a peer; data is then sent to the peer:
  $\tsrule{socket\_1}$; $\tsrule{return\_1}$; $\tsrule{connect\_1}$; $\tsrule{return\_1}$; $\dots $ $\tsrule{connect\_2}$; $\tsrule{return\_1}$;
  $\tsrule{send\_1}$; $\dots $

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:  &  \wasverb{ssize\textunderscore{}t send(int socket, const void *buffer, size\textunderscore{}t length, int flags);} \\
    FreeBSD:&  \wasverb{ssize\textunderscore{}t send(int s, const void *msg, size\textunderscore{}t len, int flags);} \\
    Linux:  &  \wasverb{int send(int s, const void *msg, size\textunderscore{}t len, int flags);} \\
    WinXP:  &  \wasverb{int send(SOCKET s, const char *buf, int len, int flags);} \\
  \end{tabular}\\

  In the Posix interface:
  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to send from, corresponding to the
     $\tstype{fd}$ argument of the model $\tslib{send}()$.

    \item \wasverb{message} is a pointer to the data to be sent of length \wasverb{length}. The two
     together correspond to the $\tstype{string}$ argument of the model $\tslib{send}()$.

    \item \wasverb{flags} is a disjunction of the message flags for the $\tslib{send}()$ call, corresponding to
     the $\tstype{msgbflag}$ $\tstype{list}$ in the model $\tslib{send}()$.

     \item the returned \wasverb{ssize\textunderscore{}t} is either non-negative or \wasverb{-1}. If it is
     non-negative then it is the amount of data from \wasverb{message} that was sent. If it is
     \wasverb{-1} then it indicates an error, in which case the error is stored in
     \wasverb{errno}. This corresponds to the model $\tslib{send}()$'s return value of type $\tstype{string}$
     which is the data that was not sent. On WinXP an error is indicated by a return value of
     \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error code available through a
     call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  The FreeBSD, Linux and WinXP interfaces are similar modulo argument renaming, except where
  noted above.

}\clustersubsection{Model details}
\seccomm{
  If the call blocks then the thread enters state $\tscon{Send2}(\tstype{sid},*,\tsunknown{str},\tsunknown{opts})$ (the optional
  parameter is used for UDP only), where

  \begin{itemize}

    \item $\tstype{sid} : \tstype{sid}$ is the identifier of the socket that made the $\tslib{send}()$ call,

    \item $\tsunknown{str} : \tstype{string}$ is the data to be sent, and

    \item $\tsunknown{opts} : \tstype{msgbflag} \;\tstype{list}$ is the set of options for the $\tslib{send}()$ call.

  \end{itemize}

  The following errors are not modelled:

  \begin{itemize}

    \item In Posix and on all three architectures, \wasverb{EDESTADDRREQ} indicates that the socket is not
    connection-mode and no peer address is set.  This doesn't apply to TCP, which is a
    connection-mode protocol.

   \item In Posix, \wasverb{EACCES} signifies that write access to the socket is denied. This is not
   modelled here.

   \item On FreeBSD and Linux, \wasverb{EFAULT} signifies that the pointers passed as either the \wasverb{address} or
   \wasverb{address\textunderscore{}len} arguments were inaccessible.  This is an artefact of the C interface to
   $\tslib{accept}()$ that is excluded by the clean interface used in the model.

    \item In Posix and on Linux, \wasverb{EINVAL} signifies that an invalid argument was passed. The typing
     of the model interface prevents this from happening.

    \item In Posix, \wasverb{EIO} signifies that an I/O error occurred while reading from or writing to the
    file system. This is not modelled.

    \item On Linux, \wasverb{EMSGSIZE} indicates that the message is too large to be sent all at once, as
    the socket requires; this is not a requirement for TCP sockets.

    \item In Posix, \wasverb{ENETDOWN} signifies that the local network interface used to reach the
    destination is down. This is not modelled.

  \end{itemize}

  The following flags are not modelled:

  \begin{itemize}

  \item On Linux, \wasverb{MSG\textunderscore{}CONFIRM} is used to tell the link layer not to probe the neighbour.

  \item On Linux, \wasverb{MSG\textunderscore{}NOSIGNAL} requests not to send \wasverb{SIGPIPE} errors on stream-oriented sockets
  when the other end breaks the connection.

  \item On FreeBSD and WinXP, \wasverb{MSG\textunderscore{}DONTROUTE} is used by routing programs.

  \item On FreeBSD, \wasverb{MSG\textunderscore{}EOR} is used to indicate the end of a record for protocols that support
   this. It is not modelled because TCP does not support records.

   \item On FreeBSD, \wasverb{MSG\textunderscore{}EOF} is used to implement Transaction TCP which is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{send\_1}$
& \textbf{tcp: fast succeed}
&  Successfully send data without blocking \\
$\tsrule{send\_2}$
& \textbf{tcp: block}
&  Block waiting for space in socket's send queue \\
$\tsrule{send\_3}$
& \textbf{tcp: slow nonurgent succeed}
&  Successfully return from blocked state having sent data \\
$\tsrule{send\_3a}$
& \textbf{tcp: block}
&  From blocked state, transfer some data to the send queue and remain blocked \\
$\tsrule{send\_4}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{EAGAIN}$: non-blocking semantics requested and call would block \\
$\tsrule{send\_5}$
& \textbf{tcp: fast fail}
&  Fail with pending error \\
$\tsrule{send\_5a}$
& \textbf{tcp: slow urgent fail}
&  Fail from blocked state with pending error \\
$\tsrule{send\_6}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{ENOTCONN}$ or $\tscon{EPIPE}$: socket not connected \\
$\tsrule{send\_7}$
& \textbf{tcp: rc}
&  Fail with $\tscon{EPIPE}$ or $\tscon{ESHUTDOWN}$: socket shut down for writing \\
$\tsrule{send\_8}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{EOPNOTSUPP}$:  message flag not valid \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\sendTI}{\rrulecc{sendTI}{send\_1}{tcp: fast succeed}{\tsholcomm{ Successfully send data without blocking }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsholop{IMPLODE} \;\tsvar{str}''))}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\Mappend{\tsvar{sndq}}{\tsvar{str}'},\tsvar{sndurp}',\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{CLOSE\_WAIT}\} \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 {}\\{}
 \tsvar{space} \;\in  \;\tsaux{send\_queue\_space}{}\\{}
\quad\quad (\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDBUF})) (\tsholop{LENGTH} \;\tsvar{sndq}) (\tscon{MSG\_OOB} \;\in  \;\tsvar{opts}) \tsvar{h}.\tstype{arch} \;\tsvar{cb}.\tsfield{t\_maxseg} \;\tsvar{i}_{2} \Mwedge {}\\{}
 {}\\{}
 (\{\tscon{MSG\_PEEK}; \tscon{MSG\_WAITALL}\} \cap  \;\tsvar{opts} = \emptyset  \Mvee  \tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge {}\\{}
 {}\\{}
 (\Mif  \;\tsvar{space} \geq  \tsholop{LENGTH} \;\tsvar{str} \;\Mthen {}\\{}
\quad\quad \tsvar{str}'=\tsvar{str} \Mwedge  \tsvar{str}''=[\,]{}\\{}
 \Melse {}\\{}
\quad\quad (\tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK}) \Mvee  (\tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts} \Mwedge  \neg{}\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch})) \Mwedge {}\\{}
\quad\quad (\Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{space} \geq  \tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDLOWAT}){}\\{}
\quad\quad \Melse                     \;\tsvar{space} >  0) \Mwedge {}\\{}
\quad\quad (\tsvar{str}',\tsvar{str}'') = \tsaux{SPLIT} \;\tsvar{space} \;\tsvar{str}{}\\{}
 ) \Mwedge {}\\{}
 \tsvar{sndurp}' = (\Mif  (\tscon{MSG\_OOB} \;\in  \;\tsvar{opts}) \Mwedge  (\tsvar{n} = \tsholop{LENGTH} \;\tsvar{str}){}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mthen  \;\Msome  (\tsholop{LENGTH} (\Mappend{\tsvar{sndq}}{\tsvar{str}'}) -1){}\\{}
\quad\quad\quad\quad\quad \Melse  \;\tsvar{sndurp})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call
    is made. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$ that has binding quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome
\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$, has no pending error, is not shutdown for writing, and is in state
    $\tscon{ESTABLISHED}$ or $\tscon{CLOSE\_WAIT}$. The $\tscon{MSG\_PEEK}$ and $\tscon{MSG\_WAITALL}$ flags are not set in
    $\tsvar{opts}_{0}$. $\tsvar{space}$ is the space in the socket's send queue, calculated using \ltslink{sendTqueueTspace}{$\tsaux{send\_queue\_space}$}.

    This rule covers two cases: (1) there is space in the socket's send queue for all the data; and
    (2) there is not space for all the data but the call is non-blocking (the $\tscon{MSG\_DONTWAIT}$ flag
    is set in $\tsvar{opts}$ or the socket's $\tscon{O\_NONBLOCK}$ flag is set), and the space is greater than
    zero, or, on FreeBSD, greater than the minimum number of bytes for $\tslib{send}()$ operations on the
    socket, $\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDLOWAT})$.

    In (1) all of the data $\tsvar{str}$ is appended to the socket's send queue and the returned
    string, $\tsvar{str}''$, is the empty string. In (2), the first $\tsvar{space}$ bytes of data, $\tsvar{str}'$, are
    appended to the socket's send queue and the remaining data, $\tsvar{str}''$, is returned.

    In both cases a $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made,
    leaving the thread state $\tscon{Ret} (\tscon{OK} (\tsholop{IMPLODE} \;\tsvar{str}''))$. If the data was marked as out-of-band,
    $\tscon{MSG\_OOB} \;\in  \;\tsvar{opts}$, then the socket's send urgent pointer will point to the end of the send
    queue.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tslib{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.

    The $\tsvar{opts}_{0}$ argument is of type $\tstype{list}$. In the model it is converted to a $\tstype{set}$ $\tsvar{opts}$
    using $\tsholop{LIST\_TO\_SET}$. The presence of $\tscon{MSG\_PEEK}$ is checked for in $\tsvar{opts}$ rather than in
    $\tsvar{opts}_{0}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    The $\tscon{MSG\_PEEK}$ and $\tscon{MSG\_WAITALL}$ flags may be set in $\tsvar{opts}_{0}$ but for the call to be
    non-blocking the socket's $\tscon{O\_NONBLOCK}$ flag must be set: the $\tscon{MSG\_DONTWAIT}$ flag has no
    effect.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTII}{\rrulecc{sendTII}{send\_2}{tcp: block}{\tsholcomm{ Block waiting for space in socket's send queue }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})}{\tsaux{never\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \neg{}((\neg{}\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge   \tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts}) \Mvee  \tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK})) \Mwedge {}\\{}
 {}\\{}
 \tsvar{space} \;\in  \;\tsaux{send\_queue\_space}{}\\{}
\quad\quad\quad\quad\quad (\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDBUF})) (\tsholop{LENGTH} \;\tsvar{sndq}) (\tscon{MSG\_OOB} \;\in  \;\tsvar{opts}) \tsvar{h}.\tstype{arch} \;\tsvar{cb}.\tsfield{t\_maxseg} \;\tsvar{i}_{2} \Mwedge {}\\{}
 {}\\{}
 (\{\tscon{MSG\_PEEK}; \tscon{MSG\_WAITALL}\} \cap  \;\tsvar{opts} = \emptyset  \Mvee  \tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch})\Mwedge {}\\{}
 {}\\{}
 ((\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{CLOSE\_WAIT}\} \Mwedge {}\\{}
\quad \tsvar{space} < \tsholop{LENGTH} \;\tsvar{str}) \Mvee {}\\{}
 (\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsvar{st} \;\in  \{\tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}\}))}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call
    is made. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$ that has binding quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome
\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$, has no pending error, is not shutdown for writing, and is in state
    $\tscon{ESTABLISHED}$ or $\tscon{CLOSE\_WAIT}$. The call is a blocking one: the socket's $\tscon{O\_NONBLOCK}$ flag
    is not set and the $\tscon{MSG\_DONTWAIT}$ flag is not set in $\tsvar{opts}_{0}$. The $\tscon{MSG\_PEEK}$ and
    $\tscon{MSG\_WAITALL}$ flags are not set in $\tsvar{opts}_{0}$.

    The space in the socket's send queue, $\tsvar{space}$ (calculated using \ltslink{sendTqueueTspace}{$\tsaux{send\_queue\_space}$}), is less than the length in bytes of the data to be sent, $\tsvar{str}$.

    The call blocks, leaving the thread state $\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})$ via a
    $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tslib{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.


\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    The $\tscon{MSG\_PEEK}$, $\tscon{MSG\_WAITALL}$, and $\tscon{MSG\_DONTWAIT}$ flags may all be set in $\tsvar{opts}_{0}$: all
    three are ignored by FreeBSD.

\\\hline
Linux
&
    In addition to the above, the rule also applies if connection establishment is still taking
    place for the socket: it is in state $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTIII}{\rrulecc{sendTIII}{send\_3}{tcp: slow nonurgent succeed}{\tsholcomm{ Successfully return from blocked state having sent data }}
{\tsvar{h} \; \Mmagiclrec  {}\\{}
 \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  {}\\{}
 \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} (\tsholop{IMPLODE} \;\tsvar{str}''))}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq} ++ \tsvar{str}',\tsvar{sndurp}',\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{CLOSE\_WAIT}\} \Mwedge {}\\{}
 \tsvar{space} \;\in  \;\tsaux{send\_queue\_space}{}\\{}
\quad\quad\quad\quad\quad (\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDBUF})) (\tsholop{LENGTH} \;\tsvar{sndq}) (\tscon{MSG\_OOB} \;\in  \;\tsvar{opts}) {}\\{}
\quad\quad\quad\quad\quad \tsvar{h}.\tstype{arch} \;\tsvar{cb}.\tsfield{t\_maxseg} \;\tsvar{i}_{2} \Mwedge {}\\{}
 \tsvar{space} \geq  \tsholop{LENGTH} \;\tsvar{str} \Mwedge {}\\{}
 \tsvar{str}'=\tsvar{str} \Mwedge  \tsvar{str}''=[\,] \Mwedge {}\\{}
 \tsvar{sndurp}' = \Mif  \;\tscon{MSG\_OOB} \;\in  \;\tsvar{opts} \;\Mthen  \;\Msome  (\tsholop{LENGTH} (\tsvar{sndq} ++ \tsvar{str}') - 1){}\\{}
\quad\quad\quad\quad\quad \Melse  \;\tsvar{sndurp}}
{\rulesubsection{Description}

    Thread $\tsvar{tid}$ is blocked in state $\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})$ where the TCP socket $\tsvar{sid}$ has
    binding quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$, has no pending error, is not shutdown for
    writing, and is in state $\tscon{ESTABLISHED}$ or $\tscon{CLOSE\_WAIT}$.

    The space in the socket's send queue, $\tsvar{space}$ (calculated using \ltslink{sendTqueueTspace}{$\tsaux{send\_queue\_space}$}),
    is greater than or equal to the length of the data to be sent, $\tsvar{str}$. The data is appended to
    the socket's send queue and the call successfully returns the empty string. A $\MLhtau $
    transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK} \text{``''})$. If the data was marked as
    out-of-band, $\tscon{MSG\_OOB} \;\in  \;\tsvar{opts}$, then the socket's urgent pointer will be updated to point to
    the end of the socket's send queue.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tslib{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.


\rrulepad }
}

\newcommand{\sendTIIIa}{\rrulecc{sendTIIIa}{send\_3a}{tcp: block}{\tsholcomm{ From blocked state, transfer some data to the send queue and remain blocked }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Send2}(\tsvar{sid},*,\tsvar{str}'',\tsvar{opts})}{\tsaux{never\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\Mappend{\tsvar{sndq}}{\tsvar{str}'},\tsvar{sndurp}',\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] \Mmagicrrec }
{\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{CLOSE\_WAIT}\} \Mwedge {}\\{}
 \tsvar{space} \;\in  \;\tsaux{send\_queue\_space}{}\\{}
\quad\quad\quad\quad\quad\quad (\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDBUF})) (\tsholop{LENGTH} \;\tsvar{sndq}) (\tscon{MSG\_OOB} \;\in  \;\tsvar{opts}) \tsvar{h}.\tstype{arch} \;\tsvar{cb}.\tsfield{t\_maxseg} \;\tsvar{i}_{2} \Mwedge {}\\{}
 \tsvar{space} < \tsholop{LENGTH} \;\tsvar{str} \Mwedge  \tsvar{space} > 0 \Mwedge {}\\{}
 (\tsvar{str}',\tsvar{str}'') = \tsaux{SPLIT} \;\tsvar{space} \;\tsvar{str} \Mwedge {}\\{}
 \tsvar{sndurp}' = \Mif  \;\tscon{MSG\_OOB} \;\in  \;\tsvar{opts} \;\Mthen  \;\Msome (\tsholop{LENGTH} (\Mappend{\tsvar{sndq}}{\tsvar{str}'}) -1) \Melse  \;\tsvar{sndurp}}
{\rulesubsection{Description}

    Thread $\tsvar{tid}$ is blocked in state $\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})$ where TCP socket $\tsvar{sid}$ has
    binding quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$, has no pending error, is not shutdown for
    writing, and is in state $\tscon{ESTABLISHED}$ or $\tscon{CLOSE\_WAIT}$. The amount of space in the socket's
    send queue, $\tsvar{space}$ (calculated using \ltslink{sendTqueueTspace}{$\tsaux{send\_queue\_space}$}), is less than the length
    of the remaining data to be sent, $\tsvar{str}$, and greater than $0$. The socket's send queue is
    filled by appending the first $\tsvar{space}$ bytes of $\tsvar{str}$, $\tsvar{str}'$, to it.

    A $\MLhtau $ transition is made, leaving the thread state $\tscon{Send2}(\tsvar{sid},*,\tsvar{str}'',\tsvar{opts})$
    where $\tsvar{str}''$ is the remaining data to be sent. If the data in $\tsvar{str}$ is out-of-band,
    $\tscon{MSG\_OOB}$ is set in $\tsvar{opts}$, then the socket's urgent pointer is updated to point to the end
    of the socket's send queue.

    Note it is unclear whether or not $\tscon{MSG\_OOB}$ should be removed from $\tsvar{opts}$ in the state.


\rrulepad }
}

\newcommand{\sendTIV}{\rrulecc{sendTIV}{send\_4}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{EAGAIN}$: non-blocking semantics requested and call would block }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EAGAIN}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{socks}}{\tsvar{sid}} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\Mfalse ,\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 {}\\{}
 (\{\tscon{MSG\_PEEK};\tscon{MSG\_WAITALL}\} \cap  \;\tsvar{opts} = \emptyset  \Mvee  \tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge {}\\{}
 {}\\{}
 ((\neg{}\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts}) \Mvee  \tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK})) \Mwedge {}\\{}
 {}\\{}
 ((\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{CLOSE\_WAIT}\} \Mwedge  {}\\{}
\quad \tsvar{space} \;\in  \;\tsaux{send\_queue\_space}{}\\{}
\quad\quad\quad\quad\quad\quad (\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDBUF})) (\tsholop{LENGTH} \;\tsvar{sndq}) (\tscon{MSG\_OOB} \;\in  \;\tsvar{opts}) \tsvar{h}.\tstype{arch} \;\tsvar{cb}.\tsfield{t\_maxseg} \;\tsvar{i}_{2} \Mwedge {}\\{}
\quad \neg{}(\tsvar{space} \geq  \tsholop{LENGTH} \;\tsvar{str} \Mvee  (\Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{space} \geq  \tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDLOWAT}) \Melse  \;\tsvar{space} > 0))) \Mvee {}\\{}
 (\tsvar{st} \;\in  \{\tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}\} \Mwedge  {}\\{}
\quad \tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch}))}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call
    is made. $\tsvar{fd}$ refers to a TCP socket that has binding quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome
\tsvar{p}_{2})$, has no pending error, is not shutdown for writing, and is in state $\tscon{ESTABLISHED}$ or
    $\tscon{CLOSE\_WAIT}$. The call is a non-blocking one: either the socket's $\tscon{O\_NONBLOCK}$ flag is set
    or the $\tscon{MSG\_DONTWAIT}$ flag is set in $\tsvar{opts}_{0}$. The $\tscon{MSG\_PEEK}$ and $\tscon{MSG\_WAITALL}$ flags are
    not set in $\tsvar{opts}_{0}$.

    The space in the socket's send queue, $\tsvar{space}$ (calculated using \ltslink{sendTqueueTspace}{$\tsaux{send\_queue\_space}$}),
    is less than both the length of the data to send $\tsvar{str}$; and on FreeBSD is less than the
    minimum number of bytes for socket send operations, $\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDLOWAT})$, or on Linux and WinXP
    is equal to zero. The call would have to block, but because it is non-blocking, it fails with an
    $\tscon{EAGAIN}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made, leaving the thread in
    state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EAGAIN}})$.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tslib{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.

    The $\tsvar{opts}_{0}$ argument is of type $\tstype{list}$. In the model it is converted to a $\tstype{set}$ $\tsvar{opts}$
    using $\tsholop{LIST\_TO\_SET}$. The presence of $\tscon{MSG\_PEEK}$ is checked for in $\tsvar{opts}$ rather than in
    $\tsvar{opts}_{0}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    For the call to be non-blocking, the socket's $\tscon{O\_NONBLOCK}$ flag must be set; the
    $\tscon{MSG\_DONTWAIT}$ flag is ignored. Additionally, the $\tscon{MSG\_PEEK}$ and $\tscon{MSG\_WAITALL}$ flags may
    be set in $\tsvar{opts}_{0}$ as they are also ignored.

\\\hline
Linux
&
    This rule also applies if the socket is in state $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$, in which case
    the send queue size does not matter.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTV}{\rrulecc{sendTV}{send\_5}{tcp: fast fail}{\tsholcomm{ Fail with pending error }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsvar{e} \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  * \Mmagicrrec )] \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tscon{PROTO\_TCP}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call
    is made. $\tsvar{fd}$ refers to a socket $\tsvar{sock}$ identified by $\tsvar{sid}$ with pending error $\Msome
\tsvar{e}$. The call fails, returning the pending error.

    A $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsunknown{opts})}$ transition is made, leaving the thread in
    state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tslib{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.


\rrulepad }
}

\newcommand{\sendTVa}{\rrulecc{sendTVa}{send\_5a}{tcp: slow urgent fail}{\tsholcomm{ Fail from blocked state with pending error }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsvar{e} \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  * \Mmagicrrec )] \Mmagicrrec }
{\tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tscon{PROTO\_TCP}}
{\rulesubsection{Description}

    Thread $\tsvar{tid}$ is blocked in state $\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})$ from an earlier $\tslib{send}()$
    call. The TCP socket $\tsvar{sid}$ has pending error $\Msome  \;\tsvar{e}$ so the call can now return, failing
    with the error.

    A $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$.


\rrulepad }
}

\newcommand{\sendTVI}{\rrulecc{sendTVI}{send\_6}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{ENOTCONN}$ or $\tscon{EPIPE}$: socket not connected }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = \tsvar{sock}.\tsvar{pr} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{es} = * \Mwedge {}\\{}
 (\tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{CLOSED}; \tscon{LISTEN}\} \Mvee {}\\{}
\quad  {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad {}\\{}
\quad (\tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}\} \Mwedge  \neg{}(\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch})) \Mvee {}\\{}
\quad \Mfalse  \tsholcomm{ Placeholder for: if \wasverb{tcp\textunderscore{}disconnect} or \wasverb{tcp\textunderscore{}usrclose} has been invoked } {}\\{}
 ) \Mwedge {}\\{}
 \tsvar{err} = (\Mif  \;\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tscon{EPIPE} \;\Melse  \;\tscon{ENOTCONN})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call
    is made. $\tsvar{fd}$ refers to a TCP socket $\tsvar{sock}$ identified by $\tsvar{sid}$ that does not have a
    pending error. The socket is not synchronised: it is in state $\tscon{CLOSED}$, $\tscon{LISTEN}$,
    $\tscon{SYN\_SENT}$, or $\tscon{SYN\_RECEIVED}$. The call fails with an $\tscon{ENOTCONN}$ error, or $\tscon{EPIPE}$ on
    Linux.

    A $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made, leaving the thread in
    state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})$ where $\tsvar{err}$ is one of the above errors.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tslib{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.


\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    The rule does not apply if the socket is in state $\tscon{SYN\_RECEIVED}$ or $\tscon{SYN\_SENT}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTVII}{\rrulecc{sendTVII}{send\_7}{tcp: rc}{\tsholcomm{ Fail with $\tscon{EPIPE}$ or $\tscon{ESHUTDOWN}$: socket shut down for writing }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{t}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\Mtrue ,\tsvar{cantrcvmore},\tscon{TCP\_PROTO}(\tsvar{tcp})))] \Mmagicrrec }
{\Mtransition{ \tsvar{lbl} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\Mtrue ,\tsvar{cantrcvmore},\tscon{TCP\_PROTO}(\tsvar{tcp})))] \Mmagicrrec }
{\Mboxedor{\exists \tsvar{fd} \;\tsvar{ff} \;\tsvar{str} \;\tsvar{opts}_{0} \;\tsvar{i}_{2} \;\tsvar{p}_{2}.   {}\\{}
\quad \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
\quad \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
\quad \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
\quad \tsvar{t} = \tscon{Run} \Mwedge {}\\{}
\quad \tsvar{lbl} = \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} \Mwedge {}\\{}
\quad \tsvar{rc} = \tscon{fast} \;\tscon{fail} \Mwedge {}\\{}
\quad \tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2} \Mwedge {}\\{}
\quad (\Mif  \;\tsvar{tcp}.\tsvar{st} \neq  \tscon{CLOSED} \;\Mthen {}\\{}
\quad\quad\quad \exists \tsvar{i}_{1} \;\tsvar{p}_{1}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1}{}\\{}
\quad\quad \Melse  \;\Mtrue ){}\\{}
\quad }{\exists \tsvar{opts} \;\tsvar{str}.  {}\\{}
\quad \tsvar{t} = \tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts}) \Mwedge {}\\{}
\quad \tsvar{lbl} = \MLhtau  \Mwedge {}\\{}
\quad \tsvar{rc} = \tscon{slow} \;\tsaux{urgent} \;\tscon{fail}{}\\{}
\quad } \Mwedge {}\\{}
 (\Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{err} = \tscon{ESHUTDOWN}{}\\{}
 \Melse                         \;\tsvar{err} = \tscon{EPIPE})}
{\rulesubsection{Description}

    This rule covers two cases: (1) from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a
    $\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call is made; and (2) thread $\tsvar{tid}$ is blocked in state
    $\tscon{Send2}(\tsvar{sid},*,\tsvar{str},\tsvar{opts})$. In (1), fd refers to a TCP socket $\tsvar{sid}$ that has binding quad
    $(\tsvar{is}_{1},\tsvar{ps}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$. In both cases the socket is shutdown for writing. The call fails
    with an $\tscon{EPIPE}$ error.

    The thread is left in state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EPIPE}})$, via a $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition in (1) or a $\MLhtau $ transition in (2).

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tslib{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    The call fails with an $\tscon{ESHUTDOWN}$ error instead of $\tscon{EPIPE}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTVIII}{\rrulecc{sendTVIII}{send\_8}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{EOPNOTSUPP}$:  message flag not valid }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EOPNOTSUPP}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tscon{PROTO\_TCP} \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 (\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \Mvee  \tscon{MSG\_WAITALL} \;\in  \;\tsvar{opts}) \Mwedge {}\\{}
 \neg{}\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call
    is made. $\tsvar{fd}$ refers to a TCP socket identified by $\tsvar{sid}$. Either the $\tscon{MSG\_PEEK}$ or
    $\tscon{MSG\_WAITALL}$ flag is set in $\tsvar{opts}_{0}$. These flags are not supported so the call fails with
    an $\tscon{EOPNOTSUPP}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made, leaving the thread in
    state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EOPNOTSUPP}})$.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tslib{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.

    The $\tsvar{opts}_{0}$ argument is of type $\tstype{list}$. In the model it is converted to a $\tstype{set}$ $\tsvar{opts}$
    using $\tsholop{LIST\_TO\_SET}$. The presence of $\tscon{MSG\_PEEK}$ is checked for in $\tsvar{opts}$ rather than in
    $\tsvar{opts}_{0}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommudpTsend}{\clustersection{(UDP only)}{$\tslib{send}()$}
\seccomm{ \[ \tslib{send}: (\tstype{fd} * (\tstype{ip} * \tstype{port}) \;\tstype{option} * \tstype{string} * \tstype{msgbflag} \;\tstype{list}) \Mtotype  \tstype{string} \]

  This section describes
  the behaviour of $\tslib{send}()$ for UDP sockets.
  A call to $\tslib{send}(\tstype{fd},\tsunknown{addr},\tsvar{data},\tsunknown{flags})$ enqueues a UDP datagram to send to a peer.
  Here the $\tstype{fd}$ argument is a file descriptor referring to a UDP socket from which to send data.
  The destination address of the data can be specified either by the $\tsunknown{addr}$ argument, which can be
  $\Msome (\tsvar{i}_{3},\tsvar{p}_{3})$ or $*$, or by the socket's peer address (its $\tsvar{is}_{2}$ and $\tsvar{ps}_{2}$ fields) if set. For a successful $\tslib{send}()$, at least one of these two must be specified. If the socket
  has a peer address set and $\tsunknown{addr}$ is set to $\Msome (\tsvar{i}_{3},\tsvar{p}_{3})$, then the address used is
  architecture-dependent: on FreeBSD the $\tslib{send}()$ call will fail with an $\tscon{EISCONN}$ error; on
  Linux and WinXP $\tsvar{i}_{3},\tsvar{p}_{3}$ will be used.

  The $\tstype{string}$, $\tsvar{data}$, is the data to be sent. The length in bytes of $\tsvar{data}$ must be less
  than the architecture-dependent maximum payload for a UDP datagram. Sending a $\tstype{string}$ of length
  zero bytes is acceptable.

  The $\tstype{msgbflag}$ $\tstype{list}$ is the list of message flags for the $\tslib{send}()$ call. The possible flags
  are $\tscon{MSG\_DONTWAIT}$ and $\tscon{MSG\_OOB}$. $\tscon{MSG\_DONTWAIT}$ specifies that non-blocking behaviour
  should be used for this call: see rules $\tsrule{send\_10}$ and $\tsrule{send\_11}$.  $\tscon{MSG\_OOB}$ specifies that
  the data to be sent is out-of-band data, which is not meaningful for UDP sockets.  FreeBSD ignores
  this flag, but on Linux and WinXP the $\tslib{send}()$ call will fail: see rule $\tsunknown{send\_20}$.

  The return value of the $\tslib{send}()$ call is a $\tstype{string}$ of the data which was not sent. A partial
  send may occur when the call is interrupted by a signal after having sent some data.

  For a datagram to be sent, the socket must be bound to a local port. When a $\tslib{send}()$ call is
  made, the socket is autobound to an ephemeral port if it does not have its local port bound.

  A successful $\tslib{send}()$ call only guarantees that the datagram has been placed on the host's out
  queue. It does not imply that the datagram has left the host, let alone been successfully
  delivered to its destination.

  A call to $\tslib{send}()$ may block if there is no room on the socket's send buffer and non-blocking
  behaviour has not been requested.

}\clustersubsection{Errors}
\seccomm{
  In addition to errors returned via ICMP (see \ltslink{deliverTinTicmpTIII}{$\tsrule{deliver\_in\_icmp\_3}$}), a call to $\tslib{send}()$
  can fail with the errors below, in which case the corresponding exception is raised:

\par\begin{ltstabular}
$\tscon{EADDRINUSE}$
&  The socket's peer address is not set and the destination address specified
   would give the socket a binding quad $\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}$ which is already in use by another
   socket.

\\\hline
$\tscon{EADDRNOTAVAIL}$
&  There are no ephemeral ports left for autobinding to.

\\\hline
$\tscon{EAGAIN}$
&  The $\tslib{send}()$ call would block and non-blocking behaviour is requested. This
   may have been done either via the $\tscon{MSG\_DONTWAIT}$ flag being set in the $\tslib{send}()$ flags or the
   socket's $\tscon{O\_NONBLOCK}$ flag being set.

\\\hline
$\tscon{EDESTADDRREQ}$
&  The socket does not have its peer address set, and no destination address
   was specified.

\\\hline
$\tscon{EINTR}$
&  A signal interrupted $\tslib{send}()$ before any data was transmitted.

\\\hline
$\tscon{EISCONN}$
&  On FreeBSD, a destination address was specified and the socket has a peer
   address set.

\\\hline
$\tscon{EMSGSIZE}$
&  The message is too large to be sent in one datagram.

\\\hline
$\tscon{ENOTCONN}$
&  The socket does not have its peer address set, and no destination address was
   specified. This can occur either when the call is first made, or if it blocks and if the peer
   address is unset by a call to $\tslib{disconnect}()$ whilst blocked.

\\\hline
$\tscon{EOPNOTSUPP}$
&  The $\tscon{MSG\_OOB}$ flag is set on Linux or WinXP.

\\\hline
$\tscon{EPIPE}$
&  Socket shut down for writing.

\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\\\hline
$\tscon{ENOBUFS}$
&  Out of resources.

\\\hline
$\tscon{ENOMEM}$
&  Out of resources.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsrule{send\_9}$; $\tsrule{return\_1}$;

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:   & \wasverb{ssize\textunderscore{}t sendto(int socket, const void *message, size\textunderscore{}t length,}\\
             & \wasverb{               int flags, const struct sockaddr *dest\textunderscore{}addr}\\
             & \wasverb{               socklen\textunderscore{}t dest\textunderscore{}len);}\\
    FreeBSD: & \wasverb{ssize\textunderscore{}t sendto(int s, const void *msg, size\textunderscore{}t len, int flags,}\\
             & \wasverb{               const struct sockaddr *to, socklen\textunderscore{}t tolen);} \\
    Linux:   & \wasverb{int sendto(int s, const void *msg, size\textunderscore{}t len, int flags,}\\
             & \wasverb{           const struct sockaddr *to, socklen\textunderscore{}t tolen);} \\
    WinXP:   & \wasverb{int sendto(SOCKET s, const char* buf, int len, int flags,} \\
             & \wasverb{           const struct sockaddr* to, int tolen);} \\
  \end{tabular}

  In the Posix interface:
  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to send from, corresponding to the
     $\tstype{fd}$ argument of the model $\tslib{send}()$.

    \item \wasverb{message} is a pointer to the data to be sent of length \wasverb{length}. The two
     together correspond to the $\tstype{string}$ argument of the model $\tslib{send}()$.

    \item \wasverb{flags} is an OR of the message flags for the $\tslib{send}()$ call, corresponding to
     the $\tstype{msgbflag}$ $\tstype{list}$ in the model $\tslib{send}()$.

    \item \wasverb{dest\textunderscore{}addr} and \wasverb{dest\textunderscore{}len} correspond to the $\tsunknown{addr}$ argument of the
     model $\tslib{send}()$. \wasverb{dest\textunderscore{}addr} is either null or a pointer to a sockaddr structure
     containing the destination address for the data. If it is null it corresponds to $\tsunknown{addr} =
*$. If it contains an address, then it corresponds to $\tsunknown{addr} = \Msome (\tsvar{i}_{3},\tsvar{p}_{3})$ where $\tsvar{i}_{3}$
     and $\tsvar{p}_{3}$ are the IP address and port specified in the sockaddr structure.

    \item the returned \wasverb{ssize\textunderscore{}t} is either non-negative or \wasverb{-1}. If it is
     non-negative then it is the amount of data from \wasverb{message} that was sent. If it is
     \wasverb{-1} then it indicates an error, in which case the error is stored in
     \wasverb{errno}. This is different to the model $\tslib{send}()$'s return value of type $\tstype{string}$
     which is the data that was not sent. On WinXP an error is indicated by a return value of
     \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error code available through a
     call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  There are other functions used to send data on a socket. \wasverb{send()} is similar to
  \wasverb{sendto()} except it does not have the \wasverb{address} and \wasverb{address\textunderscore{}len}
  arguments. It is used when the destination address of the data does not need to be
  specified. \wasverb{sendmsg()}, another output function, is a more general form of
  \wasverb{sendto()}.

}\clustersubsection{Model details}
\seccomm{
  If the call blocks then the thread enters state $\tscon{Send2}(\tstype{sid},\Msome (\tsunknown{addr},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsunknown{str},\tsunknown{opts})$ where

  \begin{itemize}

    \item $\tstype{sid} : \tstype{sid}$ is the identifier of the socket that made the $\tslib{send}()$ call,

    \item $\tsunknown{addr} : (\tstype{ip} * \tstype{port}) \;\tstype{option}$ is the destination address specified in the $\tslib{send}()$ call,

    \item $\tsvar{is}_{1} : \tstype{ip} \;\;\tstype{option}$ is the socket's local IP address, possibly $*$,

    \item $\tsvar{ps}_{1} : \tstype{port} \;\;\tstype{option}$ is the socket's local port, possibly $*$,

    \item $\tsvar{is}_{2} : \tstype{ip} \;\;\tstype{option}$ is the IP address of the socket's peer, possibly $*$,

    \item $\tsvar{ps}_{2} : \tstype{ip} \;\;\tstype{option}$ is the port of the socket's peer, possibly $*$,

    \item $\tsunknown{str} : \tstype{string}$ is the data to be sent, and

    \item $\tsunknown{opts} : \tstype{msgbflag} \;\tstype{list}$ is the set of options for the $\tslib{send}()$ call.

  \end{itemize}

  The following errors are not modelled:

  \begin{itemize}

   \item On FreeBSD, \wasverb{EACCES} signifies that the destination address is a broadcast address and the
   \wasverb{SO\textunderscore{}BROADCAST} flag has not been set on the socket. Broadcast is not modelled here.

   \item In Posix, \wasverb{EACCES} signifies that write access to the socket is denied. This is not
   modelled here.

   \item On FreeBSD and Linux, \wasverb{EFAULT} signifies that the pointers passed as either the \wasverb{address} or
   \wasverb{address\textunderscore{}len} arguments were inaccessible.  This is an artefact of the C interface to
   $\tslib{accept}()$ that is excluded by the clean interface used in the model.

    \item In Posix and on Linux, \wasverb{EINVAL} signifies that an invalid argument was passed. The typing
     of the model interface prevents this from happening.

    \item In Posix, \wasverb{EIO} signifies that an I/O error occurred while reading from or writing to the
    file system. This is not modelled.

    \item In Posix, \wasverb{ENETDOWN} signifies that the local network interface used to reach the
    destination is down. This is not modelled.

  \end{itemize}

  The following flags are not modelled:

  \begin{itemize}

  \item On Linux, \wasverb{MSG\textunderscore{}CONFIRM} is used to tell the link layer not to probe the neighbour.

  \item On Linux, \wasverb{MSG\textunderscore{}NOSIGNAL} requests not to send \wasverb{SIGPIPE} errors on stream-oriented sockets
  when the other end breaks the connection. UDP is not stream-oriented.

  \item On FreeBSD and WinXP, \wasverb{MSG\textunderscore{}DONTROUTE} is used by routing programs.

  \item On FreeBSD, \wasverb{MSG\textunderscore{}EOR} is used to indicate the end of a record for protocols that support
   this. It is not modelled because UDP does not support records.

   \item On FreeBSD, \wasverb{MSG\textunderscore{}EOF} is used to implement Transaction TCP.

  \end{itemize}



}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{send\_9}$
& \textbf{udp: fast succeed}
&  Enqueue datagram and return successfully \\
$\tsrule{send\_10}$
& \textbf{udp: block}
&  Block waiting to enqueue datagram \\
$\tsrule{send\_11}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{EAGAIN}$: call would block and non-blocking behaviour has been requested \\
$\tsrule{send\_12}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{ENOTCONN}$: no peer address set in socket and no destination address provided \\
$\tsrule{send\_13}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{EMSGSIZE}$: string to be sent is bigger than $\tsaux{UDPpayloadMax}$ \\
$\tsrule{send\_14}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{EAGAIN}$, $\tscon{EADDRNOTAVAIL}$ or $\tscon{ENOBUFS}$: there are no ephemeral ports left \\
$\tsrule{send\_15}$
& \textbf{udp: slow urgent succeed}
&  Return from blocked state after datagram enqueued \\
$\tsrule{send\_16}$
& \textbf{udp: slow urgent fail}
&  Fail: blocked socket has entered an error state \\
$\tsrule{send\_17}$
& \textbf{udp: slow urgent fail}
&  Fail with $\tscon{EMSGSIZE}$ or $\tscon{ENOTCONN}$: blocked socket has had peer address unset or string to be sent is too big \\
$\tsrule{send\_18}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{EOPNOTSUPP}$: $\tscon{MSG\_PEEK}$ flag not supported for $\tslib{send}()$ calls on WinXP; or $\tscon{MSG\_OOB}$ flag not supported on WinXP and Linux  \\
$\tsrule{send\_19}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{EADDRINUSE}$: on FreeBSD, local and destination address quad in use by another socket \\
$\tsrule{send\_21}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{EISCONN}$: socket has peer address set and destination address is specified in call on FreeBSD \\
$\tsrule{send\_22}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{EPIPE}$ or $\tscon{ESHUTDOWN}$: socket shut down for writing \\
$\tsrule{send\_23}$
& \textbf{udp: fast fail}
&  Fail with pending error \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\sendTIX}{\rrulecc{sendTIX}{send\_9}{udp: fast succeed}{\tsholcomm{ Enqueue datagram and return successfully }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{OK} (\text{``''}))}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}'_{1}; \tsvar{pr}\Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{cantsndmore} = \Mfalse  \Mwedge {}\\{}
 \tsunknown{STRLEN} (\tsholop{IMPLODE} \;\tsvar{str}) \leq  \tsaux{UDPpayloadMax} \;\tsvar{h}_{0}.\tstype{arch} \Mwedge {}\\{}
 ((\tsvar{addr} \neq  *) \Mvee  (\tsvar{sock}.\tsvar{is}_{2} \neq  *)) \Mwedge {}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{sock}.\tsvar{ps}_{1},\tscon{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{sock}.\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound}) \Mwedge {}\\{}
 \tsaux{dosend}(\tsvar{h}.\tsvar{ifds},\tsvar{h}.\tsvar{rttab},(\tsvar{addr},\tsvar{str}),(\tsvar{sock}.\tsvar{is}_{1},\Msome  \;\tsvar{p}'_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}),\tsvar{h}_{0}.\tsvar{oq},\tsvar{oq}',\Mtrue ) \Mwedge {}\\{}
 (\Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  (\tsvar{h}_{0}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDBUF}) \geq  \tsunknown{STRLEN} (\tsholop{IMPLODE} \;\tsvar{str}){}\\{}
\quad \Melse                     \;\tscon{MSG\_OOB} \;\notin  (\tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0})) \Mwedge {}\\{}
 (\neg{}(\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}) \implies  \tsvar{es} = *)}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ that is not shutdown for writing and has no
    pending errors. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a call
    $\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ succeeds if:

    \begin{itemize}

      \item the length of $\tsvar{str}$ is less than \ltslink{UDPpayloadMax}{$\tsaux{UDPpayloadMax}$}, the architecture-dependent
       maximum payload for a UDP datagram.

      \item The socket has a peer IP address set in its $\tsvar{is}_{2}$ field or the $\tsvar{addr}$ argument is
       $\Msome (\tsvar{i}_{3},\tsvar{p}_{3})$, specifying a destination address.

      \item The socket is bound to a local port $\tsvar{p}'_{1}$, or it can be autobound to $\tsvar{p}'_{1}$ and
       $\tsvar{sid}$ added to the list of bound sockets.

      \item A UDP datagram is constructed from the socket's binding quad $(\tsvar{sock}.\tsvar{is}_{1},\Msome
\tsvar{p}'_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2})$, the destination address argument $\tsvar{addr}$, and the data
       $\tsvar{str}$. This datagram is successfully enqueued on the outqueue of the host, $\tsvar{oq}$ to form
       outqueue $\tsvar{oq}'$ using auxiliary function \ltslink{dosend}{$\tsaux{dosend}$}.

    \end{itemize}

    A $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made, leaving the thread in
    state $\tscon{Ret} (\tscon{OK}(\text{``''}))$ and the host with new outqueue $\tsvar{oq}'$. If the socket was autobound to a
    port then $\tsvar{sid}$ is appended to the host's list of bound sockets.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tslib{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.




\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    The $\tscon{MSG\_OOB}$ flag is not set in $\tsvar{opts}_{0}$.

\\\hline
FreeBSD
&
    On FreeBSD there is an additional condition for a successful $\tslib{send}()$: the amount of data to
    be sent must be less than or equal to the size of the socket's send buffer.

\\\hline
Linux
&
    The $\tscon{MSG\_OOB}$ flag is not set in $\tsvar{opts}_{0}$.

\\\hline
WinXP
&
    The $\tscon{MSG\_OOB}$ flag is not set in $\tsvar{opts}_{0}$ and any pending errors are ignored.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTX}{\rrulecc{sendTX}{send\_10}{udp: block}{\tsholcomm{ Block waiting to enqueue datagram }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass {}\\{}
 \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ % TCP1_hostLTSScript.sml:11746:89-11747:-1:WARNING: curry parse failed: Timed ==> \Mtimed 7: line break not allowed in non-multiline curried op.
\tscon{Timed}(\tscon{Send2}(\tsvar{sid},\Msome  (\tsvar{addr},\tsvar{sock}.\tsvar{is}_{1},\Msome  \;\tsvar{p}'_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}),{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{str},\tsvar{opts}),{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{never\_timer})};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}'_{1}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{cantsndmore} = \Mfalse  \Mwedge {}\\{}
 (\neg{}(\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}) \implies  \tsvar{es} = *) \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 \neg{}((\neg{}\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge \tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts}) \Mvee  \tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK})) \Mwedge {}\\{}
 ((\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \Mvee  \tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}) \implies  \tscon{MSG\_OOB} \;\notin  \;\tsvar{opts}) \Mwedge {}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{sock}.\tsvar{ps}_{1},\tscon{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{sock}.\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound}) \Mwedge {}\\{}
 \tsaux{dosend}(\tsvar{h}_{0}.\tsvar{ifds},\tsvar{h}_{0}.\tsvar{rttab},(\tsvar{addr},\tsvar{str}),(\tsvar{sock}.\tsvar{is}_{1},\Msome  \;\tsvar{p}'_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}),\tsvar{h}_{0}.\tsvar{oq},\tsvar{oq}',\Mfalse ) \Mwedge {}\\{}
 ((\tsvar{addr} \neq  *) \Mvee  (\tsvar{sock}.\tsvar{is}_{2} \neq  *))}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ that is not shutdown for writing and has no
    pending errors. A $\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call is made from thread $\tsvar{tid}$ which is
    in the $\tscon{Run}$ state.

    Either the socket is a blocking one: its $\tscon{O\_NONBLOCK}$ flag is not set, or the call is a
    blocking one: the $\tscon{MSG\_DONTWAIT}$ flag is not set in $\tsvar{opts}_{0}$.

    The socket is either bound to local port $\tsvar{p}'_{1}$ or can be autobound to a port $\tsvar{p}'_{1}$.  Either
    the socket has its peer IP address set, or the destination address of the $\tslib{send}()$ call is
    set: $\tsvar{addr}\neq *$.

    A UDP datagram, constructed from the socket's binding quad $\tsvar{sock}.\tsvar{is}_{1},\Msome
\tsvar{p}'_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}$, the destination address argument $\tsvar{addr}$, and the data $\tsvar{str}$, cannot
    be placed on the outqueue of the host $\tsvar{oq}$.

    The call blocks, waiting for the datagram to be enqueued on the host's outqueue. The thread is
    left in state $\tscon{Send2}(\tsvar{sid},\Msome (\tsvar{addr},\tsvar{sock}.\tsvar{is}_{1},\Msome  \;\tsvar{p}'_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}),\tsvar{str},\tsvar{opts})$. If the
    socket was autobound to a port then $\tsvar{sid}$ is appended to the head of the host's list of bound
    sockets.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tslib{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.

    The $\tsvar{opts}_{0}$ argument is of type $\tstype{list}$. In the model it is converted to a $\tstype{set}$ $\tsvar{opts}$
    using $\tsholop{LIST\_TO\_SET}$. The presence of $\tscon{MSG\_PEEK}$ is checked for in $\tsvar{opts}$ rather than in
    $\tsvar{opts}_{0}$.


\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    The $\tscon{MSG\_DONTWAIT}$ flag may be set in $\tsvar{opts}_{0}$: it is ignored by FreeBSD.

\\\hline
Linux
&
    The $\tscon{MSG\_OOB}$ flag must not be set in $\tsvar{opts}_{0}$.

\\\hline
WinXP
&
    The $\tscon{MSG\_OOB}$ flag must not be set in $\tsvar{opts}_{0}$, and any pending error on the socket is
    ignored.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXI}{\rrulecc{sendTXI}{send\_11}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{EAGAIN}$: call would block and non-blocking behaviour has been requested }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EAGAIN}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{ps}_{1} \Mass  \Msome  \;\tsvar{p}'_{1}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{cantsndmore} = \Mfalse  \Mwedge {}\\{}
 (\neg{}(\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}) \implies  \tsvar{es} = *) \Mwedge {}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{sock}.\tsvar{ps}_{1},\tscon{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{sock}.\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound}) \Mwedge {}\\{}
 ((\tsvar{addr} \neq  *) \Mvee  (\tsvar{sock}.\tsvar{is}_{2} \neq  *)) \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 ((\neg{}\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tscon{MSG\_DONTWAIT} \;\in  \;\tsvar{opts}) \Mvee  \tsvar{ff}.\tsvar{b}(\tscon{O\_NONBLOCK})) \Mwedge {}\\{}
 \tsaux{dosend}(\tsvar{h}_{0}.\tsvar{ifds},\tsvar{h}_{0}.\tsvar{rttab},(\tsvar{addr},\tsvar{str}),(\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{ps}_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}),\tsvar{h}_{0}.\tsvar{oq},\tsvar{oq}',\Mfalse )}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ that is not shutdown for writing and has no
    pending errors. The thread $\tsvar{tid}$ is in the $\tscon{Run}$ state and a call $\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE}
\tsvar{str},\tsvar{opts}_{0}$ is made.

    The socket is either locally bound to a port $\tsvar{p}'_{1}$ or can be autobound to a port $\tsvar{p}'_{1}$.
    Either the socket has a peer IP address set, or a destination address was provided in the
    $\tslib{send}()$ call: $\tsvar{addr}\neq *$.

    Either the socket is non-blocking: its $\tscon{O\_NONBLOCK}$ flag is set, or the call is non-blocking:
    $\tscon{MSG\_DONTWAIT}$ flag was set in the $\tsvar{opts}_{0}$ argument of $\tslib{send}()$.

    A UDP datagram (constructed from the socket's binding quad
    $(\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{ps}_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2})$, the destination address argument $\tsvar{addr}$, and the data
    $\tsvar{str}$) cannot be placed on the outqueue of the host $\tsvar{oq}$.

    The $\tslib{send}()$ call fails with an $\tscon{EAGAIN}$ error. A $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made, leaving the thread state $\tscon{FAIL}\;{(\tscon{EAGAIN})}$, and the host
    with outqueue $\tsvar{oq}'$. If the socket was autobound to a port, $\tsvar{sid}$ is appended to the host's
    list of bound sockets.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tslib{send}()$ call but is a $\tstype{byte}$ $\tstype{list}$ when
    the datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte}$ $\tstype{list}$ and in the
    transition $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.

    The $\tsvar{opts}_{0}$ argument is of type $\tstype{list}$. In the model it is converted to a $\tstype{set}$ $\tsvar{opts}$
    using $\tsholop{LIST\_TO\_SET}$. The presence of $\tscon{MSG\_PEEK}$ is checked for in $\tsvar{opts}$ rather than in
    $\tsvar{opts}_{0}$.

    Note that on Linux $\tscon{EWOULDBLOCK}$ and $\tscon{EAGAIN}$ are aliased.



\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    The socket's $\tscon{O\_NONBLOCK}$ flag must be set for the rule to apply; the $\tscon{MSG\_DONTWAIT}$ flag is
    ignored by FreeBSD.

\\\hline
WinXP
&
    Pending errors on the socket are ignored.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXII}{\rrulecc{sendTXII}{send\_12}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{ENOTCONN}$: no peer address set in socket and no destination address provided }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{ \tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}'_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{err}=\tscon{EDESTADDRREQ}{}\\{}
\quad \Melse                     \;\tsvar{err}=\tscon{ENOTCONN}) \Mwedge {}\\{}
 (\neg{}(\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}) \implies  \tsvar{es} = *) \Mwedge {}\\{}
 (\Mif  \;\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad \exists \tsvar{p}'_{1}. \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{ps}_{1},\tscon{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge  \tsvar{ps}'_{1} = \Msome  \;\tsvar{p}'_{1} \Mwedge {}\\{}
\quad\quad\quad (\Mif  \;\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound}){}\\{}
\quad \Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound} \Mwedge  \tsvar{ps}'_{1} = \tsvar{ps}_{1})}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ that has no pending errors.

    A call $\tslib{send}(\tsvar{fd},\tsunknown{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0}$ is made from thread $\tsvar{tid}$ which is in the $\tscon{Run}$
    state. The socket is either locally bound to a port $\tsvar{p}'_{1}$ or it can be autobound to a port
    $\tsvar{p}'_{1}$.

    The socket does not have a peer address set, and no destination address is specified in the
    $\tslib{send}()$ call: $\tsunknown{addr} = *$. The call will fail with an $\tscon{ENOTCONN}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},*,\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition will be made, leaving the thread
    in state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOTCONN}}$. If the socket was autobound then $\tsvar{sid}$ is appended to the
    head of the host's list of bound sockets, $\tsvar{h}_{0}.\tsvar{bound}$, resulting in the new list $\tsvar{bound}$.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tslib{send}()$ call but is a $\tstype{byte} \;\tstype{list}$ when the
    datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte} \;\tstype{list}$ and in the transition
    $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    On FreeBSD the error returned is $\tscon{EDESTADDRREQ}$, the socket must not be shut down for writing,
    and if it is not bound to a local port it will not be autobound.

\\\hline
WinXP
&
    Any pending error on the socket is ignored, and if the socket's local port is not bound, $\tsvar{ps}_{1} =
*$, then it will not be autobound.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXIII}{\rrulecc{sendTXIII}{send\_13}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{EMSGSIZE}$: string to be sent is bigger than $\tsaux{UDPpayloadMax}$ }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EMSGSIZE}})}{ \tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{ps}_{1} \Mass  \tsvar{ps}'_{1}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsunknown{STRLEN} (\tsholop{IMPLODE} \;\tsvar{str}) > \tsaux{UDPpayloadMax} \;\tsvar{h}_{0}.\tstype{arch} \Mvee {}\\{}
\quad\quad (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsunknown{STRLEN} (\tsholop{IMPLODE} \;\tsvar{str}) > (\tsvar{h}_{0}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDBUF}))) \Mwedge {}\\{}
 \tsvar{ps}'_{1} \;\in  \{\tsvar{sock}.\tsvar{ps}_{1}\} \cup  (\tsholop{IMAGE} (\Msome ) (\tsaux{autobind}(\tsvar{sock}.\tsvar{ps}_{1},\tscon{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}))) \Mwedge {}\\{}
 (\Mif  \;\tsvar{sock}.\tsvar{ps}_{1} = * \Mwedge  \tsvar{ps}'_{1} \neq  * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound})}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. A call $\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ is
    made from thread $\tsvar{tid}$ which is in the $\tscon{Run}$ state.

    The length in bytes of $\tsvar{str}$ is greater than $\tsaux{UDPpayloadMax}$, the architecture-dependent
    maximum payload size for a UDP datagram. The $\tslib{send}()$ call fails with an $\tscon{EMSGSIZE}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made leaving the thread in
    state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EMSGSIZE}})$.  Additionally, the socket's local port $\tsvar{ps}_{1}$ may be autobound
    if it was not bound to a local port when the $\tslib{send}()$ call was made. If the autobinding
    occurs, then the socket's $\tsvar{sid}$ is added to the list of bound sockets $\tsvar{h}_{0}.\tsvar{bound}$, leaving
    the host's list of bound sockets as $\tsvar{bound}$.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tslib{send}()$ call but is a $\tstype{byte} \;\tstype{list}$ when the
    datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte} \;\tstype{list}$ and in the transition
    $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    On FreeBSD, the $\tslib{send}()$ call may also fail with $\tscon{EMSGSIZE}$ if the size of $\tsvar{str}$ is
    greater than the value of the socket's $\tscon{SO\_SNDBUF}$ option.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXIV}{\rrulecc{sendTXIV}{send\_14}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{EAGAIN}$, $\tscon{EADDRNOTAVAIL}$ or $\tscon{ENOBUFS}$: there are no ephemeral ports left }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,*,*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{ \tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},*,*,*,*,\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{cantsndmore} = \Mfalse  \Mwedge {}\\{}
 (\neg{}(\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}) \implies  \tsvar{es} = *) \Mwedge {}\\{}
 \tsaux{autobind}(*,\tscon{PROTO\_UDP},\tsvar{h},\tsvar{h}.\tsvar{socks}) = \emptyset  \Mwedge {}\\{}
 \tsvar{e} \;\in  \{\tscon{EAGAIN}; \tscon{EADDRNOTAVAIL}; \tscon{ENOBUFS}\}}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ that is not shutdown for writing and has no
    pending errors. The socket has no peer address set, and is not bound to a local IP address or
    port.

    From the $\tscon{Run}$ state, thread $\tsvar{tid}$ makes a $\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call.  The
    socket cannot be auto-bound to an ephemeral port so the call fails. The error returned will be
    $\tscon{EAGAIN}$, $\tscon{EADDRNOTAVAIL}$, or $\tscon{ENOBUFS}$.

    A $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition will be made. The thread will be
    left in state $\tsunknown{RET} (\tscon{FAIL}\;{\tsvar{e}})$ where $\tsvar{e}$ is one of the above errors.

\rulesubsection{Model details}

    The data to be sent is of type $\tstype{string}$ in the $\tslib{send}()$ call but is a $\tstype{byte} \;\tstype{list}$ when the
    datagram is constructed. Here the data, $\tsvar{str}$ is of type $\tstype{byte} \;\tstype{list}$ and in the transition
    $\tsholop{IMPLODE} \;\tsvar{str}$ is used to convert it into a string.


\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    Any pending error on the socket is ignored.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXV}{\rrulecc{sendTXV}{send\_15}{udp: slow urgent succeed}{\tsholcomm{ Return from blocked state after datagram enqueued }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Send2}(\tsvar{sid},\Msome  (\tsvar{addr},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsvar{str},\tsvar{opts})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{OK} (\text{``''}))}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{es}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsvar{sock}.\tsvar{cantsndmore} = \Mfalse  \Mwedge {}\\{}
 (\neg{}(\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}) \implies  \tsvar{es} = *) \Mwedge {}\\{}
 \tsunknown{STRLEN} (\tsholop{IMPLODE} \;\tsvar{str}) \leq  \tsaux{UDPpayloadMax} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 (\tsaux{dosend}(\tsvar{h}.\tsvar{ifds},\tsvar{h}.\tsvar{rttab},(\tsvar{addr},\tsvar{str}),(\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsvar{h}.\tsvar{oq},\tsvar{oq}',\Mtrue ) \Mvee {}\\{}
\quad \tsaux{dosend}(\tsvar{h}.\tsvar{ifds},\tsvar{h}.\tsvar{rttab},(\tsvar{addr},\tsvar{str}),(\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{ps}_{1},\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}),\tsvar{h}.\tsvar{oq},\tsvar{oq}',\Mtrue )) \Mwedge {}\\{}
 (\tsvar{addr} \neq  * \Mvee  \tsvar{sock}.\tsvar{is}_{2} \neq  * \Mvee  \tsvar{is}_{2} \neq  *)}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ that is not shutdown for writing and has no pending errors. The
    thread $\tsvar{tid}$ is blocked in state $\tscon{Send2}(\tsvar{sid},\Msome (\tsvar{addr},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsvar{str})$.

    A datagram can be constructed using $\tsvar{str}$ as its data. The length in bytes of $\tsvar{str}$ is less
    than or equal to $\tsaux{UDPpayloadMax}$, the architecture-dependent maximum payload size for a UDP
    datagram. There are three possible destination addresses:

    \begin{itemize}
      \item $\tsvar{addr}$, the destination address specified in the $\tslib{send}()$ call.
      \item $\tsvar{is}_{2},\tsvar{ps}_{2}$, the socket's peer address when the $\tslib{send}()$ call was made.
      \item $\tsvar{sock}.\tsvar{is}_{2},\tsvar{sock}.\tsvar{ps}_{2}$, the socket's current peer address.
    \end{itemize}

    At least one of $\tsvar{addr}$, $\tsvar{is}_{2}$, and $\tsvar{sock}.\tsvar{is}_{2}$ must specify an IP address: they are not all
    set to $*$. One of the three addresses will be used as the destination address of the
    datagram.  The datagram can be successfully enqueued on the host's outqueue, $\tsvar{h}.\tsvar{oq}$, resulting
    in a new outqueue $\tsvar{oq}'$.

    An $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}(\text{``''}))$, and the host
    with new outqueue $\tsvar{oq}'$.

\rrulepad }
}

\newcommand{\sendTXVI}{\rrulecc{sendTXVI}{send\_16}{udp: slow urgent fail}{\tsholcomm{ Fail: blocked socket has entered an error state }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Send2}(\tsvar{sid},\Msome  (\tsvar{addr},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsvar{str})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsvar{e}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  *; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec }
{\neg{}(\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch})}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ that has pending error $\Msome  \;\tsvar{e}$. The thread $\tsvar{tid}$ is blocked
    in state $\tscon{Send2}(\tsvar{sid},\Msome  (\tsvar{addr},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsvar{str})$. The error, $\tsvar{e}$, will be returned to
    the caller.

    At $\MLhtau $ transition is made, leaving the thread state $\tsunknown{RET} (\tscon{FAIL}\;{\tsvar{e}})$.

    Note that the error has occurred after the thread entered the $\tscon{Send2}$ state: rule $\tsrule{send\_11}$
    specifies that the call cannot block if there is a pending error.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    This rule does not apply: all pending errors on a socket are ignored for a $\tslib{send}()$ call.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXVII}{\rrulecc{sendTXVII}{send\_17}{udp: slow urgent fail}{\tsholcomm{ Fail with $\tscon{EMSGSIZE}$ or $\tscon{ENOTCONN}$: blocked socket has had peer address unset or string to be sent is too big }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Send2}(\tsvar{sid},\Msome (\tsvar{addr},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsvar{str},\tsvar{opts})}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{sf} \Mass  \tsvar{sf}; \tsvar{es} \Mass  \tsvar{es}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{sf} \Mass  \tsvar{sf}; \tsvar{es} \Mass  \tsvar{es}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec }
{(\neg{}(\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}) \implies  \tsvar{es} = *) \Mwedge {}\\{}
 (\exists \tsvar{oq}'. \tsaux{dosend}(\tsvar{h}.\tsvar{ifds},\tsvar{h}.\tsvar{rttab},(\tsvar{addr},\tsvar{str}),(\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsvar{h}.\tsvar{oq},\tsvar{oq}',\Mtrue )) \Mwedge {}\\{}
 ((\tsunknown{STRLEN} (\tsholop{IMPLODE} \;\tsvar{str}) > \tsaux{UDPpayloadMax} \;\tsvar{h}.\tstype{arch} \Mwedge  (\tsvar{e} = \tscon{EMSGSIZE})) \Mvee {}\\{}
\quad (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsunknown{STRLEN} (\tsholop{IMPLODE} \;\tsvar{str}) > \tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDBUF}) \Mwedge  (\tsvar{e} = \tscon{EMSGSIZE})) \Mvee {}\\{}
\quad ((\tsvar{sock}.\tsvar{is}_{2} = *) \Mwedge  (\tsvar{addr} = *) \Mwedge  (\tsvar{e} = \tscon{ENOTCONN})))}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ with no pending errors. The thread $\tsvar{tid}$ is blocked in state
    $\tscon{Send2}(\tsvar{sid},\Msome (\tsvar{addr},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}),\tsvar{str})$.

    A datagram is constructed with $\tsvar{str}$ as its payload. Its destination address is taken from
    $\tsvar{addr}$, the destination address specified when the $\tslib{send}()$ call was made, or
    $(\tsvar{is}_{2},\tsvar{ps}_{2})$, the socket's peer address when the $\tslib{send}()$ call was made. It is possible to
    enqueue the datagram on the host's outqueue, $\tsvar{h}.\tsvar{oq}$.

    This rule covers two cases. In the first, the length in bytes of $\tsvar{str}$ is greater than
    $\tsaux{UDPpayloadMax}$, the architecture-dependent maximum payload size for a UDP datagram. The error
    $\tscon{EMSGSIZE}$ is returned.

    In the second case, the original $\tslib{send}()$ call did not have a destination address specified:
    $\tsvar{addr} = *$, and the socket has had the IP address of its peer address unset:
    $\tsvar{sock}.\tsvar{is}_{2}=*$.  The peer address of the socket when the $\tslib{send}()$ call was made,
    $(\tsvar{is}_{2},\tsvar{ps}_{2})$, is ignored, and an $\tscon{ENOTCONN}$ error is returned.

    In either case, a $\MLhtau $ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$
    where $\tsvar{e}$ is either $\tscon{EMSGSIZE}$ or $\tscon{ENOTCONN}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    An $\tscon{EMSGSIZE}$ error can also be returned if the size of $\tsvar{str}$ is greater than the value of
    the socket's $\tscon{SO\_SNDBUF}$ option.

\\\hline
WinXP
&
    Any pending error on the socket is ignored.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXVIII}{\rrulecc{sendTXVIII}{send\_18}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{EOPNOTSUPP}$: $\tscon{MSG\_PEEK}$ flag not supported for $\tslib{send}()$ calls on WinXP; or $\tscon{MSG\_OOB}$ flag not supported on WinXP and Linux  }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EOPNOTSUPP}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{ps}_{1} \Mass  \tsvar{ps}'_{1}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
 [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{ps}_{1} \Mass  \tsvar{ps}_{1}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec  )] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{opts} = \tsholop{LIST\_TO\_SET} \;\tsvar{opts}_{0} \Mwedge {}\\{}
 ((\tscon{MSG\_PEEK} \;\in  \;\tsvar{opts} \Mwedge  \tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}) \Mvee {}\\{}
 (\tscon{MSG\_OOB} \;\in  \;\tsvar{opts} \Mwedge  \tsvar{sock}.\tsvar{cantsndmore} = \Mfalse  \Mwedge  (\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \Mvee  \tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}))) \Mwedge {}\\{}
 (\Mif  \;\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad\quad \exists \tsvar{p}'_{1}. \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{ps}_{1},\tscon{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge  \tsvar{ps}'_{1} = \Msome  \;\tsvar{p}'_{1} \Mwedge {}\\{}
\quad\quad (\Mif  \;\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound}){}\\{}
 \Melse {}\\{}
\quad\quad \tsvar{ps}_{1} = \tsvar{ps}'_{1} \Mwedge  \tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound})}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$
    state, a $\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call is made.

    This rule covers two cases. In the first, on WinXP, the $\tscon{MSG\_PEEK}$ flag is set in
    $\tsvar{opts}_{0}$. In the second case, on Linux and WinXP, the socket has not been shut down for
    writing, and the $\tscon{MSG\_OOB}$ flag is set in $\tsvar{opts}_{0}$. In either case, the $\tslib{send}()$ call fail
    with an $\tscon{EOPNOTSUPP}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made, leaving the thread in
    state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EOPNOTSUPP}})$.

\rulesubsection{Model details}

    The $\tsvar{opts}_{0}$ argument is of type $\tstype{list}$. In the model it is converted to a $\tstype{set}$ $\tsvar{opts}$
    using $\tsholop{LIST\_TO\_SET}$. The presence of $\tscon{MSG\_PEEK}$ is checked for in $\tsvar{opts}$ rather than in
    $\tsvar{opts}_{0}$.



\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    FreeBSD ignores the $\tscon{MSG\_PEEK}$ and $\tscon{MSG\_OOB}$ flags for $\tslib{send}()$.

\\\hline
Linux
&
    Linux ignores the $\tscon{MSG\_PEEK}$ flag for $\tslib{send}()$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXIX}{\rrulecc{sendTXIX}{send\_19}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{EADDRINUSE}$: on FreeBSD, local and destination address quad in use by another socket }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\Msome  (\tsvar{i}_{2},\tsvar{p}_{2}),\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EADDRINUSE}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{bound} \Mass  \tsvar{bound} \Mmagicrrec }
{\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{ \Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{cantsndmore} = \Mfalse  \Mwedge {}\\{}
 (\neg{}(\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch}) \implies  \tsvar{sock}.\tsvar{es} = *) \Mwedge {}\\{}
 \tsvar{p}'_{1} \;\in  \;\tsaux{autobind}(\tsvar{sock}.\tsvar{ps}_{1},\tscon{PROTO\_UDP},\tsvar{h}_{0},\tsvar{h}_{0}.\tsvar{socks}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{sock}.\tsvar{ps}_{1} = * \;\Mthen  \;\tsvar{bound} = \tsvar{sid}\Mcons \tsvar{h}_{0}.\tsvar{bound} \;\Melse  \;\tsvar{bound} = \tsvar{h}_{0}.\tsvar{bound}) \Mwedge {}\\{}
 \tsvar{i}'_{1} \;\in  \;\tsaux{auto\_outroute}(\tsvar{i}_{2},\tsvar{sock}.\tsvar{is}_{1},\tsvar{h}_{0}.\tsvar{rttab},\tsvar{h}_{0}.\tsvar{ifds}) \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}_{0}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}_{0}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = (\tsvar{h}_{0}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}) \Mwedge {}\\{}
 \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tscon{PROTO\_UDP} \Mwedge {}\\{}
 (\exists \tsvar{sid}'.{}\\{}
\quad \tsvar{sid}' \;\in  \Mfdom{\tsvar{h}_{0}.\tsvar{socks}} \Mwedge {}\\{}
\quad \Mlet  \;\tsunknown{s} = \tsvar{h}_{0}.\tsvar{socks} \Mfapply{}{\tsvar{sid}'} \Min {}\\{}
\quad \tsunknown{s}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}'_{1} \Mwedge  \tsunknown{s}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}'_{1} \Mwedge {}\\{}
\quad \tsunknown{s}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2}  \Mwedge  \tsunknown{s}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}  \Mwedge {}\\{}
\quad \tsaux{proto\_of} \;\tsunknown{s}.\tsvar{pr} = \tscon{PROTO\_UDP})}
{\rulesubsection{Description}

    On FreeBSD, consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ that is not shutdown for
    writing. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{send}(\tsvar{fd},\Msome (\tsvar{i}_{2},\tsvar{p}_{2}),\tsholop{IMPLODE}
\tsvar{str},\tsvar{opts}_{0})$ call is made. The socket is bound to local port $\tsvar{p}'_{1}$ or it can be autobound to
    port $\tsvar{p}'_{1}$. The socket can be bound to a local IP address $\tsvar{i}'_{1}$ which has a route to
    $\tsvar{i}_{2}$. Another socket, $\tsvar{sid}'$, is locally bound to $(\tsvar{i}'_{1},\tsvar{p}'_{1})$ and has its peer address set
    to $(\tsvar{i}_{2},\tsvar{p}_{2})$. The $\tslib{send}()$ call will fail with an $\tscon{EADDRINUSE}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\Msome (\tsvar{i}_{2},\tsvar{p}_{2}),\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition will be made, leaving the
    thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EADDRINUSE}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    This rule does not apply.

\\\hline
WinXP
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXXI}{\rrulecc{sendTXXI}{send\_21}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{EISCONN}$: socket has peer address set and destination address is specified in call on FreeBSD }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  *; \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i}_{2}; \tsvar{ps}_{2} \Mass  \Msome  \;\tsvar{p}_{2}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp})  \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\Msome (\tsvar{i}_{3},\tsvar{p}_{3}),\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EISCONN}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  *; \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i}_{2}; \tsvar{ps}_{2} \Mass  \Msome  \;\tsvar{p}_{2}; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp})  \Mmagicrrec )] \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch}}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ that has its peer address set: $\tsvar{is}_{2} = \Msome
\tsvar{i}_{2}$, and $\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}$. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a
    $\tslib{send}(\tsvar{fd},\Msome (\tsvar{i}_{3},\tsvar{p}_{3}),\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call is made. On FreeBSD, the call will fail with the
    $\tscon{EISCONN}$ error, as the call specified a destination address even though the socket has a peer
    address set.

    A $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\Msome (\tsvar{i}_{3},\tsvar{p}_{3}),\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition will be made, leaving the
    thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EISCONN}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    If the socket is connectionless-mode, the message shall be sent to the address specified by
    $\Msome (\tsvar{i}_{3},\tsvar{p}_{3})$. See the above $\tslib{send}()$ rules.

\\\hline
Linux
&
    This rule does not apply. Linux allows the $\tslib{send}()$ call to occur. See the above $\tslib{send}()$
    rules.

\\\hline
WinXP
&
    This rule does not apply. WinXP allows the $\tslib{send}()$ call to occur. See the above $\tslib{send}()$
    rules.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXXII}{\rrulecc{sendTXXII}{send\_22}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{EPIPE}$ or $\tscon{ESHUTDOWN}$: socket shut down for writing }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\Mtrue ,\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{err}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\Mtrue ,\tsvar{cantrcvmore},\tscon{UDP\_PROTO}(\tsvar{udp})))] \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{err} = \tscon{ESHUTDOWN}{}\\{}
 \Melse                         \;\tsvar{err} = \tscon{EPIPE}}
{\rulesubsection{Description}

     From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call
     is made where $\tsvar{fd}$ refers to a UDP socket $\tsvar{sid}$ that is shut down for writing. The call
     fails with an $\tscon{EPIPE}$ error.

     A $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made, leaving the thread in
     state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EPIPE}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
     The call fails with an $\tscon{ESHUTDOWN}$ error rather than $\tscon{EPIPE}$.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\sendTXXIII}{\rrulecc{sendTXXIII}{send\_23}{udp: fast fail}{\tsholcomm{ Fail with pending error }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tsvar{e} \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  * \Mmagicrrec )] \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tscon{PROTO\_UDP} \Mwedge {}\\{}
 \neg{}(\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})$ call
    is made where $\tsvar{fd}$ refers to a UDP socket $\tsvar{sid}$ that has pending error $\Msome  \;\tsvar{e}$.  The call
    fails, returning the pending error.

    A $\MLhcall{\tsvar{tid}}{\tslib{send}(\tsvar{fd},\tsvar{addr},\tsholop{IMPLODE} \;\tsvar{str},\tsvar{opts}_{0})}$ transition is made, leaving the thread in
    state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    This rule does not apply: all pending errors are ignored for $\tslib{send}()$ calls on WinXP.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommsetfileflags}{\clustersection{(TCP and UDP)}{$\tslib{setfileflags}()$}
\seccomm{ \[ \tslib{setfileflags}: (\tstype{fd} * \tstype{filebflag} \;\tstype{list}) \Mtotype  \tstype{unit} \]

  A call to $\tslib{setfileflags}(\tstype{fd},\tsunknown{flags})$ sets the flags on a file referred to by $\tstype{fd}$. $\tsunknown{flags}$ is
  the list of file flags to set. The possible flags are:

  \begin{itemize}
    \item $\tscon{O\_ASYNC}$ Specifies whether signal driven I/O is enabled.
    \item $\tscon{O\_NONBLOCK}$ Specifies whether a socket is non-blocking.
  \end{itemize}

  The call returns successfully if the flags were set, or fails with an error otherwise.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{setfileflags}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsrule{setfileflags\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tslib{setfileflags}()$ is Posix \wasverb{fcntl(fd,F\textunderscore{}GETFL,flags)}. On WinXP it is
  \wasverb{ioctlsocket()} with the \wasverb{FIONBIO} command.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int fcntl(int fildes, int cmd, ...);}\\
    FreeBSD: & \wasverb{int fcntl(int fd, int cmd, ...);}\\
    Linux:   & \wasverb{int fcntl(int fd, int cmd);}\\
    WinXP:   & \wasverb{int ioctlsocket(SOCKET s, long cmd, u\textunderscore{}long* argp)}
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{fildes} is a file descriptor for the file to retrieve flags from. It corresponds
     to the $\tstype{fd}$ argument of the model $\tslib{setfileflags}()$. On WinXP the \wasverb{s} is a socket
     descriptor corresponding to the $\tstype{fd}$ argument of the model $\tslib{setfileflags}()$.

    \item \wasverb{cmd} is a command to perform an operation on the file. This is set to
     \wasverb{F\textunderscore{}GETFL} for the model $\tslib{setfileflags}()$. On WinXP, \wasverb{cmd} is set to
     \wasverb{FIONBIO} to get the $\tscon{O\_NONBLOCK}$ flag; there is no $\tscon{O\_ASYNC}$ flag on WinXP.

    \item The call takes a variable number of arguments. For the model $\tslib{setfileflags}()$ it takes
     three arguments: the two described above and a third of type \wasverb{long} which represents
     the list of flags to set, corresponding to the $\tsunknown{flags}$ argument of the model
     $\tslib{setfileflags}()$. On WinXP this is the \wasverb{argp} argument.

    \item The returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

    \item \wasverb{WSAENOTSOCK} is a possible error on WinXP as the \wasverb{ioctlsocket()} call is
     specific to a socket. In the model the $\tslib{setfileflags}()$ call is performed on a file.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{setfileflags\_1}$
& \textbf{all: fast succeed}
&  Update all the file flags for an open file description \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\setfileflagsTI}{\rrulecc{setfileflagsTI}{setfileflags\_1}{all: fast succeed}{\tsholcomm{ Update all the file flags for an open file description }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus  [(\tsvar{fid},\tscon{File}(\tsvar{ft},\tsvar{ff} \; \Mmagiclrec  \tsvar{b}\Mass \tsvar{ffb} \Mmagicrrec ))] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{setfileflags}(\tsvar{fd},\tsvar{flags})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus  [(\tsvar{fid},\tscon{File}(\tsvar{ft},\tsvar{ff} \; \Mmagiclrec  \tsvar{b}\Mass \tsvar{ffb}' \Mmagicrrec ))] \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \tsvar{ffb}' = \lambda \tsvar{x}. \tsvar{x} \;\in  \;\tsvar{flags}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{setfileflags}(\tsvar{fd},\tsvar{flags})$ call is
    made. $\tsvar{fd}$ refers to the open file description $(\tsvar{fid},\tscon{File}(\tsvar{ft},\tsvar{ff} \; \Mmagiclrec  \tsvar{b} \Mass  \tsvar{ffb} \Mmagicrrec ))$ where
    $\tsvar{ffb}$ is the set of boolean file flags currently set. $\tsvar{flags}$ is a list of boolean file
    flags, possibly containing duplicates.

    All of the boolean file flags for the file description will be updated. The flags in $\tsvar{flags}$
    will all be set to $\Mtrue $, and all other flags will be set to $\Mfalse $, resulting in a new set of
    boolean file flags, $\tsvar{ffb}'$.

    A $\MLhcall{\tsvar{tid}}{\tslib{setfileflags}(\tsvar{fd},\tsvar{flags})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$.


     Note this is not exactly the same as $\tsrule{getfileflags\_1}$:
         $\tslib{getfileflags}$ never returns duplicates, but duplicates may be
         passed to $\tslib{setfileflags}$.

\rrulepad }
}

\newcommand{\seccommsetsockbopt}{\clustersection{(TCP and UDP)}{$\tslib{setsockbopt}()$}
\seccomm{  \[ \tslib{setsockbopt}: (\tstype{fd} * \tstype{sockbflag} * \tstype{bool}) \Mtotype  \tstype{unit} \]

  A call $\tslib{setsockbopt}(\tstype{fd},\tsunknown{f},\tsvar{b})$ sets the value of one of a socket's boolean flags.

  Here the $\tstype{fd}$ argument is a file descriptor referring to a socket on which to set a flag, $\tsunknown{f}$ is
  the boolean socket flag to set, and $\tsvar{b}$ is the value to set it to. Possible boolean flags are:

  \begin{itemize}

    \item $\tscon{SO\_BSDCOMPAT}$ Specifies whether the BSD semantics for delivery of ICMPs to UDP sockets
     with no peer address set is enabled.

    \item $\tscon{SO\_DONTROUTE}$ Requests that outgoing messages bypass the standard routing
     facilities. The destination shall be on a directly-connected network, and messages are directed
     to the appropriate network interface according to the destination address.

    \item $\tscon{SO\_KEEPALIVE}$ Keeps connections active by enabling the periodic transmission of
     messages, if this is supported by the protocol.

    \item $\tscon{SO\_OOBINLINE}$ Leaves received out-of-band data (data marked urgent) inline.

    \item $\tscon{SO\_REUSEADDR}$ Specifies that the rules used in validating addresses supplied to
     $\tslib{bind}()$ should allow reuse of local ports, if this is supported by the protocol.

  \end{itemize}

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{setsockbopt}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tscon{ENOPROTOOPT}$
&  The option is not supported by the protocol.

\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsrule{setsockbopt\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tslib{setsockbopt}()$ is Posix \wasverb{setsockopt()} for boolean-valued socket flags.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int setsockopt(int socket, int level, int option\textunderscore{}name,} \\
             & \wasverb{               const void *option\textunderscore{}value,}\\
             & \wasverb{               socklen\textunderscore{}t option\textunderscore{}len);}\\
    FreeBSD: & \wasverb{int setsockopt(int s, int level, int optname, } \\
             & \wasverb{               const void *optval, socklen\textunderscore{}t optlen);} \\
    Linux:   & \wasverb{int setsockopt(int s, int  level,  int  optname,} \\
             & \wasverb{               const  void  *optval, socklen\textunderscore{}t optlen);} \\
    WinXP:   & \wasverb{int setsockopt(SOCKET s, int level, int optname,} \\
             & \wasverb{               const char* optval,int optlen);}
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to set the option on, corresponding
     to the $\tstype{fd}$ argument of the model $\tslib{setsockbopt}()$.

    \item \wasverb{level} is the protocol level at which the flag resides: \wasverb{SOL\textunderscore{}SOCKET} for
     the socket level options, and \wasverb{option\textunderscore{}name} is the flag to be set. These two
     correspond to the $\tsunknown{flag}$ argument of the model $\tslib{setsockbopt}()$ where the possible values of
     \wasverb{option\textunderscore{}name} are limited to: $\tscon{SO\_BSDCOMPAT}$, $\tscon{SO\_DONTROUTE}$, $\tscon{SO\_KEEPALIVE}$,
     $\tscon{SO\_OOBINLINE}$, and $\tscon{SO\_REUSEADDR}$.

    \item \wasverb{option\textunderscore{}value} is a pointer to a location of size \wasverb{option\textunderscore{}len}
     containing the value to set the flag to. These two correspond to the $\tsvar{b}$ argument of type
     $\tstype{bool}$ in the model $\tslib{setsockbopt}()$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EFAULT} signifies the pointer passed as \wasverb{option\textunderscore{}value} was
     inaccessible. On WinXP, the error \wasverb{WSAEFAULT} may also signify that the
     \wasverb{optlen} parameter was too small. Note this error is not specified by Posix.

    \item \wasverb{EINVAL} signifies the \wasverb{option\textunderscore{}name} was invalid at the specified socket
     \wasverb{level}. In the model, typing prevents an invalid flag from being specified in a call
     to $\tslib{setsockbopt}()$.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{setsockbopt\_1}$
& \textbf{all: fast succeed}
&  Successfully set a boolean socket flag \\
$\tsrule{setsockbopt\_2}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{ENOPROTOOPT}$: $\tscon{SO\_KEEPALIVE}$ and $\tscon{SO\_OOBINLINE}$ options not supported for a UDP socket on WinXP \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\setsockboptTI}{\rrulecc{setsockboptTI}{setsockbopt\_1}{all: fast succeed}{\tsholcomm{ Successfully set a boolean socket flag }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{setsockbopt}(\tsvar{fd},\tsvar{f},\tsvar{b})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')] \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{sf} \Mass  \tsvar{sock}.\tsvar{sf} \; \Mmagiclrec  \tsvar{b} \Mass  \Mfupdate{\tsvar{sock}.\tsvar{sf}.\tsvar{b}}{\tsvar{f}}{\tsvar{b}} \Mmagicrrec  \Mmagicrrec {}\\{}
\quad  \Mwedge {}\\{}
 {}\\{}
 (\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tscon{PROTO\_UDP}{}\\{}
\quad\quad \implies  \tsvar{f} \;\notin  \{\tscon{SO\_KEEPALIVE};\tscon{SO\_OOBINLINE}\})}
{\rulesubsection{Description}

    Consider a socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, and with socket flags $\tsvar{sock}.\tsvar{sf}$. From thread
    $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{setsockbopt}(\tsvar{fd},\tsvar{f},\tsvar{b})$ call is made. $\tsvar{f}$ is the
    boolean socket flag to be set, and $\tsvar{b}$ is the boolean value to set it to. The call succeeds.

    A $\MLhcall{\tsvar{tid}}{\tslib{setsockbopt}(\tsvar{fd},\tsvar{f},\tsvar{b})}$ is made, leaving the thread state $\tscon{Ret} (\tscon{OK}())$. The
    socket's boolean flags, $\tsvar{sock}.\tsvar{sf}.\tsvar{b}$, are updated such that $\tsvar{f}$ has the value $\tsvar{b}$.

\rulesubsection{Variations}
\par\begin{ltstabular}
WinXP
&
    As above, except that if $\tsvar{sid}$ is a UDP socket, then $\tsvar{f}$ cannot be $\tscon{SO\_KEEPALIVE}$ or
    $\tscon{SO\_OOBINLINE}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\setsockboptTII}{\rrulecc{setsockboptTII}{setsockbopt\_2}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{ENOPROTOOPT}$: $\tscon{SO\_KEEPALIVE}$ and $\tscon{SO\_OOBINLINE}$ options not supported for a UDP socket on WinXP }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{setsockbopt}(\tsvar{fd},\tsvar{f},\tsvar{b})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOPROTOOPT}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec }
{\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{f} \;\in  \{\tscon{SO\_KEEPALIVE}; \tscon{SO\_OOBINLINE}\}}
{\rulesubsection{Description}

    On WinXP, consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in
    the $\tscon{Run}$ state, a $\tslib{setsockbopt}(\tsvar{fd},\tsvar{f},\tsvar{b})$ call is made, where $\tsvar{f}$ is either
    $\tscon{SO\_KEEPALIVE}$ or $\tscon{SO\_OOBINLINE}$. The call fails with an $\tscon{ENOPROTOOPT}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{setsockbopt}(\tsvar{fd},\tsvar{f},\tsvar{b})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tscon{ENOPROTOOPT}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommsetsocknopt}{\clustersection{(TCP and UDP)}{$\tslib{setsocknopt}()$}
\seccomm{  \[ \tslib{setsocknopt}: (\tstype{fd} * \tstype{socknflag} * \tstype{int}) \Mtotype  \tstype{unit} \]

  A call $\tslib{setsocknopt}(\tstype{fd},\tsunknown{f},\tsvar{n})$ sets the value of one of a socket's numeric flags. The $\tstype{fd}$
  argument is a file descriptor referring to a socket to set a flag on, $\tsunknown{f}$ is the numeric socket
  flag to set, and $\tsvar{n}$ is the value to set it to. Possible numeric flags are:

  \begin{itemize}
    \item $\tscon{SO\_RCVBUF}$ Specifies the receive buffer size.

    \item $\tscon{SO\_RCVLOWAT}$ Specifies the minimum number of bytes to process for socket input
     operations.

     \item $\tscon{SO\_SNDBUF}$ Specifies the send buffer size.

     \item $\tscon{SO\_SNDLOWAT}$ Specifies the minimum number of bytes to process for socket output
      operations.
  \end{itemize}

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{setsocknopt}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tscon{EINVAL}$
&  On FreeBSD, attempting to set a numeric flag to zero.
\\\hline
$\tscon{ENOPROTOOPT}$
&  The option is not supported by the protocol.
\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsrule{setsocknopt\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tslib{setsocknopt}()$ is Posix \wasverb{setsockopt()} for numeric-valued socket flags.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int setsockopt(int socket, int level, int option\textunderscore{}name,} \\
             & \wasverb{               const void *option\textunderscore{}value,}\\
             & \wasverb{               socklen\textunderscore{}t option\textunderscore{}len);}\\
    FreeBSD: & \wasverb{int setsockopt(int s, int level, int optname, } \\
             & \wasverb{               const void *optval, socklen\textunderscore{}t optlen);} \\
    Linux:   & \wasverb{int setsockopt(int s, int  level,  int  optname,} \\
             & \wasverb{               const  void  *optval, socklen\textunderscore{}t optlen);} \\
    WinXP:   & \wasverb{int setsockopt(SOCKET s, int level, int optname,} \\
             & \wasverb{               const char* optval,int optlen);}
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to set the option on, corresponding
     to the $\tstype{fd}$ argument of the model $\tslib{setsocknopt}()$.

    \item \wasverb{level} is the protocol level at which the flag resides: \wasverb{SOL\textunderscore{}SOCKET} for
     the socket level options, and \wasverb{option\textunderscore{}name} is the flag to be set. These two
     correspond to the $\tsunknown{flag}$ argument of the model $\tslib{setsocknopt}()$ where the possible values of
     \wasverb{option\textunderscore{}name} are limited to: $\tscon{SO\_RCVBUF}$, $\tscon{SO\_RCVLOWAT}$, $\tscon{SO\_SNDBUF}$, and
     $\tscon{SO\_SNDLOWAT}$.

    \item \wasverb{option\textunderscore{}value} is a pointer to a location of size \wasverb{option\textunderscore{}len}
     containing the value to set the flag to. These two correspond to the $\tsvar{n}$ argument of type
     $\tstype{int}$ in the model $\tslib{setsocknopt}()$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EFAULT} signifies the pointer passed as \wasverb{option\textunderscore{}value} was
     inaccessible. On WinXP, the error \wasverb{WSAEFAULT} may also signify that the
     \wasverb{optlen} parameter was too small. Note this error is not specified by Posix.

    \item \wasverb{EINVAL} signifies the \wasverb{option\textunderscore{}name} was invalid at the specified socket
     \wasverb{level}. In the model, typing prevents an invalid flag from being specified in a call
     to $\tslib{setsocknopt}()$.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{setsocknopt\_1}$
& \textbf{all: fast succeed}
&  Successfully set a numeric socket flag \\
$\tsrule{setsocknopt\_2}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EINVAL}$: on FreeBSD numeric socket flags cannot be set to zero \\
$\tsrule{setsocknopt\_4}$
& \textbf{all: fast fail}
&  Fail with $\tscon{ENOPROTOOPT}$: $\tscon{SO\_SNDLOWAT}$ not settable on Linux \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\setsocknoptTI}{\rrulecc{setsocknoptTI}{setsocknopt\_1}{all: fast succeed}{\tsholcomm{ Successfully set a numeric socket flag }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')] \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{n}' = \tsholop{MAX} (\tsaux{sf\_min\_n} \;\tsvar{h}.\tstype{arch} \;\tsvar{f}) (\tsholop{MIN} (\tsaux{sf\_max\_n} \;\tsvar{h}.\tstype{arch} \;\tsvar{f}) (\tsaux{clip\_int\_to\_num} \;\tsvar{n})) \Mwedge {}\\{}
 \tsvar{ns} = (\Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsvar{f} = \tscon{SO\_SNDBUF} \Mwedge  \tsvar{n}' < \tsvar{sock}.\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDLOWAT}) \Mthen {}\\{}
\quad\quad\quad\quad\quad \Mfupdate{(\Mfupdate{\tsvar{sock}.\tsvar{sf}.\tsvar{n}}{\tsvar{f}}{\tsvar{n}'})}{\tscon{SO\_SNDLOWAT}}{\tsvar{n}'}{}\\{}
\quad\quad \Melse  \Mfupdate{\tsvar{sock}.\tsvar{sf}.\tsvar{n}}{\tsvar{f}}{\tsvar{n}'}) \Mwedge {}\\{}
 \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{sf} \Mass  \tsvar{sock}.\tsvar{sf} \; \Mmagiclrec  \tsvar{n} \Mass  \tsvar{ns} \Mmagicrrec  \Mmagicrrec }
{\rulesubsection{Description}

    Consider the socket $\tsvar{sid}$, referenced by $\tsvar{fd}$, with numeric socket flags $\tsvar{sock}.\tsvar{sf}.\tsvar{n}$. From
    the thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})$ call is made where
    $\tsvar{f}$ is a numeric socket flag to be updated, and $\tsvar{n}$ is the integer value to set it to. The
    call succeeds.

    A $\MLhcall{\tsvar{tid}}{\tslib{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$. The socket's numeric flag $\tsvar{f}$ is updated to be the value $\tsvar{n}'$ which is: the
    architecture-specific minimum value for $\tsvar{f}$ $\tsaux{sf\_min\_n} \;\tsvar{h}.\tstype{arch} \;\tsvar{f}$, if $\tsvar{n}$ is less than this
    value; the architecture-specific maximum value for $\tsvar{f}$, i.e.~$\tsaux{sf\_max\_n} \;\tsvar{h}.\tstype{arch} \;\tsvar{f}$, if $\tsvar{n}$ is
    greater than this value, or $\tsvar{n}$ otherwise.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    If the flag to be set is $\tscon{SO\_SNDBUF}$ and the new value $\tsvar{n}$ is less than the value of the
    socket's $\tscon{SO\_SNDLOWAT}$ flag then the $\tscon{SO\_SNDLOWAT}$ flag is also set to $\tsvar{n}$.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\setsocknoptTII}{\rrulecc{setsocknoptTII}{setsocknopt\_2}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EINVAL}$: on FreeBSD numeric socket flags cannot be set to zero }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsaux{clip\_int\_to\_num} \;\tsvar{n} = 0 \Mwedge {}\\{}
 \tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch}}
{\rulesubsection{Description}

    On FreeBSD, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})$ call
    is made where $\tsvar{fd}$ is a file descriptor, $\tsvar{f}$ is a numeric socket flag, and $\tsvar{n}$ is an
    integer value to set $\tsvar{f}$ to. Because the numeric value of $\tsvar{n}$ equals $0$, the call fails
    with an $\tscon{EINVAL}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tscon{EINVAL}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.

\\\hline
WinXP
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\setsocknoptTIV}{\rrulecc{setsocknoptTIV}{setsocknopt\_4}{all: fast fail}{\tsholcomm{ Fail with $\tscon{ENOPROTOOPT}$: $\tscon{SO\_SNDLOWAT}$ not settable on Linux }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOPROTOOPT}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{f} = \tscon{SO\_SNDLOWAT}}
{\rulesubsection{Description}

    On Linux, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})$ call is
    made. $\tsvar{f} = \tscon{SO\_SNDLOWAT}$, which is not settable, so the call fails with an $\tscon{ENOPROTOOPT}$
    error.

    A $\MLhcall{\tsvar{tid}}{\tslib{setsocknopt}(\tsvar{fd},\tsvar{f},\tsvar{n})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tscon{ENOPROTOOPT}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\\\hline
WinXP
&
    This rule does not apply. Note the warning from the Win32 docs (at MSDN setsockopt):

    "If the setsockopt function is called before the bind function,
    TCP/IP options will not be checked with TCP/IP until the bind
    occurs. In this case, the setsockopt function call will always
    succeed, but the bind function call may fail because of an early
    setsockopt failing."

    This is currently unimplemented.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommsetsocktopt}{\clustersection{(TCP and UDP)}{$\tslib{setsocktopt}()$}
\seccomm{ \[ \tslib{setsocktopt}: (\tstype{fd} * \tstype{socktflag} * (\tstype{int} * \tstype{int}) \;\tstype{option}) \Mtotype  \tstype{unit} \]

  A call $\tslib{setsocktopt}(\tstype{fd},\tsunknown{f},\tsvar{t})$ sets the value of one of a socket's time-option flags.

  The $\tstype{fd}$ argument is a file descriptor referring to a socket to set a flag on, $\tsunknown{f}$ is the
  time-option socket flag to set, and $\tsvar{t}$ is the value to set it to. Possible time-option flags
  are:

  \begin{itemize}
    \item $\tscon{SO\_RCVTIMEO}$ Specifies the timeout value for input operations.

    \item $\tscon{SO\_SNDTIMEO}$ Specifies the timeout value that an output function blocks because flow
     control prevents data from being sent.
  \end{itemize}

  If $\tsvar{t}=*$ then the timeout is disabled. If $\tsvar{t}=\Msome (\tsunknown{s},\tsunknown{ns})$ then the timeout is set to $\tsunknown{s}$
  seconds and $\tsunknown{ns}$ nanoseconds.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{setsocktopt}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tscon{EBADF}$
&  The file descriptor $\tstype{fd}$ does not refer to a valid file descriptor.
\\\hline
$\tscon{EDOM}$
&  The timeout value is too big to fit in the socket structure.
\\\hline
$\tscon{ENOPROTOOPT}$
&  The option is not supported by the protocol.
\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor $\tstype{fd}$ does not refer to a socket.
\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsrule{setsocktopt\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  $\tslib{setsocktopt}()$ is Posix \wasverb{setsockopt()} for time-option socket flags.

  \begin{tabular}{ll}
    Posix:   & \wasverb{int setsockopt(int socket, int level, int option\textunderscore{}name,} \\
             & \wasverb{               const void *option\textunderscore{}value,}\\
             & \wasverb{               socklen\textunderscore{}t option\textunderscore{}len);}\\
    FreeBSD: & \wasverb{int setsockopt(int s, int level, int optname, } \\
             & \wasverb{               const void *optval, socklen\textunderscore{}t optlen);} \\
    Linux:   & \wasverb{int setsockopt(int s, int  level,  int  optname,} \\
             & \wasverb{               const  void  *optval, socklen\textunderscore{}t optlen);} \\
    WinXP:   & \wasverb{int setsockopt(SOCKET s, int level, int optname,} \\
             & \wasverb{               const char* optval,int optlen);}
   \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{socket} is the file descriptor of the socket to set the option on, corresponding
     to the $\tstype{fd}$ argument of the model $\tslib{setsocktopt}()$.

    \item \wasverb{level} is the protocol level at which the flag resides: \wasverb{SOL\textunderscore{}SOCKET} for
     the socket level options, and \wasverb{option\textunderscore{}name} is the flag to be set. These two
     correspond to the $\tsunknown{flag}$ argument of the model $\tslib{setsocktopt}()$ where the possible values of
     \wasverb{option\textunderscore{}name} are limited to: $\tscon{SO\_RCVTIMEO}$ and $\tscon{SO\_SNDTIMEO}$.

    \item \wasverb{option\textunderscore{}value} is a pointer to a location of size \wasverb{option\textunderscore{}len}
     containing the value to set the flag to. These two correspond to the $\tsvar{t}$ argument of type
     $(\tstype{int} * \tstype{int}) \;\tstype{option}$ in the model $\tslib{setsocktopt}()$.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item \wasverb{EFAULT} signifies the pointer passed as \wasverb{option\textunderscore{}value} was
     inaccessible. On WinXP, the error \wasverb{WSAEFAULT} may also signify that the
     \wasverb{optlen} parameter was too small. Note this error is not specified by Posix.

    \item \wasverb{EINVAL} signifies the \wasverb{option\textunderscore{}name} was invalid at the specified socket
     \wasverb{level}. In the model, typing prevents an invalid flag from being specified in a call
     to $\tslib{setsocknopt}()$.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{setsocktopt\_1}$
& \textbf{all: fast succeed}
&  Successfully set a time-option socket flag \\
$\tsrule{setsocktopt\_4}$
& \textbf{all: fast fail}
&  Fail with $\tscon{ENOPROTOOPT}$: on WinXP $\tscon{SO\_LINGER}$ not settable for a UDP socket \\
$\tsrule{setsocktopt\_5}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EDOM}$:  timeout value too long to fit in socket structure \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\setsocktoptTI}{\rrulecc{setsocktoptTI}{setsocktopt\_1}{all: fast succeed}{\tsholcomm{ Successfully set a time-option socket flag }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')] \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsaux{tltimeopt\_wf} \;\tsvar{t} \Mwedge   {}\\{}
 \tsvar{t}' = \tsaux{time\_of\_tltimeopt} \;\tsvar{t} \Mwedge {}\\{}
 \tsvar{t}' \geq  0 \Mwedge {}\\{}
 (\Mif  \;\tsvar{f} \;\in  \{\tscon{SO\_RCVTIMEO}; \tscon{SO\_SNDTIMEO}\} \Mwedge  \tsvar{t}' = 0{}\\{}
 \Mthen  \;\tsvar{t}'' = \infty{}\\{}
 \Melse  \;\tsvar{t}'' = \tsvar{t}') \Mwedge {}\\{}
 (\Mif  \;\tsvar{f} = \tscon{SO\_LINGER} \Mwedge   \tsvar{t} = \Msome (\tsvar{s},\tsvar{ns}) \Mthen  \;\tsvar{ns} = 0 \;\Melse  \;\Mtrue ) \Mwedge {}\\{}
 (\tsvar{f} \;\in  \{\tscon{SO\_RCVTIMEO}; \tscon{SO\_SNDTIMEO}\} \implies  \tsvar{t}'' = \infty \Mvee  \tsvar{t}'' \leq  \tsaux{sndrcv\_timeo\_t\_max}) \Mwedge {}\\{}
 \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{sf} \Mass  \tsvar{sock}.\tsvar{sf} \; \Mmagiclrec  \tsvar{t} \Mass  \Mfupdate{\tsvar{sock}.\tsvar{sf}.\tsvar{t}}{\tsvar{f}}{\tsvar{t}''} \Mmagicrrec  \Mmagicrrec }
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})$ call is
    made. $\tsvar{fd}$ refers to a socket $\tsvar{sid}$ which has time-option socket flags $\tsvar{sock}.\tsvar{sf}.\tsvar{t}$; $\tsvar{f}$
    is a time-option socket flag: either $\tscon{SO\_RCVTIMEO}$ or $\tscon{SO\_SNDTIMEO}$; and $\tsvar{t}$ is the
    well formed time-option value to set $\tsvar{f}$ to. The call succeeds.

    A $\MLhcall{\tsvar{tid}}{\tslib{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$. If $\tsvar{t}=*$ or $\tsvar{t}=\Msome  (0,0)$ then the socket's time-option flags are updated such
    that $\tsvar{sock}.\tsvar{sf}.\tsvar{t}(\tsvar{f})=*$, representing $\infty$; otherwise the socket's time-option
    flags are updated such that $\tsvar{f}$ has the time value represented by $\tsvar{t}$, which must be less
    than $\tsunknown{snd\_rcv\_timeo\_t\_max}$.

\rulesubsection{Model details}

    The type of $\tsvar{t}$ is $(\tstype{int} * \tstype{int}) \;\tstype{option}$, but the type of a time-option socket flag is
    $\tstype{time}$. The auxiliary function $\tsaux{time\_of\_tltimeopt}$ is used to do the conversion.

\rrulepad }
}

\newcommand{\setsocktoptTIV}{\rrulecc{setsocktoptTIV}{setsocktopt\_4}{all: fast fail}{\tsholcomm{ Fail with $\tscon{ENOPROTOOPT}$: on WinXP $\tscon{SO\_LINGER}$ not settable for a UDP socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOPROTOOPT}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge  \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tscon{PROTO\_UDP} \Mwedge {}\\{}
 \tsvar{f} = \tscon{SO\_LINGER}}
{\rulesubsection{Description}

    On WinXP, from thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})$ call is
    made. $\tsvar{fd}$ is a file descriptor referring to a UDP socket $\tsvar{sid}$, $\tsvar{f}$ is the time-option
    socket $\tscon{SO\_LINGER}$. The flag $\tsvar{f}$ is not settable, so the call fails with an $\tscon{ENOPROTOOPT}$
    error.

    A $\MLhcall{\tsvar{tid}}{\tslib{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{FAIL}\;{\tscon{ENOPROTOOPT}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\\\hline
Linux
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\setsocktoptTV}{\rrulecc{setsocktoptTV}{setsocktopt\_5}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EDOM}$:  timeout value too long to fit in socket structure }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EDOM}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{f} \;\in  \{\tscon{SO\_RCVTIMEO}; \tscon{SO\_SNDTIMEO}\} \Mwedge {}\\{}
 \tsaux{tltimeopt\_wf} \;\tsvar{t} \Mwedge   {}\\{}
 \tsvar{t}' = \tsaux{time\_of\_tltimeopt} \;\tsvar{t} \Mwedge {}\\{}
 (\Mif  \;\tsvar{t}' = 0{}\\{}
 \Mthen  \;\tsvar{t}'' = \infty{}\\{}
 \Melse  \;\tsvar{t}'' = \tsvar{t}') \Mwedge {}\\{}
 \neg{}(\tsvar{t}'' = \infty \Mvee  \tsvar{t}'' \leq  \tsaux{sndrcv\_timeo\_t\_max})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is currently in the $\tscon{Run}$ state, a $\tslib{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})$ call is
    made. $\tsvar{f}$ is a time-option socket flag that is either $\tscon{SO\_RCVTIMEO}$ or $\tscon{SO\_SNDTIMEO}$, and
    $\tsvar{t}$ is the time value to set $\tsvar{f}$ to. The call fails with an $\tscon{EDOM}$ error because the value
    $\tsvar{t}$ is too large to fit in the socket structure: it is not zero and it is greater than
    $\tsaux{sndrcv\_timeo\_t\_max}$.

    A $\MLhcall{\tsvar{tid}}{\tslib{setsocktopt}(\tsvar{fd},\tsvar{f},\tsvar{t})}$ call is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EDOM}})$.

\rulesubsection{Model details}

    The type of $\tsvar{t}$ is $(\tstype{int} * \tstype{int}) \;\tstype{option}$, but the type of a time-option socket flag is
    $\tstype{time}$. The auxiliary function $\tsaux{time\_of\_tltimeopt}$ is used to do the conversion.

\rrulepad }
}

\newcommand{\seccommshutdown}{\clustersection{(TCP and UDP)}{$\tslib{shutdown}()$}
\seccomm{  \[ \tslib{shutdown}: (\tstype{fd} * \tstype{bool} * \tstype{bool}) \Mtotype  \tstype{unit} \]

  A call of $\tslib{shutdown}(\tstype{fd},\tsunknown{r},\tsunknown{w})$ shuts down either the read-half of a connection, the write-half of
  a connection, or both. The $\tstype{fd}$ is a file descriptor referring to the socket to shutdown; the $\tsunknown{r}$ and $\tsunknown{w}$ indicate whether the socket should be shut down for reading and writing respectively.

  For a TCP socket, shutting down the read-half empties the socket's receive queue, but data will
  still be delivered to it and subsequent $\tslib{recv}()$ calls will return data. Shutting down the
  write-half of a TCP connection causes the remaining data in the socket's send queue to be sent and
  then TCP's connection termination to occur.

  For Linux and WinXP, a TCP socket may only be shut down if it is in the $\tscon{ESTABLISHED}$ state; on
  FreeBSD a socket may be shut down in any state.

  For a UDP socket, if the socket is shutdown for reading, data may still be read from the socket's
  receive queue on Linux, but on FreeBSD and WinXP this is not the case. Shutting down the socket
  for writing causes subsequent $\tslib{send}()$ calls to fail.


}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{shutdown}()$ can fail with the errors below, in which case the corresponding exception
  is raised:

\par\begin{ltstabular}
$\tscon{ENOTCONN}$
&  The socket is not connected and so cannot be shut down.
\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\\\hline
$\tscon{ENOBUFS}$
&  Out of resources.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
 A TCP socket is created and connects to a peer; data is transferred between the two; the socket has
 no more data to send so calls $\tslib{shutdown}()$ to inform the peer of this: $\tsrule{socket\_1}$; $\dots $;
 $\tsrule{connect\_1}$; $\dots $; $\tsrule{shutdown\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:   & \wasverb{int shutdown(int socket, int how);} \\
    FreeBSD: & \wasverb{int shutdown(int s, int how);} \\
    Linux:   & \wasverb{int shutdown(int s, int how);} \\
    WinXP:   & \wasverb{int shutdown(SOCKET s, int how);}
  \end{tabular}

  In the Posix interface:
  \begin{itemize}

    \item \wasverb{socket} is a file descriptor referring to the socket to shut down. This
     corresponds to the $\tstype{fd}$ argument of the model $\tslib{shutdown}()$.

    \item \wasverb{how} is an integer specifying the type of shutdown corresponding to the $(\tsunknown{r},\tsunknown{w})$
     arguments in the model $\tslib{shutdown}()$. If \wasverb{how} is set to \wasverb{SHUT\textunderscore{}RD} then the
     read half of the connection is to be shut down, corresponding to a $\tslib{shutdown}(\tstype{fd},\Mtrue ,\Mfalse )$ call in
     the model; if it is set to \wasverb{SHUT\textunderscore{}WR} then the write half of the connection is to be
     shut down, corresponding to a $\tslib{shutdown}(\tstype{fd},\Mfalse ,\Mtrue )$ call in the model; if it is set to
     \wasverb{SHUT\textunderscore{}RDWR} then both the read and write halves of the connection are to be shut down,
     corresponding to a $\tslib{shutdown}(\tstype{fd},\Mtrue ,\Mtrue )$ call in the model.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  The FreeBSD, Linux, and WinXP interfaces are similar, except where noted.

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:
  \begin{itemize}

    \item \wasverb{EINVAL} signifies that the \wasverb{how} argument is invalid. In the model the
     \wasverb{how} argument is represented by the two boolean flags $\tsunknown{r}$ and $\tsunknown{w}$ which guarantees
     that the only values allowed are $(\Mtrue ,\Mtrue )$, $(\Mtrue ,\Mfalse )$, $(\Mfalse ,\Mtrue )$, and $(\Mfalse ,\Mfalse )$. The first
     three correspond to the allowed values of \wasverb{how}: \wasverb{SHUT\textunderscore{}RD},
     \wasverb{SHUT\textunderscore{}WR}, and \wasverb{SHUT\textunderscore{}RDWR}. The last possible value, $(\Mfalse ,\Mfalse )$, is not
     allowed by Posix, but the model allows a $\tslib{shutdown}(\tstype{fd},\Mfalse ,\Mfalse )$ call,
     which has no effect on the socket.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

   \end{itemize}

}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{shutdown\_1}$
& \textbf{tcp: fast succeed}
&  Shut down read or write half of TCP connection \\
$\tsrule{shutdown\_2}$
& \textbf{udp: fast succeed}
&  Shutdown UDP socket for reading, writing, or both \\
$\tsrule{shutdown\_3}$
& \textbf{tcp: fast fail}
&  Fail with $\tscon{ENOTCONN}$: cannot shutdown a socket that is not connected on Linux and WinXP \\
$\tsrule{shutdown\_4}$
& \textbf{udp: fast fail}
&  Fail with $\tscon{ENOTCONN}$: socket's peer address not set on Linux \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\shutdownTI}{\rrulecc{shutdownTI}{shutdown\_1}{tcp: fast succeed}{\tsholcomm{ Shut down read or write half of TCP connection }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} ())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock}')] \Mmagicrrec }
{\tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},\tsvar{pr}) \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{pr} = \tscon{TCP\_PROTO} \;\tsunknown{tcp\_sock} \Mwedge {}\\{}
 \Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{CLOSED};\tscon{LISTEN}\} \Mwedge  \tsvar{w}  \;\Mthen {}\\{}
\quad {}\\{}
\quad {}\\{}
\quad \Mlet  \;\tsvar{sock}'' = (\tsaux{tcp\_close} \;\tsvar{h}.\tstype{arch} \;\tsvar{sock}) \Min {}\\{}
\quad \tsvar{sock}' = \tsvar{sock}'' \; \Mmagiclrec  \tsvar{cantsndmore} \Mass  (\tsvar{w}\Mvee \tsvar{cantsndmore});{}\\{}
 \tsvar{cantrcvmore} \Mass  (\tsvar{r}\Mvee \tsvar{cantrcvmore});{}\\{}
 \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsaux{tcp\_sock\_of} \;\tsvar{sock}'' \;{}\\{}
\quad\quad\quad\quad \Mmagiclrec  \tsvar{cb} \;\Mupdby  (\lambda \tsvar{cb}. \tsvar{cb} \; \Mmagiclrec  \tsfield{bsd\_cantconnect} \Mass  \Mtrue  \Mmagicrrec );{}\\{}
 \tsvar{lis} \Mass  * \Mmagicrrec ){}\\{}
 \Mmagicbolrrec {}\\{}
 \Melse {}\\{}
\quad (\neg{}\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \implies  \exists \tsvar{i}_{1} \;\tsvar{p}_{1} \;\tsvar{i}_{2} \;\tsvar{p}_{2}. \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{ESTABLISHED} \Mwedge  \tsvar{is}_{1}=\Msome  \;\tsvar{i}_{1} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{ps}_{1}=\Msome  \;\tsvar{p}_{1} \Mwedge  \tsvar{is}_{2}=\Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}_{2}=\Msome  \;\tsvar{p}_{2} \Mwedge  \tsunknown{tcp\_sock}.\tsvar{lis} = *) \Mwedge {}\\{}
\quad \tsvar{pr}' = \tscon{TCP\_PROTO} (\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{rcvq} \;\Mupdby  [\,] \tsholop{onlywhen} \;\tsvar{r};{}\\{}
 \tsvar{cb} \;\Mupdby  (\lambda \tsvar{cb}. \tsvar{cb} \; \Mmagiclrec {}\\{}
 \tsfield{tf\_shouldacknow} \;\Mupdby  \;\Mtrue  \;\tsholop{onlywhen} \;\tsvar{w} \Mmagicrrec ) \Mmagicrrec ) \Mwedge {}\\{}
\quad \tsvar{sock}' = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{w} \Mvee  \tsvar{cantsndmore},\tsvar{r} \Mvee \tsvar{cantrcvmore},\tsvar{pr}')}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})$ call is made. $\tsvar{fd}$
    refers to a TCP socket $\tsvar{sid}$ which is in the $\tscon{ESTABLISHED}$ state and has binding quad
    $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$.

    The call suceeds: a $\MLhcall{\tsvar{tid}}{\tslib{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})}$ transition is made, leaving the thread in
    state $\tscon{Ret} (\tscon{OK}())$. If $\tsvar{r}=\Mtrue $ then the read-half of the connection is shut down, setting
    $\tsvar{cantrcvmore}=\Mtrue $ and emptying the socket's receive queue; if $\tsvar{w}=\Mtrue $ then the write-half of the
    connection is shut down, setting $\tsvar{cantsndmore}=\Mtrue $; otherwise, the socket is unchanged.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    The TCP socket can be in any state, not just $\tscon{ESTABLISHED}$. If the socket is in the $\tscon{CLOSED}$
    or $\tscon{LISTEN}$ and is to be shutdown for writing, $\tsvar{w}=\Mtrue $, then the socket is closed, see \ltslink{tcpTclose}{$\tsaux{tcp\_close}$}.

    Note that testing has shown the socket's listen queue is not always set to $*$ after a
    $\tslib{shutdown}()$ call. The precise condition for this being done needs to be investigated.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\shutdownTII}{\rrulecc{shutdownTII}{shutdown\_2}{udp: fast succeed}{\tsholcomm{ Shutdown UDP socket for reading, writing, or both }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantrcvmore} \Mass  \tsvar{cantrcvmore};{}\\{}
 \tsvar{cantsndmore} \Mass  \tsvar{cantsndmore};{}\\{}
 \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsunknown{udp\_pr}) \Mmagicrrec  )] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK}())}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{cantrcvmore} \Mass  (\tsvar{r} \Mvee  \tsvar{cantrcvmore});{}\\{}
 \tsvar{cantsndmore} \Mass  (\tsvar{w} \Mvee  \tsvar{cantsndmore});{}\\{}
 \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsunknown{udp\_pr}) \Mmagicrrec  )] \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 (\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \implies  \tsvar{sock}.\tsvar{is}_{2} \neq  *)}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$, referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in the
    $\tscon{Run}$ state, a $\tslib{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})$ call is made and succeeds.

    A $\MLhcall{\tsvar{tid}}{\tslib{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}())$. If the socket was shutdown for reading when the call was made or $\tsvar{r} = \Mtrue $ then the
    socket is shutdown for reading. If the socket was shutdown for writing when the call was made or
    $\tsvar{w} = \Mtrue $ then the socket is shutdown for writing.

\rulesubsection{Variations}
\par\begin{ltstabular}
Linux
&
    As above, with the added condition that the socket's peer IP address must be set: $\tsvar{sock}.\tsvar{is}_{2} \neq
*$.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\shutdownTIII}{\rrulecc{shutdownTIII}{shutdown\_3}{tcp: fast fail}{\tsholcomm{ Fail with $\tscon{ENOTCONN}$: cannot shutdown a socket that is not connected on Linux and WinXP }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOTCONN}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \neq  \tscon{ESTABLISHED} \Mwedge {}\\{}
 \neg{}(\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})$ call is made where
    $\tsvar{fd}$ refers to a TCP socket $\tsvar{sid}$ which is not in the $\tscon{ESTABLISHED}$ state. The call fails
    with an $\tscon{ENOTCONN}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOTCONN}})$.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\shutdownTIV}{\rrulecc{shutdownTIV}{shutdown\_4}{udp: fast fail}{\tsholcomm{ Fail with $\tscon{ENOTCONN}$: socket's peer address not set on Linux }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{2} \Mass  *; \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec  ) ] \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOTCONN}})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \Mmagiclrec  \tsvar{is}_{2} \Mass  *;{}\\{}
 \tsvar{cantsndmore} \Mass  (\tsvar{w} \Mvee  \tsvar{sock}.\tsvar{cantsndmore});{}\\{}
 \tsvar{cantrcvmore} \Mass  (\tsvar{r} \Mvee  \tsvar{sock}.\tsvar{cantrcvmore});{}\\{}
 \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsvar{udp}) \Mmagicrrec )] \Mmagicrrec }
{\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff})}
{\rulesubsection{Description}

    On Linux, consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$ with no peer IP address set: $\tsvar{is}_{2}
\Mass  *$. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})$ call is
    made, and fails with an $\tscon{ENOTCONN}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOTCONN}})$. If the socket was shutdown for reading when the call was made or $\tsvar{r} = \Mtrue $ then the
    socket is shutdown for reading. If the socket was shutdown for writing when the call was made or
    $\tsvar{w} = \Mtrue $ then the socket is shutdown for writing.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    This rule does not apply: see rule $\tsrule{shutdown\_2}$.

\\\hline
WinXP
&
    This rule does not apply: see rule $\tsrule{shutdown\_2}$.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommsockatmark}{\clustersection{(TCP only)}{$\tslib{sockatmark}()$}
\seccomm{   \[ \tslib{sockatmark}: \tstype{fd} \Mtotype  \tstype{bool} \]

  A call to $\tslib{sockatmark}(\tstype{fd})$ returns a $\tstype{bool}$ specifying whether or not a socket is at the
  urgent mark.
  Here $\tstype{fd}$ is a file descriptor referring to a socket.

  If $\tstype{fd}$ refers to a TCP socket then the call will succeed, returning $\Mtrue $ if that socket is at
  the urgent mark, and $\Mfalse $ if it is not.

  If $\tstype{fd}$ refers to a UDP socket then on FreeBSD the call will return $\Mfalse $ and on all other
  architectures it will fail with an $\tscon{EINVAL}$ error: there is no concept of urgent data for UDP so
  calling $\tslib{sockatmark}()$ does not make sense.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{sockatmark}()$ can fail with the errors below, in which case the corresponding
  exception is raised:

\par\begin{ltstabular}
$\tscon{EINVAL}$
&  Calling $\tslib{sockatmark}()$ on a UDP socket does not make sense.
\\\hline
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  $\tsrule{sockatmark\_1}$; $\tsrule{return\_1}$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:   & \wasverb{int sockatmark(int s);} \\
    FreeBSD: & \wasverb{int ioctl(int d, unsigned long request, int* argp);} \\
    Linux:   & \wasverb{int ioctl(int d, int request, int* argp);} \\
    WinXP:   & \wasverb{int ioctlsocket(SOCKET s, long cmd, u\textunderscore{}long* argp);} \\
  \end{tabular}

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{s} is a file descriptor referring to a socket. This corresponds to the $\tstype{fd}$
     argument of the model $\tslib{sockatmark}()$.

    \item the returned \wasverb{int} is either \wasverb{0} or \wasverb{1} to indicate success or
     \wasverb{-1} to indicate an error, in which case the error code is in \wasverb{errno}. If the
     return value is \wasverb{1} then the socket is at the urgent mark corresponding to a return
     value of $\Mtrue $ in the model $\tslib{sockatmark}()$; if the return value is \wasverb{0} then the
     socket is not at the urgent mark, corresponding to a return value of $\Mfalse $ in the model.

  \end{itemize}

  The FreeBSD, Linux, and WinXP interfaces are significantly different: to check whether or not a
  socket is at the urgent mark, the \wasverb{ioctl()} function must be used. In the FreeBSD
  interface:

  \begin{itemize}

    \item \wasverb{d} is a file descriptor referring to a socket, corresponding to the $\tstype{fd}$
     argument of the model $\tslib{sockatmark}()$.

    \item \wasverb{request} selects which control function is to be performed. For $\tslib{sockatmark}()$,
     the request is \wasverb{SIOCATMARK}.

    \item \wasverb{argp} is a pointer to a location to store the result of the call in. If the
     socket is at the urgent mark then \wasverb{1} will be in the location pointed to by
     \wasverb{argp} upon return, corresponding to a return value of $\Mtrue $ in the model
     $\tslib{sockatmark}()$; if the socket is not at the urgent mark, then \wasverb{argp} will contain the
     value \wasverb{0}, corresponding to a return value of $\Mfalse $ in the model.

    \item the returned \wasverb{int} is either \wasverb{0} to indicate success or \wasverb{-1} to
     indicate an error, in which case the error code is in \wasverb{errno}.  On WinXP an error is
     indicated by a return value of \wasverb{SOCKET\textunderscore{}ERROR}, not \wasverb{-1}, with the actual error
     code available through a call to \wasverb{WSAGetLastError()}.

  \end{itemize}

  The Linux and WinXP interfaces are similar.

}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item On FreeBSD, Linux, and WinXP, $\tscon{EFAULT}$ can be returned if the \wasverb{argp} parameter
    points to memory not in a valid part of the process address space. This is an artefact of the C
    interface to \wasverb{ioctl()} that is excluded by the clean interface used in the model
    $\tslib{sockatmark}()$.

    \item On FreeBSD and Linux, $\tscon{EINVAL}$ can be returned if \wasverb{request} is not a valid
     request. The model $\tslib{sockatmark}()$ is implemented using the \wasverb{SIOCATMARK} request which
     is valid.

    \item $\tscon{ENOTTY}$ is possible when making an $\tsunknown{ioctl}()$ call but is not modelled.

    \item \wasverb{WSAEINPROGRESS} is WinXP-specific and described in the MSDN page as "A blocking
     Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
     function". This is not modelled here.

  \end{itemize}


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{sockatmark\_1}$
& \textbf{tcp: fast succeed}
&  Successfully return whether or not a TCP socket is at the urgent mark \\
$\tsrule{sockatmark\_2}$
& \textbf{udp: rc}
&  Fail with $\tscon{EINVAL}$: calling $\tslib{sockatmark}()$ on a UDP socket does not make sense \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\sockatmarkTI}{\rrulecc{sockatmarkTI}{sockatmark\_1}{tcp: fast succeed}{\tsholcomm{ Successfully return whether or not a TCP socket is at the urgent mark }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{sockatmark}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} \;\tsvar{b})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{socks}}{\tsvar{sid}} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{ESTABLISHED},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 \tsvar{b} = (\tsvar{rcvurp} = \Msome  \;0)}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{sockatmark}(\tsvar{fd})$ call is made. $\tsvar{fd}$
    refers to a TCP socket identified by $\tsvar{sid}$ which is in the $\tscon{ESTABLISHED}$ state and has
    binding quad $(\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2})$. The call succeeds, returning $\Mtrue $ if the
    socket is at the urgent mark: $\tsvar{rcvurp} = \Msome  \;0$; or $\Mfalse $ otherwise.

    A $\MLhcall{\tsvar{tid}}{\tslib{sockatmark}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK} \;\tsvar{b})$
    where $\tsvar{b}$ is a boolean: $\Mtrue $ or $\Mfalse $ as above.

\rrulepad }
}

\newcommand{\sockatmarkTII}{\rrulecc{sockatmarkTII}{sockatmark\_2}{udp: rc}{\tsholcomm{ Fail with $\tscon{EINVAL}$: calling $\tslib{sockatmark}()$ on a UDP socket does not make sense }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tslib{sockatmark}(\tsvar{fd})} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tsvar{ret})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsaux{proto\_of} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}).\tsvar{pr} = \tscon{PROTO\_UDP} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{rc} = \tscon{fast} \;\tscon{succeed} \Mwedge  \tsvar{ret} = \tscon{OK}(\Mfalse ){}\\{}
 \Melse                     \;\tsvar{rc} = \tscon{fast} \;\tscon{fail}    \Mwedge  \tsvar{ret} = \tscon{FAIL}\;{\tscon{EINVAL}}}
{\rulesubsection{Description}

    Consider a UDP socket $\tsvar{sid}$ referenced by $\tsvar{fd}$. From thread $\tsvar{tid}$, which is in the $\tscon{Run}$
    state, a $\tslib{sockatmark}(\tsvar{fd})$ call is made. On FreeBSD the call succeeds, returning $\Mfalse $; on
    Linux and WinXP the call fails with an $\tscon{EINVAL}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{sockatmark}(\tsvar{fd})}$ transition is made, leaving the thread state $\tscon{Ret}
(\tscon{OK}(\Mfalse ))$ on FreeBSD, and in state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINVAL}})$ on Linux and WinXP.

\rulesubsection{Variations}
\par\begin{ltstabular}
Posix
&
    As above: the call succeeds, returning $\Mfalse $.

\\\hline
FreeBSD
&
    As above: the call succeeds, returning $\Mfalse $.

\\\hline
Linux
&
    As above: the call fails with an $\tscon{EINVAL}$ error.

\\\hline
WinXP
&
    As above: the call fails with an $\tscon{EINVAL}$ error.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\seccommsocket}{\clustersection{(TCP and UDP)}{$\tslib{socket}()$}
\seccomm{ \[ \tslib{socket}: \tsunknown{sock\_type} \Mtotype  \tstype{fd} \]

  A call to $\tslib{socket}(\tsunknown{type})$ creates a new socket. Here $\tsunknown{type}$ is the type of socket to create:
  $\tscon{SOCK\_STREAM}$ for TCP and $\tscon{SOCK\_DGRAM}$ for UDP. The returned $\tstype{fd}$ is the file descriptor of
  the new socket.

}\clustersubsection{Errors}
\seccomm{
  A call to $\tslib{socket}()$ can fail with the errors below, in which case the corresponding exception
  is raised:

\par\begin{ltstabular}
$\tscon{EMFILE}$
&  No more file descriptors for this process.
\\\hline
$\tscon{ENOBUFS}$
&  Out of resources.

\\\hline
$\tscon{ENOMEM}$
&  Out of resources.

\\\hline
$\tscon{ENFILE}$
&  Out of resources.


\end{ltstabular}\par
}\clustersubsection{Common cases}
\seccomm{
  TCP: $\tsrule{socket\_1}$; $\tsrule{return\_1}$; $\tsrule{connect\_1}$; $\dots$
  UDP: $\tsrule{socket\_1}$; $\tsrule{return\_1}$; $\tsrule{bind\_1}$; $\tsrule{return\_1}$; $\tsrule{send\_9}$; $\dots$

}\clustersubsection{API}
\seccomm{
  \begin{tabular}{ll}
    Posix:  &  \wasverb{int socket(int domain, int type, int protocol);} \\
    FreeBSD:&  \wasverb{int socket(int domain, int type, int protocol);} \\
    Linux:  &  \wasverb{int socket(int doamin, int type, int protocol);} \\
    WinXP:  &  \wasverb{SOCKET socket(int af, int type, int protocol);} \\
  \end{tabular}\\

  In the Posix interface:

  \begin{itemize}

    \item \wasverb{domain} specifies the communication domain in which the socket is to be created,
    specifying the protocol family to be used. Only IPv4 sockets are modelled here, so
    \wasverb{domain} is set to \wasverb{AF\textunderscore{}INET} or \wasverb{PF\textunderscore{}INET}.

    \item \wasverb{type} specifies the communication semantics: \wasverb{SOCK\textunderscore{}STREAM} provides
          sequenced, reliable, two-way, connection-based byte streams; \wasverb{SOCK\textunderscore{}DGRAM}
          supports datagrams (connectionless, unreliable messages of a fixed maximum length). This
          corresponds to the $\tsunknown{sock\_type}$ argument of the model $\tslib{socket}()$.

    \item \wasverb{protocol} specifies the particular protocol to be used for the socket. A
    \wasverb{protocol} of \wasverb{0} requests to use the default for the appropriate socket
    \wasverb{type}: TCP for \wasverb{SOCK\textunderscore{}STREAM} and UDP for \wasverb{SOCK\textunderscore{}DGRAM}. Alternatively
    a specific protocol number can be used: \wasverb{6} for TCP and \wasverb{17} for UDP. In the
    model, $\tscon{SOCK\_STREAM}$ refers to a TCP socket and $\tscon{SOCK\_DGRAM}$ to a UDP socket so the
    \wasverb{protocol} argument is not necessary.

  \end{itemize}

  A call to $\tslib{socket}(\tscon{SOCK\_STREAM})$ in the model interface, would be a
  \wasverb{socket(AF\textunderscore{}INET,SOCK\textunderscore{}STREAM,0)} call in Posix; a call to $\tslib{socket}(\tscon{SOCK\_DGRAM})$ in the
  model interface would be a \wasverb{socket(AF\textunderscore{}INET,SOCK\textunderscore{}DGRAM,0)} call in Posix.

  The FreeBSD, Linux and WinXP interfaces are similar modulo argument renaming, except where noted
  above.


}\clustersubsection{Model details}
\seccomm{
  The following errors are not modelled:

  \begin{itemize}

    \item In Posix and on Linux, \wasverb{EACCES} specifies that the process does not have appropriate
    privileges.  We do not model a privilege state in which socket creation would be disallowed.

    \item In Posix and  on Linux, \wasverb{EAFNOSUPPORT}, specifies that the implementation does not
    support the address \wasverb{domain}. FreeBSD, Linux, and WinXP all support \wasverb{AF\textunderscore{}INET}
    sockets.

    \item On Linux, \wasverb{EINVAL} means unknown protocol, or protocol domain not available. Both
    TCP and UDP are known protocols for Linux, and \wasverb{AF\textunderscore{}INET} is a known domain on Linux.

    \item In Posix and on Linux, \wasverb{EPROTONOTSUPPORT} specifies that the protocol is not
    supported by the address family, or the protocol is not supported by the
    implementation. FreeBSD, Linux, and WinXP all support the TCP and UDP protocols.

    \item In Posix, \wasverb{EPROTOTYPE} signifies that the socket type is not supported by the
    protocol. Both \wasverb{SOCK\textunderscore{}STREAM} and \wasverb{SOCK\textunderscore{}DGRAM} are supported by TCP and UDP
    respectively.

    \item On WinXP, \wasverb{WSAESOCKTNOSUPPORT} means the specified socket type is not supported in
    this address family. The \wasverb{AF\textunderscore{}INET} family supports both \wasverb{SOCK\textunderscore{}STREAM} and
    \wasverb{SOCK\textunderscore{}DGRAM} sockets.

  \end{itemize}

  The \wasverb{AF\textunderscore{}INET6}, \wasverb{AF\textunderscore{}LOCAL}, \wasverb{AF\textunderscore{}ROUTE}, and \wasverb{AF\textunderscore{}KEY} address
  families; \wasverb{SOCK\textunderscore{}RAW} socket type; and all protocols other than TCP and UDP are not modelled.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{socket\_1}$
& \textbf{all: fast succeed}
&  Successfully return a new file descriptor for a fresh socket \\
$\tsrule{socket\_2}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EMFILE}$: out of file descriptors for this process \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\socketTI}{\rrulecc{socketTI}{socket\_1}{all: fast succeed}{\tsholcomm{ Successfully return a new file descriptor for a fresh socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds};{}\\{}
 \tsvar{files} \Mass  \tsvar{files};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{(\tslib{socket} (\tsvar{socktype}))} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{OK} \;\tsvar{fd})}{\tsaux{sched\_timer}}};{}\\{}
 \tsvar{fds} \Mass  \tsvar{fds}';{}\\{}
 \tsvar{files} \Mass  \tsvar{files} \oplus  [(\tsvar{fid},\tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsaux{ff\_default}))];{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec }
{\tsholop{CARD} (\Mfdom{\tsvar{fds}}) < \tsaux{OPEN\_MAX} \Mwedge {}\\{}
 \tsvar{fid} \;\notin  (\Mfdom{\tsvar{files}}) \Mwedge {}\\{}
 \tsvar{sid} \;\notin  (\Mfdom{\tsvar{socks}}) \Mwedge {}\\{}
 \tsaux{nextfd} \;\tsvar{h}.\tstype{arch} \;\tsvar{fds} \;\tsvar{fd} \Mwedge {}\\{}
 \tsvar{fds}' = \tsvar{fds} \oplus  (\tsvar{fd}, \tsvar{fid}) \Mwedge {}\\{}
 (\Mcase  \;\tsvar{socktype} \;\Mof {}\\{}
\quad \tscon{SOCK\_DGRAM} \Mtotype  (\tsvar{sock} ={}\\{}
\quad\quad \tscon{Sock}(\Msome  \;\tsvar{fid},\tsaux{sf\_default} \;\tsvar{h}.\tstype{arch} \;\tsvar{socktype},*,*,*,*,*,\Mfalse ,\Mfalse ,\tsaux{UDP\_Sock}([\,]))) \Mdpipe {}\\{}
\quad \tscon{SOCK\_STREAM} \Mtotype  (\tsvar{sock} ={}\\{}
\quad\quad \tscon{Sock}(\Msome  \;\tsvar{fid},\tsaux{sf\_default} \;\tsvar{h}.\tstype{arch} \;\tsvar{socktype},*,*,*,*,*,\Mfalse ,\Mfalse ,{}\\{}
\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{CLOSED},\tsaux{initial\_cb},*,[\,],*,[\,],*,\tscon{NO\_OOBDATA})))){}\\{}
 }
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{socket}(\tsvar{socktype})$ call is made. The
    number of open file descriptors is less than the maximum permitted, $\tsaux{OPEN\_MAX}$.

    If $\tsvar{socktype}=\tscon{SOCK\_STREAM}$ then a new TCP socket $\tsvar{sock}$ is created, in the $\tscon{CLOSED}$ state,
    with \ltslink{initialTcb}{$\tsaux{initial\_cb}$} as its control block, and all other fields uninitialised; if
    $\tsvar{socktype}=\tscon{SOCK\_DGRAM}$ then a new, unitialised UDP socket $\tsvar{sock}$ is created. A new open file
    description is created pointing to the socket, and a new file descriptor, $\tsvar{fd}$, is allocated
    in an architecture specific way (see \ltslink{nextfd}{$\tsaux{nextfd}$}) to point to the open file
    description. The host's finite map of sockets is updated to include an entry mapping the socket
    identifier $\tsvar{sid}$ to the socket; its finite map of file descriptions is updated to add an entry
    mapping the file descriptor $\tsvar{fid}$ to the file description of the socket; and its finite map of
    file descriptors is updated, adding a mapping from $\tsvar{fd}$ to $\tsvar{fid}$.

    A $\MLhcall{\tsvar{tid}}{\tslib{socket}(\tsunknown{sock\_type})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{OK}
\tsvar{fd})$ to return the new file descriptor.

\rrulepad }
}

\newcommand{\socketTII}{\rrulecc{socketTII}{socket\_2}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EMFILE}$: out of file descriptors for this process }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{(\tslib{socket} (\tsvar{s}))} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EMFILE}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsholop{CARD} (\Mfdom{\tsvar{h}.\tsvar{fds}}) \geq  \tsaux{OPEN\_MAX}}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a $\tslib{socket}(\tsvar{s})$ call is made. The number of
    open file descriptors is greater than the maximum allowed number, $\tsaux{OPEN\_MAX}$, and so the call
    fails with an $\tscon{EMFILE}$ error.

    A $\MLhcall{\tsvar{tid}}{\tslib{socket}(\tsvar{s})}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{EMFILE}})$.

\rrulepad }
}

\newcommand{\seccommmisc}{\clustersection{(TCP and UDP)}{Miscellaneous}
\seccomm{
  This section collects the remaining Sockets API rules:
  \begin{itemize}

  \item The rule $\tsrule{return\_1}$ characterising how the the results of system calls
  are returned to the caller, with transitions from the thread state $\Mtimed{\tscon{Ret} \;\tsunknown{v}}{\tsunknown{d}}$.

  \item Rules $\tsrule{badf\_1}$ and $\tsrule{notsock\_1}$ deal with all the Sockets API calls that take a file descriptor
  argument, dealing uniformly with the error cases in which that file descriptor is not valid or
  does not refer to a socket.

  \item Rule $\tsrule{intr\_1}$ applies to all the thread states for blocked calls, $\tscon{Accept2}(\tstype{sid})$ etc.,
  characterising the behaviour in the case where the call is interrupted by a signal.

  \item Rules $\tsrule{resourcefail\_1}$ and $\tsrule{resourcefail\_2}$ deal with the cases where calls fail due to a lack
  of system resources.
  \end{itemize}

}\clustersubsection{Errors}
\seccomm{
Common errors.

\par\begin{ltstabular}
$\tscon{EBADF}$
&   The file descriptor passed is not a valid file descriptor.

\\\hline
$\tscon{ENOTSOCK}$
&  The file descriptor passed does not refer to a socket.

\\\hline
$\tscon{EINTR}$
&  The system was interrupted by a caught signal.

\\\hline
$\tscon{ENOMEM}$
&  Out of resources.

\\\hline
$\tscon{ENOBUFS}$
&  Out of resources.

\\\hline
$\tscon{ENFILE}$
&  Out of resources.


\end{ltstabular}\par
}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{return\_1}$
& \textbf{all: misc nonurgent}
&  Return result of system call to caller \\
$\tsrule{badf\_1}$
& \textbf{all: fast fail}
&  Fail with $\tscon{EBADF}$: not a valid file descriptor \\
$\tsrule{notsock\_1}$
& \textbf{all: fast fail}
&  Fail with $\tscon{ENOTSOCK}$: file descriptor not a valid socket \\
$\tsrule{intr\_1}$
& \textbf{all: slow nonurgent fail}
&  Fail with $\tscon{EINTR}$: blocked system call interrupted by
     signal \\
$\tsrule{resourcefail\_1}$
& \textbf{all: fast badfail}
&  Fail with $\tscon{ENFILE}$, $\tscon{ENOBUFS}$ or $\tscon{ENOMEM}$: out
     of resources \\
$\tsrule{resourcefail\_2}$
& \textbf{all: slow nonurgent badfail}
&  Fail with $\tscon{ENFILE}$, $\tscon{ENOBUFS}$ or
     $\tscon{ENOMEM}$: from a blocked state with out of resources \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\returnTI}{\rrulecc{returnTI}{return\_1}{all: misc nonurgent}{\tsholcomm{ Return result of system call to caller }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} \;\tsvar{v}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhreturn{\tsvar{tid}}{\tsvar{v}} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsaux{never\_timer}}} \Mmagicrrec }
{\Mtrue }
{\rulesubsection{Description}

    A system call from thread $\tsvar{tid}$ has completed, leaving the thread state $\Mtimed{\tscon{Ret} \;\tsvar{v}}{\tsvar{d}}$.  The value $\tsvar{v}$ (which may be of the form $\tscon{OK} \;\tsvar{v}'$ or $\tscon{FAIL}\;{\tsvar{v}'}$, for success or failure respectively) is returned to the caller before the timer $\tsvar{d}$ expires.  The thread continues its execution, indicated by the resulting thread state $\Mtimed{\tscon{Run}}{\tsaux{never\_timer}}$.

\rrulepad }
}

\newcommand{\badfTI}{\rrulecc{badfTI}{badf\_1}{all: fast fail}{\tsholcomm{ Fail with $\tscon{EBADF}$: not a valid file descriptor }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsvar{opn}} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsaux{fd\_op} \;\tsvar{fd} \;\tsvar{opn} \Mwedge {}\\{}
 \tsvar{fd} \;\notin  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 (\Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsvar{e} = \tscon{ENOTSOCK} \;\Melse  \;\tsvar{e} = \tscon{EBADF})}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a system call $\tsvar{opn}$ is made. The call
    requires a single valid file descriptor, but the descriptor passed, $\tsvar{fd}$ is not valid: it does
    not refer to an open file description. The call fails with an $\tscon{EBADF}$ error, or an
    $\tscon{ENOTSOCK}$ error on WinXP.

    A $\MLhcall{\tsvar{tid}}{\tsvar{opn}}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})$ where
    $\tsvar{e}$ is one of the above errors.

    The system calls this rule applies to are: $\tslib{accept}()$, $\tslib{bind}()$, $\tslib{close}()$, $\tslib{connect}()$,
    $\tslib{disconnect}()$, $\tslib{dup}()$, $\tslib{dupfd}()$, $\tslib{getfileflags}()$, $\tslib{setfileflags}()$,
    $\tslib{getsockname}()$, $\tslib{getpeername}()$, $\tslib{getsockbopt}()$, $\tslib{getsockerr}()$,
    $\tslib{getsocklistening}()$, $\tslib{getsocknopt}()$, $\tslib{getsocktopt}()$, $\tslib{listen}()$, $\tslib{recv}()$,
    $\tslib{send}()$, $\tslib{setsockbopt}()$, $\tslib{setsocknopt}()$, $\tslib{setsocktopt}()$, $\tslib{shutdown}()$, and
    $\tslib{sockatmark}()$.  See the definition of \ltslink{fdTop}{$\tsaux{fd\_op}$}.

\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    As above: the call fails with an $\tscon{EBADF}$ error.

\\\hline
Linux
&
    As above: the call fails with an $\tscon{EBADF}$ error.

\\\hline
WinXP
&
    As above: the call fails with an $\tscon{ENOTSOCK}$ error.

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\notsockTI}{\rrulecc{notsockTI}{notsock\_1}{all: fast fail}{\tsholcomm{ Fail with $\tscon{ENOTSOCK}$: file descriptor not a valid socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{\tsvar{opn}} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOTSOCK}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsaux{fd\_sockop} \;\tsvar{fd} \;\tsvar{opn} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tsvar{ft},\tsvar{ff}) \Mwedge {}\\{}
 \neg{}(\exists \tsvar{sid}. \tsvar{ft} = \tscon{FT\_Socket}(\tsvar{sid}))}
{\rulesubsection{Description}

    From thread $\tsvar{tid}$, which is in the $\tscon{Run}$ state, a system call $\tsvar{opn}$ is made. The call
    requires a single file descriptor referring to a socket. The file descriptor $\tsvar{fd}$ that the
    user passes refers to an open file description $\tscon{File}(\tsvar{ft},\tsvar{ff})$ that does not refer to a
    socket. The call fails with an $\tscon{ENOTSOCK}$ error.

    A $\MLhcall{\tsvar{tid}}{\tsvar{opn}}$ transition is made, leaving the thread state $\tscon{Ret} (\tscon{FAIL}\;{\tscon{ENOTSOCK}})$.

    The system calls this rule applies to are: $\tslib{accept}()$, $\tslib{bind}()$, $\tslib{connect}()$,
    $\tslib{disconnect}()$, $\tslib{getpeername}()$, $\tslib{getsockbopt}()$, $\tslib{getsockerr}()$,
    $\tslib{getsocklistening}()$, $\tslib{getsockname}()$, $\tslib{getsocknopt}()$, $\tslib{getsocktopt}()$, $\tslib{listen}()$,
    $\tslib{recv}()$, $\tslib{send}()$, $\tslib{setsockbopt}()$, $\tslib{setsocknopt}()$, $\tslib{setsocktopt}()$, $\tslib{shutdown}()$,
    and $\tslib{sockatmark}()$.  See the definition of \ltslink{fdTsockop}{$\tsaux{fd\_sockop}$}.

\rrulepad }
}

\newcommand{\intrTI}{\rrulecc{intrTI}{intr\_1}{all: slow nonurgent fail}{\tsholcomm{ Fail with $\tscon{EINTR}$: blocked system call interrupted by
     signal }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{st}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tscon{EINTR}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\tsvar{sock} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}) \Mwedge {}\\{}
 (\tsvar{st} = \tscon{Close2}(\tsvar{sid}) \Mvee {}\\{}
 \tsvar{st} = \tscon{Connect2}(\tsvar{sid}) \Mvee {}\\{}
 \tsvar{st} = \tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts}) \Mvee {}\\{}
 \tsvar{st} = \tscon{Send2}(\tsvar{sid},\tsvar{addr},\tsvar{str},\tsvar{opts}) \Mvee {}\\{}
 \tsvar{st} = \tscon{PSelect2}(\tsvar{readfds},\tsvar{writefds},\tsvar{exceptfds}) \Mvee {}\\{}
 \tsvar{st} = \tscon{Accept2}(\tsvar{sid}))}
{\rulesubsection{Description}

    If on socket $\tsvar{sid}$ as user call blocked leaving a thread in one of the states:
    $\tscon{Close2}(\tsvar{sid})$, $\tscon{Connect2}(\tsvar{sid})$, $\tscon{Recv2}(\tsvar{sid})$, $\tscon{Send2}(\tsvar{sid})$, $\tscon{PSelect2}(\tsvar{sid})$ or
    $\tscon{Accept2}(\tsvar{sid})$ and a signal is caught, the calls fails returning error $\tscon{EINTR}$.

\rulesubsection{Model details}

    This rule is non-deterministic, allowing blocked calls to be interrupted at any point, as the specification does not model the dynamics of signals.

\rulesubsection{Variations}
\par\begin{ltstabular}
POSIX
&
    POSIX says that a system call "shall fail" if "interrupted by a signal".

\end{ltstabular}\par
\rrulepad }
}

\newcommand{\resourcefailTI}{\rrulecc{resourcefailTI}{resourcefail\_1}{all: fast badfail}{\tsholcomm{ Fail with $\tscon{ENFILE}$, $\tscon{ENOBUFS}$ or $\tscon{ENOMEM}$: out
     of resources }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Run}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhcall{\tsvar{tid}}{ \tsvar{call}} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\neg{}\tsaux{INFINITE\_RESOURCES} \Mwedge {}\\{}
 \tsvar{fd} \;\in  \Mfdom{\tsvar{h}.\tsvar{fds}} \Mwedge {}\\{}
 \tsvar{fid} = \tsvar{h}.\tsvar{fds} \Mfapply{}{\tsvar{fd}} \Mwedge {}\\{}
 \Mfapply{\tsvar{h}.\tsvar{files}}{\tsvar{fid}} = \tscon{File}(\tscon{FT\_Socket}(\tsvar{sid}),\tsvar{ff}) \Mwedge {}\\{}
 \tsvar{sock} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}) \Mwedge {}\\{}
 ((\tsvar{call} = \tslib{socket}(\tsvar{socktype}) \Mwedge  \tsvar{e} \;\in  \{\tscon{ENFILE}; \tscon{ENOBUFS}; \tscon{ENOMEM}\}) \Mvee {}\\{}
 (\tsvar{call} = \tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1}) \Mwedge  \tsvar{e} = \tscon{ENOBUFS}) \Mvee {}\\{}
 (\tsvar{call} = \tslib{connect}(\tsvar{fd},\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2}) \Mwedge  \tsvar{e} = \tscon{ENOBUFS}) \Mvee {}\\{}
 (\tsvar{call} = \tslib{listen}(\tsvar{fd},\tsvar{n}) \Mwedge  \tsvar{e} = \tscon{ENOBUFS}) \Mvee {}\\{}
 (\tsvar{call} = \tslib{recv}(\tsvar{fd},\tsvar{n},\tsvar{opts}) \Mwedge  \tsvar{e} \;\in  \{\tscon{ENOMEM};\tscon{ENOBUFS}\}) \Mvee {}\\{}
 (\tsvar{call} = \tslib{getsockname}(\tsvar{fd}) \Mwedge  \tsvar{e} = \tscon{ENOBUFS}) \Mvee {}\\{}
 (\tsvar{call} = \tslib{getpeername}(\tsvar{fd}) \Mwedge  \tsvar{e} = \tscon{ENOBUFS}) \Mvee {}\\{}
 (\tsvar{call} = \tslib{shutdown}(\tsvar{fd},\tsvar{r},\tsvar{w}) \Mwedge  \tsvar{e} = \tscon{ENOBUFS}) \Mvee {}\\{}
 (\tsvar{call} = \tslib{accept}(\tsvar{fd}) \Mwedge  \tsvar{e} \;\in  \{\tscon{ENFILE}; \tscon{ENOBUFS}; \tscon{ENOMEM}\}{}\\{}
 \Mwedge   \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tscon{PROTO\_TCP}))}
{\rulesubsection{Description}

    Thread $\tsvar{tid}$ performs a $\tslib{socket}()$, $\tslib{bind}()$, $\tslib{connect}()$, $\tslib{listen}()$, $\tslib{recv}()$,
    $\tslib{getsockname}()$, $\tslib{getpeername}()$, $\tslib{shutdown}()$ or $\tslib{accept}()$ system call on socket
    $\tsvar{sid}$, referred to by $\tsvar{fd}$, when insufficient system-wide resources are available to
    complete the request. Return a failure of $\tscon{ENFILE}$, $\tscon{ENOBUFS}$ or $\tscon{ENOMEM}$ immediately to
    the calling thread.

    This rule applies only when it is assumed that the host being modelled does not have
    $\tsaux{INFINITE\_RESOURCES}$, i.e. the host does not have unlimited memory, mbufs, file descriptors,
    etc.

\rulesubsection{Model details}

    The modelling of failure is deliberately non-deterministic because the cause of errors such as
    $\tscon{ENFILE}$ are determined by more than is modelled in this specification. In order to be more
    precise, the model would need to describe the whole system to determine when such error
    conditions could and should arise.

\rrulepad }
}

\newcommand{\resourcefailTII}{\rrulecc{resourcefailTII}{resourcefail\_2}{all: slow nonurgent badfail}{\tsholcomm{ Fail with $\tscon{ENFILE}$, $\tscon{ENOBUFS}$ or
     $\tscon{ENOMEM}$: from a blocked state with out of resources }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tsvar{t}}{\tsvar{d}}} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{\tscon{Ret} (\tscon{FAIL}\;{\tsvar{e}})}{\tsaux{sched\_timer}}} \Mmagicrrec }
{\neg{}\tsaux{INFINITE\_RESOURCES} \Mwedge {}\\{}
 \tsvar{sock} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}) \Mwedge {}\\{}
 ((\tsvar{t} = \tscon{Accept2}(\tsvar{sid}) \Mwedge  \tsvar{e} \;\in  \{\tscon{ENFILE}; \tscon{ENOBUFS}; \tscon{ENOMEM}\}) \Mvee {}\\{}
 (\tsvar{t} = \tscon{Connect2}(\tsvar{sid}) \Mwedge  \tsvar{e} = \tscon{ENOBUFS}) \Mvee {}\\{}
 (\tsvar{t} = \tscon{Recv2}(\tsvar{sid},\tsvar{n},\tsvar{opts}) \Mwedge  \tsvar{e} \;\in  \{\tscon{ENOBUFS}; \tscon{ENOMEM}\}))}
{\rulesubsection{Description}

    If thread $\tsvar{tid}$ of host $\tsvar{h}$ is in state $\tscon{Accept2}(\tsvar{sid})$, $\tscon{Connect2}(\tsvar{sid})$ or
    $\tscon{Recv2}(\tsvar{sid})$ following an $\tslib{accept}()$, $\tslib{connect}()$ or $\tslib{recv}()$ system call that blocked,
    and the host has subsequently exhausted its system-wide resources, fail with $\tscon{ENFILE}$,
    $\tscon{ENOBUFS}$ or $\tscon{ENOMEM}$. The error is immediately returned to the thread that made the system
    call.

    Calls to $\tslib{connect}()$ only return $\tscon{ENOBUFS}$ when resources are exhausted and calls to
    $\tslib{recv}()$ only return $\tscon{ENOBUFS}$ or $\tscon{ENOMEM}$.

    This rule applies only when it is assumed that the host being modelled does not have
    $\tsaux{INFINITE\_RESOURCES}$, i.e. the host does not have unlimited memory, mbufs, file descriptors,
    etc.

\rulesubsection{Model details}

    The modelling of failure is deliberately non-deterministic because the cause of errors such as
    $\tscon{ENFILE}$ are determined by more than is modelled in this specification. In order to be more
    precise, the model would need to describe the whole system to determine when such error
    conditions could and should arise.

\rrulepad }
}

\newcommand{\chapcommtcpTinputTprocessing}{\chaptersection{ Host LTS: TCP Input Processing}
\label{tcp_input_processing}%
\chapcomm{}
}

\newcommand{\seccommtcpTinputTprocessing}{\clustersection{(TCP only)}{Input Processing}
\seccomm{
These rules deal with the processing of TCP segments from the host's input queue.
The most important are $\tsrule{deliver\_in\_1}$, $\tsrule{deliver\_in\_2}$, and $\tsrule{deliver\_in\_3}$.

$\tsrule{deliver\_in\_1}$ deals with a passive open: a socket in $\tscon{LISTEN}$ state that receives a $\tsvar{SYN}$ and sends a $\tsvar{SYN},\tsvar{ACK}$.

$\tsrule{deliver\_in\_2}$ deals with the completion of an active open: a socket in $\tscon{SYN\_SENT}$ state (that has previously sent a $\tsvar{SYN}$ with the $\tsrule{connect\_1}$ rule) that receives a $\tsvar{SYN},\tsvar{ACK}$ and sends an $\tsvar{ACK}$.  It also deals with simultaneous opens.

$\tsrule{deliver\_in\_3}$ deals with the common cases of TCP data exchange and connection close: sockets in connected states that receive data, $\tsvar{ACK}$s, and $\tsvar{FIN}$s.
This rule is structured using the relational monad, combining auxiliaries
$\tsaux{di3\_topstuff}$, $\tsaux{di3\_ackstuff}$, $\tsaux{di3\_datastuff}$ etc., to factor out many of the imperative effects of the code.

The other rules deal with $\tsvar{RST}$s and a variety of pathological situations.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{deliver\_in\_1}$
& \textbf{tcp: network nonurgent}
&  Passive open: receive SYN, send SYN,ACK \\
$\tsrule{deliver\_in\_1b}$
& \textbf{tcp: network nonurgent}
&  For a listening socket, receive and drop a bad
     datagram and either generate a RST segment or ignore it. Drop the incoming segment if the socket's
     queue of incomplete connections is full. \\
$\tsrule{deliver\_in\_2}$
& \textbf{tcp: network nonurgent}
&  Completion of active open (in $\tscon{SYN\_SENT}$ receive SYN,ACK and send ACK) or simultaneous open (in $\tscon{SYN\_SENT}$ receive SYN and send SYN,ACK) \\
$\tsrule{deliver\_in\_2a}$
& \textbf{tcp: network nonurgent}
&  Receive bad or boring datagram and RST or ignore for $\tscon{SYN\_SENT}$ socket \\
$\tsrule{deliver\_in\_3}$
& \textbf{tcp: network nonurgent}
&  Receive data, FINs, and ACKs in a connected state \\
$\tsrule{di3\_topstuff}$
&
&  $\tsrule{deliver\_in\_3}$ initial checks \\
$\tsrule{di3\_newackstuff}$
&
&  $\tsrule{deliver\_in\_3}$ new ack processing, used in $\tsaux{di3\_ackstuff}$  \\
$\tsrule{di3\_ackstuff}$
&
&  $\tsrule{deliver\_in\_3}$ ACK processing \\
$\tsrule{di3\_datastuff\_really}$
&
&  $\tsrule{deliver\_in\_3}$ data processing \\
$\tsrule{di3\_datastuff}$
&
&  $\tsrule{deliver\_in\_3}$ data processing \\
$\tsrule{di3\_ststuff}$
&
&  $\tsrule{deliver\_in\_3}$ TCP state change processing \\
$\tsrule{di3\_socks\_update}$
&
&  $\tsrule{deliver\_in\_3}$ socket update processing \\
$\tsrule{deliver\_in\_3a}$
& \textbf{tcp: network nonurgent}
&  Receive data with invalid checksum or offset \\
$\tsrule{deliver\_in\_3b}$
& \textbf{tcp: network nonurgent}
&  Receive data after process has gone away \\
$\tsrule{deliver\_in\_3c}$
& \textbf{tcp: network nonurgent}
&  Receive stupid ACK or LAND DoS in $\tscon{SYN\_RECEIVED}$ state \\
$\tsrule{deliver\_in\_4}$
& \textbf{tcp: network nonurgent}
&  Receive and drop (silently) a non-sane or martian segment \\
$\tsrule{deliver\_in\_5}$
& \textbf{tcp: network nonurgent}
&  Receive and drop (maybe with RST) a sane segment that does not match any socket \\
$\tsrule{deliver\_in\_6}$
& \textbf{tcp: network nonurgent}
&  Receive and drop (silently) a sane segment that matches a $\tscon{CLOSED}$ socket \\
$\tsrule{deliver\_in\_7}$
& \textbf{tcp: network nonurgent}
&  Receive RST and zap non-$\{\tscon{CLOSED}$; $\tscon{LISTEN}$; $\tscon{SYN\_SENT}$; $\tscon{SYN\_RECEIVED}$; $\tscon{TIME\_WAIT}\}$ socket \\
$\tsrule{deliver\_in\_7a}$
& \textbf{tcp: network nonurgent}
&  Receive RST and zap $\tscon{SYN\_RECEIVED}$ socket \\
$\tsrule{deliver\_in\_7b}$
& \textbf{tcp: network nonurgent}
&  Receive RST and ignore for $\tscon{LISTEN}$ socket \\
$\tsrule{deliver\_in\_7c}$
& \textbf{tcp: network nonurgent}
&  Receive RST and ignore for $\tscon{SYN\_SENT}$(unacceptable ack) or $\tscon{TIME\_WAIT}$ socket \\
$\tsrule{deliver\_in\_7d}$
& \textbf{tcp: network nonurgent}
&  Receive RST and zap $\tscon{SYN\_SENT}$(acceptable ack) socket \\
$\tsrule{deliver\_in\_8}$
& \textbf{tcp: network nonurgent}
&  Receive SYN in non-$\{\tscon{CLOSED}$; $\tscon{LISTEN}$; $\tscon{SYN\_SENT}$; $\tscon{TIME\_WAIT}\}$ state \\
$\tsrule{deliver\_in\_9}$
& \textbf{tcp: network nonurgent}
&  Receive SYN in $\tscon{TIME\_WAIT}$ state if there is no matching $\tscon{LISTEN}$ socket or sequence number has not increased \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\deliverTinTI}{\rrulecc{deliverTinTI}{deliver\_in\_1}{tcp: network nonurgent}{\tsholcomm{ Passive open: receive SYN, send SYN,ACK }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks}' \oplus {}\\{}
 \tsholcomm{ Listening socket }{}\\{}
 [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis}',[\,],*,[\,],*,\tscon{NO\_OOBDATA})));{}\\{}
 \tsholcomm{ New socket formed by the incoming SYN }{}\\{}
 (\tsvar{sid}',\tscon{Sock}(*,\tsvar{sf}',\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},*,\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{SYN\_RECEIVED},\tsvar{cb}'',*,[\,],*,[\,],*,\tscon{NO\_OOBDATA})))] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsholcomm{ \textbf{Summary:} A host $\tsvar{h}$ with listening socket $\tsvar{sock}$ referenced by index $\tsvar{sid}$ receives a valid and
    well-formed $\tsvar{SYN}$ segment $\tsvar{seg}$ addressed to socket $\tsvar{sock}$. A new socket in the
    $\tscon{SYN\_RECEIVED}$ state is constructed, referenced by $\tsvar{sid}' (\neq  \tsvar{sid})$, is added to the queue of
    incomplete incoming connection attempts $\tsvar{q}$, and a $\tsvar{SYN}$,$\tsvar{ACK}$ segment is generated in
    reply with some field values being chosen or negotiated. The reply segment is finally queued on
    the host's output queue for transmission, ignoring any errors upon queueing failure.
    }{}\\{}
 {}\\{}
 \tsvar{sid} \;\notin  (\Mfdom{\tsvar{socks}}) \Mwedge {}\\{}
 \tsvar{sid}' \;\notin  (\Mfdom{\tsvar{socks}}) \Mwedge {}\\{}
 \tsvar{sid} \neq  \tsvar{sid}' \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Take TCP segment $\tsvar{seg}$ from the head of the host's input queue }{}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ The segment must be of an acceptable form }{}\\{}
 \tsholcomm{ Note: some segment fields are ignored during TCP connection establishment and as such may
        contain arbitrary values. These are equal to the identifiers postfixed with
        $\tsunknown{\_discard}$ below, which are otherwise unconstrained. }{}\\{}
 (\exists \tsunknown{win\_} \;\tsunknown{ws\_}  \;\tsunknown{mss\_} \;\tsunknown{PSH\_discard} \;\tsunknown{URG\_discard} \;\tsunknown{FIN\_discard} \;\tsunknown{urp\_discard} \;\tsunknown{data\_discard} \;\tsunknown{ack\_discard}.{}\\{}
\quad \tsvar{seg} ={}\\{}
\quad\quad \Mmagiclrec  \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{seq}:\tsaux{tcp\_seq\_foreign});{}\\{}
 \tsvar{ack}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsunknown{ack\_discard}:\tsaux{tcp\_seq\_local});{}\\{}
 \tsvar{URG}  \Mass  \tsunknown{URG\_discard};{}\\{}
 \tsvar{ACK}  \Mass  \Mfalse ;           \tsholcomm{ $\tsvar{ACK}$ must be $\Mfalse $ in a SYN segment }{}\\{}
 \tsvar{PSH}  \Mass  \tsunknown{PSH\_discard};{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;           \tsholcomm{ Valid SYN segments never have $\tsvar{RST}$ set }{}\\{}
 \tsvar{SYN}  \Mass  \Mtrue ;           \tsholcomm{ Is a SYN segment! }{}\\{}
 \tsvar{FIN}  \Mass  \tsunknown{FIN\_discard};{}\\{}
 \tsvar{win}  \Mass  \tsunknown{win\_};{}\\{}
 \tsvar{ws}   \Mass  \tsunknown{ws\_};{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_discard};{}\\{}
 \tsvar{mss}  \Mass  \tsunknown{mss\_};{}\\{}
 \tsvar{ts}   \Mass  \tsvar{ts};{}\\{}
 \tsvar{data} \Mass  \tsunknown{data\_discard}{}\\{}
 \Mmagicbolrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Equality of some type casts }{}\\{}
 \tsholop{w2n} \;\tsunknown{win\_} = \tsvar{win} \Mwedge {}\\{}
 \tsholop{option\_map}\Mspii{\tsholop{ORD}}{\tsunknown{ws\_}} = \tsvar{ws} \Mwedge {}\\{}
 \tsholop{option\_map}\Mspii{\tsholop{w2n}}{\tsunknown{mss\_}} = \tsvar{mss}{}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ The segment is addressed to an $\tsaux{IP}$ address belonging to one of the interfaces of host
        $\tsvar{h}$ and is not addressed from or to a link-layer multicast or an IP-layer broadcast
        address }{}\\{}
 \tsvar{i}_{1} \;\in  \;\tsaux{local\_ips} \;\tsvar{h}.\tsvar{ifds} \Mwedge {}\\{}
 \neg{}(\tsaux{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{1}) \Mwedge {}\\{}
 \neg{}(\tsaux{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{2}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Find the socket $\tsvar{sock}$ that has the best match for the address quad in segment
        $\tsvar{seg}$, see \ltslink{tcpTsocketTbestTmatch}{$\tsaux{tcp\_socket\_best\_match}$}. Socket $\tsvar{sock}$ must have a form matching the patten $\tscon{Sock}$(\dots). }{}\\{}
 \tsaux{tcp\_socket\_best\_match} \;\tsvar{socks} (\tsvar{sid},\tsvar{sock}) \tsvar{seg} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis},[\,],*,[\,],*,\tscon{NO\_OOBDATA})) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ A BSD socket in the $\tscon{LISTEN}$ state may have its peer's $\tsaux{IP}$ address $\tsvar{is}_{2}$ and port
        $\tsvar{ps}_{2}$ set because $\tslib{listen}()$ can be called from any TCP state. On other architectures
        they are both constrained to $*$. }{}\\{}
 ((\tsvar{is}_{2} = * \Mwedge  \tsvar{ps}_{2} = *) \Mvee {}\\{}
 (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ If socket $\tsvar{sid}$ has a local $\tsaux{IP}$ address specified it should be the same as the
        destination $\tsaux{IP}$ address of the segment $\tsvar{seg}$, otherwise the $\tsvar{seg}$ is not
        addressed to this socket. If the socket does not have a local $\tsaux{IP}$ address the segment is
        acceptable because the socket is listening on all local $\tsaux{IP}$ addresses. The segment must
        not have been sent by socket $\tsvar{sock}$.  Note: a socket is permitted to connect to itself by
        a simultaneous open. This is handled by \ltslink{deliverTinTII}{$\tsrule{deliver\_in\_2}$} and not here. }{}\\{}
 (\Mcase  \;\tsvar{is}_{1} \;\Mof  \;\Msome  \;\tsunknown{i1'} \Mtotype  \tsunknown{i1'} = \tsvar{i}_{1} \Mdpipe  * \Mtotype  \Mtrue ) \Mwedge {}\\{}
 \neg{}(\tsvar{i}_{1} = \tsvar{i}_{2} \Mwedge  \tsvar{p}_{1} = \tsvar{p}_{2}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ If another socket in the $\tscon{TIME\_WAIT}$ state matches the address quad of the SYN segment
        then only proceed with the new incoming connection attempt if the sequence number of the
        segment $\tsvar{seq}$ is strictly greater than the next expected sequence number on the
        $\tscon{TIME\_WAIT}$ socket, $\tsfield{rcv\_nxt}$. This prevents old or duplicate SYN segments from previous
        incarnations of the connection from inadvertently creating new connections. }{}\\{}
 \neg{}(\exists  (\tsvar{sid}, \tsvar{sock}) \Mcons  \tsvar{socks}.{}\\{}
\quad \exists  \tsunknown{tcp\_sock}.{}\\{}
\quad \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{TIME\_WAIT} \Mwedge {}\\{}
\quad \tsvar{sock}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsvar{sock}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge  \tsvar{sock}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{sock}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2} \Mwedge {}\\{}
\quad \tsvar{seq} \leq  \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{rcv\_nxt} ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Otherwise, the $\tscon{TIME\_WAIT}$ sock is completely defunct because there is a new connection
        attempt from the same remote end-point. Close it completely. }{}\\{}
 \tsholcomm{ Note: this models the behaviour in RFC1122 Section 4.2.2.13 which states that a new $\tsvar{SYN}$
        with a sequence number larger than the maximum seen in the last incarnation may reopen the
        connection, \ie, reuse the socket for the new connection changing out of the $\tscon{TIME\_WAIT}$
        state. This is modelled by closing the existing $\tscon{TIME\_WAIT}$ socket and creating the new
        socket from scratch. }{}\\{}
 \tsvar{socks}' = \tsunknown{\$o\_f} (\lambda \tsvar{sock}.{}\\{}
\quad \Mif  \exists \tsunknown{tcp\_sock}. \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{TIME\_WAIT} \Mwedge {}\\{}
\quad\quad\quad \tsvar{sock}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsvar{sock}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge {}\\{}
\quad\quad\quad \tsvar{sock}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{sock}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2}{}\\{}
\quad \Mthen {}\\{}
\quad\quad\quad \tsaux{tcp\_close} \;\tsvar{h}.\tstype{arch} \;\tsvar{sock}{}\\{}
\quad \Melse {}\\{}
\quad\quad\quad \tsvar{sock}{}\\{}
 ) \tsvar{socks} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Accept the new connection attempt to the incomplete connection queue if the queue of
        completed (established) connections is not already full }{}\\{}
 \tsaux{accept\_incoming\_q0} \;\tsvar{lis} \;\Mtrue  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Possibly drop an arbitrary connection from the queue of incomplete connection
        attempts -- this covers the behaviour of FreeBSD when the oldest connection in the SYN bucket
        or in the whole SYN cache is dropped, depending upon which became full. }{}\\{}
 (\tsholop{choose} \;\tsunknown{drop} \Mcons  \tsaux{drop\_from\_q0} \;\tsvar{lis}.{}\\{}
\quad \Mif  \;\tsunknown{drop} \;\Mthen {}\\{}
\quad\quad \exists \tsvar{q0L} \;\tsvar{sid}'' \;\tsvar{q0R}.{}\\{}
\quad\quad\quad \tsvar{lis}.\tsvar{q}_{0} = \Mappend{\tsvar{q0L}}{(\tsvar{sid}'' \Mcons  \tsvar{q0R})} \Mwedge {}\\{}
\quad\quad\quad \tsvar{q}'_{0} = \Mappend{\tsvar{q0L}}{\tsvar{q0R}}{}\\{}
\quad \Melse {}\\{}
\quad\quad \tsvar{q}'_{0} = \tsvar{lis}.\tsvar{q}_{0}{}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Put the new incomplete connection on the (possibly pruned) incomplete connections queue. }{}\\{}
 \tsvar{lis}' = \tsvar{lis} \; \Mmagiclrec  \tsvar{q}_{0} \Mass  \tsvar{sid}' \Mcons  \tsvar{q}'_{0} \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Create a SYN,ACK segment in reply: }{}\\{}
 {}\\{}
 \tsholcomm{ The maximum segment size of the outgoing SYN,ACK reply segment must be in range,
        \ie, less than the maximum IP segment size minus the space consumed by IP and TCP
        headers. This is deliberately non-deterministic: an implementation would query the
        interface's MTU and subtract the header space required. }{}\\{}
 \tsvar{advmss} \;\in  \{ \tsvar{n} \mid  \tsvar{n} \geq  1 \Mwedge  \tsvar{n} \leq  (65535 - 40) \} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Be non-deterministic in deciding whether to transmit a maximum segment size option. A host
        either supports the maximum segment size option or not -- here the specfication permits
        either sending the option or not, but if the option is sent it must contain
        the advertised mss chosen previously by the host. This captures all acceptable
        behaviour. }{}\\{}
 \tsvar{advmss}' \;\in  \{*; \Msome  \;\tsvar{advmss}\} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ If a timestamp option was present in the received segment and a non-deterministic choice is
        made to do timestamping on this connection (\ie, the host supports timestamping), then
        timestamping is being used for this connection.  Otherwise, timestamping is not used because
        one or both hosts do not support it. A real host would either do timestamping or not
        depending on its configuration. Here all acceptable behaviour must be permitted. }{}\\{}
 \tsunknown{tf\_rcvd\_tstmp'} = \tsholop{IS\_SOME} \;\tsvar{ts} \Mwedge {}\\{}
 (\tsholop{choose} \;\tsunknown{want\_tstmp} \Mcons  \{\Mfalse ; \Mtrue \}.{}\\{}
\quad \tsunknown{tf\_doing\_tstmp'} = (\tsunknown{tf\_rcvd\_tstmp'} \Mwedge  \tsunknown{want\_tstmp}){}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Lookup the bandwidth delay product from the route metric cache and calculate the size of the
        receive and send buffers, the maximum segment size and the initial congestion window. }{}\\{}
 {}\\{}
 \tsunknown{bw\_delay\_product\_for\_rt} = * \Mwedge {}\\{}
 (\tsvar{rcvbufsize}',\tsvar{sndbufsize}',\tsunknown{t\_maxseg'},\tsunknown{snd\_cwnd'}) ={}\\{}
 \tsaux{calculate\_buf\_sizes} \;\tsvar{advmss} \;\tsvar{mss} \;\tsunknown{bw\_delay\_product\_for\_rt} (\tsaux{is\_localnet} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{2}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF})) (\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDBUF})) \tsunknown{tf\_doing\_tstmp'} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Store the new receive and send buffer sizes }{}\\{}
 \tsvar{sf}' = \tsvar{sf} \; \Mmagiclrec  \tsvar{n} \Mass  \tsaux{funupd\_list} \;\tsvar{sf}.\tsvar{n} [(\tscon{SO\_RCVBUF},\tsvar{rcvbufsize}'); (\tscon{SO\_SNDBUF},\tsvar{sndbufsize}')] \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Non-deterministically choose to do window scaling (\ie, choose whether this host supports
        window scaling or not). Do window scaling on the new connection if the received SYN segment
        contained a window scaling option and this host supports it. A real host would either be
        configured to do window scaling or not (provided it supported window scaling). Here all
        acceptable behaviour must be permitted. }{}\\{}
 \tsunknown{req\_ws} \;\in  \{\Mfalse ;\Mtrue \} \Mwedge {}\\{}
 \tsunknown{tf\_doing\_ws'} = (\tsunknown{req\_ws} \Mwedge  \tsholop{IS\_SOME} \;\tsvar{ws}) \Mwedge {}\\{}
 (\Mif  \;\tsunknown{tf\_doing\_ws'} \;\Mthen  \tsholcomm{ Doing window scaling }{}\\{}
\quad \tsholcomm{ Constrain the receive scale to be within the correct range and the send scale to be that
           received from the remote host }{}\\{}
\quad \tsunknown{rcv\_scale'} \;\in  \{ \tsvar{n} \mid  \tsvar{n} \geq  0 \Mwedge  \tsvar{n} \leq  \tsaux{TCP\_MAXWINSCALE} \} \Mwedge  \tsunknown{snd\_scale'} = \tsholop{option\_case}\Mspiii{0}{\MI }{\tsvar{ws}}{}\\{}
 \Melse {}\\{}
\quad \tsholcomm{ Otherwise, turn off scaling }{}\\{}
\quad \tsunknown{rcv\_scale'} = 0 \Mwedge  \tsunknown{snd\_scale'} = 0) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Constrain the receive window for the new connection -- this is advertised in the
        $\tsvar{SYN}$,$\tsvar{ACK}$ reply. No scaling is performed here as scaling is not applied to segments
        containing a valid $\tsvar{SYN}$ since the support for window scaling has not been fully
        negotitated yet! }{}\\{}
 {}\\{}
 \tsunknown{rcv\_window} \;\in  \{ \tsvar{n} \mid  \tsvar{n} \geq  0 \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{n} \leq  \tsaux{TCP\_MAXWIN}  \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{n} \leq  \tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) \} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Time the SYN,ACK reply segment. This is a new connection thus no previous timers can be
        running. }{}\\{}
 (\Mlet  \;\tsunknown{t\_rttseg'} = \Msome  (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}, \tsvar{cb}.\tsfield{snd\_nxt}  ) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Initial sequence number of $\tsvar{SYN}$,$\tsvar{ACK}$ reply segment is unconstrained. }{}\\{}
 \tsvar{iss} \;\in  \{ \tsvar{n} \mid  \Mtrue  \} \Mwedge {}\\{}
 \tsholcomm{ The $\tsvar{ack}$ value in the reply segment must acknowledge the remote host's initial $\tsvar{SYN}$. }{}\\{}
 \Mlet  \;\tsvar{ack}' = \tsvar{seq} + 1 \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Update the new connection's control block in light of above. }{}\\{}
 \tsvar{cb}' = \tsvar{cb} \; \Mmagiclrec {}\\{}
 {}\\{}
 \tsfield{tt\_keep}           \Mass  \Msome  (\Mtimed{()}{\tsaux{slow\_timer} \;\tsaux{TCPTV\_KEEP\_IDLE}});{}\\{}
 \tsfield{tt\_rexmt}          \Mass  \tsaux{start\_tt\_rexmt} \;\tsvar{h}.\tstype{arch} \;0 \;\Mfalse  \;\tsvar{cb}.\tsfield{t\_rttinf};{}\\{}
 \tsvar{iss}               \Mass  \tsvar{iss};{}\\{}
 \tsvar{irs}               \Mass  \tsvar{seq};{}\\{}
 \tsfield{rcv\_wnd}           \Mass  \tsunknown{rcv\_window};{}\\{}
 \tsfield{tf\_rxwin0sent}     \Mass  (\tsunknown{rcv\_window} = 0);{}\\{}
 \tsfield{rcv\_adv}           \Mass  \tsvar{ack}' + \tsunknown{rcv\_window};{}\\{}
 \tsfield{rcv\_nxt}           \Mass  \tsvar{ack}';{}\\{}
 \tsfield{snd\_una}           \Mass  \tsvar{iss};{}\\{}
 \tsfield{snd\_max}           \Mass  \tsvar{iss} + 1;   \tsholcomm{ $\tsvar{SYN}$ consumes one-byte of sequence space }{}\\{}
 \tsfield{snd\_nxt}           \Mass  \tsvar{iss} + 1;   \tsholcomm{ $\tsvar{SYN}$ consumes one-byte of sequence space }{}\\{}
 \tsfield{snd\_cwnd}          \Mass  \tsunknown{snd\_cwnd'};{}\\{}
 \tsfield{rcv\_up}            \Mass  \tsvar{seq} + 1;   \tsholcomm{ Pull along with left edge of unused window }{}\\{}
 \tsfield{t\_maxseg}          \Mass  \tsunknown{t\_maxseg'}; \tsholcomm{ The negotiated mss, with options removed }{}\\{}
 {\tsvar{t}}_{\tsvar{advmss}}          \Mass  \tsvar{advmss}';   \tsholcomm{ Remember the mss advertised (if any) by this socket in case the $\tsvar{SYN}$ segment is retransmitted }{}\\{}
 \tsfield{rcv\_scale}         \Mass  \tsunknown{rcv\_scale'};{}\\{}
 \tsfield{snd\_scale}         \Mass  \tsunknown{snd\_scale'};{}\\{}
 \tsfield{tf\_doing\_ws}       \Mass  \tsunknown{tf\_doing\_ws'};{}\\{}
 \tsfield{ts\_recent}         \Mass  \Mcase  \;\tsvar{ts} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad * \Mtotype  \tsvar{cb}.\tsfield{ts\_recent} \Mdpipe {}\\{}
\quad\quad\quad\quad\quad\quad \Msome  (\tsunknown{ts\_val},\tsunknown{ts\_ecr}) \Mtotype  \Mtimewindow{\tsunknown{ts\_val}}{\tsaux{kern\_timer} \;\tsaux{dtsinval}};{}\\{}
 \tsfield{last\_ack\_sent}     \Mass  \tsvar{ack}';{}\\{}
 \tsfield{t\_rttseg}          \Mass  \tsunknown{t\_rttseg'};{}\\{}
 \tsfield{tf\_req\_tstmp}      \Mass  \tsunknown{tf\_doing\_tstmp'};{}\\{}
 \tsfield{tf\_doing\_tstmp}    \Mass  \tsunknown{tf\_doing\_tstmp'}{}\\{}
 \Mmagicbolrrec ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Construct the SYN,ACK segment using the values stored in the updated control block for the
         new connection. See \ltslink{makeTsynTackTsegment}{$\tsaux{make\_syn\_ack\_segment}$}. }{}\\{}
 \tsholop{choose} \;\tsvar{seg}' \Mcons  \tsaux{make\_syn\_ack\_segment} \;\tsvar{cb}' (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}).{}\\{}
 {}\\{}
 \tsholcomm{ Add the SYN,ACK reply segment to the host's output queue, ignoring failure. Constrain the
         new connection's initial control block $\tsvar{cb}$ to have just the right values in case
         queueing of the segment fails (perhaps due to a routing failure) and some control block
         state has to be rolled back. See \ltslink{rollbackTtcpToutput}{$\tsaux{rollback\_tcp\_output}$} and \ltslink{enqueueTorTfail}{$\tsaux{enqueue\_or\_fail}$} for more detail. }{}\\{}
 \tsaux{enqueue\_or\_fail} \;\Mtrue  \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} [\tscon{TCP} \;\tsvar{seg}'] \tsvar{oq}{}\\{}
\quad (\tsvar{cb} \;{}\\{}
\quad\quad \Mmagiclrec  \tsfield{snd\_nxt} \Mass  \tsvar{iss}; \tsholcomm{ If queueing fails, need to retransmit the $\tsvar{SYN}$ }{}\\{}
 \tsfield{snd\_max} \Mass  \tsvar{iss}; \tsholcomm{ If queueing fails, need to retransmit the $\tsvar{SYN}$ }{}\\{}
 \tsfield{t\_maxseg} \Mass  \tsunknown{t\_maxseg'};{}\\{}
 \tsfield{last\_ack\_sent} \Mass  \tsaux{tcp\_seq\_foreign} \;0w;{}\\{}
 \tsfield{rcv\_adv} \Mass  \tsaux{tcp\_seq\_foreign} \;0w{}\\{}
 \Mmagicbolrrec ) \tsvar{cb}' (\tsvar{cb}'',\tsvar{oq}'){}\\{}
 {}\\{}
 }
{\rulesubsection{Model details}

    During TCP connection establishment, BSD uses syn-caches and syn-buckets to protect against some
    types of denial-of-service attack. These techniques delay the memory allocation for a socket's
    data structures until connection establishment is complete. They are not modelled directly in
    this specification, which instead favours the use of the full socket structure for clarity. The
    behaviour is observationally equivalent provided correct bounds are applied to the lengths of
    the incoming connection queues.

    When a socket completes connection establishment, \ie, enters the $\tscon{ESTABLISHED}$ state, BSD
    updates the socket's control block $\tsfield{t\_maxseg}$ field to the minimum of the maximum segment size
    it advertised in the emitted SYN,ACK segment and that received in the SYN segment from the
    remote end. This update is later than perhaps it need be. This model updates the $\tsfield{t\_maxseg}$ at
    the moment both the maximum segment values are known. As a consequence the initial maximum
    segment value advertised by the host must be stored just in case the SYN,ACK segment need be
    retransmitted.


\rulesubsection{Variations}
\par\begin{ltstabular}
FreeBSD
&
    On FreeBSD, the $\tslib{listen}()$ socket call can be called on a TCP socket in any state, thus it is
    possible for a listening TCP socket to have a peer address, \ie, $\tsvar{is}_{2}$ and $\tsvar{ps}_{2}$ pair,
    specified. This in turn affects the behaviour of connection establishment because an incoming
    $\tsvar{SYN}$ segment only matches this type of listening socket if its address quad matches the
    socket's entire address quad, heavily restricting the usefulness of such a socket.

    Such a restrictive peer address binding is permitted by the model for FreeBSD only.


\end{ltstabular}\par
\rrulepad }
}

\newcommand{\deliverTinTIb}{\rrulecc{deliverTinTIb}{deliver\_in\_1b}{tcp: network nonurgent}{\tsholcomm{ For a listening socket, receive and drop a bad
     datagram and either generate a RST segment or ignore it. Drop the incoming segment if the socket's
     queue of incomplete connections is full. }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq};{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}';{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}';{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm}' \Mmagicrrec }
{\tsholcomm{ \textbf{Summary}:
    A host $\tsvar{h}$ with listening socket $\tsvar{sock}$ referenced by index $\tsvar{sid}$ receives a segment
    $\tsvar{seg}$ addressed to socket $\tsvar{sock}$. The segment either contains an invalid combination of the
    $\tsvar{SYN}$ and $\tsvar{ACK}$ flags, is a forged segment trying to force the listening socket $\tsvar{sock}$ to
    connect to itself, or the new incomplete connection can not be added to the queue of incomplete
    connections because the completed connections queue is full.  The segment is dropped. If the
    segment had the $\tsvar{ACK}$ flag set and not $\tsvar{SYN}$, a RST segment is generated and added to the
    host's output queue $\tsvar{oq}$ for transmission.    }{}\\{}
 {}\\{}
 \tsholcomm{ Take TCP segment $\tsvar{seg}$ from the head of the host's input queue }{}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ The segment must be of an acceptable form }{}\\{}
 \tsholcomm{ Note: some segment fields are ignored during TCP connection establishment and as such may
        contain arbitrary values. These are equal to the identifiers postfixed with
        $\tsunknown{\_discard}$ below, which are otherwise unconstrained. }{}\\{}
 (\exists \tsunknown{seq\_discard} \;\tsunknown{ack\_discard} \;\tsunknown{URG\_discard} \;\tsunknown{PSH\_discard} \;\tsunknown{FIN\_discard}{}\\{}
 \tsunknown{win\_discard} \;\tsunknown{ws\_discard} \;\tsunknown{urp\_discard} \;\tsunknown{mss\_discard} \;\tsunknown{ts\_discard} \;\tsunknown{data\_discard}.{}\\{}
 \tsvar{seg} = \Mmagiclrec {}\\{}
 \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsunknown{seq\_discard}:\tsaux{tcp\_seq\_foreign});{}\\{}
 \tsvar{ack}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsunknown{ack\_discard}:\tsaux{tcp\_seq\_local});{}\\{}
 \tsvar{URG}  \Mass  \tsunknown{URG\_discard};{}\\{}
 \tsvar{ACK}  \Mass  \tsvar{ACK};         \tsholcomm{ might be set in a bad SYN segment }{}\\{}
 \tsvar{PSH}  \Mass  \tsunknown{PSH\_discard};{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;           \tsholcomm{ SYN segments never have $\tsvar{RST}$ set }{}\\{}
 \tsvar{SYN}  \Mass  \tsvar{SYN};         \tsholcomm{ might not be set in a bad segment to a listening socket }{}\\{}
 \tsvar{FIN}  \Mass  \tsunknown{FIN\_discard};{}\\{}
 \tsvar{win}  \Mass  \tsunknown{win\_discard};{}\\{}
 \tsvar{ws}   \Mass  \tsunknown{ws\_discard};{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_discard};{}\\{}
 \tsvar{mss}  \Mass  \tsunknown{mss\_discard};{}\\{}
 \tsvar{ts}   \Mass  \tsunknown{ts\_discard};{}\\{}
 \tsvar{data} \Mass  \tsunknown{data\_discard}{}\\{}
 \Mmagicbolrrec {}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Segment is addressed to an IP address belonging to one of the interfaces of host $\tsvar{h}$ and is
        not a link-layer multicast or IP-layer broadcast address }{}\\{}
 \tsvar{i}_{1} \;\in  \;\tsaux{local\_ips} \;\tsvar{h}.\tsvar{ifds} \Mwedge {}\\{}
 \neg{}(\tsaux{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{1}) \Mwedge   \tsholcomm{ very unlikely, since $\tsvar{i}_{1} \;\in  \;\tsaux{local\_ips} \;\tsvar{h}.\tsvar{ifds}$ }{}\\{}
 \neg{}(\tsaux{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{2}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Find the socket $\tsvar{sock}$ that has the best match for the address quad in segment
        $\tsvar{seg}$, see \ltslink{tcpTsocketTbestTmatch}{$\tsaux{tcp\_socket\_best\_match}$}. Socket $\tsvar{sock}$ must have a form matching the patten $\tscon{Sock}$(\dots). }{}\\{}
 \tsaux{tcp\_socket\_best\_match} (\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}) (\tsvar{sid},\tsvar{sock}) \tsvar{seg} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\Msome  \;\tsvar{lis},\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ If socket $\tsvar{sock}$ has a local IP address specified it should be the same as the destination
        IP address of segment $\tsvar{seg}$. }{}\\{}
 (\Mcase  \;\tsvar{is}_{1} \;\Mof  \;\Msome  \;\tsunknown{i1'} \Mtotype  \tsunknown{i1'} = \tsvar{i}_{1} \Mdpipe  * \Mtotype  \Mtrue ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ A BSD socket in the $\tscon{LISTEN}$ state may have its peer's IP address $\tsvar{is}_{2}$ and port $\tsvar{ps}_{2}$
       set because $\tslib{listen}()$ can be called from any TCP state. On other architectures they are
       both constrained to $*$. }{}\\{}
 ((\tsvar{is}_{2} = * \Mwedge  \tsvar{ps}_{2} = *) \Mvee {}\\{}
 (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Check that either:
        (a) the $\tsvar{SYN}$, $\tsvar{ACK}$ flag combination is bad, or
        (b) the socket is illegally connecting to itself  (Note: it is not possible to perform a
            self-connect once a socket is in the $\tscon{LISTEN}$ state by using the sockets interface
            alone -- it can only be achieved by a forged incoming segment. It is possible for a
            TCP socket to connect to itself but this is achieved through a sequence of socket calls
            that avoids entering the $\tscon{LISTEN}$ state), or
        (c) the new incomplete connection can not be added to the incomplete connections queue because
            the queue of complete connections is full. }{}\\{}
 (\tsvar{ACK} \Mvee {}\\{}
 (\neg{}\tsvar{SYN} \Mwedge  \neg{}\tsvar{ACK}) \Mvee {}\\{}
 (\tsvar{SYN} \Mwedge  \neg{}\tsvar{ACK} \Mwedge  \tsvar{i}_{1} = \tsvar{i}_{2} \Mwedge  \tsvar{p}_{1} = \tsvar{p}_{2}) \Mvee {}\\{}
 \tsaux{accept\_incoming\_q0} \;\tsvar{lis} \;\Mfalse {}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ If an ACK with no SYN has been received send a RST segment, else just silently drop
        everything else. See \ltslink{dropwithreset}{$\tsaux{dropwithreset}$}. }{}\\{}
 (\Mif  \neg{}\tsvar{SYN} \Mwedge  \tsvar{ACK} \;\Mthen {}\\{}
\quad \tsaux{dropwithreset} \;\tsvar{seg} \;\tsvar{h}.\tsvar{ifds} (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}) \tscon{BANDLIM\_RST\_OPENPORT} \;\tsvar{bndlm} \;\tsvar{bndlm}' \;\tsvar{outsegs}{}\\{}
 \Melse {}\\{}
\quad \tsvar{outsegs} = [\,] \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Add  the RST segment (if any) to the host's output queue, ignoring failure.
    See \ltslink{enqueueTandTignoreTfail}{$\tsaux{enqueue\_and\_ignore\_fail}$}. }{}\\{}
 \tsaux{enqueue\_and\_ignore\_fail} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{outsegs} \;\tsvar{oq} \;\tsvar{oq}'}
{\rrulepad }
}

\newcommand{\deliverTinTII}{\rrulecc{deliverTinTII}{deliver\_in\_2}{tcp: network nonurgent}{\tsholcomm{ Completion of active open (in $\tscon{SYN\_SENT}$ receive SYN,ACK and send ACK) or simultaneous open (in $\tscon{SYN\_SENT}$ receive SYN and send SYN,ACK) }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{cantsndmore},\tsvar{cantrcvmore},\tscon{TCP\_PROTO} \;\tsunknown{tcp\_sock}))] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf}',\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{cantsndmore},\tsvar{cantrcvmore}',{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st}',\tsvar{cb}'',*,[\,],*,\tsvar{rcvq}',\tsvar{rcvurp}',\tsvar{iobc}')))] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsunknown{tcp\_sock} = \tsaux{TCP\_Sock0}(\tscon{SYN\_SENT},\tsvar{cb},*,[\,],*,[\,],*,\tscon{NO\_OOBDATA}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Take TCP segment $\tsvar{seg}$ from the head of the host's input queue }{}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 {}\\{}
 (\exists \tsunknown{win\_} \;\tsunknown{ws\_} \;\tsunknown{urp\_} \;\tsunknown{mss\_} \;\tsunknown{PSH\_discard}.{}\\{}
 \tsvar{win} = \tsholop{w2n} \;\tsunknown{win\_} \Mwedge {}\\{}
 \tsvar{ws} = \tsholop{option\_map}\Mspii{\tsholop{ORD}}{\tsunknown{ws\_}} \Mwedge {}\\{}
 \tsvar{urp} = \tsholop{w2n} \;\tsunknown{urp\_} \Mwedge {}\\{}
 \tsvar{mss} = \tsholop{option\_map}\Mspii{\tsholop{w2n}}{\tsunknown{mss\_}} \Mwedge {}\\{}
 \tsvar{seg} = \Mmagiclrec {}\\{}
 \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{seq}:\tsaux{tcp\_seq\_foreign});{}\\{}
 \tsvar{ack}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{ack}:\tsaux{tcp\_seq\_local});{}\\{}
 \tsvar{URG}  \Mass  \tsvar{URG};{}\\{}
 \tsvar{ACK}  \Mass  \tsvar{ACK};{}\\{}
 \tsvar{PSH}  \Mass  \tsunknown{PSH\_discard};{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mtrue ;{}\\{}
 \tsvar{FIN}  \Mass  \tsvar{FIN};{}\\{}
 \tsvar{win}  \Mass  \tsunknown{win\_};{}\\{}
 \tsvar{ws}   \Mass  \tsunknown{ws\_};{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_};{}\\{}
 \tsvar{mss}  \Mass  \tsunknown{mss\_};{}\\{}
 \tsvar{ts}   \Mass  \tsvar{ts};{}\\{}
 \tsvar{data} \Mass  \tsvar{data}{}\\{}
 \Mmagicbolrrec ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Note that there does not exist a better socket match to which the segment should be sent,
     as the whole quad is matched exactly }{}\\{}
 {}\\{}
 \tsholcomm{ The ACK must be acceptable, else send RST. Typically (no data on active open), this is the same
                           as $\tsvar{ack} = \tsvar{iss} + 1$ }{}\\{}
 {}\\{}
 (\tsvar{ACK} \implies  (\tsvar{cb}.\tsvar{iss} < \tsvar{ack} \Mwedge  \tsvar{ack} \leq  \tsvar{cb}.\tsfield{snd\_max})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ resolve negotiated window scaling }{}\\{}
 (\Mcase  (\tsvar{cb}.\tsfield{request\_r\_scale}, \tsvar{ws}) \Mof {}\\{}
\quad\quad (\Msome  \;\tsunknown{rs}, \Msome  \;\tsunknown{ss}) \Mtotype  \tsunknown{rcv\_scale'} = \tsunknown{rs} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{snd\_scale'} = \tsunknown{ss} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{tf\_doing\_ws'} = \Mtrue  \Mdpipe {}\\{}
\quad\quad \tsunknown{\_15432}             \Mtotype  \tsunknown{rcv\_scale'} = 0 \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{snd\_scale'} = 0 \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{tf\_doing\_ws'} = \Mfalse ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ resolve negotiated timestamping }{}\\{}
 \tsunknown{tf\_rcvd\_tstmp'} = \tsholop{IS\_SOME} \;\tsvar{ts} \Mwedge {}\\{}
 \tsunknown{tf\_doing\_tstmp'} = (\tsunknown{tf\_rcvd\_tstmp'} \Mwedge  \tsvar{cb}.\tsfield{tf\_req\_tstmp}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Note that for test generation at present we clear the route metric cache so this will always be NONE.  BSD reads from the routing cache if there is an entry, otherwise passes NONE here. }{}\\{}
 \tsunknown{bw\_delay\_product\_for\_rt} = * \Mwedge {}\\{}
 {}\\{}
 \Mlet  \;\tsunknown{ourmss} = (\Mcase  \;\tsvar{cb}.\tsfield{t\_advmss} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad *   \Mtotype  \tsvar{cb}.\tsfield{t\_maxseg} \tsholcomm{ we did not advertise an MSS, so use the default value }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mdpipe  \Msome  \;\tsunknown{v} \Mtotype  \tsunknown{v}) \Min {}\\{}
 {}\\{}
 ((\tsvar{rcvbufsize}',\tsvar{sndbufsize}',\tsunknown{t\_maxseg''},\tsunknown{snd\_cwnd'}) ={}\\{}
\quad\quad \Mif  \;\tsvar{mss} \neq  * \Mvee  \neg{}\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad \tsaux{calculate\_buf\_sizes} \;\tsunknown{ourmss} \;\tsvar{mss} \;\tsunknown{bw\_delay\_product\_for\_rt}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsaux{is\_localnet} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{2}) (\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF})){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDBUF})) \tsunknown{tf\_doing\_tstmp'} \;\tsvar{h}.\tstype{arch}{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad \tsholcomm{ Note that since \wasverb{tcp\textunderscore{}mss()} is not called \wasverb{snd\textunderscore{}cwnd} remains at its initial (stupidly high) value. }{}\\{}
\quad\quad\quad (\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}),\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDBUF}),\tsvar{cb}.\tsfield{t\_maxseg},\tsvar{cb}.\tsfield{snd\_cwnd}){}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsvar{sf}' = \tsvar{sf} \; \Mmagiclrec  \tsvar{n} \Mass  \tsaux{funupd\_list} \;\tsvar{sf}.\tsvar{n} [(\tscon{SO\_RCVBUF},\tsvar{rcvbufsize}');{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad (\tscon{SO\_SNDBUF},\tsvar{sndbufsize}')] \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \tsunknown{rcv\_window} = \tsaux{calculate\_bsd\_rcv\_wnd} \;\tsvar{sf}' \;\tsunknown{tcp\_sock} \Mwedge {}\\{}
 {}\\{}
 \Mlet  (\tsunknown{t\_softerror'},\tsunknown{t\_rttseg'},\tsunknown{t\_rttinf'},\tsunknown{tt\_rexmt'}){}\\{}
\quad = (\Mif  \;\tsvar{ACK} \;\Mthen {}\\{}
\quad\quad\quad\quad \tsholcomm{ completion of active open.  Conditions originally
              copied verbatim from $\tsrule{deliver\_in\_3}$. }{}\\{}
 {}\\{}
\quad\quad\quad\quad \tsholcomm{ update RTT estimators from timestamp or roundtrip time }{}\\{}
\quad\quad\quad\quad \Mlet  \;\tsunknown{emission\_time} = \Mcase  \;\tsvar{ts} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  (\tsunknown{ts\_val},\tsunknown{ts\_ecr}) \Mtotype  \Msome  (\tsunknown{ts\_ecr} - 1){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mdpipe  * \Mtotype {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mcase  \;\tsvar{cb}.\tsfield{t\_rttseg} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  (\tsvar{ts}_{0},\tsvar{seq}_{0}) \Mtotype  \Mif  \;\tsvar{ack} > \tsvar{seq}_{0}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mthen  \;\Msome  \;\tsvar{ts}_{0}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;*{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mdpipe  *            \Mtotype  *) \Min {}\\{}
 {}\\{}
\quad\quad\quad\quad \tsholcomm{ clear soft error, cancel timer, and update estimators if we successfully timed a segment round-trip }{}\\{}
\quad\quad\quad\quad \Mlet  (\tsunknown{t\_softerror'},\tsunknown{t\_rttseg'},\tsunknown{t\_rttinf'}){}\\{}
\quad\quad\quad\quad\quad = \Mif  \;\tsholop{IS\_SOME} \;\tsunknown{emission\_time} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad (*,{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad *,{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{update\_rtt} (\tsaux{real\_of\_int} (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks} - \tsholop{THE} \;\tsunknown{emission\_time}) / \tsaux{HZ}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{t\_rttinf}){}\\{}
\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{cb}.\tsfield{t\_softerror},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{t\_rttseg},{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{t\_rttinf}) \Min {}\\{}
 {}\\{}
\quad\quad\quad\quad \tsholcomm{ mess with retransmit timer if appropriate }{}\\{}
\quad\quad\quad\quad \Mlet  \;\tsunknown{tt\_rexmt'} ={}\\{}
\quad\quad\quad\quad (\Mif  \;\tsvar{ack} = \tsvar{cb}.\tsfield{snd\_max} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ if acked everything, stop }{}\\{}
\quad\quad\quad\quad\quad\quad\quad *{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ $\tsunknown{needoutput} = 1$ -- see below }{}\\{}
\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsaux{mode\_of} \;\tsvar{cb}.\tsfield{tt\_rexmt} = \Msome  \;\tscon{RexmtSyn} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ if partial ack, restart from current backoff value,
                      which is always zero because of the above updates to
                      the RTT estimators and shift value.
                    }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{start\_tt\_rexmtsyn} \;\tsvar{h}.\tstype{arch} \;0 \;\Mtrue  \;\tsunknown{t\_rttinf'}{}\\{}
\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsaux{mode\_of} \;\tsvar{cb}.\tsfield{tt\_rexmt} \;\in  \{*; \Msome  \;\tscon{Rexmt}\} \Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ ditto }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{start\_tt\_rexmt} \;\tsvar{h}.\tstype{arch} \;0 \;\Mtrue  \;\tsunknown{t\_rttinf'}{}\\{}
\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{emission\_time} \neq  * \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mcase  \;\tsvar{cb}.\tsfield{tt\_rexmt} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ bizarre but true. \wasverb{tcp\textunderscore{}input.c:1766} says c.f.~Phil Karn's retransmit algorithm }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad * \Mtotype  *{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mdpipe  \Msome  (\Mtimed{(\tsunknown{mode},\tsunknown{shift})}{\tsunknown{d}}) \Mtotype  \Msome  (\Mtimed{(\tsunknown{mode},0)}{\tsunknown{d}}){}\\{}
\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ do nothing }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{tt\_rexmt}{}\\{}
\quad\quad\quad\quad ) \Min {}\\{}
\quad\quad\quad\quad (\tsunknown{t\_softerror'},{}\\{}
\quad\quad\quad\quad\quad \tsunknown{t\_rttseg'},{}\\{}
\quad\quad\quad\quad\quad \tsunknown{t\_rttinf'},{}\\{}
\quad\quad\quad\quad\quad \tsunknown{tt\_rexmt'}){}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad\quad \tsholcomm{ simultaneous open }{}\\{}
\quad\quad\quad\quad (\tsvar{cb}.\tsfield{t\_softerror},{}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{t\_rttseg},{}\\{}
\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{t\_rttinf},{}\\{}
\quad\quad\quad\quad\quad \tsaux{start\_tt\_rexmt} \;\tsvar{h}.\tstype{arch} \;0 \;\Mtrue  \;\tsvar{cb}.\tsfield{t\_rttinf})  \tsholcomm{ reset rexmt timer }{}\\{}
\quad\quad ) \Min {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ urgent pointer processing.  See $\tsrule{deliver\_in\_3}$ for discussion (these conditions are originally copied verbatim from there). }{}\\{}
 (\exists \tsvar{iobc} \;\tsvar{rcvurp}.{}\\{}
 \tsvar{iobc} = \tscon{NO\_OOBDATA} \Mwedge   \tsholcomm{ we know the initial state has no OOB data }{}\\{}
 \tsvar{rcvurp} = * \Mwedge  {}\\{}
 (\Mif  \;\tsvar{URG} \Mwedge {}\\{}
\quad\quad \tsvar{urp} > 0 \Mwedge {}\\{}
\quad\quad {}\\{}
\quad\quad \tsvar{urp} + 0  \leq  \tsaux{SB\_MAX}{}\\{}
 \Mthen {}\\{}
\quad\quad (\Mif  \;\tsvar{seq} + \tsvar{urp} > \tsvar{cb}.\tsfield{rcv\_up} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \tsunknown{rcv\_up'} = \tsvar{seq} + 1 + \tsvar{urp} \Mwedge  {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad\quad \tsvar{rcvurp}' = \Msome  (0  + \tsholop{Num} (\tsvar{seq} + \tsvar{urp} - \tsvar{cb}.\tsfield{rcv\_nxt})){}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsunknown{rcv\_up'} = \tsvar{cb}.\tsfield{rcv\_nxt} \Mwedge  \tsholcomm{ pull along with window }{}\\{}
\quad\quad\quad\quad\quad \tsvar{rcvurp}' = \tsvar{rcvurp}) \Mwedge {}\\{}
\quad\quad (\Mif  \;\tsvar{urp} \leq  \tsholop{LENGTH} \;\tsvar{data} \Mwedge  \tsvar{sf}.\tsvar{b}(\tscon{SO\_OOBINLINE}) = \Mfalse  \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \tsvar{iobc}' = \tscon{OOBDATA} (\tsunknown{EL} (\tsvar{urp} - 1) \tsvar{data}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsunknown{data\_deoobed} = \Mappend{(\tsaux{TAKE} (\tsvar{urp} - 1) \tsvar{data})}{(\tsaux{DROP} \;\tsvar{urp} \;\tsvar{data})}{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsvar{iobc}' = (\Mif  \;\tsvar{seq} + \tsvar{urp} > \tsvar{cb}.\tsfield{rcv\_up} \;\Mthen  \;\tscon{NO\_OOBDATA} \;\Melse  \;\tsvar{iobc}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsunknown{data\_deoobed} = \tsvar{data}){}\\{}
 \Melse {}\\{}
\quad\quad \tsunknown{rcv\_up'} = \tsvar{seq} + 1  \Mwedge {}\\{}
\quad\quad \tsvar{rcvurp}' = \tsvar{rcvurp} \Mwedge {}\\{}
\quad\quad \tsvar{iobc}' = \tsvar{iobc} \Mwedge {}\\{}
\quad\quad \tsunknown{data\_deoobed} = \tsvar{data}){}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ data processing is much simpler here than in $\tsrule{deliver\_in\_3}$ because we know
     we will only ever receive the one $\tsvar{SYN},\tsvar{ACK}$ datagram (duplicates will
     be rejected, and there's only one datagram and so cannot be
     reordered). }{}\\{}
 \tsvar{data}' = \tsaux{TAKE} \;\tsunknown{rcv\_window} \;\tsunknown{data\_deoobed} \Mwedge {}\\{}
 \tsvar{FIN}' = (\Mif  \;\tsvar{data}' = \tsunknown{data\_deoobed} \;\Mthen  \;\tsvar{FIN} \;\Melse  \;\Mfalse ) \Mwedge {}\\{}
 \tsvar{rcvq}' = \tsvar{data}' \Mwedge   \tsholcomm{ because $\tsvar{rcvq}$ is empty initially }{}\\{}
 \tsunknown{rcv\_nxt'} = \tsvar{seq} + 1  + \tsholop{LENGTH} \;\tsvar{data}' + (\Mif  \;\tsvar{FIN}' \;\Mthen  \;1 \;\Melse  \;0) \Mwedge {}\\{}
 \tsunknown{rcv\_wnd'} = \tsunknown{rcv\_window} - \tsholop{LENGTH} \;\tsvar{data}' \Mwedge  {}\\{}
 {}\\{}
 \tsvar{cb}' = \tsvar{cb} \; \Mmagiclrec {}\\{}
 \tsfield{tt\_rexmt}    \Mass  \tsunknown{tt\_rexmt'};{}\\{}
 \tsholcomm{ not persist, because we do not have any data to send }{}\\{}
 \tsfield{t\_idletime}  \Mass  \tsaux{stopwatch\_zero};  \tsholcomm{ just received a segment }{}\\{}
 \tsfield{tt\_keep}     \Mass  \Msome  (\Mtimed{()}{\tsaux{slow\_timer} \;\tsaux{TCPTV\_KEEP\_IDLE}});  {}\\{}
 \tsfield{tt\_conn\_est} \Mass  *;{}\\{}
 \tsfield{tt\_delack}   \Mass  *;{}\\{}
 {}\\{}
 \tsfield{snd\_una}     \;\Mupdby  \;\tsvar{ack} \;\tsholop{onlywhen} \;\tsvar{ACK};  \tsholcomm{ = cb.iss + 1, or +2 if full ack of SYN,FIN }{}\\{}
 \tsfield{snd\_nxt}     \;\Mupdby  \;\tsvar{ack} \;\tsholop{onlywhen} (\tsvar{ACK} \Mwedge  \tsvar{cantsndmore});  \tsholcomm{ prepare for possible outbound FIN }{}\\{}
 \tsfield{snd\_max}     \;\Mupdby  \;\tsvar{ack} \;\tsholop{onlywhen} (\tsvar{ACK} \Mwedge  \tsvar{cantsndmore} \Mwedge  \tsvar{ack} > \tsvar{cb}.\tsfield{snd\_max});{}\\{}
 \tsholcomm{ we doubt $\tsfield{snd\_max}$ can ever increase here, but put this in for safety }{}\\{}
 \tsfield{snd\_wl1}     \Mass  \Mif  \;\tsvar{ACK} \;\Mthen  \;\tsvar{seq} + 1 \;\Melse  \;\tsvar{seq};    \tsholcomm{ must update window. c.f.~TCPv2p951, TCPv2p981f, and \wasverb{tcp\textunderscore{}input.c:1824} }{}\\{}
 \tsfield{snd\_wl2}     \;\Mupdby  \;\tsvar{ack} \;\tsholop{onlywhen} \;\tsvar{ACK};{}\\{}
 \tsfield{snd\_wnd}     \Mass  \tsvar{win} ;{}\\{}
 {}\\{}
 \tsfield{snd\_cwnd}    \Mass  \Mif  \;\tsvar{ACK} \Mwedge  \tsvar{ack} > \tsvar{cb}.\tsvar{iss} + 1 \;\Mthen {}\\{}
\quad \tsholcomm{ BSD clamps \wasverb{snd\textunderscore{}cwnd} to the maximum window size (65535), but only if
                                  we received an ack for data other than the initial SYN. See \wasverb{tcp\textunderscore{}input.c::1791} }{}\\{}
\quad \tsholop{MIN} (\tsunknown{snd\_cwnd'}) (\tsaux{TCP\_MAXWIN} \ll  \tsunknown{snd\_scale'}){}\\{}
 \Melse {}\\{}
\quad \tsunknown{snd\_cwnd'};{}\\{}
 \tsfield{rcv\_scale}   \Mass  \tsunknown{rcv\_scale'};{}\\{}
 \tsfield{snd\_scale}   \Mass  \tsunknown{snd\_scale'};{}\\{}
 \tsfield{tf\_doing\_ws} \Mass  \tsunknown{tf\_doing\_ws'};{}\\{}
 \tsvar{irs}         \Mass  \tsvar{seq};{}\\{}
 \tsfield{rcv\_nxt}     \Mass  \tsunknown{rcv\_nxt'};{}\\{}
 \tsfield{rcv\_wnd}     \Mass  \tsunknown{rcv\_wnd'};{}\\{}
 \tsfield{tf\_rxwin0sent} \Mass  (\tsunknown{rcv\_wnd'} = 0);{}\\{}
 \tsfield{rcv\_adv}     \Mass  \tsunknown{rcv\_nxt'} + (\tsunknown{rcv\_wnd'} \gg  \tsunknown{rcv\_scale'}) \ll  \tsunknown{rcv\_scale'};{}\\{}
 \tsfield{rcv\_up}      \Mass  \tsunknown{rcv\_up'};{}\\{}
 \tsfield{t\_maxseg}    \Mass  \tsunknown{t\_maxseg''};{}\\{}
 \tsfield{ts\_recent}     \Mass  \Mcase  \;\tsvar{ts} \;\Mof {}\\{}
\quad \tsholcomm{ record irrespective of whether we negotiated to do this or not, like BSD }{}\\{}
\quad\quad\quad * \Mtotype  \tsvar{cb}.\tsfield{ts\_recent} \Mdpipe {}\\{}
\quad\quad\quad \Msome  (\tsunknown{ts\_val},\tsunknown{ts\_ecr}) \Mtotype  \Mtimewindow{\tsunknown{ts\_val}}{\tsaux{kern\_timer} \;\tsaux{dtsinval}};{}\\{}
\quad\quad\quad \tsholcomm{ timestamp will become invalid in 24 days }{}\\{}
 \tsfield{last\_ack\_sent} \Mass  \tsunknown{rcv\_nxt'};{}\\{}
 \tsfield{t\_softerror}   \Mass  \tsunknown{t\_softerror'};{}\\{}
 \tsfield{t\_rttseg}      \Mass  \tsunknown{t\_rttseg'};{}\\{}
 \tsfield{t\_rttinf}      \Mass  \tsunknown{t\_rttinf'};{}\\{}
 \tsfield{tf\_req\_tstmp}  \Mass  \tsunknown{tf\_doing\_tstmp'};  {}\\{}
 \tsfield{tf\_doing\_tstmp} \Mass  \tsunknown{tf\_doing\_tstmp'} {}\\{}
 \Mmagicbolrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ now generate $\tsvar{seg}'$, unless we're delaying the ACK }{}\\{}
 (\tsholop{choose} \;\tsvar{seg}' \Mcons  (\Mif  \;\tsvar{ACK} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ completion of active open }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{make\_ack\_segment} \;\tsvar{cb}' (\tsvar{cantsndmore} \Mwedge  \tsvar{ack} < \tsvar{cb}.\tsvar{iss} + 2) (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ simultaneous open }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad {}\\{}
 {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad {}\\{}
 {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mlet  \;\tsvar{cb}''' ={}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mif  ((\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge  \tsvar{cb}.\tsfield{tf\_req\_tstmp}) \Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}' \; \Mmagiclrec  \tsfield{tf\_req\_tstmp} \Mass  \Mtrue ;{}\\{}
 \tsfield{tf\_doing\_tstmp} \Mass  \Mtrue  \Mmagicrrec {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}') \Min {}\\{}
 {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{make\_ack\_segment} \;\tsvar{cb}''' \;\Mfalse  (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{make\_syn\_ack\_segment} \;\tsvar{cb}''' (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}))).{}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Add  the segment to the host's output queue.   See \ltslink{enqueueTorTfail}{$\tsaux{enqueue\_or\_fail}$}. }{}\\{}
 {}\\{}
 \tsaux{enqueue\_or\_fail} \;\Mtrue  \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} [\tscon{TCP} \;\tsvar{seg}'] \tsvar{oq}{}\\{}
\quad\quad\quad\quad (\tsvar{cb} \; \Mmagiclrec  \tsfield{t\_rttinf}      \Mass  \tsvar{cb}'.\tsfield{t\_rttinf};{}\\{}
 \tsfield{t\_maxseg}      \Mass  \tsunknown{t\_maxseg''};{}\\{}
 \tsfield{snd\_nxt}       \Mass  \tsvar{cb}.\tsfield{snd\_nxt};{}\\{}
 \tsfield{tt\_delack}     \Mass  \tsvar{cb}.\tsfield{tt\_delack};{}\\{}
 \tsfield{last\_ack\_sent} \Mass  \tsvar{cb}.\tsfield{last\_ack\_sent};{}\\{}
 \tsfield{rcv\_adv}       \Mass  \tsvar{cb}.\tsfield{rcv\_adv}{}\\{}
 \Mmagicbolrrec ) \tsvar{cb}' (\tsvar{cb}'',\tsvar{oq}'){}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Note that we change state even if enqueuing or routing returned an error,
            trusting to retransmit to solve our problem. }{}\\{}
 (\Mif  \;\tsvar{ACK} \;\Mthen {}\\{}
\quad\quad \tsholcomm{ completion of active open }{}\\{}
\quad\quad (\Mif  \neg{}\tsvar{FIN}' \;\Mthen {}\\{}
\quad\quad\quad\quad (\tsvar{cantrcvmore}' = \tsvar{cantrcvmore} \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{st}' ={}\\{}
\quad\quad\quad\quad\quad (\Mif  \;\tsvar{cantsndmore} = \Mfalse  \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tscon{ESTABLISHED}  {}\\{}
\quad\quad\quad\quad\quad\quad \Melse  \;\Mif  \;\tsvar{cb}.\tsfield{snd\_max} > \tsvar{cb}.\tsvar{iss} + 1 \Mwedge  \tsvar{ack} \geq  \tsvar{cb}.\tsfield{snd\_max} \;\Mthen  \tsholcomm{ our $\tsvar{FIN}$ is $\tsvar{ACK}$ed }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tscon{FIN\_WAIT\_2}{}\\{}
\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tscon{FIN\_WAIT\_1})) \tsholcomm{ we were trying to send a FIN from $\tscon{SYN\_SENT}$, so move straight
                                                  to $\tscon{FIN\_WAIT\_2}$. Definitely the case with BSD; should also be
                                                  true for other archs. }{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad (\tsvar{cantrcvmore}' = \Mtrue  \Mwedge {}\\{}
\quad\quad\quad\quad\quad \tsvar{st}' ={}\\{}
\quad\quad\quad\quad\quad\quad (\Mif  \;\tsvar{cantsndmore} = \Mfalse  \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tscon{CLOSE\_WAIT}{}\\{}
\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tscon{LAST\_ACK})))         \tsholcomm{ we were trying to send a FIN from $\tscon{SYN\_SENT}$ and also receive a
                                                  FIN, so we move straight into $\tscon{LAST\_ACK}$. }{}\\{}
 \Melse {}\\{}
\quad\quad \tsholcomm{ simultaneous open }{}\\{}
\quad\quad (\Mif  \neg{}\tsvar{FIN}' \;\Mthen {}\\{}
\quad\quad\quad\quad (\tsvar{st}' = \tscon{SYN\_RECEIVED} \Mwedge {}\\{}
\quad\quad\quad\quad \tsvar{cantrcvmore}' = \tsvar{cantrcvmore}){}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad (\tsvar{st}' = \tscon{CLOSE\_WAIT} \Mwedge   \tsholcomm{ yes, really! (in BSD) even though we've not yet had our initial SYN acknowledged! See \wasverb{tcp\textunderscore{}input.c:2065 +/-2000} }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad \tsvar{cantrcvmore}' = \Mtrue )){}\\{}
 )}
{\rrulepad }
}

\newcommand{\deliverTinTIIa}{\rrulecn{deliverTinTIIa}{deliver\_in\_2a}{tcp: network nonurgent}{\tsholcomm{ Receive bad or boring datagram and RST or ignore for $\tscon{SYN\_SENT}$ socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq};{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}';{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}';{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm}' \Mmagicrrec }
{\tsholcomm{
   \textbf{Summary:} For a $\tscon{SYN\_SENT}$ socket unacceptable acks get RSTed; boring but otherwise OK segments are ignored.   }{}\\{}
 {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{SYN\_SENT},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Take TCP segment $\tsvar{seg}$ from the head of the host's input queue }{}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 {}\\{}
 (\exists \tsunknown{seq\_discard} \;\tsunknown{URG\_discard} \;\tsunknown{PSH\_discard} \;\tsunknown{FIN\_discard}{}\\{}
\quad \tsunknown{win\_discard} \;\tsunknown{ws\_discard} \;\tsunknown{urp\_discard} \;\tsunknown{mss\_discard} \;\tsunknown{ts\_discard} \;\tsunknown{data\_discard}.{}\\{}
 \tsvar{seg} = \Mmagiclrec {}\\{}
 \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsunknown{seq\_discard}:\tsaux{tcp\_seq\_foreign});{}\\{}
 \tsvar{ack}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{ack}:\tsaux{tcp\_seq\_local});{}\\{}
 \tsvar{URG}  \Mass  \tsunknown{URG\_discard};{}\\{}
 \tsvar{ACK}  \Mass  \tsvar{ACK};{}\\{}
 \tsvar{PSH}  \Mass  \tsunknown{PSH\_discard};{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \tsvar{SYN};{}\\{}
 \tsvar{FIN}  \Mass  \tsunknown{FIN\_discard};{}\\{}
 \tsvar{win}  \Mass  \tsunknown{win\_discard};{}\\{}
 \tsvar{ws}   \Mass  \tsunknown{ws\_discard};{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_discard};{}\\{}
 \tsvar{mss}  \Mass  \tsunknown{mss\_discard};{}\\{}
 \tsvar{ts}   \Mass  \tsunknown{ts\_discard};{}\\{}
 \tsvar{data} \Mass  \tsunknown{data\_discard}{}\\{}
 \Mmagicbolrrec {}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Note that there does not exist a better socket match to which the segment should be sent, as the whole quad is matched exactly. }{}\\{}
 {}\\{}
 ((\tsvar{ACK} \Mwedge  \neg{}(\tsvar{cb}.\tsvar{iss} < \tsvar{ack} \Mwedge  \tsvar{ack} \leq  \tsvar{cb}.\tsfield{snd\_max})) \Mvee {}\\{}
 (\neg{}\tsvar{SYN} \Mwedge  (\neg{}\tsvar{ACK} \Mvee  (\tsvar{ACK} \Mwedge  \tsvar{cb}.\tsvar{iss} < \tsvar{ack} \Mwedge  \tsvar{ack} \leq  \tsvar{cb}.\tsfield{snd\_max})))) \Mwedge {}\\{}
 {}\\{}
 (\Mif  \;\tsvar{ACK} \Mwedge  \neg{}(\tsvar{cb}.\tsvar{iss} < \tsvar{ack} \Mwedge  \tsvar{ack} \leq  \tsvar{cb}.\tsfield{snd\_max}) \Mthen {}\\{}
\quad\quad \tsaux{dropwithreset} \;\tsvar{seg} \;\tsvar{h}.\tsvar{ifds} (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}) \tscon{BANDLIM\_UNLIMITED} \;\tsvar{bndlm} \;\tsvar{bndlm}' \;\tsvar{outsegs}{}\\{}
 \Melse  \;\Mif  \neg{}\tsvar{SYN} \Mwedge  (\neg{}\tsvar{ACK} \Mvee  (\tsvar{ACK} \Mwedge  \tsvar{cb}.\tsvar{iss} < \tsvar{ack} \Mwedge  \tsvar{ack} \leq  \tsvar{cb}.\tsfield{snd\_max})) \Mthen {}\\{}
\quad\quad \tsvar{outsegs} = [\,] \Mwedge  \tsvar{bndlm}' = \tsvar{bndlm}{}\\{}
 \Melse {}\\{}
\quad\quad \Mfalse ) \Mwedge {}\\{}
 \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsvar{sock} \;\Min {}\\{}
 \tsholcomm{ BSD \wasverb{rcv\textunderscore{}wnd} bug: the receive window updated code in \wasverb{tcp\textunderscore{}input} gets executed \emph{before} the segment is
       processed, so even for bad segments, it gets updated. }{}\\{}
 \Mlet  \;\tsunknown{rcv\_window} = \tsaux{calculate\_bsd\_rcv\_wnd} \;\tsvar{sf} \;\tsunknown{tcp\_sock} \;\Min {}\\{}
 \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec \tsvar{cb} \Mass  \tsunknown{tcp\_sock}.\tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsfield{rcv\_wnd} \Mass  \Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsunknown{rcv\_window} \;\Melse  \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{rcv\_wnd};{}\\{}
 \tsfield{rcv\_adv} \Mass  \Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{rcv\_nxt} + \tsunknown{rcv\_window}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{rcv\_adv};{}\\{}
 \tsfield{t\_idletime} \Mass  \tsaux{stopwatch\_zero}; {}\\{}
 \tsfield{tt\_keep} \Mass  \Msome  (\Mtimed{()}{\tsaux{slow\_timer} \;\tsaux{TCPTV\_KEEP\_IDLE}}) {}\\{}
 \Mmagicbolrrec  \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
 \tsaux{enqueue\_and\_ignore\_fail} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{outsegs} \;\tsvar{oq} \;\tsvar{oq}'}
{}
}

\newcommand{\deliverTinTIII}{\rrulecc{deliverTinTIII}{deliver\_in\_3}{tcp: network nonurgent}{\tsholcomm{ Receive data, FINs, and ACKs in a connected state }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid}, \tsvar{sock})];{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks}';{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm}' \Mmagicrrec }
{\tsvar{sid} \;\notin  (\Mfdom{\tsvar{socks}}) \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock})  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Assert that the socket meets some sanity properties. This is logically superfluous  but
        aids semi-automatic model checking. See \ltslink{saneTsocket}{$\tsaux{sane\_socket}$} for further details. }{}\\{}
 \tsaux{sane\_socket} \;\tsvar{sock} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Take TCP segment $\tsvar{seg}$ from the head of the host's input queue }{}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ The segment must be of an acceptable form }{}\\{}
 \tsholcomm{ Note: some segment fields (namely TCP options $\tsvar{ws}$ and $\tsvar{mss}$), are only used during
        connection establishment and any values assigned to them in segments during a connection are
        simply ignored. They are equal to the identifiers $\tsunknown{ws\_discard}$ and
        $\tsunknown{mss\_discard}$ respectively, which are otherwise unconstrained. }{}\\{}
 (\exists \tsunknown{win\_} \;\tsunknown{urp\_} \;\tsunknown{ws\_discard} \;\tsunknown{mss\_discard}.{}\\{}
 \tsvar{seg} = \Mmagiclrec {}\\{}
 \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{seq}:\tsaux{tcp\_seq\_foreign});{}\\{}
 \tsvar{ack}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{ack}:\tsaux{tcp\_seq\_local});{}\\{}
 \tsvar{URG}  \Mass  \tsvar{URG};  \tsholcomm{ Urgent/OOB data is processed by this rule }{}\\{}
 \tsvar{ACK}  \Mass  \tsvar{ACK};  \tsholcomm{ Acknowledgements are processed }{}\\{}
 \tsvar{PSH}  \Mass  \tsvar{PSH};  \tsholcomm{ Push flag maybe set on an incoming data segment }{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;    \tsholcomm{ $\tsvar{RST}$ segments are not handled by this rule }{}\\{}
 \tsvar{SYN}  \Mass  \tsvar{SYN};  \tsholcomm{ $\tsvar{SYN}$ flag set may be set in the final segment of a simultaneous open }{}\\{}
 \tsvar{FIN}  \Mass  \tsvar{FIN};  \tsholcomm{ Processing of FIN flag handled }{}\\{}
 \tsvar{win}  \Mass  \tsunknown{win\_};{}\\{}
 \tsvar{ws}   \Mass  \tsunknown{ws\_discard};{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_};{}\\{}
 \tsvar{mss}  \Mass  \tsunknown{mss\_discard};{}\\{}
 \tsvar{ts}   \Mass  \tsvar{ts};{}\\{}
 \tsvar{data} \Mass  \tsvar{data}  \tsholcomm{ Segment may have data }{}\\{}
 \Mmagicbolrrec  \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Equality of some type casts, and application of the socket's send window scaling to the
          received window advertisment }{}\\{}
 \tsvar{win} = \tsholop{w2n} \;\tsunknown{win\_} \ll  \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_scale} \Mwedge {}\\{}
 \tsvar{urp} = \tsholop{w2n} \;\tsunknown{urp\_}{}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ The socket is fully connected so its complete address quad must match the address
        quad of the segment $\tsvar{seg}$. By definition, $\tsvar{sock}$ is the socket with the best address
        match thus the auxiliary function $\tsaux{tcp\_socket\_best\_match}$ is not required here. }{}\\{}
 \tsvar{sock}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsvar{sock}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge {}\\{}
 \tsvar{sock}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{sock}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ The socket must be in a connected state, or is in the $\tscon{SYN\_RECEIVED}$ state and
        $\tsvar{seg}$ is the final segment completing a passive or simultaneous open. }{}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \;\notin  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT}\} \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{SYN\_RECEIVED};\tscon{ESTABLISHED};\tscon{CLOSE\_WAIT};\tscon{FIN\_WAIT\_1};\tscon{FIN\_WAIT\_2};{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tscon{CLOSING};\tscon{LAST\_ACK};\tscon{TIME\_WAIT}\} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ For a socket in the $\tscon{SYN\_RECEIVED}$ state check that the ACK is valid (the acknowledge
        value $\tsvar{ack}$ is not outside the range of sequence numbers that have been transmitted to the
        remote socket) and that the segment is not a LAND DoS attack (the segment's sequence number
        is not smaller than the remote socket's (the receiver from this socket's perspective)
        initial sequence number) }  {}\\{}
 \neg{}(\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge {}\\{}
 ((\tsvar{ACK} \Mwedge  (\tsvar{ack} \leq  \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_una} \Mvee  \tsvar{ack} > \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_max})) \Mvee {}\\{}
\quad \tsvar{seq} < \tsunknown{tcp\_sock}.\tsvar{cb}.\tsvar{irs})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ If socket $\tsvar{sock}$ has previously emitted a $\tsvar{FIN}$ segment check that a thread is still
        associated with the socket, i.e.~check that the socket still has a valid file identifier
        $\tstype{fid} \neq  *$. If not, and the segment contains new data, the segment should not be
        processed by this rule as there is no thread to read the data from the socket after
        processing.  Query: how does this $\tsvar{st}$ condition relate to $\tsunknown{wesentafin}$ below? }{}\\{}
 \neg{}(\tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{FIN\_WAIT\_1}; \tscon{CLOSING}; \tscon{LAST\_ACK}; \tscon{FIN\_WAIT\_2}; \tscon{TIME\_WAIT}\} \Mwedge {}\\{}
 \tsvar{sock}.\tstype{fid} = * \Mwedge   {}\\{}
 \tsvar{seq} + \tsholop{LENGTH} \;\tsvar{data} > \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{rcv\_nxt}) \Mwedge   {}\\{}
 {}\\{}
 \tsholcomm{ A $\tsvar{SYN}$ should be received only in the $\tscon{SYN\_RECEIVED}$ state. }{}\\{}
 (\tsvar{SYN} \implies  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Socket $\tsvar{sock}$ has previously sent a $\tsvar{FIN}$ segment iff $\tsfield{snd\_max}$ is strictly greater
        than the sequence number of the byte after the last byte in the send queue $\tsvar{sndq}$. }{}\\{}
 \Mlet  \;\tsunknown{wesentafin} = \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_max} > \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_una} + \tsholop{LENGTH} \;\tsunknown{tcp\_sock}.\tsvar{sndq} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ If the socket $\tsvar{sock}$ has previously sent a $\tsvar{FIN}$ segment it has been acknowledged by
        segment $\tsvar{seg}$ if the segment has the $\tsvar{ACK}$ flag set and an acknowledgment number $\tsvar{ack}
\geq  \tsvar{cb}.\tsfield{snd\_max}$. }{}\\{}
 \Mlet  \;\tsunknown{ourfinisacked} = (\tsunknown{wesentafin} \Mwedge  \tsvar{ACK} \Mwedge  \tsvar{ack} \geq  \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_max}) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Process the segment and return an updated socket state }{}\\{}
 \tsholcomm{ The segment processing is performed by the four relations below, \ie, $\tsaux{di3\_topstuff}$,
        $\tsaux{di3\_ackstuff}$, $\tsaux{di3\_datastuff}$ and $\tsaux{di3\_ststuff}$. Each of these relates a socket and
        bandwidth limiter state before the segment is processed to a tuple containing an updated
        socket, new bandwidth limiter state, a list of zero or more segments to output and a
        continue flag. The aim is to model the progression of the segment through
        \wasverb{tcp\textunderscore{}input()}. When the continue flag is $\Mtrue $ segment processing should
        continue. The infix function $\tsaux{andThen}$ applies the function on its left hand side and only
        continues with the function on its right hand side if the left hand function's continue flag
        is $\Mtrue $. For a further explanation of this relational monad behaviour see \ltslink{auxTrelmonad}{$\tsunknown{aux\_relmonad}$}. }{}\\{}
 \Mlet  \;\tsunknown{topstuff} ={}\\{}
\quad \tsholcomm{ Initial processing of the segment: PAWS (protection against wrap sequence numbers);
            ensure segment is not entirely off the right hand edge of the window; timer updates,
            etc.\ For further information see \ltslink{diIIITtopstuff}{$\tsaux{di3\_topstuff}$}.}{}\\{}
\quad \tsaux{di3\_topstuff} \;\tsvar{seg} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}){}\\{}
 \Mand  \;\tsunknown{ackstuff} ={}\\{}
\quad \tsholcomm{ Process the segment's acknowledgement number and do congestion control. See \ltslink{diIIITackstuff}{$\tsaux{di3\_ackstuff}$}.}{}\\{}
\quad \tsaux{di3\_ackstuff} \;\tsunknown{tcp\_sock} \;\tsvar{seg} \;\tsunknown{ourfinisacked} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}){}\\{}
 \Mand  \;\tsunknown{datastuff} \;\tsunknown{theststuff} ={}\\{}
\quad \tsholcomm{ Extract and reassemble data (including urgent data). See \ltslink{diIIITdatastuff}{$\tsaux{di3\_datastuff}$}. }{}\\{}
\quad \tsaux{di3\_datastuff} \;\tsunknown{theststuff} \;\tsunknown{tcp\_sock} \;\tsvar{seg} \;\tsunknown{ourfinisacked} \;\tsvar{h}.\tstype{arch}{}\\{}
 \Mand  \;\tsunknown{ststuff} \;\tsunknown{FIN\_reass} ={}\\{}
\quad \tsholcomm{ Possibly change the socket's state (especially on receipt of a valid $\tsvar{FIN}$). See
            \ltslink{diIIITststuff}{$\tsaux{di3\_ststuff}$}. }{}\\{}
\quad \tsaux{di3\_ststuff} \;\tsunknown{FIN\_reass} \;\tsunknown{ourfinisacked} \;\tsvar{ack}{}\\{}
 \Min {}\\{}
 (\tsunknown{topstuff}      \;\tsaux{andThen}{}\\{}
\quad \tsunknown{ackstuff}      \;\tsaux{andThen}{}\\{}
\quad \tsunknown{datastuff} \;\tsunknown{ststuff}){}\\{}
 (\tsvar{sock},\tsvar{bndlm}) \tsholcomm{ state before }{}\\{}
 ((\tsvar{sock}',\tsvar{bndlm}',\tsvar{outsegs}),\tsvar{continue}') \Mwedge  \tsholcomm{ state after }{}\\{}
 {}\\{}
 \tsvar{sock}'.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ If socket $\tsvar{sock}$ was initially in the $\tscon{SYN\_RECEIVED}$ state and after processing $\tsvar{seg}$
        is in the $\tscon{ESTABLISHED}$ state (or if the segment contained a $\tsvar{FIN}$ and the socket is in one of the
        $\tscon{FIN\_WAIT\_1}$, $\tscon{FIN\_WAIT\_2}$ or $\tscon{CLOSE\_WAIT}$ states), the socket is probably on some
        other socket's incomplete connections queue and $\tsvar{seg}$ is the final segment in a passive
        open. If it is on some other socket's incomplete connections queue the other socket is
        updated to move the newly connected socket's reference from the incomplete to the complete
        connections queue (unless the complete connection queue is full, in which case the new
        connection is dropped and all references to it are removed).  If not, $\tsvar{seg}$ is the final
        segment in a simultaneous open in which case no other sockets are updated.  The auxiliary
        function \ltslink{diIIITsocksTupdate}{$\tsaux{di3\_socks\_update}$} does all the hard work, updating the relevant
        sockets in the finite map $\tsvar{socks}$ to yield $\tsvar{socks}'$. }{}\\{}
 (\Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge {}\\{}
\quad \tsunknown{tcp\_sock'}.\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}; \tscon{CLOSE\_WAIT}\} \Mthen {}\\{}
\quad\quad \tsaux{di3\_socks\_update} \;\tsvar{sid} (\tsvar{socks} \oplus  (\tsvar{sid},\tsvar{sock}')) \tsvar{socks}'{}\\{}
 \Melse {}\\{}
\quad \tsholcomm{ If the socket was not initially in the $\tscon{SYN\_RECEIVED}$ state, \ie $\tsvar{seg}$ was processed
            by an already connected socket, ensure the updated socket is in the final finite
            maps of sockets. }{}\\{}
\quad \tsvar{socks}' = \tsvar{socks} \oplus  (\tsvar{sid},\tsvar{sock}')) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Queue any segments for output on the host's output queue. In the common case there are no
        segments to be output as output is handled by $\tsrule{deliver\_out\_1}$ etc. The exception is
        that $\tsaux{di3\_ackstuff}$ (and its auxiliaries) require an immediate $\tsvar{ACK}$ segment to be
        emitted under certain congestion control conditions. See \ltslink{diIIITackstuff}{$\tsaux{di3\_ackstuff}$} and \ltslink{diIIITnewackstuff}{$\tsaux{di3\_newackstuff}$} for further details. }{}\\{}
 \tsaux{enqueue\_oq\_list\_qinfo}(\tsvar{oq},\tsvar{outsegs},\tsvar{oq}')}
{\rrulepad }
}

\newcommand{\defndiIIITtopstuff}{\ddefnc{diIIITtopstuff}{\iA{di3\_topstuff}}{\subddefnA[{ $\tsrule{deliver\_in\_3}$ initial checks }]{di3\_topstuff}{\tsaux{di3\_topstuff} \;\tsunknown{seg} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsvar{ticks} ={}\\{}
 \tsholcomm{ monadic state accessor: $\tsvar{sock}$ is the socket processing the segment, as determined by $\tsrule{deliver\_in\_3}$ }{}\\{}
 (\tsaux{get\_sock} \lambda  \tsvar{sock}.{}\\{}
 \tsholcomm{ Pull out the TCP protocol and control blocks }{}\\{}
 \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsvar{sock} \;\Min {}\\{}
 \Mlet  \;\tsvar{cb} = \tsunknown{tcp\_sock}.\tsvar{cb} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ If the segment has the $\tsvar{SYN}$ flag set, increment the sequence number so that it is the
        sequence number of the first byte of data in the segment }{}\\{}
 \Mlet  \;\tsvar{seq} = \tsunknown{tcp\_seq\_flip\_sense} \;\tsunknown{seg}.\tsvar{seq} + (\Mif  \;\tsunknown{seg}.\tsvar{SYN} \;\Mthen  \;1 \;\Melse  \;0) \Min {}\\{}
 \tsholcomm{ The sequence number of the byte logically after the last byte of data in the segment }{}\\{}
 \Mlet  \;\tsunknown{rseq} = \tsvar{seq} + \tsholop{LENGTH} \;\tsunknown{seg}.\tsvar{data} \;\Min {}\\{}
 \Mlet  \;\tsvar{ts} = \tsunknown{seg}.\tsvar{ts} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ PAWS (Protection Against Wrapped Sequence numbers) check: If the segment contains a
        timestamp value that is strictly less than $\tsfield{ts\_recent}$ then the segment is invalid and
        the PAWS check fails. The value $\tsfield{ts\_recent}$ is the timestamp value of the most recent
        of the previous segments that was successfully processed, \ie, the last segment that
        $\tsrule{deliver\_in\_3}$ processed without dropping. }{}\\{}
 \Mlet  \;\tsunknown{paws\_failed} ={}\\{}
 (\exists \tsunknown{ts\_val} \;\tsunknown{ts\_ecr} \;\tsfield{ts\_recent}.{}\\{}
\quad \tsvar{ts} = \Msome  (\tsunknown{ts\_val},\tsunknown{ts\_ecr}) \Mwedge    \tsholcomm{ segment's timestamp field is a pair }{}\\{}
\quad \tsaux{timewindow\_val\_of} \;\tsvar{cb}.\tsfield{ts\_recent} = \Msome  \;\tsfield{ts\_recent} \Mwedge  \tsholcomm{ most recent timestamp recorded }{}\\{}
\quad \tsunknown{ts\_val} < \tsfield{ts\_recent}) \Min  \tsholcomm{ check the segment's timestamp is not old }{}\\{}
 {}\\{}
 \tsholcomm{ If the segment lies entirely off the right-hand edge of $\tsvar{sock}$'s receive window then it
        should be dropped, provided it is not a window probe. }{}\\{}
 \Mlet  \;\tsunknown{segment\_off\_right\_hand\_edge} ={}\\{}
 (\Mlet  \;\tsunknown{rcv\_wnd'} = \tsaux{calculate\_bsd\_rcv\_wnd} \;\tsvar{sock}.\tsvar{sf} \;\tsunknown{tcp\_sock} \;\Min     \tsholcomm{ size of receive window }{}\\{}
\quad (\tsvar{seq} \geq  \tsvar{cb}.\tsfield{rcv\_nxt} + \tsunknown{rcv\_wnd'}) \Mwedge   \tsholcomm{ segment starts on or after the right hand edge }{}\\{}
\quad (\tsunknown{rseq} > \tsvar{cb}.\tsfield{rcv\_nxt} + \tsunknown{rcv\_wnd'}) \Mwedge   \tsholcomm{ segment ends after the right hand edge }{}\\{}
\quad (\tsunknown{rcv\_wnd'} \neq  0)) \Min   \tsholcomm{ The segment is not a window probe, \ie, $\tsunknown{rcv\_wnd'}$ is not
        zero }{}\\{}
 {}\\{}
 \tsholcomm{ Drop the segment being processed if either the PAWS check or the "off right hand edge
        of window" checks fail }{}\\{}
 \Mlet  \;\tsunknown{drop\_it} = (\tsunknown{paws\_failed} \Mvee  \tsunknown{segment\_off\_right\_hand\_edge}) \Min {}\\{}
 {}\\{}
 \tsholcomm{ The value $\tsfield{ts\_recent}$ will be updated to hold the value of the segment's timestamp
        field if the segment is not dropped. Timestamps are invalidated after 24 days -
        this is ensured by the attached kernel timer $\tsaux{kern\_timer} \;\tsaux{dtsinval}$. }{}\\{}
 \Mlet  \;\tsunknown{ts\_recent'} = \Mtimewindow{\tsholop{FST} (\tsholop{THE} \;\tsvar{ts})}{ \tsaux{kern\_timer} \;\tsaux{dtsinval}} \Min {}\\{}
 {}\\{}
 \tsholcomm{ Reset the socket's idle timer and keepalive timer to start counting from zero as
        activity is taking place on the socket: a segment is being processed. If the
        $\tscon{FIN\_WAIT\_2}$ timer is enabled this may be reset upon processing this segment. See
        \ltslink{updateTidle}{$\tsaux{update\_idle}$} for further details }{}\\{}
 \Mlet  (\tsunknown{t\_idletime'},\tsunknown{tt\_keep'},\tsunknown{tt\_fin\_wait\_2'}) = \tsaux{update\_idle} \;\tsunknown{tcp\_sock} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Using the monadic state accessor \ltslink{modifyTcb}{$\tsaux{modify\_cb}$}, update the socket's control
        block with the new timer values and the most recent timestamp seen.

        The $\tsfield{ts\_recent}$ field is only updated if the segment currently being processed is not
        scheduled to be dropped,  has a timestamp value set and  is from a segment whose
        first byte of data has sequence number less than or equal to the last acknowledgement
        number sent in a segment to the remote end. The last condition (when coupled with the
        PAWS check above) ensures that $\tsfield{ts\_recent}$ only increases monotonically and as is only
        updated by either a duplicate segment with a newer timestamp, or the next in-order
        segment expected by the receiving socket with a newer timestamp. It would be incorrect
        to record the newer timestamps of out-of-order segments because they would fail the PAWS
        check and get dropped

        Note: if a reasonably continuous stream of segments is being received with increasing
        timestamp values and few data segments are sent in return such that acknowledgments are
        delayed, \ie, every other segment is acknowledged), then only the timestamp from every other
        segment is recorded by these conditions. This is still sufficient to protect against
        wrapped sequence numbers. }{}\\{}
 \tsaux{modify\_cb} (\lambda \tsvar{cb}'.\tsvar{cb}' \; \Mmagiclrec  \tsfield{tt\_keep} \Mass  \tsunknown{tt\_keep'};{}\\{}
 \tsfield{tt\_fin\_wait\_2} \Mass  \tsunknown{tt\_fin\_wait\_2'};{}\\{}
 \tsfield{t\_idletime} \Mass  \tsunknown{t\_idletime'};{}\\{}
 \tsfield{ts\_recent} \;\Mupdby  \;\tsunknown{ts\_recent'} \;\tsholop{onlywhen}{}\\{}
 (\neg{}\tsunknown{drop\_it} \Mwedge  \tsholop{IS\_SOME} \;\tsvar{ts} \Mwedge  \tsvar{seq} \leq  \tsvar{cb}.\tsfield{last\_ack\_sent}){}\\{}
 \Mmagicbolrrec ) \tsaux{andThen}{}\\{}
 {}\\{}
 \Mif  \;\tsunknown{drop\_it} \;\Mthen {}\\{}
 \tsholcomm{ Decided to drop the segment. \ltslink{mliftTdropafterackTorTfail}{$\tsaux{mlift\_dropafterack\_or\_fail}$} may decide to $\tsvar{RST}$ the
          connection depending upon the socket state. If so, the $\tsvar{RST}$ segment is retained on
          the monadic output segment list returned to $\tsrule{deliver\_in\_3}$ for queueing. }{}\\{}
 \tsaux{mlift\_dropafterack\_or\_fail} \;\tsunknown{seg} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsvar{ticks} \;\tsaux{andThen}{}\\{}
 \tsholcomm{ After dropping, stop processing the segment. No need to waste time processing the
          segment any further }{}\\{}
 \tsaux{stop}{}\\{}
 \Melse {}\\{}
 \tsholcomm{ Otherwise the segment is valid so allow processsing to continue. }{}\\{}
 \tsaux{cont}{}\\{}
 )}
}
{\rrulepad }
}

\newcommand{\defndiIIITnewackstuff}{\ddefnc{diIIITnewackstuff}{\iA{di3\_newackstuff}}{\subddefnA[{ $\tsrule{deliver\_in\_3}$ new ack processing, used in $\tsaux{di3\_ackstuff}$  }]{di3\_newackstuff}{\tsaux{di3\_newackstuff} \;\tsunknown{tcp\_sock\_0} \;\tsunknown{seg} \;\tsunknown{ourfinisacked} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsvar{ticks} ={}\\{}
 \tsholcomm{ Pull some fields out of the segment }{}\\{}
 \Mlet  \;\tsvar{ack}  = \tsunknown{tcp\_seq\_flip\_sense} \;\tsunknown{seg}.\tsvar{ack} \;\Min {}\\{}
 \Mlet  \;\tsvar{ts}   = \tsunknown{seg}.\tsvar{ts} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Get the socket's control block using the monadic state accessor $\tsaux{get\_cb}$. }{}\\{}
 (\tsaux{get\_cb} \lambda  \tsvar{cb}'.{}\\{}
 {}\\{}
 (\Mif  \neg{}\tsaux{TCP\_DO\_NEWRENO} \Mvee  \tsvar{cb}'.\tsfield{t\_dupacks} < 3 \;\Mthen {}\\{}
\quad\quad \tsholcomm{ If not doing NewReno-style Fast Retransmit or there have been fewer than 3 duplicate
             $\tsunknown{ACKS}$ then clear the duplicate $\tsvar{ACK}$ counter. If there were more than 3
             duplicate $\tsunknown{ACKS}$ previously then the congestion window was inflated as per RFC2581
             so retract it to $\tsfield{snd\_ssthresh}$ }{}\\{}
\quad\quad \tsaux{modify\_cb} (\lambda \tsvar{cb}'.\tsvar{cb}' \; \Mmagiclrec  \tsfield{t\_dupacks} \Mass  0;{}\\{}
 \tsfield{snd\_cwnd} \;\Mupdby  (\tsholop{MIN} \;\tsvar{cb}'.\tsfield{snd\_cwnd} \;\tsvar{cb}'.\tsfield{snd\_ssthresh})  \tsholcomm{ retract the window safely }{}\\{}
\quad\quad \tsholop{onlywhen} (\tsvar{cb}'.\tsfield{t\_dupacks} \geq  3) \Mmagicrrec ){}\\{}
 {}\\{}
\quad \Melse  \;\Mif  \;\tsaux{TCP\_DO\_NEWRENO} \Mwedge  \tsvar{cb}'.\tsfield{t\_dupacks} \geq  3 \Mwedge  \tsvar{ack} < \tsvar{cb}'.\tsfield{snd\_recover} \;\Mthen {}\\{}
\quad\quad \tsholcomm{ The host supports NewReno-style Fast Recovery, the socket has received at least three
             duplicate $\tsvar{ACK}$s previously and the new $\tsvar{ACK}$ does not complete the recovery
             process, \ie, there are further losses or network delays. The new $\tsvar{ACK}$ is a partial
             $\tsvar{ACK}$ per RFC2582. Perform a retransmit of the next unacknowledged segment and
             deflate the congestion window as per the RFC. }{}\\{}
\quad\quad \tsaux{modify\_cb} (\lambda \tsvar{cb}'.\tsvar{cb}' \; \Mmagiclrec {}\\{}
 \tsholcomm{ Clear the retransmit timer and round-trip time
                                           measurement timer. These will be started by
                                           $\tsaux{tcp\_output\_really}$ when the retransmit is
                                           actioned. }{}\\{}
 \tsfield{tt\_rexmt} \Mass  *;{}\\{}
 \tsfield{t\_rttseg} \Mass  *;{}\\{}
 {}\\{}
 \tsholcomm{ Segment to retransmit starts here }{}\\{}
 \tsfield{snd\_nxt} \Mass  \tsvar{ack};{}\\{}
 {}\\{}
 \tsholcomm{ Allow one segment to be emitted }{}\\{}
 \tsfield{snd\_cwnd} \Mass  \tsvar{cb}'.\tsfield{t\_maxseg}{}\\{}
 \Mmagicbolrrec ) \tsaux{andThen}{}\\{}
 {}\\{}
\quad\quad \tsholcomm{ Attempt to create a segment for output using the modified control block (this is a
             relational monad idiom) }{}\\{}
\quad\quad \tsaux{mlift\_tcp\_output\_perhaps\_or\_fail} \;\tsvar{ticks} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsaux{andThen}{}\\{}
 {}\\{}
\quad\quad \tsholcomm{ Finally update the control block:  }{}\\{}
\quad\quad \tsaux{modify\_cb} (\lambda \tsvar{cb}'.\tsvar{cb}' \; \Mmagiclrec {}\\{}
 \tsholcomm{ RFC2582 partial window deflation: deflate the congestion
                                         window by the amount of data freshly acknowledged and add
                                         back one maximum segment size }{}\\{}
 \tsfield{snd\_cwnd} \Mass  \tsholop{Num} (\tsholop{int\_of\_num} \;\tsvar{cb}'.\tsfield{snd\_cwnd} -{}\\{}
\quad\quad\quad\quad\quad (\tsvar{ack} - \tsvar{cb}'.\tsfield{snd\_una}) + \tsholop{int\_of\_num} \;\tsvar{cb}'.\tsfield{t\_maxseg});{}\\{}
 \tsfield{snd\_nxt} \Mass   \tsvar{cb}'.\tsfield{snd\_nxt} \Mmagicrrec ) \tsholcomm{ restore previous value }{}\\{}
 {}\\{}
\quad \Melse  \;\Mif  \;\tsaux{TCP\_DO\_NEWRENO} \Mwedge  \tsvar{cb}'.\tsfield{t\_dupacks} \geq  3 \Mwedge  \tsvar{ack} \geq  \tsvar{cb}'.\tsfield{snd\_recover} \;\Mthen {}\\{}
\quad\quad \tsholcomm{ The host supports NewReno-style Fast Recovery, the socket has received at least three
             duplicate $\tsvar{ACK}$ segments and the new $\tsvar{ACK}$ acknowledges at least everything upto
             $\tsfield{snd\_recover}$, completing the recovery process. }{}\\{}
 {}\\{}
\quad\quad \tsaux{modify\_cb} (\lambda \tsvar{cb}'.\tsvar{cb}' \; \Mmagiclrec  \tsfield{t\_dupacks} \Mass  0; \tsholcomm{ clear the duplicate $\tsvar{ACK}$ counter }{}\\{}
 \tsholcomm{ Open up the congestion window, being careful to avoid an
                                         RFC2582 Ch3.5 Pg6 "burst of data". }{}\\{}
 \tsfield{snd\_cwnd} \Mass  ({}\\{}
 \Mif  \;\tsvar{cb}'.\tsfield{snd\_max} - \tsvar{ack} < \tsholop{int\_of\_num} \;\tsvar{cb}'.\tsfield{snd\_ssthresh} \;\Mthen {}\\{}
 \tsholcomm{ If $\tsfield{snd\_ssthresh}$ is greater than the number of
                                              bytes of data still unacknowledged and presumed to be
                                              in-flight, set $\tsfield{snd\_cwnd}$ to be one segment larger
                                              than the total size of all the segments in
                                              flight. This is burst avoidance: $\tsunknown{tcp\_output}$ is
                                              only able to send upto one further segment until some
                                              of the in flight data is acknowledged. }{}\\{}
 \tsholop{Num} (\tsvar{cb}'.\tsfield{snd\_max} - \tsvar{ack} + \tsholop{int\_of\_num} \;\tsvar{cb}'.\tsfield{t\_maxseg}){}\\{}
 \Melse {}\\{}
 \tsholcomm{ Otherwise, set $\tsfield{snd\_cwnd}$ to be $\tsfield{snd\_ssthresh}$,
                                              forbidding any further segment output until some in
                                              flight data is acknowledged.}{}\\{}
 \tsvar{cb}'.\tsfield{snd\_ssthresh}){}\\{}
 \Mmagicbolrrec ){}\\{}
 {}\\{}
\quad \Melse  \;\tsaux{assert\_failure} \text{``di3\textunderscore{}newackstuff''} \tsholcomm{ impossible }{}\\{}
 {}\\{}
 ) \tsaux{andThen}{}\\{}
 {}\\{}
 \tsholcomm{ Check $\tsvar{ack}$ value is sensible, \ie, not greater than the highest sequence number
       transmitted so far }{}\\{}
 \Mif  \;\tsvar{ack} > \tsvar{cb}'.\tsfield{snd\_max} \;\Mthen {}\\{}
\quad \tsholcomm{ Drop the segment and possibly emit a $\tsvar{RST}$ segment }{}\\{}
\quad \tsaux{mlift\_dropafterack\_or\_fail} \;\tsunknown{seg} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsvar{ticks} \;\tsaux{andThen}{}\\{}
\quad \tsaux{stop}{}\\{}
 \Melse  \tsholcomm{ continue processing }{}\\{}
 \tsholcomm{ If the retransmit timer is set and the socket has done only one retransmit and it is still
        within the bad retransmit timer window, then because this is an $\tsvar{ACK}$ of new data the
        retransmission was done in error. Flag this so that the control block can be recovered
        from retransmission mode. This is known as a "bad retransmit". }{}\\{}
 \Mlet  \;\tsunknown{revert\_rexmt} = (\tsaux{mode\_of} \;\tsvar{cb}'.\tsfield{tt\_rexmt} \;\in  \{\Msome  \;\tscon{Rexmt}; \Msome  \;\tscon{RexmtSyn}\} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{shift\_of} \;\tsvar{cb}'.\tsfield{tt\_rexmt} = 1 \Mwedge  \tsaux{timewindow\_open} \;\tsvar{cb}'.\tsfield{t\_badrxtwin}) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Attempt to calculate a new round-trip time estimate }{}\\{}
 \Mlet  \;\tsunknown{emission\_time} = \Mcase  (\tsvar{ts}, \tsvar{cb}'.\tsfield{t\_rttseg}) \Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\Msome  (\tsunknown{ts\_val},\tsunknown{ts\_ecr}), \tsunknown{\_}) \Mtotype {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ By using the segment's timestamp if it has one }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  (\tsunknown{ts\_ecr} - 1){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mdpipe  (*, \Msome  (\tsvar{ts}_{0},\tsvar{seq}_{0})) \Mtotype {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ Or if not, by the control blocks round-trip timer, if it covers
                                  the segment(s) being acknowledged }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mif  \;\tsvar{ack} > \tsvar{seq}_{0} \;\Mthen  \;\Msome  \;\tsvar{ts}_{0} \;\Melse  \;*{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mdpipe  (*, *) \Mtotype {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ Otherwise, it is not possible to calculate a round-trip update }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad * \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ If a new round-trip time estimate was calculated above, update the round-trip information
        held by the socket's control block }{}\\{}
 \Mlet  \;\tsunknown{t\_rttinf'} = \Mcase  \;\tsunknown{emission\_time} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Msome  \;\tsfield{t\_rttinf} \Mtotype  \tsaux{update\_rtt} (\tsaux{real\_of\_int} (\tsvar{ticks} - \tsholop{THE} \;\tsunknown{emission\_time}) / \tsaux{HZ}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}'.\tsfield{t\_rttinf}{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mdpipe  * \Mtotype  \tsvar{cb}'.\tsfield{t\_rttinf} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Update the retransmit timer }{}\\{}
 \Mlet  \;\tsunknown{tt\_rexmt'} ={}\\{}
 (\Mif  \;\tsvar{ack} = \tsvar{cb}'.\tsfield{snd\_max} \;\Mthen {}\\{}
\quad\quad * \tsholcomm{ If all sent data has been acknowledged, disable the timer }{}\\{}
 \Melse  \;\Mcase  \;\tsaux{mode\_of} \;\tsvar{cb}'.\tsfield{tt\_rexmt} \;\Mof {}\\{}
\quad\quad * \Mtotype {}\\{}
\quad\quad\quad \tsholcomm{ If not set, set it as there is still unacknowledged data }{}\\{}
\quad\quad\quad \tsaux{start\_tt\_rexmt} \;\tstype{arch} \;0 \;\Mtrue  \;\tsunknown{t\_rttinf'}{}\\{}
 \Mdpipe  \Msome  \;\tscon{Rexmt} \Mtotype {}\\{}
\quad\quad\quad \tsholcomm{ If set, reset it as a new acknowledgement segment has arrived }{}\\{}
\quad\quad\quad \tsaux{start\_tt\_rexmt} \;\tstype{arch} \;0 \;\Mtrue  \;\tsunknown{t\_rttinf'}{}\\{}
 \Mdpipe  \tsunknown{\_444} \Mtotype {}\\{}
\quad\quad\quad \tsholcomm{ Otherwise, leave it alone. The timer will never be in $\tscon{RexmtSyn}$ here and the
               only other case is $\tscon{Persist}$, in which case it should be left alone until such
               time as a window update is received }{}\\{}
\quad\quad\quad \tsvar{cb}'.\tsfield{tt\_rexmt}{}\\{}
 ) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Update the send queue and window }{}\\{}
 \Mlet  (\tsunknown{snd\_wnd'},\tsvar{sndq}') = (\Mif  \;\tsunknown{ourfinisacked} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ If this socket has previously emitted a $\tsvar{FIN}$ segment and the
                                 $\tsvar{FIN}$ has now been $\tsvar{ACK}$ed, decrease $\tsfield{snd\_wnd}$ by the length of
                                 the send queue and clear the send queue.}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{cb}'.\tsfield{snd\_wnd} - \tsholop{LENGTH} \;\tsunknown{tcp\_sock\_0}.\tsvar{sndq}, [\,]){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ Otherwise, reduce the send window by the amound of data
                                 acknowledged as it is now consuming space on the receiver's
                                 receive queue. Remove the acknowledged bytes from the send queue
                                 as they will never need to be retransmitted.}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{cb}'.\tsfield{snd\_wnd} - \tsholop{Num} (\tsvar{ack} - \tsunknown{tcp\_sock\_0}.\tsvar{cb}.\tsfield{snd\_una}),{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{DROP} (\tsholop{Num} (\tsvar{ack} - \tsunknown{tcp\_sock\_0}.\tsvar{cb}.\tsfield{snd\_una})) \tsunknown{tcp\_sock\_0}.\tsvar{sndq}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad ) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Update the control block }{}\\{}
 \tsaux{modify\_cb} (\lambda \tsvar{cb}. \tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsholcomm{ If $\tsunknown{revert\_rexmt}$ (above) flags that a bad retransmission occured, undo the congestion avoidance changes }{}\\{}
 \tsfield{snd\_cwnd} \;\Mupdby  \;\tsvar{cb}.\tsfield{snd\_cwnd\_prev} \;\tsholop{onlywhen} \;\tsunknown{revert\_rexmt};{}\\{}
 \tsfield{snd\_ssthresh} \;\Mupdby  \;\tsvar{cb}.\tsfield{snd\_ssthresh\_prev} \;\tsholop{onlywhen} \;\tsunknown{revert\_rexmt};{}\\{}
 \tsfield{snd\_nxt} \;\Mupdby  \;\tsvar{cb}'.\tsfield{snd\_max} \;\tsholop{onlywhen} \;\tsunknown{revert\_rexmt};{}\\{}
 \tsfield{t\_badrxtwin} \;\Mupdby  \;\tscon{TimeWindowClosed} \;\tsholop{onlywhen} \;\tsunknown{revert\_rexmt}{}\\{}
 \Mmagicbolrrec ) \tsaux{andThen}{}\\{}
 \tsaux{modify\_cb} (\lambda \tsvar{cb}. \tsvar{cb} \;{}\\{}
 \Mmagiclrec {}\\{}
 \tsholcomm{ Update the round-trip time estimates and retransmit timer }{}\\{}
 \tsfield{t\_rttinf} \Mass  \tsunknown{t\_rttinf'};{}\\{}
 \tsfield{tt\_rexmt} \Mass  \tsunknown{tt\_rexmt'};{}\\{}
 {}\\{}
 \tsholcomm{ If the $\tsvar{ACK}$ segment allowed us to successfully time a segment (and update the
              round-trip time estimates) then clear the soft error flag and clear the segment
              round-trip timer in order that it can be used on a future segment. }{}\\{}
 \tsfield{t\_softerror} \;\Mupdby  \;* \;\tsholop{onlywhen} \;\tsholop{IS\_SOME} \;\tsunknown{emission\_time};{}\\{}
 \tsfield{t\_rttseg} \;\Mupdby  \;* \;\tsholop{onlywhen} \;\tsholop{IS\_SOME} \;\tsunknown{emission\_time};{}\\{}
 {}\\{}
 \tsholcomm{ Update the congestion window by the algorithm in \ltslink{expandTcwnd}{$\tsaux{expand\_cwnd}$} only when not performing NewReno retransmission or
              the duplicate $\tsvar{ACK}$ counter is zero, \ie, expand the congestion
              window when this $\tsvar{ACK}$ is not a NewReno-style partial $\tsvar{ACK}$ and
              hence the connection has yet recovered }{}\\{}
 \tsfield{snd\_cwnd} \;\Mupdby  \;\tsaux{expand\_cwnd} \;\tsvar{cb}.\tsfield{snd\_ssthresh} \;\tsunknown{tcp\_sock\_0}.\tsvar{cb}.\tsfield{t\_maxseg}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsaux{TCP\_MAXWIN} \ll  \tsunknown{tcp\_sock\_0}.\tsvar{cb}.\tsfield{snd\_scale}) \tsvar{cb}.\tsfield{snd\_cwnd}{}\\{}
\quad\quad \tsholop{onlywhen} (\neg{}\tsaux{TCP\_DO\_NEWRENO} \Mvee  \tsvar{cb}'.\tsfield{t\_dupacks} = 0);{}\\{}
 \tsfield{snd\_wnd}  \Mass  \tsunknown{snd\_wnd'}; \tsholcomm{ The updated send window }{}\\{}
 \tsfield{snd\_una}  \Mass  \tsvar{ack};      \tsholcomm{ Have had up to $\tsvar{ack}$ acknowledged }{}\\{}
 \tsfield{snd\_nxt}  \Mass  \tsholop{MAX} \;\tsvar{ack} \;\tsvar{cb}.\tsfield{snd\_nxt} ;  \tsholcomm{ Ensure invariant $\tsfield{snd\_nxt} \geq  \tsfield{snd\_una}$ }{}\\{}
 {}\\{}
 \tsholcomm{ Reset the $2MSL$ timer if in the $\tscon{TIME\_WAIT}$ state as have
              received a valid $\tsvar{ACK}$ segment for the waiting socket }{}\\{}
 \tsfield{tt\_2msl}  \;\Mupdby  \;\Msome  (\Mtimed{()}{\tsaux{slow\_timer} (2*\tsaux{TCPTV\_MSL})}){}\\{}
\quad\quad \tsholop{onlywhen} (\tsunknown{tcp\_sock\_0}.\tsvar{st} = \tscon{TIME\_WAIT}){}\\{}
 \Mmagicbolrrec ) \tsaux{andThen}{}\\{}
 \tsaux{modify\_tcp\_sock} (\lambda \tsvar{s}. \tsvar{s} \; \Mmagiclrec  \tsvar{sndq} \Mass  \tsvar{sndq}' \Mmagicrrec ) \tsaux{andThen}  \tsholcomm{ The send queue update }{}\\{}
 {}\\{}
 (\Mif  \;\tsunknown{tcp\_sock\_0}.\tsvar{st} = \tscon{LAST\_ACK} \Mwedge  \tsunknown{ourfinisacked} \;\Mthen {}\\{}
\quad \tsholcomm{ If the socket's $\tsvar{FIN}$ has been acknowledged and the socket is in the $\tscon{LAST\_ACK}$
            state, close the socket and stop processing this segment }{}\\{}
\quad \tsaux{modify\_sock} (\tsaux{tcp\_close} \;\tstype{arch}) \tsaux{andThen}{}\\{}
\quad \tsaux{stop}{}\\{}
 \Melse  \;\Mif  \;\tsunknown{tcp\_sock\_0}.\tsvar{st} = \tscon{TIME\_WAIT} \Mwedge  \tsvar{ack} > \tsunknown{tcp\_sock\_0}.\tsvar{cb}.\tsfield{snd\_una} \tscomm{ data acked past FIN } \Mthen {}\\{}
\quad \tsholcomm{ If the socket is in $\tscon{TIME\_WAIT}$ and this segment contains a new acknowledgement (that
            acknowledges past the $\tsvar{FIN}$ segment, drop it---it's invalid. Stop processing. }{}\\{}
\quad \tsaux{mlift\_dropafterack\_or\_fail} \;\tsunknown{seg} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsvar{ticks} \;\tsaux{andThen}{}\\{}
\quad \tsaux{stop}{}\\{}
 \Melse {}\\{}
\quad \tsholcomm{ Otherwise, flag that $\tsrule{deliver\_in\_3}$ can continue processing the segment if need be }{}\\{}
\quad \tsaux{cont}){}\\{}
 {}\\{}
 ) \tscomm{ cb' }}
}
{\rrulepad }
}

\newcommand{\defndiIIITackstuff}{\ddefnc{diIIITackstuff}{\iA{di3\_ackstuff}}{\subddefnA[{ $\tsrule{deliver\_in\_3}$ ACK processing }]{di3\_ackstuff}{\tsaux{di3\_ackstuff} \;\tsunknown{tcp\_sock\_0} \;\tsunknown{seg} \;\tsunknown{ourfinisacked} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsvar{ticks} ={}\\{}
 \tsholcomm{ Pull some fields out of the segment }{}\\{}
 \Mlet  \;\tsvar{ack}  = \tsunknown{tcp\_seq\_flip\_sense} \;\tsunknown{seg}.\tsvar{ack} \;\Min {}\\{}
 \Mlet  \;\tsvar{seq}  = \tsunknown{tcp\_seq\_flip\_sense} \;\tsunknown{seg}.\tsvar{seq} \;\Min {}\\{}
 \Mlet  \;\tsvar{data} = \tsunknown{seg}.\tsvar{data} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Pull out senders advertised window from the segment, applying the sender's scaling }{}\\{}
 \Mlet  \;\tsvar{win}  = \tsholop{w2n} \;\tsunknown{seg}.\tsvar{win} \ll  \tsunknown{tcp\_sock\_0}.\tsvar{cb}.\tsfield{snd\_scale} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Get the socket's control block using the monadic state accessor $\tsaux{get\_cb}$. Process the
        acknowledgement data in the segment, do some congestion control calculations and finally
        update the control blocks }{}\\{}
 (\tsaux{get\_cb} \lambda  \tsvar{cb}.{}\\{}
\quad \tsholcomm{ The segment is possibly a duplicate ack if it contains no data, does not contain a window
         update and the socket has unacknowledged data (the retransmit timer is still active).  The
         no data condition is important: if this socket is sending little or no data at present and is
         waiting for some previous data to be acknowledged, but is receiving data filled segments
         from the other end, these may all contain the same acknowledgement number and trigger the
         retransmit logic erroneously. }{}\\{}
 \Mlet  \;\tsunknown{has\_data} = (\tsvar{data} \neq  [\,] \Mwedge {}\\{}
\quad\quad (\tsaux{bsd\_arch} \;\tstype{arch} \implies  (\tsvar{cb}.\tsfield{rcv\_nxt} < \tsvar{seq} + \tsholop{LENGTH} \;\tsvar{data} \Mwedge  \tsvar{seq} < \tsvar{cb}.\tsfield{rcv\_nxt} + \tsvar{cb}.\tsfield{rcv\_wnd}))) \Min {}\\{}
 \Mlet  \;\tsunknown{maybe\_dup\_ack} = (\neg{}\tsunknown{has\_data} \Mwedge  \tsvar{win} = \tsvar{cb}.\tsfield{snd\_wnd} \Mwedge  \tsaux{mode\_of} \;\tsvar{cb}.\tsfield{tt\_rexmt} = \Msome  \;\tscon{Rexmt}) \Min {}\\{}
 {}\\{}
 \Mif  \;\tsvar{ack} \leq  \tsvar{cb}.\tsfield{snd\_una} \Mwedge  \tsunknown{maybe\_dup\_ack} \;\Mthen {}\\{}
\quad \tsholcomm{ Received a duplicate acknowledgement: it is an old acknowledgement (strictly less than
            $\tsfield{snd\_una}$) and it meets the duplicate acknowledgement conditions above.
            Do Fast Retransmit/Fast Recovery Congestion Control (RFC 2581 Ch3.2 Pg6) and
            NewReno-style Fast Recovery (RFC 2582, Ch3 Pg3), updating the control block variables
            and creating segments for transmission as appropriate. }{}\\{}
 {}\\{}
\quad\quad \Mlet  \;\tsunknown{t\_dupacks'} = \tsvar{cb}.\tsfield{t\_dupacks} + 1 \;\Min {}\\{}
 {}\\{}
\quad\quad \Mif  \;\tsunknown{t\_dupacks'} < 3  \;\Mthen {}\\{}
\quad\quad\quad \tsholcomm{ Fewer than three duplicate acks received so far. Just increment the duplicate ack
                counter.  We must continue processing, in case $\tsvar{FIN}$ is set. }{}\\{}
\quad\quad\quad \tsaux{modify\_cb} (\lambda \tsvar{cb}'.\tsvar{cb}' \; \Mmagiclrec  \tsfield{t\_dupacks} \Mass  \tsunknown{t\_dupacks'} \Mmagicrrec ) \tsaux{andThen}{}\\{}
\quad\quad\quad \tsaux{cont}{}\\{}
 {}\\{}
\quad\quad \Melse  \;\Mif  \;\tsunknown{t\_dupacks'} > 3 \Mvee  (\tsunknown{t\_dupacks'} = 3 \Mwedge  \tsaux{TCP\_DO\_NEWRENO} \Mwedge  \tsvar{ack} < \tsvar{cb}.\tsfield{snd\_recover}) \Mthen {}\\{}
\quad\quad\quad \tsholcomm{ If this is the 4th or higher duplicate $\tsvar{ACK}$ then Fast Retransmit/Fast Recovery
                congestion control is already in progress. Increase the congestion window by another
                maximum segment size (as the duplicate $\tsvar{ACK}$ indicates another out-or-order
                segment has been received by the other end and is no longer consuming network
                resource), increment the duplicate $\tsvar{ACK}$ counter, and attempt to output another
                segment. }{}\\{}
\quad\quad\quad \tsholcomm{ If this is the 3rd duplicate $\tsvar{ACK}$, the host supports NewReno extensions and
                $\tsvar{ack}$ is strictly less than the fast recovery "recovered" sequence number
                $\tsfield{snd\_recover}$, then the host is already doing NewReno-style fast recovery and has
                possibly falsely retransmitted a segment, the retransmitted segment has been lost or
                it has been delayed. Reset the duplicate $\tsvar{ACK}$ counter, increase the congestion
                window by a maximum segment size (for the same reason as before) and attempt to output
                another segment. NB: this will not cause a cycle to develop! The retransmission
                timer will eventually fire if recovery does not happen "fast". }{}\\{}
\quad\quad\quad \tsaux{modify\_cb} (\lambda \tsvar{cb}'.\tsvar{cb}' \; \Mmagiclrec  \tsfield{t\_dupacks} \Mass  \Mif  \;\tsunknown{t\_dupacks'} = 3 \;\Mthen  \;0 \tsholcomm{ false retransmit,
            or further loss or delay }{}\\{}
\quad\quad\quad\quad \Melse  \;\tsunknown{t\_dupacks'};{}\\{}
 \tsfield{snd\_cwnd} \Mass  \tsvar{cb}.\tsfield{snd\_cwnd} + \tsvar{cb}.\tsfield{t\_maxseg} \Mmagicrrec  ) \tsaux{andThen}{}\\{}
\quad\quad\quad \tsaux{mlift\_tcp\_output\_perhaps\_or\_fail} \;\tsvar{ticks} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsaux{andThen}{}\\{}
\quad\quad\quad \tsaux{stop} \tsholcomm{ no need to process the segment any further }{}\\{}
 {}\\{}
\quad\quad \Melse  \;\Mif  \;\tsunknown{t\_dupacks'} = 3 \Mwedge  \neg{}(\tsaux{TCP\_DO\_NEWRENO} \Mwedge  \tsvar{ack} < \tsvar{cb}.\tsfield{snd\_recover}) \Mthen {}\\{}
\quad\quad\quad \tsholcomm{ If this is the 3rd duplicate segment and if the host supports NewReno extensions, a
               NewReno-style Fast Retransmit is not already in progress, then do a Fast Retransmit }{}\\{}
 {}\\{}
\quad\quad\quad \tsholcomm{ Update the control block before the retransmit to reflect which data requires
                retransmission }{}\\{}
\quad\quad\quad \tsaux{modify\_cb} (\lambda \tsvar{cb}'.\tsvar{cb}' \; \Mmagiclrec  \tsfield{t\_dupacks}    \Mass  \tsunknown{t\_dupacks'};  \tsholcomm{ increment the counter }{}\\{}
 {}\\{}
 \tsholcomm{ Set to half the current flight size as per RFC2581/2582 }{}\\{}
 \tsfield{snd\_ssthresh} \Mass  \tsholop{MAX} \;2 ((\tsholop{MIN} \;\tsvar{cb}.\tsfield{snd\_wnd} \;\tsvar{cb}.\tsfield{snd\_cwnd}) \tsholop{DIV} \;2{}\\{}
\quad\quad\quad\quad\quad \tsholop{DIV} \;\tsvar{cb}.\tsfield{t\_maxseg}) * \tsvar{cb}.\tsfield{t\_maxseg};{}\\{}
 {}\\{}
 \tsholcomm{ If doing NewReno-style Fast Retransmit set to the
                                            highest sequence number transmitted so far $\tsfield{snd\_max}$. }{}\\{}
 \tsfield{snd\_recover}  \;\Mupdby  \;\tsvar{cb}.\tsfield{snd\_max} \;\tsholop{onlywhen} \;\tsaux{TCP\_DO\_NEWRENO};{}\\{}
 {}\\{}
 \tsholcomm{ Clear the retransmit timer and round-trip time
                                            measurement timer. These will be started by
                                            $\tsaux{tcp\_output\_really}$ when the retransmit is
                                            actioned. }{}\\{}
 \tsfield{tt\_rexmt}     \Mass  *;{}\\{}
 \tsfield{t\_rttseg}     \Mass  *;{}\\{}
 {}\\{}
 \tsholcomm{ Sequence number to retransmit---this is equal to the
                                        $\tsvar{ack}$ value in the duplicate $\tsvar{ACK}$ segment }{}\\{}
 \tsfield{snd\_nxt}      \Mass  \tsvar{ack};{}\\{}
 \tsholcomm{ Ensure the congestion window is large enough to allow
                                            one segment to be emitted }{}\\{}
 \tsfield{snd\_cwnd}     \Mass  \tsvar{cb}.\tsfield{t\_maxseg}  \Mmagicrrec ) \tsaux{andThen}{}\\{}
 {}\\{}
\quad\quad\quad \tsholcomm{ Attempt to create a segment for output using the modified control block (this is all
                a relational monad idiom) }{}\\{}
\quad\quad\quad \tsaux{mlift\_tcp\_output\_perhaps\_or\_fail} \;\tsvar{ticks} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsaux{andThen}{}\\{}
 {}\\{}
\quad\quad\quad \tsholcomm{ Finally, update the congestion window to $\tsfield{snd\_ssthresh}$ plus 3 maximum segment
                sizes (this is the artificial inflation of RFC2581/2582 because it is known that the
                3 segments that generated the 3 duplicate acknowledgments are received and no longer
                consuming network resource. Also put $\tsfield{snd\_nxt}$ back to its previous value. }{}\\{}
\quad\quad\quad \tsaux{modify\_cb} (\lambda \tsvar{cb}'.\tsvar{cb}' \; \Mmagiclrec  \tsfield{snd\_cwnd}     \Mass  \tsvar{cb}'.\tsfield{snd\_ssthresh} + \tsvar{cb}.\tsfield{t\_maxseg} * \tsunknown{t\_dupacks'};{}\\{}
 \tsfield{snd\_nxt}      \Mass  \tsholop{MAX} \;\tsvar{cb}.\tsfield{snd\_nxt} \;\tsvar{cb}'.\tsfield{snd\_nxt} \Mmagicrrec ) \tsaux{andThen}{}\\{}
\quad\quad\quad \tsaux{stop} \tsholcomm{ no need to process the segment any further }{}\\{}
 {}\\{}
\quad\quad \Melse  \;\tsaux{assert\_failure} \text{``di3\textunderscore{}ackstuff''} \tsholcomm{ Believed to be impossible---here for completion and safety }{}\\{}
 {}\\{}
 {}\\{}
\quad \Melse  \;\Mif  \;\tsvar{ack} \leq  \tsvar{cb}.\tsfield{snd\_una} \Mwedge  \neg{}\tsunknown{maybe\_dup\_ack} \;\Mthen {}\\{}
\quad\quad \tsholcomm{ Have received an old (would use the word "duplicate" if it did not have a special
              meaning) $\tsvar{ACK}$ and it is neither a duplicate $\tsvar{ACK}$ nor the $\tsvar{ACK}$ of a new
              sequence number thus just clear the duplicate $\tsvar{ACK}$ counter. }{}\\{}
\quad\quad \tsaux{modify\_cb} (\lambda \tsvar{cb}'.\tsvar{cb}' \; \Mmagiclrec  \tsfield{t\_dupacks} \Mass  0 \Mmagicrrec ){}\\{}
 {}\\{}
\quad \Melse  \tsholcomm{ Must be: $\tsvar{ack} > \tsvar{cb}.\tsfield{snd\_una}$ }{}\\{}
\quad\quad \tsholcomm{ This is the $\tsvar{ACK}$ of a new sequence number---this case is handled by the auxiliary
              function \ltslink{diIIITnewackstuff}{$\tsaux{di3\_newackstuff}$} }{}\\{}
\quad\quad \tsaux{di3\_newackstuff} \;\tsunknown{tcp\_sock\_0} \;\tsunknown{seg} \;\tsunknown{ourfinisacked} \;\tstype{arch} \;\tsvar{rttab} \;\tsvar{ifds} \;\tsvar{ticks}{}\\{}
 )}
}
{\rrulepad }
}

\newcommand{\defndiIIITdatastuffTreally}{\ddefnc{diIIITdatastuffTreally}{\iA{di3\_datastuff\_really}}{\subddefnA[{ $\tsrule{deliver\_in\_3}$ data processing }]{di3\_datastuff\_really}{\tsaux{di3\_datastuff\_really} \;\tsunknown{the\_ststuff} \;\tsunknown{tcp\_sock\_0} \;\tsunknown{seg} \;\tsunknown{bsd\_fast\_path} \;\tstype{arch} ={}\\{}
 \tsholcomm{ Pull some fields out of the segment }{}\\{}
 \Mlet  \;\tsvar{ACK}  = \tsunknown{seg}.\tsvar{ACK} \;\Min {}\\{}
 \Mlet  \;\tsvar{FIN}  = \tsunknown{seg}.\tsvar{FIN} \;\Min {}\\{}
 \Mlet  \;\tsvar{PSH}  = \tsunknown{seg}.\tsvar{PSH} \;\Min {}\\{}
 \Mlet  \;\tsvar{URG}  = \tsunknown{seg}.\tsvar{URG} \;\Min {}\\{}
 \Mlet  \;\tsvar{ack}  = \tsunknown{tcp\_seq\_flip\_sense} \;\tsunknown{seg}.\tsvar{ack} \;\Min {}\\{}
 \Mlet  \;\tsvar{urp}  = \tsholop{w2n} \;\tsunknown{seg}.\tsvar{urp} \;\Min {}\\{}
 \Mlet  \;\tsvar{data} = \tsunknown{seg}.\tsvar{data} \;\Min {}\\{}
 \Mlet  \;\tsvar{seq}  = \tsunknown{tcp\_seq\_flip\_sense} \;\tsunknown{seg}.\tsvar{seq} + (\Mif  \;\tsunknown{seg}.\tsvar{SYN} \;\Mthen  \;1 \;\Melse  \;0) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Pull out the senders advertised window and apply the sender's scale factor }{}\\{}
 \Mlet  \;\tsvar{win}  = \tsholop{w2n} \;\tsunknown{seg}.\tsvar{win} \ll  (\tsunknown{tcp\_sock\_0}).\tsvar{cb}.\tsfield{snd\_scale} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Get the socket's control block using the monadic state accessor $\tsaux{get\_cb}$. Process the
         segments data and possibly update the send window }{}\\{}
 (\tsaux{get\_sock} \lambda  \tsvar{sock}.{}\\{}
 \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsvar{sock} \;\Min {}\\{}
 \Mlet  \;\tsvar{cb} = \tsunknown{tcp\_sock}.\tsvar{cb} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Trim segment to be within the receive window }{}\\{}
 {}\\{}
 \tsholcomm{ Trim duplicate data from the left edge of $\tsvar{data}$, \ie, data before $\tsvar{cb}.\tsfield{rcv\_nxt}$.
         Adjust $\tsvar{seq}$, $\tsvar{URG}$ and $\tsvar{urp}$ in respect of left edge trimming. If the urgent data
         has been trimmed from the segment's data, $\tsvar{URG}$ is cleared also.  Note: the urgent
         pointer always points to the byte immediately following the urgent byte and is relative
         to the start of the segment's data. An urgent pointer of zero signifies that there is no
         urgent data in the segment. }{}\\{}
 \Mlet  \;\tsunknown{trim\_amt\_left} = \Mif  \;\tsvar{cb}.\tsfield{rcv\_nxt} > \tsvar{seq} \;\Mthen  \;\tsholop{MIN} (\tsholop{Num} (\tsvar{cb}.\tsfield{rcv\_nxt} - \tsvar{seq})) (\tsholop{LENGTH} \;\tsvar{data}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;0 \;\Min {}\\{}
 \Mlet  \;\tsunknown{data\_trimmed\_left} = \tsaux{DROP} \;\tsunknown{trim\_amt\_left} \;\tsvar{data} \;\Min {}\\{}
 \Mlet  \;\tsunknown{seq\_trimmed} = \tsvar{seq} + \tsunknown{trim\_amt\_left} \;\Min  \tsholcomm{ Trimmed data starts at $\tsunknown{seq\_trimmed}$ }{}\\{}
 \Mlet  \;\tsunknown{urp\_trimmed} = \Mif  \;\tsvar{urp} > \tsunknown{trim\_amt\_left} \;\Mthen  \;\tsvar{urp} - \tsunknown{trim\_amt\_left} \;\Melse  \;0 \;\Min {}\\{}
 \Mlet  \;\tsunknown{URG\_trimmed} = \Mif  \;\tsunknown{urp\_trimmed} \neq  0 \;\Mthen  \;\tsvar{URG} \;\Melse  \;\Mfalse  \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Trim any data outside the receive window from the right hand edge. If all the data is
         within the window and the $\tsvar{FIN}$ flag is set then the $\tsvar{FIN}$ flag is valid and should
         be processed.  Note: this trimming may remove urgent data from the segment. The urgent
         pointer and flag are not cleared here because there is still urgent data to be received,
         but now in a future segment. }{}\\{}
 \Mlet  \;\tsunknown{data\_trimmed\_left\_right} = \tsaux{TAKE} \;\tsvar{cb}.\tsfield{rcv\_wnd} \;\tsunknown{data\_trimmed\_left} \;\Min {}\\{}
 \Mlet  \;\tsunknown{FIN\_trimmed} = \Mif  \;\tsunknown{data\_trimmed\_left\_right} = \tsunknown{data\_trimmed\_left} \;\Mthen  \;\tsvar{FIN} \;\Melse  \;\Mfalse  \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Processing of urgent (OOB) data: }{}\\{}
 {}\\{}
 \tsholcomm{ We have a valid urgent pointer iff the trimmed segment has its urgent flag set with a non-zero urgent
         pointer, and the urgent pointer plus the length of the receive queue is less than or equal
         to $\tsaux{SB\_MAX}$. The last condition is imposed by FreeBSD, supposedly to prevent \wasverb{soreceive}
         from crashing (although we cannot identify why it might crash). }{}\\{}
 \Mlet  \;\tsunknown{urp\_valid} = (\tsunknown{URG\_trimmed} \Mwedge  \tsunknown{urp\_trimmed} > 0 \Mwedge  \tsunknown{urp\_trimmed} + \tsholop{LENGTH} \;\tsunknown{tcp\_sock}.\tsvar{rcvq} \leq  \tsaux{SB\_MAX}) \Min {}\\{}
 {}\\{}
 \tsholcomm{ This is a new urgent pointer, \ie, it is greater than any previous one stored in
        $\tsvar{cb}.\tsfield{rcv\_up}$. Note: the urgent pointer is relative to the sequence number of a segment }{}\\{}
 \Mlet  \;\tsunknown{urp\_advanced} = (\tsunknown{urp\_valid} \Mwedge  (\tsunknown{seq\_trimmed} + \tsunknown{urp\_trimmed} > \tsvar{cb}.\tsfield{rcv\_up})) \Min {}\\{}
 {}\\{}
 \tsholcomm{ The urgent pointer lies within segment $\tsunknown{seg}$ and the socket is not set to do inline delivery,
         therefore it is possible to pull out the urgent byte from the stream }{}\\{}
 \Mlet  \;\tsunknown{can\_pull} = (\tsunknown{urp\_valid} \Mwedge {}\\{}
\quad\quad \tsunknown{urp\_trimmed} \leq  \tsholop{LENGTH} \;\tsunknown{data\_trimmed\_left\_right} \Mwedge  \tsvar{sock}.\tsvar{sf}.\tsvar{b}(\tscon{SO\_OOBINLINE}) = \Mfalse ) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Build trimmed segment to place on reassembly queue.  If urgent data is in this segment and
         the socket is not doing inline delivery (and hence the urgent byte is stored in $\tsvar{iobc}$),
         remove the urgent byte from the segment's data so that it does not get placed in the
         receive queue, and set $\tsfield{spliced\_urp}$ to the sequence number of the urgent byte. }{}\\{}
 \Mlet  \;\tsunknown{rseg} = \Mmagiclrec  \tsvar{seq}  \Mass  \tsunknown{seq\_trimmed};{}\\{}
 \tsfield{spliced\_urp} \Mass  \Mif  \;\tsunknown{can\_pull} \;\Mthen  \;\Msome (\tsvar{cb}.\tsfield{rcv\_nxt} + \tsunknown{urp\_trimmed} - 1) \Melse  \;*;{}\\{}
 \tsvar{FIN}  \Mass  \tsunknown{FIN\_trimmed};{}\\{}
 \tsvar{data} \Mass  \Mif  \;\tsunknown{can\_pull} \;\Mthen {}\\{}
\quad\quad \Mappend{(\tsaux{TAKE} (\tsvar{urp} - 1) \tsunknown{data\_trimmed\_left\_right})}{(\tsaux{DROP} \;\tsvar{urp} \;\tsunknown{data\_trimmed\_left\_right})}{}\\{}
\quad \Melse  \;\tsunknown{data\_trimmed\_left\_right}{}\\{}
 \Mmagicbolrrec  \Min {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Perform a monadic socket state update }{}\\{}
 \tsaux{modify\_tcp\_sock} (\lambda \tsvar{s}.\tsvar{s} \;{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{s}.\tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsholcomm{ If the segment's urgent pointer is valid and advances the urgent
                                 pointer, update $\tsfield{rcv\_up}$ with the new absolute pointer,
                                 otherwise just pull it along with the left hand edge of the
                                 receive window. Note: an earlier segment may have set $\tsfield{rcv\_up}$
                                 to point somewhere into a future segment. The use of $\tsholop{MAX}$
                                 ensures that the pointer is not accidentally overwritten until the
                                 future segment arrives. }{}\\{}
 \tsholcomm{ FreeBSD does not pull $\tsfield{rcv\_up}$ along in the fast path; this is a bug }{}\\{}
 \tsfield{rcv\_up} \;\Mupdby  (\Mif  \;\tsunknown{urp\_advanced} \;\Mthen  \;\tsunknown{seq\_trimmed} + \tsunknown{urp\_trimmed}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsholop{MAX} \;\tsvar{cb}.\tsfield{rcv\_up} \;\tsvar{cb}.\tsfield{rcv\_nxt}){}\\{}
\quad \tsholop{onlywhen} \neg{}(\tsaux{bsd\_arch} \;\tstype{arch} \Mwedge  \tsunknown{bsd\_fast\_path}) \Mmagicrrec ;{}\\{}
 \tsholcomm{ If the urgent pointer is valid and advances the urgent pointer,
                              update $\tsvar{rcvurp}$---the socket's receive queue urgent data index---to
                              be the index into the receive queue where the new urgent data will
                              be stored. Note: the subtraction of $1$ is correct because $\tsvar{rcvurp}$
                              points to the location where the urgent byte is stored not the byte
                              immediately following the urgent byte (as is the convention for the
                              $\tsvar{urp}$ field in the TCP header). }{}\\{}
 \tsvar{rcvurp} \;\Mupdby  (\Msome  (\tsholop{LENGTH} \;\tsunknown{tcp\_sock}.\tsvar{rcvq} +{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholop{Num}(\tsunknown{seq\_trimmed} + \tsunknown{urp\_trimmed} - \tsvar{cb}.\tsfield{rcv\_nxt} - 1))){}\\{}
\quad\quad \tsholop{onlywhen} \;\tsunknown{urp\_advanced};{}\\{}
 \tsholcomm{ If the segment's urgent pointer is valid, the urgent data is within
                              this segment and the socket is not doing inline delivery of
                              urgent data, pull out the urgent byte into $\tsvar{iobc}$. If the urgent
                              data is within a future segment set $\tsvar{iobc}$ to $\tscon{NO\_OOBDATA}$ to
                              signify that the urgent data is not available yet, otherwise leave
                              $\tsvar{iobc}$ alone if the urgent pointer is not valid. }{}\\{}
 \tsvar{iobc} \;\Mupdby  (\Mif  \;\tsunknown{can\_pull} \;\Mthen  \;\tscon{OOBDATA} (\tsunknown{EL} (\tsvar{urp} - 1){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{data\_trimmed\_left\_right}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tscon{NO\_OOBDATA}){}\\{}
\quad \tsholop{onlywhen} \;\tsunknown{urp\_valid}{}\\{}
 \Mmagicbolrrec ) \tsaux{andThen}{}\\{}
 {}\\{}
 \tsholcomm{ Processing of non-urgent data. There are 6 cases to consider: }{}\\{}
 {}\\{}
 (\tsaux{chooseM} \{\Mfalse ;\Mtrue \} \lambda  \tsunknown{FIN\_reass}.{}\\{}
 {}\\{}
 \tsholcomm{ Case (1) The segment contains new in-order, in-window data possibly with a $\tsvar{FIN}$ and the
             receive window is not closed. Note: it is possible that the segment contains just one
             byte of OOB data that may have already been pulled out into $\tsvar{iobc}$ if OOB delivery
             is out-of-line. In which case, the below must still be performed even though no data
             is contributed to the reassembly buffer in order that $\tsfield{rcv\_nxt}$ is updated correctly
             (because a byte of urgent data consumes a byte of sequence number space). This is why
             $\tsunknown{data\_trimmed\_left\_right}$ is used rather than $\tsunknown{data\_deoobed}$ in some of the
             conditions below. }{}\\{}
 (\Mif  \;\tsunknown{seq\_trimmed} = \tsvar{cb}.\tsfield{rcv\_nxt} \Mwedge {}\\{}
\quad\quad \tsunknown{seq\_trimmed} + \tsholop{LENGTH} \;\tsunknown{data\_trimmed\_left\_right} + (\Mif  \;\tsunknown{FIN\_trimmed} \;\Mthen  \;1 \;\Melse  \;0) > \tsvar{cb}.\tsfield{rcv\_nxt} \Mwedge {}\\{}
\quad\quad \tsvar{cb}.\tsfield{rcv\_wnd} > 0 \;\Mthen {}\\{}
 {}\\{}
\quad \tsholcomm{ Only need to acknowledge the segment if there is new in-window data (including urgent
            data) or a valid $\tsvar{FIN}$ }{}\\{}
\quad \Mlet  \;\tsunknown{have\_stuff\_to\_ack} = (\tsunknown{data\_trimmed\_left\_right} \neq  [\,] \Mvee  \tsunknown{FIN\_trimmed}) \Min {}\\{}
 {}\\{}
\quad \tsholcomm{ If the socket is connected, has data to $\tsvar{ACK}$ but no $\tsvar{FIN}$ to $\tsvar{ACK}$, the
            reassembly queue is empty, the socket is not currently within a bad retransmit window
            and an $\tsvar{ACK}$ is not already being delayed, then delay the $\tsvar{ACK}$. }{}\\{}
\quad \Mlet  \;\tsunknown{delay\_ack} = (\tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{ESTABLISHED};\tscon{CLOSE\_WAIT};\tscon{FIN\_WAIT\_1};{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscon{CLOSING};\tscon{LAST\_ACK};\tscon{FIN\_WAIT\_2}\} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{have\_stuff\_to\_ack} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \neg{}\tsunknown{FIN\_trimmed} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{t\_segq} = [\,] \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \neg{}\tsvar{cb}.\tsfield{tf\_rxwin0sent} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{tt\_delack} = * ) \Min {}\\{}
 {}\\{}
\quad \tsholcomm{ Check to see whether any data or a $\tsvar{FIN}$ can be reassembled. $\tsaux{tcp\_reass}$ returns
            the set of all possible reassemblies, one of which is chosen non-deterministically
            here. Note: a $\tsvar{FIN}$ can only be reassembled once all the data has been
            reassembled. The $\tsunknown{len}$ result from $\tsaux{tcp\_reass}$ is the length of the reassembled
            data, $\tsunknown{data\_reass}$, plus the length of any out-of-line urgent data that is not
            included in the reassembled data but logically occurs within it. This is to ensure that
            control block variables such as $\tsfield{rcv\_nxt}$ are incremented by the correct amount, \ie,
            by the amount of data (whether urgent or not) received successfully by the socket. See
            \ltslink{tcpTreass}{$\tsaux{tcp\_reass}$} for further details. }{}\\{}
\quad \Mlet  \;\tsunknown{rsegq} = \tsunknown{rseg} \Mcons  \tsvar{cb}.\tsfield{t\_segq} \;\Min {}\\{}
\quad (\tsaux{chooseM} (\tsaux{tcp\_reass} \;\tsvar{cb}.\tsfield{rcv\_nxt} \;\tsunknown{rsegq}) \lambda  (\tsunknown{data\_reass},\tsunknown{len},\tsunknown{FIN\_reass0}).{}\\{}
 {}\\{}
\quad \tsholcomm{ Length (in sequence space) of reassembled data, counting a $\tsvar{FIN}$ as one byte and
            including any out-of-line urgent data previously removed }{}\\{}
\quad \Mlet  \;\tsunknown{len\_reass} = \tsunknown{len} + (\Mif  \;\tsunknown{FIN\_reass0} \;\Mthen  \;1 \;\Melse  \;0) \Min {}\\{}
 {}\\{}
\quad \tsholcomm{ Add the reassembled data to the receive queue and increment $\tsfield{rcv\_nxt}$ to mark the
            sequence number of the byte past the last byte in the receive queue}{}\\{}
\quad \Mlet  \;\tsvar{rcvq}' = \Mappend{\tsunknown{tcp\_sock}.\tsvar{rcvq}}{\tsunknown{data\_reass}} \Min {}\\{}
\quad \Mlet  \;\tsunknown{rcv\_nxt'} = \tsvar{cb}.\tsfield{rcv\_nxt} + \tsunknown{len\_reass} \;\Min  \tscomm{ includes oob bytes as they occupy sequence space }{}\\{}
 {}\\{}
\quad \tsholcomm{ Prune the receive queue of any data or $\tsvar{FIN}$s that were reassembled, keeping all
            segments that contain data at or past sequence number $\tsvar{cb}.\tsfield{rcv\_nxt} + \tsunknown{len\_reass}$. }{}\\{}
\quad \Mlet  \;\tsunknown{t\_segq'} = \tsaux{tcp\_reass\_prune} \;\tsunknown{rcv\_nxt'} \;\tsunknown{rsegq} \;\Min {}\\{}
 {}\\{}
\quad \tsholcomm{ Reduce the receive window in light of the data added to the receive queue. Do not
            include out-of-line urgent data because it does not store data in the receive queue. }{}\\{}
\quad \Mlet  \;\tsunknown{rcv\_wnd'} = \tsvar{cb}.\tsfield{rcv\_wnd} - \tsholop{LENGTH} \;\tsunknown{data\_reass} \;\Min {}\\{}
 {}\\{}
\quad \tsholcomm{ Hack: assertion used to share values with later conditions }{}\\{}
\quad \tsaux{assert} (\tsunknown{FIN\_reass} = \tsunknown{FIN\_reass0}) \tsaux{andThen}{}\\{}
 {}\\{}
\quad \tsholcomm{ Update the socket state }{}\\{}
\quad \tsaux{modify\_tcp\_sock} (\lambda \tsvar{s}.\tsvar{s} \;{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mmagiclrec  \tsvar{rcvq} \Mass  \tsvar{rcvq}';  \tsholcomm{ the updated receive queue }{}\\{}
 \tsvar{cb} \Mass  \tsvar{s}.\tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsholcomm{ Start the delayed ack timer if decided to earlier, \ie,
                                    $\tsunknown{delay\_ack} = \Mtrue $. }{}\\{}
 \tsfield{tt\_delack} \;\Mupdby  \;\Msome  (\Mtimed{()}{\tsaux{fast\_timer} \;\tsaux{TCPTV\_DELACK}}) \tsholop{onlywhen} \;\tsunknown{delay\_ack};{}\\{}
 \tsholcomm{ Set if not delaying an $\tsvar{ACK}$ and have stuff to $\tsvar{ACK}$ }{}\\{}
 \tsfield{tf\_shouldacknow} \;\Mupdby  \neg{}\tsunknown{delay\_ack} \;\tsholop{onlywhen} \;\tsunknown{have\_stuff\_to\_ack};{}\\{}
 \tsfield{t\_segq} \Mass  \tsunknown{t\_segq'};   \tsholcomm{ updated reassembly queue, post-pruning }{}\\{}
 \tsfield{rcv\_nxt} \Mass  \tsunknown{rcv\_nxt'};{}\\{}
 \tsfield{rcv\_wnd} \Mass  \tsunknown{rcv\_wnd'}{}\\{}
 \Mmagicbolrrec {}\\{}
 \Mmagicbolrrec ){}\\{}
\quad ) \tscomm{ chooseM }{}\\{}
 {}\\{}
 \tsholcomm{ Case (2) The segment contains new out-of-order in-window data, possibly with a $\tsvar{FIN}$, and the
              receive window is not closed. Note: it may also contain in-window urgent data that may
              have been pulled out-of-line but still require processing to keep reassembly happy. }{}\\{}
 \Melse  \;\Mif  \;\tsunknown{seq\_trimmed} > \tsvar{cb}.\tsfield{rcv\_nxt} \Mwedge  \tsunknown{seq\_trimmed} < \tsvar{cb}.\tsfield{rcv\_nxt} + \tsvar{cb}.\tsfield{rcv\_wnd} \Mwedge {}\\{}
\quad\quad\quad\quad \tsholop{LENGTH} \;\tsunknown{data\_trimmed\_left\_right} + (\Mif  \;\tsunknown{FIN\_trimmed} \;\Mthen  \;1 \;\Melse  \;0) > 0 \Mwedge {}\\{}
\quad\quad\quad\quad \tsvar{cb}.\tsfield{rcv\_wnd} > 0 \;\Mthen {}\\{}
 {}\\{}
\quad \tsholcomm{ Hack: assertion used to share values with later conditions }{}\\{}
\quad \tsaux{assert} (\tsunknown{FIN\_reass} = \Mfalse ) \tsaux{andThen}{}\\{}
 {}\\{}
\quad \tsholcomm{ Update the socket's TCP control block state }{}\\{}
\quad \tsaux{modify\_cb} (\lambda \tsvar{cb}. \tsvar{cb} \; \Mmagiclrec  \tsholcomm{ Add the segment to the reassembly queue }{}\\{}
 \tsfield{t\_segq} \Mass  \tsunknown{rseg} \Mcons  \tsvar{cb}.\tsfield{t\_segq};{}\\{}
 \tsholcomm{ Acknowledge out-of-order data immediately (per RFC2581 Ch4.2) }{}\\{}
 \tsfield{tf\_shouldacknow} \Mass  \Mtrue {}\\{}
 \Mmagicbolrrec ){}\\{}
 {}\\{}
 \tsholcomm{ Case (3) The segment is a pure $\tsvar{ACK}$ segment (contains no data) (and must be in-order). }{}\\{}
 \tsholcomm{ Invariant here that $\tsunknown{seq\_trimmed} = \tsvar{seq}$ if segment is a pure $\tsvar{ACK}$. Note: the length
          of the original segment (not the trimmed segment) is used in the guard to ensure this
          really was a pure $\tsvar{ACK}$ segment. }{}\\{}
 \Melse  \;\Mif  \;\tsvar{ACK} \Mwedge  \tsunknown{seq\_trimmed} = \tsvar{cb}.\tsfield{rcv\_nxt} \Mwedge  \tsholop{LENGTH} \;\tsvar{data} + (\Mif  \;\tsvar{FIN} \;\Mthen  \;1 \;\Melse  \;0) = 0 \;\Mthen {}\\{}
 {}\\{}
\quad \tsholcomm{ Hack: assertion used to share values with later conditions }{}\\{}
\quad \tsaux{assert} (\tsunknown{FIN\_reass} = \Mfalse ) \tsholcomm{ Have not received a FIN }{}\\{}
 {}\\{}
 \tsholcomm{ Case (4) Segment contained no useful data---was a completely old segment. Note: the original
          fields from the segment, \ie, $\tsvar{seq}$, $\tsvar{data}$ and $\tsvar{FIN}$ are used in the guard
          below---the trimmed variants are useless here! }{}\\{}
 \tsholcomm{ Case (5) Segment is a window probe.  Note: the original fields from the segment, \ie, $\tsvar{data}$
          and $\tsvar{FIN}$ are used in the guard below---the trimmed variants are useless here! }{}\\{}
 \tsholcomm{ Case (6) Segment is completely beyond the window and is not a window probe }{}\\{}
 \Melse  \;\Mif  (\tsvar{seq} < \tsvar{cb}.\tsfield{rcv\_nxt} \Mwedge  \tsvar{seq} + \tsholop{LENGTH} \;\tsvar{data} + (\Mif  \;\tsvar{FIN} \;\Mthen  \;1 \;\Melse  \;0) \leq  \tsvar{cb}.\tsfield{rcv\_nxt}) \Mvee  \tsholcomm{ (4) }{}\\{}
\quad\quad\quad\quad (\tsunknown{seq\_trimmed} = \tsvar{cb}.\tsfield{rcv\_nxt} \Mwedge  \tsvar{cb}.\tsfield{rcv\_wnd} = 0 \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsholop{LENGTH} \;\tsvar{data} + (\Mif  \;\tsvar{FIN} \;\Mthen  \;1 \;\Melse  \;0) > 0) \Mvee  \tsholcomm{ (5) }{}\\{}
\quad\quad\quad\quad \Mtrue  \;\Mthen  \tsholcomm{ (6) }{}\\{}
 {}\\{}
\quad \tsholcomm{ Hack: assertion used to share values with later conditions }{}\\{}
\quad \tsaux{assert} (\tsunknown{FIN\_reass} = \Mfalse ) \tsaux{andThen}  \tscomm{ Definitely false---segment is outside window }{}\\{}
 {}\\{}
\quad \tsholcomm{ Update socket's control block to assert that an $\tsvar{ACK}$ segment should be sent now. }{}\\{}
\quad \tsholcomm{ Source: TCPIPv2p959 says "segment is discarded and an ack is sent as a reply" }{}\\{}
\quad \tsaux{modify\_cb} (\lambda \tsvar{cb}. \tsvar{cb} \; \Mmagiclrec  \tsfield{tf\_shouldacknow} \Mass  \Mtrue  \Mmagicrrec ){}\\{}
 {}\\{}
 \Melse {}\\{}
\quad\quad \tsaux{assert\_failure} \text{``di3\textunderscore{}datastuff''}  \tscomm{ impossible }{}\\{}
 {}\\{}
 ) \tsaux{andThen}{}\\{}
 {}\\{}
 \tsholcomm{ Finished processing the segment's data }{}\\{}
 \tsholcomm{ Thread the reassembled $\tsvar{FIN}$ flag through to $\tsaux{di3\_ststuff}$ }{}\\{}
 \tsunknown{the\_ststuff} \;\tsunknown{FIN\_reass}{}\\{}
 {}\\{}
 ) \tscomm{ chooseM FIN\textunderscore{}reass }{}\\{}
 ) \tscomm{ get\textunderscore{}sock \textbackslash{}sock }}
}
{\rrulepad }
}

\newcommand{\defndiIIITdatastuff}{\ddefnc{diIIITdatastuff}{\iA{di3\_datastuff}}{\subddefnA[{ $\tsrule{deliver\_in\_3}$ data processing }]{di3\_datastuff}{\tsaux{di3\_datastuff} \;\tsunknown{the\_ststuff} \;\tsunknown{tcp\_sock\_0} \;\tsunknown{seg} \;\tsunknown{ourfinisacked} \;\tstype{arch} ={}\\{}
 \tsholcomm{ Pull some fields out of the segment }{}\\{}
 \Mlet  \;\tsvar{ACK}  = \tsunknown{seg}.\tsvar{ACK} \;\Min {}\\{}
 \Mlet  \;\tsvar{FIN}  = \tsunknown{seg}.\tsvar{FIN} \;\Min {}\\{}
 \Mlet  \;\tsvar{PSH}  = \tsunknown{seg}.\tsvar{PSH} \;\Min {}\\{}
 \Mlet  \;\tsvar{URG}  = \tsunknown{seg}.\tsvar{URG} \;\Min {}\\{}
 \Mlet  \;\tsvar{ack}  = \tsunknown{tcp\_seq\_flip\_sense} \;\tsunknown{seg}.\tsvar{ack} \;\Min {}\\{}
 \Mlet  \;\tsvar{urp}  = \tsholop{w2n} \;\tsunknown{seg}.\tsvar{urp} \;\Min {}\\{}
 \Mlet  \;\tsvar{data} = \tsunknown{seg}.\tsvar{data} \;\Min {}\\{}
 \Mlet  \;\tsvar{seq}  = \tsunknown{tcp\_seq\_flip\_sense} \;\tsunknown{seg}.\tsvar{seq} + (\Mif  \;\tsunknown{seg}.\tsvar{SYN} \;\Mthen  \;1 \;\Melse  \;0) \Min {}\\{}
 \Mlet  \;\tsvar{win}  = \tsholop{w2n} \;\tsunknown{seg}.\tsvar{win} \ll  (\tsunknown{tcp\_sock\_0}).\tsvar{cb}.\tsfield{snd\_scale} \;\Min {}\\{}
 {}\\{}
 \tsaux{get\_sock} \lambda  \tsvar{sock}.{}\\{}
 \Mlet  \;\tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsvar{sock} \;\Min {}\\{}
 \Mlet  \;\tsvar{cb} = \tsunknown{tcp\_sock}.\tsvar{cb} \;\Min {}\\{}
 {}\\{}
 \tsholcomm{ Various things
         do not happen if BSD processes the segment using its header prediction
         (fast-path) code. Header prediction occurs only in the $\tscon{ESTABLISHED}$ state, with
         segments that have only $\tsvar{ACK}$ and/or $\tsvar{PSH}$ flags set, are in-order, do not contain a window
         update, when data is not being retransmitted (no congestion is occuring) and either:
         (a) the segment is a valid pure ACK segment of new data, less than three duplcicate
             $\tsvar{ACK}$s have been received and the congestion window is at least as large as the
             send window, or
         (b) the segment contains new data, does not acknowlegdge any new data, the segment
             reassembly queue is empty and there is space for the segment's data in the socket's
             receive buffer.
     }{}\\{}
 \Mlet  \;\tsunknown{bsd\_fast\_path} = ((\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{ESTABLISHED}) \Mwedge  \neg{}\tsunknown{seg}.\tsvar{SYN} \Mwedge  \neg{}\tsvar{FIN} \Mwedge  \neg{}\tsunknown{seg}.\tsvar{RST} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \neg{}\tsvar{URG} \Mwedge  \tsvar{ACK} \Mwedge  \tsvar{seq} = \tsvar{cb}.\tsfield{rcv\_nxt} \Mwedge  \tsvar{cb}.\tsfield{snd\_wnd} = \tsvar{win} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{snd\_max} = \tsvar{cb}.\tsfield{snd\_nxt} \Mwedge  ({}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{ack} > \tsvar{cb}.\tsfield{snd\_una} \Mwedge  \tsvar{ack} \leq  \tsvar{cb}.\tsfield{snd\_max} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{snd\_cwnd} \geq  \tsvar{cb}.\tsfield{snd\_wnd} \Mwedge  \tsvar{cb}.\tsfield{t\_dupacks} < 3){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{ack} = \tsvar{cb}.\tsfield{snd\_una} \Mwedge  \tsvar{cb}.\tsfield{t\_segq} = [\,] \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsholop{LENGTH} \;\tsvar{data}) <{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{sock}.\tsvar{sf}.\tsvar{n}(\tscon{SO\_RCVBUF}) - \tsholop{LENGTH} \;\tsunknown{tcp\_sock}.\tsvar{rcvq})))) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Update the send window using the received segment if the segment will not be processed by
         BSD's fast path, has the $\tsvar{ACK}$ flag set, is not to the right of the window, and either:

        (a) the last window update was from a segment with sequence number less than $\tsvar{seq}$,
            \ie, an older segment than the current segment, or

        (b) the last window update was from a segment with sequence number equal to $\tsvar{seq}$ but
            with an acknowledgement number less than $\tsvar{ack}$, \ie, this segment acknowledges
            newer data than the segment the last window update was taken from, or

        (c) the last window update was from a segment with sequence number equal to
            $\tsvar{seq}$ and acknowledgement number equal to $\tsvar{ack}$, \ie, a segment similar to that
            the previous update came from, but this segment contains a larger window advertisment
            than was previously advertised, or

        (d) this segment is the third segment during connection establishement (state is
            $\tscon{SYN\_RECEIVED}$) and does not have the $\tsvar{FIN}$ flag set. }{}\\{}
 \Mlet  \;\tsunknown{update\_send\_window} = (\neg{}\tsunknown{bsd\_fast\_path} \Mwedge  \tsunknown{seg}.\tsvar{ACK} \Mwedge  \tsvar{seq} \leq  \tsvar{cb}.\tsfield{rcv\_nxt} + \tsvar{cb}.\tsfield{rcv\_wnd} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{cb}.\tsfield{snd\_wl1} < \tsvar{seq} \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{cb}.\tsfield{snd\_wl1} = \tsvar{seq} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{cb}.\tsfield{snd\_wl2} < \tsvar{ack} \Mvee  \tsvar{cb}.\tsfield{snd\_wl2} = \tsvar{ack} \Mwedge  \tsvar{win} > \tsvar{cb}.\tsfield{snd\_wnd})) \Mvee {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge  \neg{}\tsvar{FIN}))) \Min   \tsholcomm{ This replaces BSD's \wasverb{snd\textunderscore{}wl1 := seq-1} hack; should perhaps be $\neg{}\tsunknown{FIN\_reass}$ }{}\\{}
 {}\\{}
 \Mlet  \;\tsunknown{seq\_trimmed} = \tsholop{MAX} \;\tsvar{seq} (\tsholop{MIN} \;\tsvar{cb}.\tsfield{rcv\_nxt} (\tsvar{seq} + \tsholop{LENGTH} \;\tsvar{data})) \Min {}\\{}
 {}\\{}
 \tsholcomm{ Write back the window updates }{}\\{}
 \tsaux{modify\_cb} (\lambda \tsvar{cb}. \tsvar{cb} \; \Mmagiclrec  \tsfield{snd\_wnd} \;\Mupdby  \;\tsvar{win} \;\tsholop{onlywhen} \;\tsunknown{update\_send\_window};{}\\{}
 \tsfield{snd\_wl1} \;\Mupdby  \;\tsunknown{seq\_trimmed} \;\tsholop{onlywhen} \;\tsunknown{update\_send\_window};{}\\{}
 \tsfield{snd\_wl2} \;\Mupdby  \;\tsvar{ack} \;\tsholop{onlywhen} \;\tsunknown{update\_send\_window}{}\\{}
 \tsholcomm{ persist timer will be set by $\tsrule{deliver\_out\_1}$ if this updates the window to zero and there is data to send }{}\\{}
 \Mmagicbolrrec ) \tsaux{andThen}{}\\{}
 {}\\{}
 \tsholcomm{ If in $\tscon{TIME\_WAIT}$ or will transition to it from $\tscon{CLOSING}$, ignore any URG, data, or FIN.
        Note that in $\tscon{FIN\_WAIT\_1}$ or $\tscon{FIN\_WAIT\_2}$, we still process data, even if $\tsunknown{ourfinisacked}$.  }{}\\{}
 \Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{TIME\_WAIT} \Mvee  (\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSING} \Mwedge  \tsunknown{ourfinisacked}) \Mthen {}\\{}
\quad \tsholcomm{ pull along urgent pointer }{}\\{}
\quad \tsaux{modify\_cb} (\lambda \tsvar{cb}. \tsvar{cb} \; \Mmagiclrec  \tsfield{rcv\_up} \Mass  \tsholop{MAX} \;\tsvar{cb}.\tsfield{rcv\_up} \;\tsvar{cb}.\tsfield{rcv\_nxt} \Mmagicrrec ) \tsaux{andThen}{}\\{}
\quad \tsunknown{the\_ststuff} \;\Mfalse {}\\{}
 \Melse {}\\{}
\quad \tsaux{di3\_datastuff\_really} \;\tsunknown{the\_ststuff} \;\tsunknown{tcp\_sock\_0} \;\tsunknown{seg} \;\tsunknown{bsd\_fast\_path} \;\tstype{arch}}
}
{\rrulepad }
}

\newcommand{\defndiIIITststuff}{\ddefnc{diIIITststuff}{\iA{di3\_ststuff}}{\subddefnA[{ $\tsrule{deliver\_in\_3}$ TCP state change processing }]{di3\_ststuff}{\tsaux{di3\_ststuff} \;\tsunknown{FIN\_reass} \;\tsunknown{ourfinisacked} \;\tsvar{ack} ={}\\{}
 {}\\{}
 \tsholcomm{ The entirety of this function is an encoding of the TCP State Transition Diagram (as it is, not as it is traditionally depicted)
        post-$\tscon{SYN\_SENT}$ state. It specifies for given start state and set of conditions (all or
        some of which are affected by the processing of the current segment), which state the TCP
        socket should be moved into next }{}\\{}
 {}\\{}
 \tsholcomm{ Get the TCP socket using the monadic state accessor $\tsaux{get\_cb}$. }{}\\{}
 (\tsaux{get\_sock} \lambda  \tsvar{sock}.{}\\{}
\quad \Mlet  \;\tsvar{cb} = (\tsaux{tcp\_sock\_of} \;\tsvar{sock}).\tsvar{cb} \;\Min  \tsholcomm{ ...and its control block }{}\\{}
 {}\\{}
\quad \tsholcomm{ Several of the encoded transitions (below) require the socket to be moved into the
           $\tscon{TIME\_WAIT}$ state, in which case the \wasverb{2MSL} timer is started, all other timers
           are cancelled and the socket's state is changed to $\tscon{TIME\_WAIT}$. This common idiom is
           defined monadically as a function here }{}\\{}
\quad \Mlet  \;\tsunknown{enter\_TIME\_WAIT} ={}\\{}
\quad\quad \tsaux{modify\_tcp\_sock} (\lambda \tsvar{s}.\tsvar{s} \;{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mmagiclrec  \tsvar{st} \Mass  \tscon{TIME\_WAIT};{}\\{}
 \tsvar{cb} \Mass  \tsvar{s}.\tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsfield{tt\_2msl} \Mass  \Msome  (\Mtimed{()}{\tsaux{slow\_timer} (2*\tsaux{TCPTV\_MSL})});{}\\{}
 \tsfield{tt\_rexmt} \Mass  *;{}\\{}
 \tsfield{tt\_keep} \Mass  *;{}\\{}
 \tsfield{tt\_delack} \Mass  *;{}\\{}
 \tsfield{tt\_conn\_est} \Mass  *;{}\\{}
 \tsfield{tt\_fin\_wait\_2} \Mass  *{}\\{}
 \Mmagicbolrrec {}\\{}
 \Mmagicbolrrec ) \Min {}\\{}
 {}\\{}
 \tsholcomm{ If the processing of the current segment has led to $\tsunknown{FIN\_reass}$ being asserted then the
          whole data stream from the other end has been received and reconstructed, including
          the final $\tsvar{FIN}$ flag. The socket should have its read-half flagged as shut down, \ie,
          $\tsvar{cantrcvmore} = \Mtrue $, otherwise the socket is not modified. }{}\\{}
 (\Mif  \;\tsunknown{FIN\_reass} \;\Mthen {}\\{}
\quad\quad \tsaux{modify\_sock} (\lambda \tsvar{s}.\tsvar{s} \; \Mmagiclrec  \tsvar{cantrcvmore} \Mass  \Mtrue  \Mmagicrrec ){}\\{}
\quad \Melse  \;\tsaux{cont}) \tsaux{andThen}{}\\{}
 {}\\{}
 \tsholcomm{ State Transition Diagram encoding: }{}\\{}
 \tsholcomm{ The state transition encoding, case-split on the current state and whether a $\tsvar{FIN}$ from
          the remote end has been reassembled }{}\\{}
 \Mcase  ((\tsaux{tcp\_sock\_of} \;\tsvar{sock}).\tsvar{st}, \tsunknown{FIN\_reass}) \Mof {}\\{}
 {}\\{}
\quad (\tscon{SYN\_RECEIVED},\Mfalse ) \Mtotype  \tsholcomm{ In $\tscon{SYN\_RECEIVED}$ and have not received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \Mif  \;\tsvar{ack} \geq  \tsvar{cb}.\tsvar{iss} + 1 \;\Mthen {}\\{}
\quad\quad\quad \tsholcomm{ This socket's initial $\tsvar{SYN}$ has been acknowledged }{}\\{}
\quad\quad\quad \tsaux{modify\_tcp\_sock} (\lambda \tsvar{s}. \tsvar{s} \;{}\\{}
\quad\quad\quad\quad\quad \Mmagiclrec  \tsvar{st} \Mass  \Mif  \neg{}\tsvar{sock}.\tsvar{cantsndmore} \;\Mthen {}\\{}
\quad \tscon{ESTABLISHED} \tsholcomm{ socket is now fully connected }{}\\{}
 \Melse {}\\{}
\quad \tsholcomm{ The connecting socket had it's write-half shutdown by $\tslib{shutdown}()$
                               forcing a $\tsvar{FIN}$ to be emitted to the other end }{}\\{}
\quad \Mif  \;\tsunknown{ourfinisacked} \;\Mthen {}\\{}
\quad\quad \tsholcomm{ The emitted $\tsvar{FIN}$ has been acknowledged }{}\\{}
\quad\quad \tscon{FIN\_WAIT\_2}{}\\{}
\quad \Melse {}\\{}
\quad\quad \tsholcomm{ Still waiting for the emitted $\tsvar{FIN}$ to be acknowledged }{}\\{}
\quad\quad \tscon{FIN\_WAIT\_1}{}\\{}
 \Mmagicbolrrec ){}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad \tsholcomm{ Not a valid path }{}\\{}
\quad\quad\quad \tsaux{stop} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{SYN\_RECEIVED},\Mtrue ) \Mtotype   \tsholcomm{ In $\tscon{SYN\_RECEIVED}$ and have received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ Enter the $\tscon{CLOSE\_WAIT}$ state, missing out $\tscon{ESTABLISHED}$ }{}\\{}
\quad\quad \tsaux{modify\_tcp\_sock} (\lambda \tsvar{s}.\tsvar{s} \; \Mmagiclrec  \tsvar{st} \Mass  \tscon{CLOSE\_WAIT} \Mmagicrrec ) \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{ESTABLISHED},\Mfalse )  \Mtotype   \tsholcomm{ In $\tscon{ESTABLISHED}$ and have not received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ Doing common-case data delivery and acknowledgements. Remain in $\tscon{ESTABLISHED}$. }{}\\{}
\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
 {}\\{}
\quad (\tscon{ESTABLISHED},\Mtrue )  \Mtotype   \tsholcomm{ In $\tscon{ESTABLISHED}$ and received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ Move into the $\tscon{CLOSE\_WAIT}$ state }{}\\{}
\quad\quad \tsaux{modify\_tcp\_sock} (\lambda \tsvar{s}.\tsvar{s} \; \Mmagiclrec  \tsvar{st} \Mass  \tscon{CLOSE\_WAIT} \Mmagicrrec ) \Mdpipe {}\\{}
 {}\\{}
 {}\\{}
\quad (\tscon{CLOSE\_WAIT},\Mfalse )   \Mtotype   \tsholcomm{ In $\tscon{CLOSE\_WAIT}$ and have not received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ Do nothing and remain in $\tscon{CLOSE\_WAIT}$. The socket has its receive-side shut down due to
             the $\tsvar{FIN}$ it received previously from the remote end. It can continue to emit
             segments containing data and receive acknowledgements back until such a time that it
             closes down and emits a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{CLOSE\_WAIT},\Mtrue )   \Mtotype   \tsholcomm{ In $\tscon{CLOSE\_WAIT}$ and received (another) $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ The duplicate $\tsvar{FIN}$ will have had a new sequence number to be valid and reach this
             point; RFC793 says "ignore" it so do not change state! If it were a duplicate with the
             same sequence number as the previously accepted $\tsvar{FIN}$, then the $\tsrule{deliver\_in\_3}$
             acknowledgement processing function $\tsaux{di3\_ackstuff}$ would have dropped it. }{}\\{}
\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{FIN\_WAIT\_1},\Mfalse )   \Mtotype   \tsholcomm{ In $\tscon{FIN\_WAIT\_1}$ and have not received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ This socket will have emitted a $\tsvar{FIN}$ to enter $\tscon{FIN\_WAIT\_1}$. }{}\\{}
\quad\quad \Mif  \;\tsunknown{ourfinisacked} \;\Mthen {}\\{}
\quad\quad\quad \tsholcomm{ If this socket's $\tsvar{FIN}$ has been acknowledged, enter state $\tscon{FIN\_WAIT\_2}$ and start
                the $\tscon{FIN\_WAIT\_2}$ timer. The timer ensures that if the other end has gone away
                without emitting a $\tsvar{FIN}$ and does not transmit any more data the socket is closed
                rather left dangling. }{}\\{}
\quad\quad\quad \tsaux{modify\_tcp\_sock} (\lambda \tsvar{s}.\tsvar{s} \;{}\\{}
\quad\quad\quad\quad\quad\quad \Mmagiclrec  \tsvar{st} \Mass  \tscon{FIN\_WAIT\_2};{}\\{}
 \tsvar{cb} \Mass  \tsvar{s}.\tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsfield{tt\_fin\_wait\_2} \;\Mupdby  \;\Msome  (\Mtimed{()}{\tsaux{slow\_timer} \;\tsaux{TCPTV\_MAXIDLE}}){}\\{}
\quad\quad\quad\quad \tsholop{onlywhen} \;\tsvar{sock}.\tsvar{cantrcvmore} \tsholcomm{ believe always true }{}\\{}
 \Mmagicbolrrec {}\\{}
 \Mmagicbolrrec ){}\\{}
 {}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad \tsholcomm{ If this socket's $\tsvar{FIN}$ has not been acknowledged then remain in $\tscon{FIN\_WAIT\_1}$ }{}\\{}
\quad\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{FIN\_WAIT\_1},\Mtrue )   \Mtotype   \tsholcomm{ In $\tscon{FIN\_WAIT\_1}$ and received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \Mif  \;\tsunknown{ourfinisacked} \;\Mthen {}\\{}
\quad\quad\quad \tsholcomm{ ...and this socket's $\tsvar{FIN}$ has been acknowledged then the connection has been
                closed successfully so enter $\tscon{TIME\_WAIT}$. Note: this differs slightly from the
                behaviour of BSD which momentarily enters the $\tscon{FIN\_WAIT\_2}$ and after a little more
                processing enters $\tscon{TIME\_WAIT}$ }{}\\{}
\quad\quad\quad \tsunknown{enter\_TIME\_WAIT}{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad \tsholcomm{ If this socket's $\tsvar{FIN}$ has not been acknowledged then the other end is attempting
                to close the connection simultaneously (a simultaneous close). Move to the
                $\tscon{CLOSING}$ state }{}\\{}
\quad\quad\quad \tsaux{modify\_tcp\_sock} (\lambda \tsvar{s}.\tsvar{s} \; \Mmagiclrec  \tsvar{st} \Mass  \tscon{CLOSING} \Mmagicrrec ) \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{FIN\_WAIT\_2},\Mfalse )   \Mtotype   \tsholcomm{ In $\tscon{FIN\_WAIT\_2}$ and have not received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ This socket has previously emitted a $\tsvar{FIN}$ which has already been acknowledged. It
              can continue to receive data from the other end which it must acknowledge. During
              this time the socket should remain in $\tscon{FIN\_WAIT\_2}$ until such a time that it
              receives a valid $\tsvar{FIN}$ from the remote end, or if no activity occurs on the
              connection the $\tscon{FIN\_WAIT\_2}$ timer will fire, eventually closing the socket }{}\\{}
\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{FIN\_WAIT\_2},\Mtrue )   \Mtotype   \tsholcomm{ In $\tscon{FIN\_WAIT\_2}$ and have received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ Connection has been shutdown so enter $\tscon{TIME\_WAIT}$ }{}\\{}
\quad\quad \tsunknown{enter\_TIME\_WAIT} \Mdpipe {}\\{}
 {}\\{}
 {}\\{}
\quad (\tscon{CLOSING},\Mfalse )      \Mtotype    \tsholcomm{ In $\tscon{CLOSING}$ and have not received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \Mif  \;\tsunknown{ourfinisacked} \;\Mthen {}\\{}
\quad\quad\quad \tsholcomm{ If this socket's $\tsvar{FIN}$ has been acknowledged (common-case), enter $\tscon{TIME\_WAIT}$ as
                the connection has been successfully closed }{}\\{}
\quad\quad\quad \tsunknown{enter\_TIME\_WAIT}{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad \tsholcomm{ Otherwise, the other end has not yet received or processed the $\tsvar{FIN}$ emitted by
                this socket. Remain in the $\tscon{CLOSING}$ state until it does so. Note: if the
                previosuly emitted $\tsvar{FIN}$ is not acknowledged this socket's retransmit timer will
                eventually fire causing retransmission of the $\tsvar{FIN}$. }{}\\{}
\quad\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{CLOSING},\Mtrue )      \Mtotype   \tsholcomm{ In $\tscon{CLOSING}$ and have received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ The received $\tsvar{FIN}$ is a duplicate $\tsvar{FIN}$ with a new sequence number so as per RFC793 is
              ignored -- if it were a duplicate with the same sequence number as the previously
              accepted $\tsvar{FIN}$, then the $\tsrule{deliver\_in\_3}$ acknowledgement processing function
              $\tsaux{di3\_ackstuff}$ would have dropped it. }{}\\{}
\quad\quad\quad \Mif  \;\tsunknown{ourfinisacked} \;\Mthen {}\\{}
\quad\quad\quad\quad \tsholcomm{ If this socket's $\tsvar{FIN}$ has been acknowledged then the connection is now
                 successfully closed, so enter $\tscon{TIME\_WAIT}$ state }{}\\{}
\quad\quad\quad\quad \tsunknown{enter\_TIME\_WAIT}{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad \tsholcomm{ Otherwise, ignore the new $\tsvar{FIN}$ and remain in the same state }{}\\{}
\quad\quad\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{LAST\_ACK},\Mfalse )     \Mtotype   \tsholcomm{ In $\tscon{LAST\_ACK}$ and have not received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ Remain in $\tscon{LAST\_ACK}$ until this socket's $\tsvar{FIN}$ is acknowledged. Note: eventually
              the retransmit timer will fire forcing the $\tsvar{FIN}$ to be retransmitted. }{}\\{}
\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{LAST\_ACK},\Mtrue )     \Mtotype   \tsholcomm{ In $\tscon{LAST\_ACK}$ and have received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ This transition is handled specially at the end of $\tsaux{di3\_newackstuff}$ at which point
              processing stops, thus this transition is not possible }{}\\{}
\quad\quad \tsaux{assert\_failure} \text{``di3\textunderscore{}ststuff''} \tsholcomm{ impossible } \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{TIME\_WAIT},\Mfalse )    \Mtotype   \tsholcomm{ In $\tscon{TIME\_WAIT}$ and have not received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ Remaining in $\tscon{TIME\_WAIT}$ until the \wasverb{2MSL} timer expires }{}\\{}
\quad\quad \tsaux{cont} \Mdpipe {}\\{}
 {}\\{}
\quad (\tscon{TIME\_WAIT},\Mtrue )    \Mtotype   \tsholcomm{ In $\tscon{TIME\_WAIT}$ and have received a $\tsvar{FIN}$ }{}\\{}
\quad\quad \tsholcomm{ Remaining in $\tscon{TIME\_WAIT}$ until the \wasverb{2MSL} timer expires }{}\\{}
\quad\quad \tsaux{cont}{}\\{}
 )}
}
{\rrulepad }
}

\newcommand{\defndiIIITsocksTupdate}{\ddefnc{diIIITsocksTupdate}{\iA{di3\_socks\_update}}{\subddefnA[{ $\tsrule{deliver\_in\_3}$ socket update processing }]{di3\_socks\_update}{\tsaux{di3\_socks\_update} \;\tstype{sid} \;\tsvar{socks} \;\tsvar{socks}' ={}\\{}
 {}\\{}
 \Mlet  \;\tsunknown{sock\_1} = \tsvar{socks} \Mfapply{}{\tstype{sid}} \Min {}\\{}
 \exists \tsunknown{tcp\_sock\_1}.{}\\{}
 \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock\_1}) = \tsunknown{sock\_1}.\tsvar{pr} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Socket $\tsunknown{sock\_1}$ referenced by identifier $\tstype{sid}$ has just finished connection establishement
      and either there is another socket with $\tsunknown{sock\_1}$ on its pending connections queue and this
      is the completion of a passive open, or there is not another socket and this is the completion
      of a simultaneous open. See the inline comment in \ltslink{deliverTinTIII}{$\tsrule{deliver\_in\_3}$} for further
      details. }{}\\{}
 {}\\{}
 \Mlet  \;\tsunknown{interesting} = \lambda \tsvar{sid}'.{}\\{}
\quad\quad \tsvar{sid}' \neq  \tstype{sid} \Mwedge {}\\{}
\quad\quad \Mcase  (\tsvar{socks} \Mfapply{}{\tsvar{sid}'}).\tsvar{pr} \;\Mof {}\\{}
\quad\quad\quad \tscon{UDP\_PROTO} \;\tsunknown{udp\_sock} \Mtotype  \Mfalse {}\\{}
\quad\quad \Mdpipe  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) \Mtotype {}\\{}
\quad\quad\quad\quad \Mcase  \;\tsunknown{tcp\_sock'}.\tsvar{lis} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad * \Mtotype  \Mfalse {}\\{}
\quad\quad\quad\quad \Mdpipe  \Msome  \;\tsvar{lis} \Mtotype {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tstype{sid} \;\in  \;\tsvar{lis}.\tsvar{q}_{0} \;\Min {}\\{}
 {}\\{}
 \Mlet  \;\tsunknown{interesting\_sids} = (\Mfdom{\tsvar{socks}}) \cap  \;\tsunknown{interesting} \;\Min {}\\{}
 {}\\{}
 \Mif  \;\tsunknown{interesting\_sids} \neq  \{\} \Mthen {}\\{}
 \tsholcomm{ There exists another socket $\tsvar{sock}'$ that is listening and has socket $\tsunknown{sock\_1}$ referenced by
          $\tstype{sid}$ on its queue of incomplete connections $\tsvar{lis}.\tsvar{q}_{0}$. }{}\\{}
 \exists \tsvar{sid}' \;\tsvar{sock}' \;\tsunknown{tcp\_sock'} \;\tsvar{lis} \;\tsvar{q0L} \;\tsvar{q0R}.{}\\{}
 \tsvar{sid}' \;\in  \;\tsunknown{interesting\_sids} \Mwedge {}\\{}
 \tsvar{sock}' = \tsvar{socks} \Mfapply{}{\tsvar{sid}'} \Mwedge {}\\{}
 \tsvar{sock}'.\tsvar{pr} = \tscon{TCP\_PROTO} \;\tsunknown{tcp\_sock'} \Mwedge {}\\{}
 \tsvar{sid}' \neq  \tstype{sid} \Mwedge {}\\{}
 \tsunknown{tcp\_sock'}.\tsvar{lis} = \Msome  \;\tsvar{lis} \Mwedge {}\\{}
 \tsvar{lis}.\tsvar{q}_{0} = \Mappend{\tsvar{q0L}}{(\tstype{sid} \Mcons  \tsvar{q0R})} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Choose non-deterministically whether there is room on the queue of completed connections }{}\\{}
 \tsholop{choose} \;\tsunknown{ok} \Mcons  \tsaux{accept\_incoming\_q} \;\tsvar{lis}.{}\\{}
 {}\\{}
 \Mif  \;\tsunknown{ok} \;\Mthen {}\\{}
\quad \tsholcomm{ If there is room, then remove socket $\tstype{sid}$ from the queue of incomplete connections
            and add it to the queue of completed connections. }{}\\{}
\quad \Mlet  \;\tsvar{lis}' = \tsvar{lis} \; \Mmagiclrec  \tsvar{q}_{0} \Mass  \Mappend{\tsvar{q0L}}{\tsvar{q0R}};{}\\{}
 \tsvar{q} \Mass  \tstype{sid} \Mcons  \tsvar{lis}.\tsvar{q} \Mmagicrrec  \Min {}\\{}
 {}\\{}
\quad \tsholcomm{ Update the newly connected sockets receive window }{}\\{}
\quad \Mlet  \;\tsunknown{rcv\_window} = \tsaux{calculate\_bsd\_rcv\_wnd} \;\tsunknown{sock\_1}.\tsvar{sf} \;\tsunknown{tcp\_sock\_1} \;\Min {}\\{}
\quad \tsholcomm{ BSD bug - $\tsfield{rcv\_adv}$ gets incorrectly set using the old value of $\tsfield{rcv\_wnd}$, as this is done
                     by the syncache, which is called from \wasverb{tcp\textunderscore{}input()} before the $\tsfield{rcv\_wnd}$ update
                     takes place. Note that we have the following:
                     \wasverb{SYN\textunderscore{}SENT-\textgreater{}ESTABLISHED =\textgreater{}} update $\tsfield{rcv\_wnd}$ then $\tsfield{rcv\_adv}$
                     \wasverb{SYN\textunderscore{}RCVD-\textgreater{}ESTABLISHED =\textgreater{}} update $\tsfield{rcv\_adv}$ then $\tsfield{rcv\_wnd}$ }{}\\{}
\quad \Mlet  \;\tsvar{cb}' = \tsunknown{tcp\_sock\_1}.\tsvar{cb} \; \Mmagiclrec  \tsfield{rcv\_wnd} \Mass  \tsunknown{rcv\_window};{}\\{}
 \tsfield{rcv\_adv} \Mass  \tsunknown{tcp\_sock\_1}.\tsvar{cb}.\tsfield{rcv\_nxt} + \tsunknown{tcp\_sock\_1}.\tsvar{cb}.\tsfield{rcv\_wnd} \Mmagicrrec  \Min {}\\{}
 {}\\{}
\quad \tsholcomm{ Update both the newly connected socket and the listening socket }{}\\{}
\quad \tsvar{socks}' = \tsvar{socks} \oplus {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad [(\tstype{sid}, \tsunknown{sock\_1} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock\_1} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}' \Mmagicrrec ) \Mmagicrrec );{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{sid}', \tsvar{sock}' \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'} \; \Mmagiclrec  \tsvar{lis} \Mass  \Msome  \;\tsvar{lis}' \Mmagicrrec ) \Mmagicrrec )]{}\\{}
 \Melse {}\\{}
\quad \tsholcomm{ ...otherwise there is no room on the listening socket's completed connections queue, so
           drop the newly connected socket and remove it from the listening socket's queue of
           incomplete connections. Note: the dropped connection is not sent a $\tsvar{RST}$ but a $\tsvar{RST}$
           is sent upon receipt of further segments from the other end as the socket entry has gone
           away. }{}\\{}
\quad \tscomm{ Note that the above note needs to be verified by testing. }{}\\{}
\quad \Mlet  \;\tsvar{lis}' = \tsvar{lis} \; \Mmagiclrec  \tsvar{q}_{0} \Mass  \Mappend{\tsvar{q0L}}{\tsvar{q0R}} \Mmagicrrec  \Min {}\\{}
\quad \tsvar{socks}' = \tsvar{socks} \oplus  (\tsvar{sid}', \tsvar{sock}' \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'} \; \Mmagiclrec  \tsvar{lis} \Mass  \Msome  \;\tsvar{lis}' \Mmagicrrec ) \Mmagicrrec ){}\\{}
 {}\\{}
 \Melse {}\\{}
 \tsholcomm{ There is no such socket with socket $\tstype{sid}$ on its queue of incomplete connections, thus
         socket $\tstype{sid}$ was involved in a simultaneous open. Do not update any socket. }{}\\{}
 \tsvar{socks}' = \tsvar{socks}}
}
{\rrulepad }
}

\newcommand{\deliverTinTIIIa}{\rrulecn{deliverTinTIIIa}{deliver\_in\_3a}{tcp: network nonurgent}{\tsholcomm{ Receive data with invalid checksum or offset }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks};{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks};{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec }
{\tsholcomm{
    \textbf{Summary:}
    This rule is a placeholder for the case where a received segment has an invalid checksum or offset, in which case implementations should drop it on the floor.  The model of TCP segments does not contain checksum or offset, however, hence the $\Mfalse $ below.
    }{}\\{}
 {}\\{}
 \tsvar{sid} \;\in  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 \tsunknown{sock\_0} = \tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
 \tsunknown{sock\_0}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsunknown{sock\_0}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge  \tsunknown{sock\_0}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsunknown{sock\_0}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2} \Mwedge {}\\{}
 \tsunknown{sock\_0}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock\_0}) \Mwedge {}\\{}
 {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 {}\\{}
 (\exists \tsunknown{win\_} \;\tsunknown{urp\_} \;\tsunknown{ws\_discard} \;\tsunknown{mss\_discard}.{}\\{}
 \tsvar{win} = \tsholop{w2n} \;\tsunknown{win\_} \ll  \tsunknown{tcp\_sock\_0}.\tsvar{cb}.\tsfield{snd\_scale} \Mwedge {}\\{}
 \tsvar{urp} = \tsholop{w2n} \;\tsunknown{urp\_} \Mwedge {}\\{}
 \tsvar{seg} = \Mmagiclrec {}\\{}
 \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{seq}:\tsaux{tcp\_seq\_foreign});{}\\{}
 \tsvar{ack}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{ack}:\tsaux{tcp\_seq\_local});{}\\{}
 \tsvar{URG}  \Mass  \tsvar{URG};{}\\{}
 \tsvar{ACK}  \Mass  \tsvar{ACK};{}\\{}
 \tsvar{PSH}  \Mass  \tsvar{PSH};{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mfalse ;{}\\{}
 \tsvar{FIN}  \Mass  \tsvar{FIN};{}\\{}
 \tsvar{win}  \Mass  \tsunknown{win\_};{}\\{}
 \tsvar{ws}   \Mass  \tsunknown{ws\_discard};{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_};{}\\{}
 \tsvar{mss}  \Mass  \tsunknown{mss\_discard};{}\\{}
 \tsvar{ts}   \Mass  \tsvar{ts};{}\\{}
 \tsvar{data} \Mass  \tsvar{data}{}\\{}
 \Mmagicbolrrec ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Note that there does not exist a better socket match to which the segment should be sent, as the whole quad is matched exactly }{}\\{}
 {}\\{}
 \tsunknown{tcp\_sock\_0}.\tsvar{st} \;\notin  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT}\} \Mwedge   {}\\{}
 \tsunknown{tcp\_sock\_0}.\tsvar{st} \;\in  \{\tscon{SYN\_RECEIVED};\tscon{ESTABLISHED};\tscon{CLOSE\_WAIT};\tscon{FIN\_WAIT\_1};\tscon{FIN\_WAIT\_2};{}\\{}
\quad\quad\quad\quad\quad \tscon{CLOSING};\tscon{LAST\_ACK};\tscon{TIME\_WAIT}\} \Mwedge   {}\\{}
 {}\\{}
 \Mfalse   \tsholcomm{ invalid checksum or offset }}
{}
}

\newcommand{\deliverTinTIIIb}{\rrulecn{deliverTinTIIIb}{deliver\_in\_3b}{tcp: network nonurgent}{\tsholcomm{ Receive data after process has gone away }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks};{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks}';{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm}' \Mmagicrrec }
{\tsholcomm{ \textbf{Summary:} if data arrives after the process associated with a socket has gone away,  close socket and emit RST segment. }{}\\{}
 {}\\{}
 \tsvar{sid} \;\in  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 \tsunknown{sock\_0} = \tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
 \tsunknown{sock\_0}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsunknown{sock\_0}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge  \tsunknown{sock\_0}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsunknown{sock\_0}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2} \Mwedge {}\\{}
 \tsunknown{sock\_0}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock\_0}) \Mwedge {}\\{}
 {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 {}\\{}
 (\exists \tsunknown{win\_} \;\tsunknown{urp\_} \;\tsunknown{ws\_discard} \;\tsunknown{mss\_discard}.{}\\{}
 \tsvar{win} = \tsholop{w2n} \;\tsunknown{win\_} \ll  \tsunknown{tcp\_sock\_0}.\tsvar{cb}.\tsfield{snd\_scale} \Mwedge {}\\{}
 \tsvar{urp} = \tsholop{w2n} \;\tsunknown{urp\_} \Mwedge {}\\{}
 \tsvar{seg} = \Mmagiclrec {}\\{}
 \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{seq}:\tsaux{tcp\_seq\_foreign});{}\\{}
 \tsvar{ack}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{ack}:\tsaux{tcp\_seq\_local});{}\\{}
 \tsvar{URG}  \Mass  \tsvar{URG};{}\\{}
 \tsvar{ACK}  \Mass  \tsvar{ACK};{}\\{}
 \tsvar{PSH}  \Mass  \tsvar{PSH};{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mfalse ;{}\\{}
 \tsvar{FIN}  \Mass  \tsvar{FIN};{}\\{}
 \tsvar{win}  \Mass  \tsunknown{win\_};{}\\{}
 \tsvar{ws}   \Mass  \tsunknown{ws\_discard};{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_};{}\\{}
 \tsvar{mss}  \Mass  \tsunknown{mss\_discard};{}\\{}
 \tsvar{ts}   \Mass  \tsvar{ts};{}\\{}
 \tsvar{data} \Mass  \tsvar{data}{}\\{}
 \Mmagicbolrrec ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Note that there does not exist a better socket match to which the segment should be sent, as the whole quad is matched exactly. }{}\\{}
 {}\\{}
 \tsholcomm{ test that this is data arriving after process has gone away }{}\\{}
 \tsunknown{tcp\_sock\_0}.\tsvar{st} \;\in  \{\tscon{FIN\_WAIT\_1}; \tscon{CLOSING}; \tscon{LAST\_ACK}; \tscon{FIN\_WAIT\_2}; \tscon{TIME\_WAIT}\} \Mwedge {}\\{}
 \tsunknown{sock\_0}.\tstype{fid} = * \Mwedge   {}\\{}
 \tsvar{seq} + \tsholop{LENGTH} \;\tsvar{data} > \tsunknown{tcp\_sock\_0}.\tsvar{cb}.\tsfield{rcv\_nxt} \Mwedge   {}\\{}
 {}\\{}
 \tsholcomm{ close socket and emit RST segment }{}\\{}
 \tsvar{socks}' = \tsvar{socks} \oplus  (\tsvar{sid},\tsaux{tcp\_close} \;\tsvar{h}.\tstype{arch} \;\tsunknown{sock\_0}) \Mwedge {}\\{}
 \tsaux{dropwithreset\_ignore\_fail} \;\tsvar{seg} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{h}.\tsvar{rttab} (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}){}\\{}
\quad\quad \tscon{BANDLIM\_UNLIMITED} \;\tsvar{bndlm} \;\tsvar{bndlm}' \;\tsvar{outsegs} \Mwedge {}\\{}
 \tsaux{enqueue\_oq\_list\_qinfo}(\tsvar{oq},\tsvar{outsegs},\tsvar{oq}')}
{}
}

\newcommand{\deliverTinTIIIc}{\rrulecn{deliverTinTIIIc}{deliver\_in\_3c}{tcp: network nonurgent}{\tsholcomm{ Receive stupid ACK or LAND DoS in $\tscon{SYN\_RECEIVED}$ state }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks};{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks}';{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm}' \Mmagicrrec }
{\tsholcomm{ \textbf{Summary:} if we receive a stupid ACK or a LAND DoS in $\tscon{SYN\_RECEIVED}$ state
    then update timers and emit a RST appropriately. }{}\\{}
 {}\\{}
 \tsvar{sid} \;\in  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 \tsunknown{sock\_0} = \tsvar{socks} \Mfapply{}{\tsvar{sid}} \Mwedge {}\\{}
 \tsunknown{sock\_0}.\tsvar{is}_{1} = \Msome  \;\tsvar{i}_{1} \Mwedge  \tsunknown{sock\_0}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1} \Mwedge  \tsunknown{sock\_0}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsunknown{sock\_0}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2} \Mwedge {}\\{}
 \tsunknown{sock\_0}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock\_0}) \Mwedge {}\\{}
 {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 {}\\{}
 (\exists \tsunknown{win\_} \;\tsunknown{urp\_} \;\tsunknown{ws\_discard} \;\tsunknown{mss\_discard}.{}\\{}
 \tsvar{win} = \tsholop{w2n} \;\tsunknown{win\_} \ll  \tsunknown{tcp\_sock\_0}.\tsvar{cb}.\tsfield{snd\_scale} \Mwedge {}\\{}
 \tsvar{urp} = \tsholop{w2n} \;\tsunknown{urp\_} \Mwedge {}\\{}
 \tsvar{seg} = \Mmagiclrec {}\\{}
 \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{seq}:\tsaux{tcp\_seq\_foreign});{}\\{}
 \tsvar{ack}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{ack}:\tsaux{tcp\_seq\_local});{}\\{}
 \tsvar{URG}  \Mass  \tsvar{URG};{}\\{}
 \tsvar{ACK}  \Mass  \tsvar{ACK};{}\\{}
 \tsvar{PSH}  \Mass  \tsvar{PSH};{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mfalse ;{}\\{}
 \tsvar{FIN}  \Mass  \tsvar{FIN};{}\\{}
 \tsvar{win}  \Mass  \tsunknown{win\_};{}\\{}
 \tsvar{ws}   \Mass  \tsunknown{ws\_discard};{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_};{}\\{}
 \tsvar{mss}  \Mass  \tsunknown{mss\_discard};{}\\{}
 \tsvar{ts}   \Mass  \tsvar{ts};{}\\{}
 \tsvar{data} \Mass  \tsvar{data}{}\\{}
 \Mmagicbolrrec ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Note that there does not exist a better socket match to which the segment should be sent, as the whole quad is matched exactly. }{}\\{}
 {}\\{}
 \tsholcomm{ test for stupid ACK in $\tscon{SYN\_RECEIVED}$, and for LAND DoS attack }{}\\{}
 \tsunknown{tcp\_sock\_0}.\tsvar{st} = \tscon{SYN\_RECEIVED} \Mwedge {}\\{}
 ((\tsvar{ACK} \Mwedge  (\tsvar{ack} \leq  \tsunknown{tcp\_sock\_0}.\tsvar{cb}.\tsfield{snd\_una} \Mvee  \tsvar{ack} > \tsunknown{tcp\_sock\_0}.\tsvar{cb}.\tsfield{snd\_max})) \Mvee   {}\\{}
 \tsvar{seq} < \tsunknown{tcp\_sock\_0}.\tsvar{cb}.\tsvar{irs}) \Mwedge   {}\\{}
 {}\\{}
 \tsholcomm{ incoming segment; update timers }{}\\{}
 \Mlet  (\tsunknown{t\_idletime'},\tsunknown{tt\_keep'},\tsunknown{tt\_fin\_wait\_2'}) = \tsaux{update\_idle} \;\tsunknown{tcp\_sock\_0} \;\Min {}\\{}
 \Mlet  \;\tsunknown{tcp\_sock'} = \tsunknown{tcp\_sock\_0} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsunknown{tcp\_sock\_0}.\tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsfield{t\_idletime} \Mass  \tsunknown{t\_idletime'};{}\\{}
 \tsfield{tt\_keep} \Mass  \tsunknown{tt\_keep'};{}\\{}
 \tsfield{tt\_fin\_wait\_2} \Mass  \tsunknown{tt\_fin\_wait\_2'} \Mmagicrrec  \Mmagicrrec  \Min {}\\{}
 \tsvar{socks}' = \tsvar{socks} \oplus  (\tsvar{sid},\tsunknown{sock\_0} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) \Mmagicrrec ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ emit RST. See \ltslink{dropwithresetTignoreTfail}{$\tsaux{dropwithreset\_ignore\_fail}$} and \ltslink{enqueueToqTlistTqinfo}{$\tsaux{enqueue\_oq\_list\_qinfo}$}. }{}\\{}
 \tsaux{dropwithreset\_ignore\_fail} \;\tsvar{seg} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{h}.\tsvar{rttab} (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}){}\\{}
\quad\quad \tscon{BANDLIM\_UNLIMITED} \;\tsvar{bndlm} \;\tsvar{bndlm}' \;\tsvar{outsegs} \Mwedge {}\\{}
 \tsaux{enqueue\_oq\_list\_qinfo}(\tsvar{oq},\tsvar{outsegs},\tsvar{oq}')}
{}
}

\newcommand{\deliverTinTIV}{\rrulecn{deliverTinTIV}{deliver\_in\_4}{tcp: network nonurgent}{\tsholcomm{ Receive and drop (silently) a non-sane or martian segment }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec }
{\tsholcomm{ \textbf{Summary:}
   Receive and drop any segment for this host that does not have sensible checksum or offset fields,
   or one that originates from a martian address.  The first part of this condition is a
   placeholder, awaiting the day when we switch to a non-lossy segment representation, hence the
   $\Mfalse $.
   }{}\\{}
 {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 \tsvar{seg}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge   {}\\{}
 \tsvar{is}_{1} = \tsvar{seg}.\tsvar{is}_{1} \Mwedge {}\\{}
 \tsvar{i}_{2} \;\in  \;\tsaux{local\_ips}(\tsvar{h}.\tsvar{ifds}) \Mwedge   {}\\{}
 (\Mfalse  \Mvee                   \tsholcomm{ placeholder for segment checksum and offset field not sensible }{}\\{}
 \neg{}( {}\\{}
\quad \Mtrue  \Mwedge   \tsholcomm{ placeholder for not a link-layer multicast or broadcast }{}\\{}
\quad \neg{}(\tsaux{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{2}) \Mwedge   \tsholcomm{ seems unlikely, since $\tsvar{i}_{1} \;\in  \;\tsaux{local\_ips} \;\tsvar{h}.\tsvar{ifds}$ }{}\\{}
\quad \neg{}(\tsvar{is}_{1} = *) \Mwedge {}\\{}
\quad \neg{}\tsaux{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} (\tsholop{THE} \;\tsvar{is}_{1}){}\\{}
 ){}\\{}
 )}
{}
}

\newcommand{\deliverTinTV}{\rrulecc{deliverTinTV}{deliver\_in\_5}{tcp: network nonurgent}{\tsholcomm{ Receive and drop (maybe with RST) a sane segment that does not match any socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq} ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec \tsvar{iq} \Mass  \tsvar{iq}' ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm}' \Mmagicrrec }
{\tsholcomm{ \textbf{Summary:}
   Receive and drop any segment for this host that does not match any sockets (but does have
   sensible checksum and offset fields). Typically, generate RST in response, computing $\tsvar{ack}$ and $\tsvar{seq}$ to supposedly  make the other
   end see this as an 'acceptable ack'.
   }{}\\{}
 {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 {}\\{}
 \tsvar{seg}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{1} \Mwedge   \tsvar{i}_{1} \;\in  \;\tsaux{local\_ips}(\tsvar{h}.\tsvar{ifds}) \Mwedge   {}\\{}
 \tsvar{seg}.\tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{1} \Mwedge {}\\{}
 \tsvar{seg}.\tsvar{is}_{1} \neq  * \Mwedge  \tsvar{seg}.\tsvar{ps}_{1} \neq  * \Mwedge {}\\{}
 {}\\{}
 \Mtrue  \Mwedge                                               \tsholcomm{ placeholder for segment checksum and offset field sensible }{}\\{}
 {}\\{}
 \neg{}(\exists  ((\tstype{sid},\tsunknown{sock}) \Mcons  \tsvar{h}.\tsvar{socks}) \tsunknown{tcp\_sock}.{}\\{}
\quad\quad \tsunknown{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad\quad \tsaux{match\_score} (\tsunknown{sock}.\tsvar{is}_{1}, \tsunknown{sock}.\tsvar{ps}_{1}, \tsunknown{sock}.\tsvar{is}_{2}, \tsunknown{sock}.\tsvar{ps}_{2}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad (\tsholop{THE} \;\tsvar{seg}.\tsvar{is}_{1}, \tsvar{seg}.\tsvar{ps}_{1}, \tsholop{THE} \;\tsvar{seg}.\tsvar{is}_{2}, \tsvar{seg}.\tsvar{ps}_{2}) > 0{}\\{}
\quad ) \Mwedge  {}\\{}
 {}\\{}
 \tsaux{dropwithreset} \;\tsvar{seg} \;\tsvar{h}.\tsvar{ifds} (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}) \tscon{BANDLIM\_RST\_CLOSEDPORT} \;\tsvar{bndlm} \;\tsvar{bndlm}' \;\tsvar{outsegs}' \Mwedge {}\\{}
 \tsaux{enqueue\_and\_ignore\_fail} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{outsegs}' \;\tsvar{oq} \;\tsvar{oq}'}
{\rrulepad }
}

\newcommand{\deliverTinTVI}{\rrulecn{deliverTinTVI}{deliver\_in\_6}{tcp: network nonurgent}{\tsholcomm{ Receive and drop (silently) a sane segment that matches a $\tscon{CLOSED}$ socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec }
{\tsholcomm{ \textbf{Summary:}
   Receive and drop any segment for this host that does not match any sockets (but does have
   sensible checksum or offset fields).

   Note that pathological segments where $\tsvar{is}_{1}$, $\tsvar{ps}_{1}$, or $\tsvar{ps}_{2}$ are not set in the segment are
   not dealt with here but need to be.  }{}\\{}
 {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 (\exists  ((\tstype{sid},\tsunknown{sock}) \Mcons  \tsvar{h}.\tsvar{socks}) \tsunknown{tcp\_sock}.{}\\{}
\quad\quad \tsunknown{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad\quad \tsaux{match\_score} (\tsunknown{sock}.\tsvar{is}_{1}, \tsunknown{sock}.\tsvar{ps}_{1}, \tsunknown{sock}.\tsvar{is}_{2}, \tsunknown{sock}.\tsvar{ps}_{2}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad (\tsholop{THE} \;\tsvar{seg}.\tsvar{is}_{1}, \tsvar{seg}.\tsvar{ps}_{1}, \tsholop{THE} \;\tsvar{seg}.\tsvar{is}_{2}, \tsvar{seg}.\tsvar{ps}_{2}) > 0 \Mwedge {}\\{}
\quad\quad \tsaux{tcp\_socket\_best\_match} \;\tsvar{h}.\tsvar{socks} (\tstype{sid},\tsunknown{sock}) \tsvar{seg} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
\quad\quad \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSED}) \Mwedge {}\\{}
\quad\quad \tsvar{seg}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{1} \Mwedge   \tsvar{i}_{1} \;\in  \;\tsaux{local\_ips}(\tsvar{h}.\tsvar{ifds}) \Mwedge   {}\\{}
\quad\quad \Mtrue  \tsholcomm{ placeholder for segment checksum and offset field sensible }}
{}
}

\newcommand{\deliverTinTVII}{\rrulecn{deliverTinTVII}{deliver\_in\_7}{tcp: network nonurgent}{\tsholcomm{ Receive RST and zap non-$\{\tscon{CLOSED}$; $\tscon{LISTEN}$; $\tscon{SYN\_SENT}$; $\tscon{SYN\_RECEIVED}$; $\tscon{TIME\_WAIT}\}$ socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{{\tsvar{ts}}_{\tsvar{st}}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ts} \Mass  \Mfupdate{\tsvar{ts}}{\tsvar{tid}}{\Mtimed{{\tsvar{ts}}_{\tsvar{st}}}{\tsvar{d}}};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec }
{\tsholcomm{ \textbf{Summary:} receive RST and silently zap non-$\{\tscon{CLOSED}$; $\tscon{LISTEN}$; $\tscon{SYN\_SENT}$; $\tscon{SYN\_RECEIVED}$; $\tscon{TIME\_WAIT}\}$ socket }{}\\{}
 {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 \tsvar{st} \;\notin  \{\tscon{CLOSED}; \tscon{LISTEN}; \tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}; \tscon{TIME\_WAIT}\} \Mwedge {}\\{}
 {}\\{}
 (\exists \tsunknown{seq\_discard} \;\tsunknown{ack\_discard} \;\tsunknown{URG\_discard} \;\tsunknown{ACK\_discard} \;\tsunknown{PSH\_discard} \;\tsunknown{SYN\_discard} \;\tsunknown{FIN\_discard}{}\\{}
\quad \tsunknown{win\_discard} \;\tsunknown{ws\_discard} \;\tsunknown{urp\_discard} \;\tsunknown{mss\_discard} \;\tsunknown{ts\_discard} \;\tsunknown{data\_discard}.{}\\{}
 \tsvar{seg} = \Mmagiclrec {}\\{}
 \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsunknown{seq\_discard}:\tsaux{tcp\_seq\_foreign});{}\\{}
 \tsvar{ack}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsunknown{ack\_discard}:\tsaux{tcp\_seq\_local});{}\\{}
 \tsvar{URG}  \Mass  \tsunknown{URG\_discard};{}\\{}
 \tsvar{ACK}  \Mass  \tsunknown{ACK\_discard};{}\\{}
 \tsvar{PSH}  \Mass  \tsunknown{PSH\_discard};{}\\{}
 \tsvar{RST}  \Mass  \Mtrue ;{}\\{}
 \tsvar{SYN}  \Mass  \tsunknown{SYN\_discard};{}\\{}
 \tsvar{FIN}  \Mass  \tsunknown{FIN\_discard};{}\\{}
 \tsvar{win}  \Mass  \tsunknown{win\_discard};{}\\{}
 \tsvar{ws}   \Mass  \tsunknown{ws\_discard};{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_discard};{}\\{}
 \tsvar{mss}  \Mass  \tsunknown{mss\_discard};{}\\{}
 \tsvar{ts}   \Mass  \tsunknown{ts\_discard};{}\\{}
 \tsvar{data} \Mass  \tsunknown{data\_discard}{}\\{}
 \Mmagicbolrrec {}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 ( \tsholcomm{ $\tsvar{sock}.\tsvar{st} \;\in  \{\tscon{CLOSED}; \tscon{LISTEN}; \tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}; \tscon{TIME\_WAIT}\}$
          excluded already above }{}\\{}
 \Mif  \;\tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}; \tscon{CLOSE\_WAIT}\} \Mthen {}\\{}
\quad\quad \tsvar{err} = \Msome  \;\tscon{ECONNRESET}{}\\{}
 \Melse  \tsholcomm{ $\tsvar{sock}.\tsvar{st} \;\in  \{\tscon{CLOSING}; \tscon{LAST\_ACK}\}$ -- leave existing error }{}\\{}
\quad\quad \tsvar{err} = \tsvar{sock}.\tsvar{es}) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ see \ltslink{tcpTclose}{$\tsaux{tcp\_close}$} }{}\\{}
 \tsvar{sock}' = \tsaux{tcp\_close} \;\tsvar{h}.\tstype{arch} (\tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \tsvar{err} \Mmagicrrec  ){}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 }
{}
}

\newcommand{\deliverTinTVIIa}{\rrulecc{deliverTinTVIIa}{deliver\_in\_7a}{tcp: network nonurgent}{\tsholcomm{ Receive RST and zap $\tscon{SYN\_RECEIVED}$ socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  \tsunknown{socks\_update'};{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec }
{\tsholcomm{ \textbf{Summary:} receive RST and zap $\tscon{SYN\_RECEIVED}$ socket, removing from listen queue etc. }{}\\{}
 {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 {}\\{}
 (\exists \tsunknown{seq\_discard} \;\tsunknown{ack\_discard} \;\tsunknown{URG\_discard} \;\tsunknown{ACK\_discard} \;\tsunknown{PSH\_discard} \;\tsunknown{SYN\_discard} \;\tsunknown{FIN\_discard}{}\\{}
 \tsunknown{win\_discard} \;\tsunknown{ws\_discard} \;\tsunknown{urp\_discard} \;\tsunknown{mss\_discard} \;\tsunknown{ts\_discard} \;\tsunknown{data\_discard}.{}\\{}
 \tsvar{seg} = \Mmagiclrec {}\\{}
 \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsunknown{seq\_discard}:\tsaux{tcp\_seq\_foreign});{}\\{}
 \tsvar{ack}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsunknown{ack\_discard}:\tsaux{tcp\_seq\_local});{}\\{}
 \tsvar{URG}  \Mass  \tsunknown{URG\_discard};{}\\{}
 \tsvar{ACK}  \Mass  \tsunknown{ACK\_discard};{}\\{}
 \tsvar{PSH}  \Mass  \tsunknown{PSH\_discard};{}\\{}
 \tsvar{RST}  \Mass  \Mtrue ;{}\\{}
 \tsvar{SYN}  \Mass  \tsunknown{SYN\_discard};{}\\{}
 \tsvar{FIN}  \Mass  \tsunknown{FIN\_discard};{}\\{}
 \tsvar{win}  \Mass  \tsunknown{win\_discard};{}\\{}
 \tsvar{ws}   \Mass  \tsunknown{ws\_discard};{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_discard};{}\\{}
 \tsvar{mss}  \Mass  \tsunknown{mss\_discard};{}\\{}
 \tsvar{ts}   \Mass  \tsunknown{ts\_discard};{}\\{}
 \tsvar{data} \Mass  \tsunknown{data\_discard}{}\\{}
 \Mmagicbolrrec {}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsvar{sid} \;\notin  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{SYN\_RECEIVED},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 {}\\{}
 ( \tsholcomm{ There is a corresponding listening socket -- passive open }{}\\{}
 (\exists (\tsvar{sid}',\tsunknown{lsock}) \Mcons  \tsvar{socks} \backslash{}\backslash{} \tsvar{sid}.{}\\{}
 \exists \tsunknown{tcp\_lsock} \;\tsvar{lis} \;\tsvar{q0L} \;\tsvar{q0R} \;\tsvar{lsock}'.{}\\{}
\quad \tsunknown{lsock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_lsock}) \Mwedge {}\\{}
\quad \tsunknown{tcp\_lsock}.\tsvar{st} = \tscon{LISTEN} \Mwedge {}\\{}
\quad \tsunknown{tcp\_lsock}.\tsvar{lis} = \Msome  \;\tsvar{lis} \Mwedge {}\\{}
\quad \tsvar{lis}.\tsvar{q}_{0} = \Mappend{\tsvar{q0L}}{(\tsvar{sid} \Mcons  \tsvar{q0R})} \Mwedge {}\\{}
\quad \tsvar{lsock}' = \tsunknown{lsock} \;{}\\{}
\quad\quad \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_lsock} \; \Mmagiclrec  \tsvar{lis} \Mass {}\\{}
 \Msome  (\tsvar{lis} \; \Mmagiclrec  \tsvar{q}_{0} \Mass  \Mappend{\tsvar{q0L}}{\tsvar{q0R}} \Mmagicrrec ) \Mmagicrrec ) \Mmagicrrec  \Mwedge   {}\\{}
\quad \tsunknown{socks\_update'} = [(\tsvar{sid}',\tsvar{lsock}'); (\tsvar{sid},\tsvar{sock}')]{}\\{}
 ) \Mvee {}\\{}
 ( \tsholcomm{ No corresponding socket -- simultaneous open }{}\\{}
 \tsunknown{socks\_update'} = [(\tsvar{sid},\tsvar{sock}')] )) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ We do not delete the socket entry here because of simultaneous opens.
    Keep existing error for $\tscon{SYN\_RECEIVED}$ socket on RST }{}\\{}
 \tsvar{sock}' = (\tsaux{tcp\_close} \;\tsvar{h}.\tstype{arch} \;\tsvar{sock})  \Mmagiclrec  \tsvar{ps}_{1} \Mass  \Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;* \;\Melse  \;\tsvar{sock}.\tsvar{ps}_{1} \Mmagicrrec }
{\rrulepad }
}

\newcommand{\deliverTinTVIIb}{\rrulecn{deliverTinTVIIb}{deliver\_in\_7b}{tcp: network nonurgent}{\tsholcomm{ Receive RST and ignore for $\tscon{LISTEN}$ socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec }
{\tsholcomm{ \textbf{Summary:} receive RST and ignore for $\tscon{LISTEN}$ socket }{}\\{}
 {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\tsvar{is}_{1},\Msome  \;\tsvar{p}_{1},\tsvar{is}_{2},\tsvar{ps}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{LISTEN},\tsvar{cb},\tsvar{lis},\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ BSD listen bug -- since we can call $\tslib{listen}()$ from any state, the peer IP/port may have been set }{}\\{}
 ((\tsvar{is}_{2} = * \Mwedge  \tsvar{ps}_{2} = *) \Mvee {}\\{}
 (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{ps}_{2} = \Msome  \;\tsvar{p}_{2})) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 \tsvar{i}_{1} \;\in  \;\tsaux{local\_ips} \;\tsvar{h}.\tsvar{ifds} \Mwedge {}\\{}
 \Mtrue  \Mwedge   \tsholcomm{ placeholder for not a link-layer multicast or broadcast }{}\\{}
 \tsholcomm{ seems unlikely, since $\tsvar{i}_{1} \;\in  \;\tsaux{local\_ips} \;\tsvar{h}.\tsvar{ifds}$ }{}\\{}
 \neg{}(\tsaux{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{1}) \Mwedge {}\\{}
 \neg{}(\tsaux{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{2}) \Mwedge {}\\{}
 (\Mcase  \;\tsvar{is}_{1} \;\Mof {}\\{}
\quad\quad \Msome  \;\tsunknown{i1'} \Mtotype  \tsunknown{i1'} = \tsvar{i}_{1} \Mdpipe {}\\{}
\quad\quad * \Mtotype  \Mtrue ) \Mwedge {}\\{}
 {}\\{}
 (\exists \tsunknown{seq\_discard} \;\tsunknown{ack\_discard} \;\tsunknown{URG\_discard} \;\tsunknown{ACK\_discard} \;\tsunknown{PSH\_discard} \;\tsunknown{SYN\_discard} \;\tsunknown{FIN\_discard}{}\\{}
\quad \tsunknown{win\_discard} \;\tsunknown{ws\_discard} \;\tsunknown{urp\_discard} \;\tsunknown{mss\_discard} \;\tsunknown{ts\_discard} \;\tsunknown{data\_discard}.{}\\{}
 \tsvar{seg} = \Mmagiclrec {}\\{}
 \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsunknown{seq\_discard}:\tsaux{tcp\_seq\_foreign});{}\\{}
 \tsvar{ack}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsunknown{ack\_discard}:\tsaux{tcp\_seq\_local});{}\\{}
 \tsvar{URG}  \Mass  \tsunknown{URG\_discard};{}\\{}
 \tsvar{ACK}  \Mass  \tsunknown{ACK\_discard};{}\\{}
 \tsvar{PSH}  \Mass  \tsunknown{PSH\_discard};{}\\{}
 \tsvar{RST}  \Mass  \Mtrue ;{}\\{}
 \tsvar{SYN}  \Mass  \tsunknown{SYN\_discard};{}\\{}
 \tsvar{FIN}  \Mass  \tsunknown{FIN\_discard};{}\\{}
 \tsvar{win}  \Mass  \tsunknown{win\_discard};{}\\{}
 \tsvar{ws}   \Mass  \tsunknown{ws\_discard};{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_discard};{}\\{}
 \tsvar{mss}  \Mass  \tsunknown{mss\_discard};{}\\{}
 \tsvar{ts}   \Mass  \tsunknown{ts\_discard};{}\\{}
 \tsvar{data} \Mass  \tsunknown{data\_discard}{}\\{}
 \Mmagicbolrrec {}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsaux{tcp\_socket\_best\_match} (\tsvar{socks} \backslash{}\backslash{} \tsvar{sid}) (\tsvar{sid},\tsvar{sock}) \tsvar{seg} \;\tsvar{h}.\tstype{arch} \tsholcomm{ there does not exist a better socket match to which the segment should be sent }}
{}
}

\newcommand{\deliverTinTVIIc}{\rrulecc{deliverTinTVIIc}{deliver\_in\_7c}{tcp: network nonurgent}{\tsholcomm{ Receive RST and ignore for $\tscon{SYN\_SENT}$(unacceptable ack) or $\tscon{TIME\_WAIT}$ socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec }
{\tsholcomm{ \textbf{Summary:} receive RST and ignore for $\tscon{SYN\_SENT}$(unacceptable ack) or $\tscon{TIME\_WAIT}$ socket }{}\\{}
 {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 \tsvar{sid} \;\notin  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 \tsvar{st} \;\in  \{\tscon{SYN\_SENT}; \tscon{TIME\_WAIT}\} \Mwedge {}\\{}
 {}\\{}
 (\exists \tsunknown{seq\_discard} \;\tsunknown{URG\_discard} \;\tsunknown{PSH\_discard} \;\tsunknown{SYN\_discard} \;\tsunknown{FIN\_discard}{}\\{}
\quad \tsunknown{win\_discard} \;\tsunknown{ws\_discard} \;\tsunknown{urp\_discard} \;\tsunknown{mss\_discard} \;\tsunknown{ts\_discard} \;\tsunknown{data\_discard}.{}\\{}
 \tsvar{seg} = \Mmagiclrec {}\\{}
 \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsunknown{seq\_discard}:\tsaux{tcp\_seq\_foreign});{}\\{}
 \tsvar{ack}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{ack}:\tsaux{tcp\_seq\_local});{}\\{}
 \tsvar{URG}  \Mass  \tsunknown{URG\_discard};{}\\{}
 \tsvar{ACK}  \Mass  \tsvar{ACK};{}\\{}
 \tsvar{PSH}  \Mass  \tsunknown{PSH\_discard};{}\\{}
 \tsvar{RST}  \Mass  \Mtrue ;{}\\{}
 \tsvar{SYN}  \Mass  \tsunknown{SYN\_discard};{}\\{}
 \tsvar{FIN}  \Mass  \tsunknown{FIN\_discard};{}\\{}
 \tsvar{win}  \Mass  \tsunknown{win\_discard};{}\\{}
 \tsvar{ws}   \Mass  \tsunknown{ws\_discard};{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_discard};{}\\{}
 \tsvar{mss}  \Mass  \tsunknown{mss\_discard};{}\\{}
 \tsvar{ts}   \Mass  \tsunknown{ts\_discard};{}\\{}
 \tsvar{data} \Mass  \tsunknown{data\_discard}{}\\{}
 \Mmagicbolrrec {}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ no- or unacceptable- ACK }{}\\{}
 (\tsvar{st} = \tscon{SYN\_SENT} \implies {}\\{}
\quad\quad (\neg{}\tsvar{ACK} \Mvee  (\tsvar{ACK} \Mwedge  \neg{}(\tsvar{cb}.\tsvar{iss} < \tsvar{ack} \Mwedge  \tsvar{ack} \leq  \tsvar{cb}.\tsfield{snd\_max})))) \Mwedge {}\\{}
 {}\\{}
 \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 (\Mif  \;\tsvar{st} = \tscon{TIME\_WAIT} \;\Mthen   \tsholcomm{ only update if $\geq  \tscon{ESTABLISHED}$, c.f.\ \wasverb{tcp\textbackslash{}\textunderscore{}input.c:887} }{}\\{}
\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsfield{t\_idletime} \Mass  \tsaux{stopwatch\_zero}; \tsholcomm{ just received segment }{}\\{}
 \tsfield{tt\_keep} \Mass  \Msome  (\Mtimed{()}{\tsaux{slow\_timer} \;\tsaux{TCPTV\_KEEP\_IDLE}})  \Mmagicrrec {}\\{}
 \Mmagicbolrrec ) \Mmagicrrec {}\\{}
 \Melse  \tsholcomm{ $\tsvar{st} = \tscon{SYN\_SENT}$ }{}\\{}
\quad \tsholcomm{ BSD \wasverb{rcv\textunderscore{}wnd} bug: the receive window updated code in \wasverb{tcp\textunderscore{}input} gets executed \emph{before} the segment is
          processed, so even for bad segments, it gets updated }{}\\{}
\quad \Mlet  \;\tsunknown{rcv\_window} = \tsaux{calculate\_bsd\_rcv\_wnd} \;\tsvar{sf} \;\tsunknown{tcp\_sock} \;\Min {}\\{}
\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsfield{rcv\_wnd} \Mass  \Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsunknown{rcv\_window} \;\Melse  \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{rcv\_wnd};{}\\{}
 \tsfield{rcv\_adv} \Mass  \Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{rcv\_nxt} + \tsunknown{rcv\_window}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{rcv\_adv}{}\\{}
 \Mmagicbolrrec {}\\{}
 \Mmagicbolrrec ) \Mmagicrrec  )}
{\rrulepad }
}

\newcommand{\deliverTinTVIId}{\rrulecn{deliverTinTVIId}{deliver\_in\_7d}{tcp: network nonurgent}{\tsholcomm{ Receive RST and zap $\tscon{SYN\_SENT}$(acceptable ack) socket }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')];{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec }
{\tsholcomm{ \textbf{Summary}
   Receiving an acceptable-ack RST segment: kill the connection and set the socket's error field appropriately,
   unless we are WinXP where we simply ignore the RST.
   }{}\\{}
 {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 \tsvar{sid} \;\notin  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{SYN\_SENT},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 {}\\{}
 (\exists \tsunknown{seq\_discard} \;\tsunknown{URG\_discard} \;\tsunknown{PSH\_discard} \;\tsunknown{SYN\_discard} \;\tsunknown{FIN\_discard}{}\\{}
\quad \tsunknown{win\_discard} \;\tsunknown{ws\_discard} \;\tsunknown{urp\_discard} \;\tsunknown{mss\_discard} \;\tsunknown{ts\_discard} \;\tsunknown{data\_discard}.{}\\{}
 \tsvar{seg} = \Mmagiclrec {}\\{}
 \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsunknown{seq\_discard}:\tsaux{tcp\_seq\_foreign});{}\\{}
 \tsvar{ack}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{ack}:\tsaux{tcp\_seq\_local});{}\\{}
 \tsvar{URG}  \Mass  \tsunknown{URG\_discard};{}\\{}
 \tsvar{ACK}  \Mass  \Mtrue ;{}\\{}
 \tsvar{PSH}  \Mass  \tsunknown{PSH\_discard};{}\\{}
 \tsvar{RST}  \Mass  \Mtrue ;{}\\{}
 \tsvar{SYN}  \Mass  \tsunknown{SYN\_discard};{}\\{}
 \tsvar{FIN}  \Mass  \tsunknown{FIN\_discard};{}\\{}
 \tsvar{win}  \Mass  \tsunknown{win\_discard};{}\\{}
 \tsvar{ws}   \Mass  \tsunknown{ws\_discard};{}\\{}
 \tsvar{urp}  \Mass  \tsunknown{urp\_discard};{}\\{}
 \tsvar{mss}  \Mass  \tsunknown{mss\_discard};{}\\{}
 \tsvar{ts}   \Mass  \tsunknown{ts\_discard};{}\\{}
 \tsvar{data} \Mass  \tsunknown{data\_discard}{}\\{}
 \Mmagicbolrrec {}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \tsvar{cb}.\tsvar{iss} < \tsvar{ack} \Mwedge  \tsvar{ack} \leq  \tsvar{cb}.\tsfield{snd\_max}  \Mwedge  \tsholcomm{ acceptable ack }{}\\{}
 {}\\{}
 (\Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad \tsvar{sock}' = \tsvar{sock}   \tsholcomm{ Windows XP just ignores RST's with a valid ack during connection establishment }{}\\{}
 \Melse {}\\{}
\quad (\exists \tsvar{err}.{}\\{}
\quad \tsvar{err} \;\in  \{\tscon{ECONNREFUSED}; \tscon{ECONNRESET}\} \Mwedge  \tsholcomm{ Note it is unclear whether or not this error will overwrite any existing error on the socket }{}\\{}
\quad \tsvar{sock}' = (\tsaux{tcp\_close} \;\tsvar{h}.\tstype{arch} \;\tsvar{sock})  \Mmagiclrec  \tsvar{ps}_{1} \Mass  \Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;* \;\Melse  \;\tsvar{sock}.\tsvar{ps}_{1};{}\\{}
 \tsvar{es} \Mass  \Msome  \;\tsvar{err} \Mmagicrrec ))}
{}
}

\newcommand{\deliverTinTVIII}{\rrulecn{deliverTinTVIII}{deliver\_in\_8}{tcp: network nonurgent}{\tsholcomm{ Receive SYN in non-$\{\tscon{CLOSED}$; $\tscon{LISTEN}$; $\tscon{SYN\_SENT}$; $\tscon{TIME\_WAIT}\}$ state }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' ;{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm}' \Mmagicrrec }
{\tsholcomm{ \textbf{Summary:}
     Receive a SYN in non-$\{\tscon{CLOSED}$; $\tscon{LISTEN}$; $\tscon{SYN\_SENT}$; $\tscon{TIME\_WAIT}\}$ state.
     Drop it and (depending on the architecture) generate a RST. }{}\\{}
 {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 \tsvar{sid} \;\notin  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 (\exists \tsunknown{ws\_discard} \;\tsunknown{mss\_discard}.{}\\{}
 \tsvar{seg} = \Mmagiclrec {}\\{}
 \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{seq}:\tsaux{tcp\_seq\_foreign});{}\\{}
 \tsvar{ack}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{ack}:\tsaux{tcp\_seq\_local});{}\\{}
 \tsvar{URG}  \Mass  \tsvar{URG};{}\\{}
 \tsvar{ACK}  \Mass  \tsvar{ACK};{}\\{}
 \tsvar{PSH}  \Mass  \tsvar{PSH};{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mtrue ;{}\\{}
 \tsvar{FIN}  \Mass  \tsvar{FIN};{}\\{}
 \tsvar{win}  \Mass  \tsvar{win};{}\\{}
 \tsvar{ws}   \Mass  \tsunknown{ws\_discard};{}\\{}
 \tsvar{urp}  \Mass  \tsvar{urp};{}\\{}
 \tsvar{mss}  \Mass  \tsunknown{mss\_discard};{}\\{}
 \tsvar{ts}   \Mass  \tsvar{ts};{}\\{}
 \tsvar{data} \Mass  \tsvar{data}{}\\{}
 \Mmagicbolrrec {}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Note that it may be the case that this rule should only apply when the SYN is \emph{in the
     trimmed window}, should not it?; it's OK if there's a SYN bit set, for example in a
     retransmission. }{}\\{}
 {}\\{}
 \tsvar{st} \;\notin  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT};\tscon{TIME\_WAIT}\} \Mwedge {}\\{}
 {}\\{}
 \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \Mlet  \;\tsunknown{t\_idletime'} = \tsaux{stopwatch\_zero} \;\Min {}\\{}
 \Mlet  \;\tsunknown{tt\_keep'} = \Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} \neq  \tscon{SYN\_RECEIVED} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  (\Mtimed{()}{\tsaux{slow\_timer} \;\tsaux{TCPTV\_KEEP\_IDLE}}){}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_keep} \;\Min {}\\{}
 \Mlet  \;\tsunknown{tt\_fin\_wait\_2'} = \Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{FIN\_WAIT\_2} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  (\Mtimed{()}{\tsaux{slow\_timer} \;\tsaux{TCPTV\_MAXIDLE}}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_fin\_wait\_2} \;\Min {}\\{}
 {}\\{}
 \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{cb} \Mass  \tsunknown{tcp\_sock}.\tsvar{cb} \; \Mmagiclrec  \tsfield{tt\_keep} \Mass  \tsunknown{tt\_keep'};{}\\{}
 \tsfield{tt\_fin\_wait\_2} \Mass  \tsunknown{tt\_fin\_wait\_2'};{}\\{}
 \tsfield{t\_idletime} \Mass  \tsunknown{t\_idletime'} \Mmagicrrec {}\\{}
 \Mmagicbolrrec ) \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
 (\Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsaux{make\_rst\_segment\_from\_cb} \;\tsunknown{tcp\_sock}.\tsvar{cb} (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) \tsvar{seg}' \;\Melse  \;\Mtrue ) \Mwedge {}\\{}
 \tsaux{dropwithreset} \;\tsvar{seg} \;\tsvar{h}.\tsvar{ifds} (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}) \tscon{BANDLIM\_UNLIMITED} \;\tsvar{bndlm} \;\tsvar{bndlm}' \;\tsvar{outsegs} \Mwedge {}\\{}
 \tsvar{outsegs}' = (\Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  (\tscon{TCP}(\tsvar{seg}'))\Mcons \tsvar{outsegs} \;\Melse  \;\tsvar{outsegs}) \Mwedge {}\\{}
 \tsaux{enqueue\_each\_and\_ignore\_fail} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{outsegs}' \;\tsvar{oq} \;\tsvar{oq}'}
{}
}

\newcommand{\deliverTinTIX}{\rrulecn{deliverTinTIX}{deliver\_in\_9}{tcp: network nonurgent}{\tsholcomm{ Receive SYN in $\tscon{TIME\_WAIT}$ state if there is no matching $\tscon{LISTEN}$ socket or sequence number has not increased }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq};{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}';{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}';{}\\{}
 \tsvar{bndlm} \Mass  \tsvar{bndlm}' \Mmagicrrec }
{\tsholcomm{ \textbf{Summary:}
     Receive a SYN in $\tscon{TIME\_WAIT}\}$ state where there is no matching $\tscon{LISTEN}$ socket.
     Drop it and (depending on the architecture) generate a RST. }{}\\{}
 {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{TCP} \;\tsvar{seg})) \Mwedge {}\\{}
 {}\\{}
 \tsvar{sid} \;\notin  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tscon{TIME\_WAIT},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})) \Mwedge {}\\{}
 {}\\{}
 (\exists \tsunknown{ws\_discard} \;\tsunknown{mss\_discard}.{}\\{}
 \tsvar{seg} = \Mmagiclrec {}\\{}
 \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{seq}:\tsaux{tcp\_seq\_foreign});{}\\{}
 \tsvar{ack}  \Mass  \tsunknown{tcp\_seq\_flip\_sense} (\tsvar{ack}:\tsaux{tcp\_seq\_local});{}\\{}
 \tsvar{URG}  \Mass  \tsvar{URG};{}\\{}
 \tsvar{ACK}  \Mass  \tsvar{ACK};{}\\{}
 \tsvar{PSH}  \Mass  \tsvar{PSH};{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mtrue ;{}\\{}
 \tsvar{FIN}  \Mass  \tsvar{FIN};{}\\{}
 \tsvar{win}  \Mass  \tsvar{win};{}\\{}
 \tsvar{ws}   \Mass  \tsunknown{ws\_discard};{}\\{}
 \tsvar{urp}  \Mass  \tsvar{urp};{}\\{}
 \tsvar{mss}  \Mass  \tsunknown{mss\_discard};{}\\{}
 \tsvar{ts}   \Mass  \tsvar{ts};{}\\{}
 \tsvar{data} \Mass  \tsvar{data}{}\\{}
 \Mmagicbolrrec {}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ no matching LISTEN socket, or the sequence number has not increased }{}\\{}
 ((\tsvar{seq} \leq  (\tsaux{tcp\_sock\_of} \;\tsvar{sock}).\tsvar{cb}.\tsfield{rcv\_nxt}){}\\{}
\quad \Mvee {}\\{}
 \neg{}(\exists  ((\tsvar{sid},\tsvar{sock}) \Mcons  \tsvar{socks}) \tsunknown{tcp\_sock}.{}\\{}
\quad \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
\quad \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{LISTEN} \Mwedge {}\\{}
\quad \tsvar{sock}.\tsvar{is}_{1} \;\in  \{*;\Msome  \;\tsvar{i}_{1}\} \Mwedge {}\\{}
\quad \tsvar{sock}.\tsvar{ps}_{1} = \Msome  \;\tsvar{p}_{1}){}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 (\Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\tsaux{make\_rst\_segment\_from\_cb} \;\tsvar{cb} (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) \tsvar{seg}' \;\Melse  \;\Mtrue ) \Mwedge {}\\{}
 \tsaux{dropwithreset} \;\tsvar{seg} \;\tsvar{h}.\tsvar{ifds} (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}) \tscon{BANDLIM\_RST\_CLOSEDPORT} \;\tsvar{bndlm} \;\tsvar{bndlm}' \;\tsvar{outsegs} \Mwedge {}\\{}
 \tsvar{outsegs}' = (\Mif  \;\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  (\tscon{TCP}(\tsvar{seg}'))\Mcons \tsvar{outsegs} \;\Melse  \;\tsvar{outsegs}) \Mwedge {}\\{}
 \tsaux{enqueue\_each\_and\_ignore\_fail} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{outsegs}' \;\tsvar{oq} \;\tsvar{oq}'{}\\{}
 {}\\{}
 \tsholcomm{
   This rule does not appear in the BSD code; what happens there is that the old $\tscon{TIME\_WAIT}$ state
   socket is closed, and then the code jumps back to the top.  So this rule covers the case where it
   then discovers nothing else is listening, like $\tsrule{deliver\_in\_5}$.
   }}
{}
}

\newcommand{\chapcommtcpToutput}{\chaptersection{ Host LTS: TCP Output}
\label{tcp_output}%
\chapcomm{}
}

\newcommand{\seccommtcpToutputTsection}{\clustersection{(TCP only)}{Output}
\seccomm{


  A TCP implementation would typically perform output deterministically, e.g.\ during the processing
  a received segment it may construct and enqueue an acknowledgement segment to be emitted.  This
  means that the detailed behaviour of a particular implementation depends on exactly where the
  output routines are called, affecting when segments are emitted.  The contents of an emitted
  segment, on the other hand, must usually be determined by the socket state (especially the
  $\tstype{tcpcb}$), not from transient program variables, so that retransmissions can be performed.



  In this specification we choose to be somewhat nondeterministic, loosely specifying when
  common-case TCP output is to occur.  This simplifies the modelling of existing implementations
  (avoiding the need to capture the code points at which the output routines are called) and should
  mean the specification is closer to capturing the set of all reasonable implementations.

  A significant defect in the current specification is that it does not impose a very tight lower
  bound on how often output takes place.  The satisfactory dynamic behaviour of TCP connections
  depends on an "ACK clock" property, with receivers  acknowledging data sufficiently often to
  update the sender's send window.  Characterising this may need additional constraints.

  The rule presented in this chapter describes TCP output in the common case, i.e.~the behaviour of
  TCP when emitting a non-SYN, non-RST segment. The whole behaviour is captured by the single rule
  $\tsrule{deliver\_out\_1}$ which relies upon the auxiliary functions \ltslink{tcpToutputTrequired}{$\tsaux{tcp\_output\_required}$} and
  \ltslink{tcpToutputTreally}{$\tsaux{tcp\_output\_really}$}.  Output (strictly, adding segments to the host's output queue) may take
  place whenever this rule can fire; it does construct the output segments purely from the socket state.



% This specification
% allows a little more non-determinism than any given implementation: common case TCP output may
% take place, i.e. rule [[deliver_out_1]] may be applicable, at any time that a socket in the host's
% finite map of sockets is in a compatible state. This was a deliberate design choice that
% simplifies the modelling of existing TCP implementations which may emit segments under different
% conditions. All these may be valid behaviours either with respect to one or more of the TCP RFCs,
% or simply because their behaviour has become widely adopted and accepted. Either way, this rule
% encompasses all the observed behaviour of the implementations and the acceptable behaviour defined
% by the TCP RFCs (SB coughs!).


  The two auxiliary functions are loosely based on BSD's TCP output function, which can be logically
  divided into two halves. The first of these ---to some approximation--- is a guard that prevents
  output from occuring unless it is valid to do so, and the second actually creates a segment and
  passes it to the IP layer for output. This distinction is mirrored in the specification, with $\tsaux{tcp\_output\_required}$
  acting as the guard and $\tsaux{tcp\_output\_really}$ forming the segment ready to be appended to the
  host's output queue. Unfortunately it is not possible to be as clean here as one might hope,
  because under some circumstances $\tsaux{tcp\_output\_required}$ may have side-effects. It should be noted
  that $\tsaux{tcp\_output\_really}$ only creates a segment and does not perform any "output" --- the
  act of adding the segment (perhaps unreliably) to the host's output queue is the job of the
  caller.

  The output cases not covered by $\tsrule{deliver\_out\_1}$ are handled specially and often in a more
  deterministic way. Segments with the SYN flag set are created by the auxiliary functions
  \ltslink{makeTsynTsegment}{$\tsaux{make\_syn\_segment}$} and \ltslink{makeTsynTackTsegment}{$\tsaux{make\_syn\_ack\_segment}$} and are output deterministically in response to
  either user events or segment input. SYN segments are emitted by the rules commonly involved in
  connection establishment, namely $\tsrule{connect\_1}$, $\tsrule{deliver\_in\_1}$, $\tsrule{deliver\_in\_2}$,
  $\tsrule{timer\_tt\_rexmtsyn\_1}$ and $\tsrule{timer\_tt\_rexmt\_1}$ and are special-cased in this way for clarity
  because connection establishment performs extra work such as option negotiation and state
  initialisation.

  The creation of RST segments is performed by the auxiliaries \ltslink{makeTrstTsegmentTfromTcb}{$\tsaux{make\_rst\_segment\_from\_cb}$} and
  \ltslink{makeTrstTsegmentTfromTseg}{$\tsaux{make\_rst\_segment\_from\_seg}$}, and are used by the rules that require a reset segment to be
  emitted in response to a user event, e.g.\ a $\tslib{close}()$ call on a socket with a zero linger time,
  or as a socket's response to receiving some types of invalid segment.

  In a few places, mainly in the specification of certain congestion control methods, some rules use
  \ltslink{tcpToutputTreally}{$\tsaux{tcp\_output\_really}$} or the wrapper functions \ltslink{tcpToutputTperhaps}{$\tsaux{tcp\_output\_perhaps}$} and
  \ltslink{mliftTtcpToutputTperhapsTorTfail}{$\tsaux{mlift\_tcp\_output\_perhaps\_or\_fail}$} directly and---more importantly---deterministically. This is
  partly for clarity, perhaps because an RFC states that output "MUST" occur at that point, and
  partly for convenience, possibly because the model would require much extra state (hence adding
  unnecessary complexity) if the output function was not used in-place.

  The $\tsaux{tcp\_output\_perhaps}$ function almost entirely mimics an implementation's TCP output
  function. It calls $\tsaux{tcp\_output\_required}$ to check that output can take place, applying any
  side-effects that it returns, and finally creates the segment with $\tsaux{tcp\_output\_really}$.  See
  \ltslink{tcpToutputTperhaps}{$\tsaux{tcp\_output\_perhaps}$} and \ltslink{mliftTtcpToutputTperhapsTorTfail}{$\tsaux{mlift\_tcp\_output\_perhaps\_or\_fail}$} for more
  information.

  Other auxiliary functions are involved in TCP output and are described earlier. Once a
  segment has been constructed it is added to the host's output queue by one of \ltslink{enqueueTorTfail}{$\tsaux{enqueue\_or\_fail}$},
  \ltslink{enqueueTorTfailTsock}{$\tsaux{enqueue\_or\_fail\_sock}$}, \ltslink{enqueueTandTignoreTfail}{$\tsaux{enqueue\_and\_ignore\_fail}$}, \ltslink{enqueueTeachTandTignoreTfail}{$\tsaux{enqueue\_each\_and\_ignore\_fail}$} or
  \ltslink{mliftTtcpToutputTperhapsTorTfail}{$\tsaux{mlift\_tcp\_output\_perhaps\_or\_fail}$}.  These functions are used by $\tsrule{deliver\_out\_1}$ and other
  rules in the specification to non-deterministically add a segment to the host's output queue. In
  the common case, a segment is added to the host's output queue successfully. In other cases, the
  auxiliary function \ltslink{rollbackTtcpToutput}{$\tsaux{rollback\_tcp\_output}$} may assert a segment is unroutable and prevent the
  segment from being added to the queue. Some failures are non-deterministic in order to model "out
  of resource" style errors, although most are deterministic routing failures determined from the
  socket and host states. $\tsaux{rollback\_tcp\_output}$ has a second task to "undo" several of the
  socket's control block changes upon an error condition. Some of the enqueue functions ignore
  failure, e.g. $\tsaux{enqueue\_and\_ignore\_fail}$, and upon an error they just fail to queue the segment
  and do not update the socket with the "rolled-back" control block returned by
  $\tsaux{rollback\_tcp\_output}$. %All of these functions are documented towards the end of this chapter.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{deliver\_out\_1}$
& \textbf{tcp: network nonurgent}
&  Common case TCP output \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\deliverToutTI}{\rrulecc{deliverToutTI}{deliver\_out\_1}{tcp: network nonurgent}{\tsholcomm{ Common case TCP output }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}'')] ;{}\\{}
 \tsvar{oq} \Mass   \tsvar{oq}' \Mmagicrrec }
{\tsholcomm{ \textbf{Summary:} output TCP segment if possible.  In some cases update the socket's persist
    timer without performing output. }{}\\{}
 {}\\{}
 \tsholcomm{ The TCP socket is connected }{}\\{}
 \tsvar{sid} \;\notin  \Mfdom{\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{sock} = \tscon{Sock}(\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},{}\\{}
\quad\quad\quad\quad\quad \tsvar{cantrcvmore},\tscon{TCP\_PROTO}(\tsunknown{tcp\_sock})) \Mwedge {}\\{}
 \tsunknown{tcp\_sock} = \tsaux{TCP\_Sock0}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc}) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ and either is in a synchronised state with initial $\tsvar{SYN}$ acknowledged\dots }{}\\{}
 ( (\tsvar{st} \;\in  \{\tscon{ESTABLISHED};\tscon{CLOSE\_WAIT};\tscon{FIN\_WAIT\_1};\tscon{FIN\_WAIT\_2};\tscon{CLOSING};{}\\{}
\quad\quad\quad\quad \tscon{LAST\_ACK};\tscon{TIME\_WAIT}\} \Mwedge {}\\{}
\quad \tsvar{cb}.\tsfield{snd\_una} \neq  \tsvar{cb}.\tsvar{iss}) \Mvee {}\\{}
 \tsholcomm{ \dots{}or is in the $\tscon{SYN\_SENT}$ or $\tscon{SYN\_RECEIVED}$ state and a $\tsvar{FIN}$ needs to be emitted }{}\\{}
 (\tsvar{st} \;\in  \{\tscon{SYN\_SENT}; \tscon{SYN\_RECEIVED}\} \Mwedge  \tsvar{cantsndmore} \Mwedge  \tsvar{cb}.\tsfield{tf\_shouldacknow}){}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ A segment will be emitted if $\tsaux{tcp\_output\_required}$ asserts that a segment can be
        output ($\tsunknown{do\_output}$). If $\tsaux{tcp\_output\_required}$ returns a function to alter the socket's
        persist timer ($\tsunknown{persist\_fun}$), then this does not of itself mean that a segment is
        required, however $\tsrule{deliver\_out\_1}$ should still fire to allow the update to take place. }{}\\{}
 \Mlet  (\tsunknown{do\_output},\tsunknown{persist\_fun}) = \tsaux{tcp\_output\_required} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{sock} \;\Min {}\\{}
 (\tsunknown{do\_output} \Mvee  \tsunknown{persist\_fun} \neq  *) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Apply any persist timer side-effect from $\tsaux{tcp\_output\_required}$ }{}\\{}
 \Mlet  \;\tsvar{sock}_{0} = % TCP1_hostLTSScript.sml:16905:48-16906:-1:WARNING: curry parse failed: option_case ==> \tsholop{option\_case}\Mspiii 7: line break not allowed in non-multiline curried op.
\tsholop{option\_case} \tsvar{sock} (\lambda  \tsvar{f}. \tsvar{sock} \;{}\\{}
\quad\quad\quad\quad\quad\quad \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \;\tsvar{cb} \;\Mupdby  \;\tsvar{f}) \Mmagicrrec ) \tsunknown{persist\_fun} \;\Min {}\\{}
 {}\\{}
 (\Mif  \;\tsunknown{do\_output} \;\Mthen  \tsholcomm{ output a segment }{}\\{}
\quad \tsholcomm{ Construct the segment to emit, updating the socket's state }{}\\{}
\quad \tsaux{tcp\_output\_really} \;\tsvar{h}.\tstype{arch} \;\Mfalse  (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}) \tsvar{h}.\tsvar{ifds} \;\tsvar{sock}_{0} (\tsvar{sock}',\tsvar{outsegs}') \Mwedge {}\\{}
 {}\\{}
\quad \tsvar{sock}'.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) \Mwedge {}\\{}
 {}\\{}
\quad \tsholcomm{ Add the segment to the host's output queue, rolling back the socket's control block state if
           an error occurs }{}\\{}
\quad \tsaux{enqueue\_or\_fail\_sock} (\tsunknown{tcp\_sock'}.\tsvar{st} \;\in  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT}\}) \tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{outsegs}' \;\tsvar{oq} \;\tsvar{sock}_{0} \;\tsvar{sock}' (\tsvar{sock}'',\tsvar{oq}'){}\\{}
 {}\\{}
 \Melse  \tsholcomm{ Do not output a segment, but ensure things are tidied up }{}\\{}
\quad \tsvar{oq} = \tsvar{oq}' \Mwedge {}\\{}
\quad \tsvar{sock}'' = \tsvar{sock}_{0}{}\\{}
 )}
{\rrulepad }
}

\newcommand{\chapcommtcpTtimers}{\chaptersection{ Host LTS: TCP Timers}
\label{tcp_timers}%
\chapcomm{}
}

\newcommand{\seccommtcpTtimersTsection}{\clustersection{(TCP only)}{Timers}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{timer\_tt\_rexmtsyn\_1}$
& \textbf{tcp: misc nonurgent}
&  SYN retransmit timer expires \\
$\tsrule{timer\_tt\_rexmt\_1}$
& \textbf{tcp: misc nonurgent}
&  retransmit timer expires \\
$\tsrule{timer\_tt\_persist\_1}$
& \textbf{tcp: misc nonurgent}
&  persist timer expires \\
$\tsrule{timer\_tt\_keep\_1}$
& \textbf{tcp: network nonurgent}
&  keepalive timer expires \\
$\tsrule{timer\_tt\_2msl\_1}$
& \textbf{tcp: misc nonurgent}
&  2*MSL timer expires \\
$\tsrule{timer\_tt\_delack\_1}$
& \textbf{tcp: misc nonurgent}
&  delayed-ACK timer expires \\
$\tsrule{timer\_tt\_conn\_est\_1}$
& \textbf{tcp: misc nonurgent}
&  connection establishment timer expires \\
$\tsrule{timer\_tt\_fin\_wait\_2\_1}$
& \textbf{tcp: misc nonurgent}
&  $\tscon{FIN\_WAIT\_2}$ timer expires \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\timerTttTrexmtsynTI}{\rrulecc{timerTttTrexmtsynTI}{timer\_tt\_rexmtsyn\_1}{tcp: misc nonurgent}{\tsholcomm{ SYN retransmit timer expires }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  [(\tsvar{sid},\tsvar{sock}')];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_rexmt} = \Msome  (\Mtimed{(\tscon{RexmtSyn},\tsvar{shift})}{\tsvar{d}}) \Mwedge {}\\{}
 \tsaux{timer\_expires} \;\tsvar{d} \Mwedge   \tsholcomm{ timer has expired }{}\\{}
 \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_SENT} \Mwedge   \tsholcomm{ this rule is incomplete: $\tscon{RexmtSyn}$ is possible in other states, since $\tsrule{deliver\_in\_2}$ may change state without clearing $\tsfield{tt\_rexmt}$ }{}\\{}
 {}\\{}
 \tsvar{cb} = \tsunknown{tcp\_sock}.\tsvar{cb} \Mwedge {}\\{}
 {}\\{}
 (\Mif  \;\tsvar{shift}+1 \geq  \tsaux{TCP\_MAXRXTSHIFT} \;\Mthen {}\\{}
\quad \tsholcomm{ Timer has expired too many times. Drop and close the connection }{}\\{}
 {}\\{}
\quad \tsholcomm{ since socket state is $\tscon{SYN\_SENT}$, no segments can be output }{}\\{}
\quad \tsaux{tcp\_drop\_and\_close} \;\tsvar{h}.\tstype{arch} (\Msome  \;\tscon{ETIMEDOUT}) \tsvar{sock} (\tsvar{sock}',[\,]) \Mwedge {}\\{}
\quad \tsvar{oq}' = \tsvar{oq}{}\\{}
 {}\\{}
 \Melse {}\\{}
\quad \tsholcomm{ Update the control block based upon the number of occasions on which the timer expired }{}\\{}
 {}\\{}
\quad (\Mif  \;\tsvar{shift}+1 = 1 \Mwedge  \tsvar{cb}.\tsfield{t\_rttinf}.\tsfield{tf\_srtt\_valid} \;\Mthen  \tsholcomm{ On the first retransmit store values for recovery from a bad retransmit }{}\\{}
\quad\quad \tsholcomm{ we cannot guess the safe window for this if we do not know the RTT, hence the second condition }{}\\{}
\quad\quad \tsunknown{snd\_cwnd\_prev'} = \tsvar{cb}.\tsfield{snd\_cwnd} \Mwedge {}\\{}
\quad\quad \tsunknown{snd\_ssthresh\_prev'} = \tsvar{cb}.\tsfield{snd\_ssthresh} \Mwedge {}\\{}
\quad\quad \tsunknown{t\_badrxtwin'} = \Mtimewindow{()}{\tsaux{kern\_timer} (\tstype{time} (\tsvar{cb}.\tsfield{t\_rttinf}.\tsfield{t\_srtt} / 2))}  \tsholcomm{ $\tsaux{kern\_timer}$ for a ticks-based deadline }{}\\{}
\quad \Melse  \tsholcomm{ Otherwise keep the previous values }{}\\{}
\quad\quad \tsunknown{snd\_cwnd\_prev'} = \tsvar{cb}.\tsfield{snd\_cwnd\_prev} \Mwedge {}\\{}
\quad\quad \tsunknown{snd\_ssthresh\_prev'} = \tsvar{cb}.\tsfield{snd\_ssthresh\_prev} \Mwedge {}\\{}
\quad\quad \tsunknown{t\_badrxtwin'} = \tsvar{cb}.\tsfield{t\_badrxtwin}  \tsholcomm{ should be TimeWindowClosed, since retransmit timer is always longer than $\tsfield{t\_srtt}/2$ }{}\\{}
\quad ) \Mwedge {}\\{}
 {}\\{}
\quad (\Mif  (\tsvar{shift}+1 = 3) \Mwedge  \neg{}(\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch}) \Mthen  \tsholcomm{ On the third retransmit turn off window scaling and timestamping options }{}\\{}
\quad\quad \tsunknown{tf\_req\_tstmp'} = \Mfalse  \Mwedge {}\\{}
\quad\quad \tsunknown{request\_r\_scale'} = *  {}\\{}
\quad \Melse  \tsholcomm{ Otherwise keep the previous values }{}\\{}
\quad\quad \tsunknown{tf\_req\_tstmp'} = \tsvar{cb}.\tsfield{tf\_req\_tstmp} \Mwedge {}\\{}
\quad\quad \tsunknown{request\_r\_scale'} = \tsvar{cb}.\tsfield{request\_r\_scale}{}\\{}
\quad ) \Mwedge {}\\{}
 {}\\{}
\quad \Mlet  \;\tsunknown{t\_rttinf'} ={}\\{}
\quad\quad (\Mif  \;\tsvar{shift}+1 > \tsaux{TCP\_MAXRXTSHIFT} \;\tsholop{DIV} \;4 \;\Mthen {}\\{}
\quad\quad\quad \tsholcomm{ Invalidate the recorded smoothed round-trip time for the connection after
                $\tsaux{TCP\_MAXRXTSHIFT} \;\tsholop{DIV} \;4$ retransmits }{}\\{}
\quad\quad\quad \tsholcomm{ Note that the BSD code adjusts the $\tsunknown{srtt}$ and $\tsunknown{rttvar}$ values here to ensure that if it does not
                get a new rtt measurement before the next retransmit it can still use the existing
                values. We do not need to do this for two reasons: (1) we have a flag to invalidate
                the $\tsunknown{srtt}$ values (the only reason BSD updates $\tsunknown{srtt}$ to be zero and hacks $\tsunknown{rrttvar}$ is to
                mark it invalid and request a new rtt update), and (2) the $\tsaux{BSD\_RTTVAR\_BUG}$ does not
                affect SYN retransmits in any case (because for SYN retransmits $\tsunknown{srtt}$ is zero and BSD
                hacks up $\tsunknown{rttvar}$ appropriately at the start of a new connection to make everything
                just work) }{}\\{}
\quad\quad\quad \tsholcomm{ Note that the socket's route should be discarded. }{}\\{}
\quad\quad\quad \tsvar{cb}.\tsfield{t\_rttinf} \; \Mmagiclrec  \tsfield{tf\_srtt\_valid} \Mass  \Mfalse  \Mmagicrrec {}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad \tsvar{cb}.\tsfield{t\_rttinf}) \Min {}\\{}
 {}\\{}
\quad \tsvar{cb}' = \tsvar{cb} \; \Mmagiclrec      \tsholcomm{ Restart the $\tsunknown{rexmt}$ timer to time the retransmitted SYN }{}\\{}
 \tsfield{tt\_rexmt} \Mass  \tsaux{start\_tt\_rexmtsyn} \;\tsvar{h}.\tstype{arch} (\tsvar{shift} + 1) \Mfalse  \;\tsvar{cb}.\tsfield{t\_rttinf};{}\\{}
 \tsholcomm{ reset to next backoff point }{}\\{}
 \tsfield{t\_badrxtwin} \Mass  \tsunknown{t\_badrxtwin'};{}\\{}
 \tsfield{t\_rttinf} \Mass  \tsunknown{t\_rttinf'} \;{}\\{}
\quad\quad\quad\quad \Mmagiclrec  \tsfield{t\_lastshift} \Mass  \tsvar{shift} + 1;{}\\{}
 \tsfield{t\_wassyn} \Mass  \Mtrue  \Mmagicrrec ;{}\\{}
 \tsfield{tf\_req\_tstmp}      \Mass  \tsunknown{tf\_req\_tstmp'};{}\\{}
 \tsfield{request\_r\_scale}   \Mass  \tsunknown{request\_r\_scale'};{}\\{}
 \tsfield{snd\_nxt}           \Mass  \tsvar{cb}.\tsvar{iss} + 1;  \tsholcomm{ value after sending SYN }{}\\{}
 \tsfield{snd\_recover}       \Mass  \tsvar{cb}.\tsvar{iss} + 1;   \tsholcomm{ value after sending SYN }{}\\{}
 {}\\{}
 \tsfield{t\_rttseg}          \Mass  *;{}\\{}
 \tsfield{snd\_cwnd}          \Mass  \tsvar{cb}.\tsfield{t\_maxseg};{}\\{}
 \tsholcomm{ Calculation as per BSD }{}\\{}
 \tsfield{snd\_ssthresh}      \Mass  \tsvar{cb}.\tsfield{t\_maxseg} * \tsholop{MAX} \;2 (\tsholop{MIN} \;\tsvar{cb}.\tsfield{snd\_wnd} \;\tsvar{cb}.\tsfield{snd\_cwnd}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholop{DIV} (2 * \tsvar{cb}.\tsfield{t\_maxseg}));{}\\{}
 \tsfield{snd\_cwnd\_prev}     \Mass  \tsunknown{snd\_cwnd\_prev'};{}\\{}
 \tsfield{snd\_ssthresh\_prev} \Mass  \tsunknown{snd\_ssthresh\_prev'};{}\\{}
 \tsfield{t\_dupacks}         \Mass  0 \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
\quad (\exists \tsvar{i}_{1} \;\tsvar{i}_{2} \;\tsvar{p}_{1} \;\tsvar{p}_{2}. (\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{is}_{2}, \tsvar{sock}.\tsvar{ps}_{1}, \tsvar{sock}.\tsvar{ps}_{2}) = (\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{p}_{2}) \Mwedge {}\\{}
 {}\\{}
\quad \tsholcomm{ Create the segment to be retransmitted }{}\\{}
\quad \tsholop{choose} \;\tsunknown{seg'} \Mcons  (\tsaux{make\_syn\_segment} \;\tsvar{cb}' (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks})).{}\\{}
\quad \tsholcomm{ Attempt to add the new segment to the host's output queue, constraining the final control block state }{}\\{}
\quad \tsaux{enqueue\_or\_fail} \;\Mfalse  \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} [\tscon{TCP} \;\tsunknown{seg'}] \tsvar{oq}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{cb} \; \Mmagiclrec  \tsfield{snd\_nxt} \Mass  \tsvar{cb}.\tsvar{iss}; \tsfield{tt\_delack} \Mass  *;{}\\{}
 \tsfield{last\_ack\_sent} \Mass  \tsaux{tcp\_seq\_foreign} \;0w; \tsfield{rcv\_adv} \Mass  \tsaux{tcp\_seq\_foreign} \;0w{}\\{}
 \Mmagicbolrrec ) \tsvar{cb}' (\tsvar{cb}'',\tsvar{oq}'){}\\{}
\quad ) \Mwedge {}\\{}
\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}'' \Mmagicrrec ) \Mmagicrrec {}\\{}
\quad )}
{\rrulepad }
}

\newcommand{\timerTttTrexmtTI}{\rrulecc{timerTttTrexmtTI}{timer\_tt\_rexmt\_1}{tcp: misc nonurgent}{\tsholcomm{ retransmit timer expires }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock}'')] ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsvar{sock}'.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) \Mwedge {}\\{}
 (\tsunknown{tcp\_sock}.\tsvar{st} \;\notin  \{\tscon{CLOSED}; \tscon{LISTEN}; \tscon{SYN\_SENT}; \tscon{CLOSE\_WAIT}; \tscon{FIN\_WAIT\_2}; \tscon{TIME\_WAIT}\} \Mvee {}\\{}
 (\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{LISTEN} \Mwedge  \tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch})) \Mwedge   {}\\{}
 {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_rexmt} = \Msome  (\Mtimed{(\tscon{Rexmt},\tsvar{shift})}{\tsvar{d}}) \Mwedge {}\\{}
 \tsaux{timer\_expires} \;\tsvar{d} \Mwedge {}\\{}
 {}\\{}
 \tsvar{cb} = \tsunknown{tcp\_sock}.\tsvar{cb} \Mwedge {}\\{}
 {}\\{}
 (\Mif  \;\tsvar{shift}+1 > (\Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED} \;\Mthen  \;\tsaux{TCP\_SYNACKMAXRXTSHIFT}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse  \;\tsaux{TCP\_MAXRXTSHIFT}) \Mthen {}\\{}
\quad \tsholcomm{ Note that BSD's syncaches have a much lower threshold for retransmitting SYN,ACKs than normal }{}\\{}
\quad \tsholcomm{ drop connection }{}\\{}
 {}\\{}
\quad {}\\{}
\quad \tsaux{tcp\_drop\_and\_close} \;\tsvar{h}.\tstype{arch} (\Msome  \;\tscon{ETIMEDOUT}) \tsvar{sock} (\tsvar{sock}',[\tscon{TCP} \;\tsvar{seg}'])  \tsholcomm{ will always get exactly one segment }{}\\{}
 {}\\{}
 \Melse {}\\{}
 {}\\{}
\quad \tsholcomm{ on first retransmit, store values for recovery from bad retransmit }{}\\{}
\quad \tsholcomm{ we cannot guess the safe window for this if we do not know the RTT, hence the second condition }{}\\{}
\quad (\Mif  \;\tsvar{shift}+1 = 1 \Mwedge  \tsvar{cb}.\tsfield{t\_rttinf}.\tsfield{tf\_srtt\_valid} \;\Mthen {}\\{}
\quad\quad\quad\quad \tsunknown{snd\_cwnd\_prev'} = \tsvar{cb}.\tsfield{snd\_cwnd} \Mwedge {}\\{}
\quad\quad\quad\quad \tsunknown{snd\_ssthresh\_prev'} = \tsvar{cb}.\tsfield{snd\_ssthresh} \Mwedge {}\\{}
\quad\quad\quad\quad \tsunknown{t\_badrxtwin'} = \Mtimewindow{()}{\tsaux{kern\_timer} (\tstype{time} (\tsvar{cb}.\tsfield{t\_rttinf}.\tsfield{t\_srtt} / 2))}  \tsholcomm{ $\tsaux{kern\_timer}$ for a ticks-based deadline }{}\\{}
\quad \Melse {}\\{}
\quad\quad\quad\quad \tsunknown{snd\_cwnd\_prev'} = \tsvar{cb}.\tsfield{snd\_cwnd\_prev} \Mwedge {}\\{}
\quad\quad\quad\quad \tsunknown{snd\_ssthresh\_prev'} = \tsvar{cb}.\tsfield{snd\_ssthresh\_prev} \Mwedge {}\\{}
\quad\quad\quad\quad \tsunknown{t\_badrxtwin'} = \tsvar{cb}.\tsfield{t\_badrxtwin}) \Mwedge    \tsholcomm{ should be TimeWindowClosed, since retransmit timer is always longer than $\tsfield{t\_srtt}/2$ }{}\\{}
 {}\\{}
\quad \tsholcomm{ NB: The socket is not in $\tscon{SYN\_SENT}$ here; the rexmt timer has been split into two, and $\tscon{SYN\_SENT}$ uses
          $\tsunknown{tt\_rexmtsyn}$. }{}\\{}
 {}\\{}
\quad \Mlet  \;\tsunknown{t\_rttinf'} = (\Mif  \;\tsvar{shift}+1 > \tsaux{TCP\_MAXRXTSHIFT} \;\tsholop{DIV} \;4 \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ Note that the socket's route should be discarded. }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{t\_rttinf} \; \Mmagiclrec {}\\{}
 \tsfield{tf\_srtt\_valid} \Mass  \Mfalse ;{}\\{}
 \tsfield{t\_srtt} \;\Mupdby  (\tsvar{cb}.\tsfield{t\_rttinf}.\tsfield{t\_srtt} / 4){}\\{}
 \tsholop{onlywhen} (\tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge  \tsaux{BSD\_RTTVAR\_BUG}){}\\{}
 \Mmagicbolrrec {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}.\tsfield{t\_rttinf}) \Min {}\\{}
 {}\\{}
\quad \tsholcomm{ backoff the timer and do a retransmit }{}\\{}
\quad \tsvar{cb}' = \tsvar{cb} \; \Mmagiclrec  \tsfield{tt\_rexmt}          \Mass  \tsaux{start\_tt\_rexmt} \;\tsvar{h}.\tstype{arch} (\tsvar{shift} + 1) \Mfalse  \;\tsvar{cb}.\tsfield{t\_rttinf};  \tsholcomm{ reset to next backoff point }{}\\{}
 \tsholcomm{ $\tsaux{tcp\_output\_really}$ touches this again, but actually leaves it the same, unless $\tsvar{sock}.\tsunknown{snd\_urp}$ is set and $\tsvar{win}_{0}\neq 0$, weirdly }{}\\{}
 \tsfield{t\_badrxtwin}       \Mass  \tsunknown{t\_badrxtwin'};{}\\{}
 \tsfield{t\_rttinf}          \Mass  \tsunknown{t\_rttinf'} \; \Mmagiclrec {}\\{}
 \tsfield{t\_lastshift}   \Mass  \tsvar{shift} + 1;{}\\{}
 \tsfield{t\_wassyn}      \Mass  \Mfalse {}\\{}
 \Mmagicbolrrec ;{}\\{}
 \tsfield{snd\_nxt}           \Mass  \tsvar{cb}.\tsfield{snd\_una};             \tsholcomm{ want to retransmit from $\tsfield{snd\_una}$ }{}\\{}
 \tsfield{snd\_recover}       \Mass  \tsvar{cb}.\tsfield{snd\_max};{}\\{}
 \tsfield{t\_rttseg}          \Mass  *;  {}\\{}
 \tsfield{snd\_cwnd}          \Mass  \tsvar{cb}.\tsfield{t\_maxseg};{}\\{}
 \tsfield{snd\_ssthresh}      \Mass  \tsvar{cb}.\tsfield{t\_maxseg} * \tsholop{MAX} \;2 (\tsholop{MIN} \;\tsvar{cb}.\tsfield{snd\_wnd} \;\tsvar{cb}.\tsfield{snd\_cwnd} \;\tsholop{DIV} (2 * \tsvar{cb}.\tsfield{t\_maxseg}));{}\\{}
 \tsfield{snd\_cwnd\_prev}     \Mass  \tsunknown{snd\_cwnd\_prev'};{}\\{}
 \tsfield{snd\_ssthresh\_prev} \Mass  \tsunknown{snd\_ssthresh\_prev'};{}\\{}
 \tsfield{t\_dupacks}         \Mass  0 \Mmagicrrec  \Mwedge {}\\{}
 {}\\{}
\quad (\Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_RECEIVED} \;\Mthen {}\\{}
\quad\quad\quad\quad (\exists \tsvar{i}_{1} \;\tsvar{i}_{2} \;\tsvar{p}_{1} \;\tsvar{p}_{2}.{}\\{}
\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad \tsholcomm{ If we're Linux doing a simultaneous open and support timestamping then ensure
                timestamping is enabled in any retransmitted SYN,ACK segments. See $\tsrule{deliver\_in\_2}$
                for the rationale in full, but in short Linux is RFC1323 compliant and makes
                a hash of option negotiation during a simultaneous open. We make the option decision
                early (as per the RFC and BSD) and have to hack up SYN,ACK segments to contain
                timestamp options if the Linux host supports timestamping.  }{}\\{}
\quad\quad\quad\quad \tsholcomm{ Note: this behaviour is also safe if we are here due to a passive open. In this
                case, if the remote end does not support timestamping, $\tsfield{tf\_req\_tstmp}$ is $\Mfalse $ due to
                the option negotiation in $\tsrule{deliver\_in\_1}$. Then $\tsfield{tf\_doing\_tstmp}$ is necessarily $\Mfalse $ too
                and the retransmitted SYN,ACK segment does not contain a timestamp. OTOH, if
                $\tsfield{tf\_req\_tstmp}$ is still $\Mtrue $ then so is $\tsfield{tf\_doing\_tstmp}$ and the faked up $\tsvar{cb}$ below is safe. }{}\\{}
\quad\quad\quad\quad \tsholcomm{ Note that similar to the above note on timestamping, window scaling may also have to be dealt with here. }{}\\{}
\quad\quad\quad\quad \Mlet  \;\tsvar{cb}''' ={}\\{}
\quad\quad\quad\quad\quad (\Mif  ((\tsaux{linux\_arch} \;\tsvar{h}.\tstype{arch}) \Mwedge  \tsvar{cb}.\tsfield{tf\_req\_tstmp}) \Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}' \; \Mmagiclrec  \tsfield{tf\_req\_tstmp} \Mass  \Mtrue ;{}\\{}
 \tsfield{tf\_doing\_tstmp} \Mass  \Mtrue  \Mmagicrrec {}\\{}
\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}') \Min {}\\{}
 {}\\{}
\quad\quad\quad\quad \tsholcomm{ Note that $\tsfield{tt\_delack}$ and possibly other timers should be cleared here }{}\\{}
\quad\quad\quad\quad (\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{is}_{2}, \tsvar{sock}.\tsvar{ps}_{1}, \tsvar{sock}.\tsvar{ps}_{2}) = (\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{p}_{2}) \Mwedge {}\\{}
 {}\\{}
\quad\quad\quad\quad \tsholcomm{ We are in $\tscon{SYN\_RECEIVED}$ and want to retransmit the SYN,ACK, so we either got here
                via $\tsrule{deliver\_in\_1}$ or $\tsrule{deliver\_in\_2}$. In both cases, $\tsaux{calculate\_buf\_sizes}$ was used to
                set $\tsvar{cb}.\tsfield{t\_maxseg}$ to the correct value (as per \wasverb{tcp\textunderscore{}mss()} in BSD), however, we need
                to use the old values in retransmitting the SYN,ACK, as per \wasverb{tcp\textunderscore{}mssopt()} in BSD.
                $\tsaux{make\_syn\_ack\_segment}$ therefore uses the value stored in $\tsvar{cb}.\tsfield{t\_advmss}$ to set the
                same mss option in the segment, so we do not need to do anything special here. }{}\\{}
\quad\quad\quad\quad \tsvar{seg}' \;\in  \;\tsaux{make\_syn\_ack\_segment} \;\tsvar{cb}''' (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}) \Mwedge {}\\{}
 {}\\{}
\quad\quad\quad\quad \tsholcomm{ We need to remember to add the length of the segment data (i.e. 1 for a SYN) back onto
                $\tsfield{snd\_nxt}$ in the $\tsvar{cb}$, since this is what $\tsaux{tcp\_output\_really}$ does for normal retransmits. If
                we do not do this, then we'll end up trying to send the first lot of data with a $\tsvar{seq}$ of
                $\tsvar{iss}$, rather than $\tsvar{iss} + 1$ }{}\\{}
\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}' \;{}\\{}
 \Mmagiclrec  \tsfield{snd\_nxt} \Mass  \tsvar{cb}'.\tsfield{snd\_nxt} + 1 \Mmagicrrec  \Mmagicrrec ) \Mmagicrrec {}\\{}
\quad\quad\quad\quad ){}\\{}
\quad\quad \Melse  \;\Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{LISTEN} \;\Mthen   \tsholcomm{ BSD LISTEN bug:
             in BSD it is possible to transition a socket to the LISTEN state without
                cancelling the rexmt timer.  In this case, segments are emitted with
                no flags set. }{}\\{}
\quad\quad\quad\quad \tsaux{bsd\_arch} \;\tsvar{h}.\tstype{arch} \Mwedge {}\\{}
\quad\quad\quad\quad (\exists \tsvar{i}_{1} \;\tsvar{i}_{2} \;\tsvar{p}_{1} \;\tsvar{p}_{2}.{}\\{}
\quad\quad\quad\quad (\tsvar{sock}.\tsvar{is}_{1},\tsvar{sock}.\tsvar{is}_{2}, \tsvar{sock}.\tsvar{ps}_{1}, \tsvar{sock}.\tsvar{ps}_{2}) = (\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{p}_{2}) \Mwedge {}\\{}
\quad\quad\quad\quad \tsvar{seg}' \;\in  \;\tsaux{bsd\_make\_phantom\_segment} \;\tsvar{cb}' (\tsvar{i}_{1},\tsvar{i}_{2},\tsvar{p}_{1},\tsvar{p}_{2}) (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}) (\tsvar{sock}.\tsvar{cantsndmore})) \Mwedge {}\\{}
\quad\quad\quad\quad \tsholcomm{ Retransmission only continues if $\tsvar{FIN}$ is set in the outgoing segment (really!) }{}\\{}
\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}{}\\{}
  \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}' \; \Mmagiclrec  \tsfield{tt\_rexmt} \;\Mupdby  \;* \;\tsholop{onlywhen} \neg{}\tsvar{seg}'.\tsvar{FIN} \Mmagicrrec  \Mmagicrrec ) \Mmagicrrec {}\\{}
\quad\quad \Melse  \tsholcomm{  $\tscon{ESTABLISHED}, \tscon{FIN\_WAIT\_1}, \tscon{CLOSING}, \tscon{LAST\_ACK}$ }{}\\{}
\quad\quad\quad\quad \tsholcomm{ i.e., cannot be $\tscon{CLOSED}, \tscon{LISTEN}, \tscon{SYN\_SENT}, \tscon{CLOSE\_WAIT}, \tscon{FIN\_WAIT\_2}, \tscon{TIME\_WAIT}$ }{}\\{}
\quad\quad\quad\quad \tsaux{tcp\_output\_really} \;\tsvar{h}.\tstype{arch} \;\Mfalse  (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}) \tsvar{h}.\tsvar{ifds}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}' \Mmagicrrec ) \Mmagicrrec ){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{sock}',[\tscon{TCP} \;\tsvar{seg}'])  \tsholcomm{ always emits exactly one segment }{}\\{}
\quad ){}\\{}
 {}\\{}
 ) \Mwedge {}\\{}
 {}\\{}
 \tsaux{enqueue\_or\_fail} \;\Mtrue  \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} [\tscon{TCP} \;\tsvar{seg}'] \tsvar{oq}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{cb}' \;\tsunknown{tcp\_sock'}.\tsvar{cb} (\tsvar{cb}'',\tsvar{oq}') \Mwedge {}\\{}
 \tsvar{sock}'' = \tsvar{sock}' \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}'' \Mmagicrrec ) \Mmagicrrec }
{\rrulepad }
}

\newcommand{\timerTttTpersistTI}{\rrulecn{timerTttTpersistTI}{timer\_tt\_persist\_1}{tcp: misc nonurgent}{\tsholcomm{ persist timer expires }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock}'')];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsvar{sock}'.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_rexmt} = \Msome  (\Mtimed{(\tscon{Persist},\tsvar{shift})}{\tsvar{d}}) \Mwedge {}\\{}
 \tsaux{timer\_expires} \;\tsvar{d} \Mwedge {}\\{}
 \Mlet  \;\tsvar{sock}_{0} = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{cb} \Mass  \tsunknown{tcp\_sock}.\tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsfield{tt\_rexmt} \Mass  \tsaux{start\_tt\_persist} (\tsvar{shift}+1) \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{t\_rttinf} \;\tsvar{h}.\tstype{arch} \Mmagicrrec  \Mmagicrrec ) \Mmagicrrec  \Min {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad {}\\{}
 \tsaux{tcp\_output\_really} \;\tsvar{h}.\tstype{arch} \;\Mtrue  \tsholcomm{ $\Mtrue $ indicates a window probe is requested }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}) \tsvar{h}.\tsvar{ifds}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}_{0}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsvar{sock}',\tsvar{outsegs}') \Mwedge {}\\{}
 \tsaux{enqueue\_or\_fail\_sock} (\tsunknown{tcp\_sock'}.\tsvar{st} \;\in  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT}\}) \tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{outsegs}' \;\tsvar{oq} \;\tsvar{sock}_{0} \;\tsvar{sock}' (\tsvar{sock}'',\tsvar{oq}')}
{}
}

\newcommand{\timerTttTkeepTI}{\rrulecn{timerTttTkeepTI}{timer\_tt\_keep\_1}{tcp: network nonurgent}{\tsholcomm{ keepalive timer expires }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb},*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tscon{Sock}(\Msome  \;\tsvar{fid},\tsvar{sf},\Msome  \;\tsvar{i}_{1},\Msome  \;\tsvar{p}_{1},\Msome  \;\tsvar{i}_{2},\Msome  \;\tsvar{p}_{2},\tsvar{es},\tsvar{cantsndmore},\tsvar{cantrcvmore},{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{TCP\_Sock}(\tsvar{st},\tsvar{cb}',*,\tsvar{sndq},\tsvar{sndurp},\tsvar{rcvq},\tsvar{rcvurp},\tsvar{iobc})))] ;{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{{}\\{}
 {}\\{}
 \tsholcomm{ Note that in another rule the following needs to be specified:
        if the timer has expired for the last time, then (in another rule):
         (if HAVERCVDSYN (i.e., not $\tscon{CLOSED}/\tscon{LISTEN}/\tscon{SYN\_SENT}$) then
              send a RST
          else
              do not do anything yet) $\Mwedge $
         copy soft error to es $\Mwedge $
         free tcpcb, saving RTT
     }{}\\{}
 {}\\{}
 \tsvar{cb}.\tsfield{tt\_keep} = \Msome  (\Mtimed{()}{\tsvar{d}}) \Mwedge {}\\{}
 \tsaux{timer\_expires} \;\tsvar{d} \Mwedge {}\\{}
 \tsholcomm{ Note the following condition also needs to be investigated: $\tsvar{cb}.\tsunknown{t\_rcvtime} + \tsunknown{tcp\_keepidle} + \tsunknown{tcp\_keepcnt} * \tsunknown{tcp\_keepintvl} < \tsunknown{NOW} \Mwedge $ --  still probing }{}\\{}
 (\exists \tsunknown{win\_}.{}\\{}
 \tsholop{w2n} \;\tsunknown{win\_} = \tsvar{cb}.\tsfield{rcv\_wnd} \gg  \tsvar{cb}.\tsfield{rcv\_scale} \Mwedge {}\\{}
 {}\\{}
 \Mlet  \;\tsvar{ts} = \Mif  \;\tsvar{cb}.\tsfield{tf\_doing\_tstmp} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad \Mlet  \;\tsunknown{ts\_ecr'} = \tsholop{option\_case}\Mspiii{(\tsaux{ts\_seq} \;0w)}{\MI }{(\tsaux{timewindow\_val\_of} \;\tsvar{cb}.\tsfield{ts\_recent})} \Min {}\\{}
\quad\quad\quad\quad\quad\quad \Msome ((\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}),\tsunknown{ts\_ecr'}){}\\{}
\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad * \;\Min {}\\{}
 {}\\{}
 \tsvar{seg} = \Mmagiclrec  \tsvar{is}_{1}  \Mass  \Msome  \;\tsvar{i}_{2};{}\\{}
 \tsvar{is}_{2}  \Mass  \Msome  \;\tsvar{i}_{1};{}\\{}
 \tsvar{ps}_{1}  \Mass  \Msome  \;\tsvar{p}_{2};{}\\{}
 \tsvar{ps}_{2}  \Mass  \Msome  \;\tsvar{p}_{1};{}\\{}
 \tsvar{seq}  \Mass  \tsvar{cb}.\tsfield{snd\_una} - 1;  \tsholcomm{ deliberately outside window }{}\\{}
 \tsvar{ack}  \Mass  \tsvar{cb}.\tsfield{rcv\_nxt};{}\\{}
 \tsvar{URG}  \Mass  \Mfalse ;{}\\{}
 \tsvar{ACK}  \Mass  \Mtrue ;{}\\{}
 \tsvar{PSH}  \Mass  \Mfalse ;{}\\{}
 \tsvar{RST}  \Mass  \Mfalse ;{}\\{}
 \tsvar{SYN}  \Mass  \Mfalse ;{}\\{}
 \tsvar{FIN}  \Mass  \Mfalse ;{}\\{}
 \tsvar{win}  \Mass  \tsunknown{win\_};{}\\{}
 \tsvar{ws}   \Mass  *;{}\\{}
 \tsvar{urp}  \Mass  0w;{}\\{}
 \tsvar{mss}  \Mass  *;{}\\{}
 \tsvar{ts}   \Mass  \tsvar{ts};{}\\{}
 \tsvar{data} \Mass  [\,]{}\\{}
 \Mmagicbolrrec ) \Mwedge {}\\{}
 {}\\{}
 \tsaux{enqueue\_and\_ignore\_fail} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} [\tscon{TCP} \;\tsvar{seg}] \tsvar{oq} \;\tsvar{oq}' \Mwedge {}\\{}
 \tsvar{cb}' = \tsvar{cb} \; \Mmagiclrec  \tsfield{tt\_keep} \Mass  \Msome  (\Mtimed{()}{\tsaux{slow\_timer} \;\tsaux{TCPTV\_KEEPINTVL}});  {}\\{}
 \tsfield{last\_ack\_sent} \Mass  \tsvar{seg}.\tsvar{ack}{}\\{}
 \Mmagicbolrrec }
{}
}

\newcommand{\timerTttTIImslTI}{\rrulecn{timerTttTIImslTI}{timer\_tt\_2msl\_1}{tcp: misc nonurgent}{\tsholcomm{ 2*MSL timer expires }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock}')] \Mmagicrrec }
{\tsholcomm{ \textbf{Summary:}
   When the 2MSL $\tscon{TIME\_WAIT}$ period expires, the socket is closed.
   }{}\\{}
 {}\\{}
 \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_2msl} = \Msome  (\Mtimed{()}{\tsvar{d}}) \Mwedge {}\\{}
 \tsaux{timer\_expires} \;\tsvar{d} \Mwedge {}\\{}
 \tsvar{sock}' = \tsaux{tcp\_close} \;\tsvar{h}.\tstype{arch} \;\tsvar{sock}}
{}
}

\newcommand{\timerTttTdelackTI}{\rrulecc{timerTttTdelackTI}{timer\_tt\_delack\_1}{tcp: misc nonurgent}{\tsholcomm{ delayed-ACK timer expires }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock}'')];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsvar{sock}'.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'}) \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_delack} = \Msome  (\Mtimed{()}{\tsvar{d}}) \Mwedge {}\\{}
 \tsaux{timer\_expires} \;\tsvar{d} \Mwedge {}\\{}
 \Mlet  \;\tsvar{sock}_{0} = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsunknown{tcp\_sock}.\tsvar{cb} \; \Mmagiclrec  \tsfield{tt\_delack} \Mass  * \Mmagicrrec  \Mmagicrrec ) \Mmagicrrec  \Min {}\\{}
 \tsaux{tcp\_output\_really} \;\tsvar{h}.\tstype{arch} \;\Mfalse  (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}) \tsvar{h}.\tsvar{ifds} \;\tsvar{sock}_{0} (\tsvar{sock}',\tsvar{outsegs}') \Mwedge {}\\{}
 \tsaux{enqueue\_or\_fail\_sock} (\tsunknown{tcp\_sock'}.\tsvar{st} \;\in  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT}\}) \tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{outsegs}' \;\tsvar{oq} \;\tsvar{sock}_{0} \;\tsvar{sock}' (\tsvar{sock}'',\tsvar{oq}')}
{\rulesubsection{Description}

   This overlaps with $\tsrule{deliver\_out\_1}$.  This is a bit odd, but is a consequence of our liberal nondeterministic TCP output.

\rrulepad }
}

\newcommand{\timerTttTconnTestTI}{\rrulecc{timerTttTconnTestTI}{timer\_tt\_conn\_est\_1}{tcp: misc nonurgent}{\tsholcomm{ connection establishment timer expires }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock}')];{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsholcomm{
   \textbf{Summary:}
   If the connection-establishment timer goes off, drop the connection
   (possibly $\tsvar{RST}$ing the other end). }{}\\{}
 {}\\{}
 \tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_conn\_est} = \Msome  (\Mtimed{()}{\tsvar{d}}) \Mwedge {}\\{}
 \tsaux{timer\_expires} \;\tsvar{d} \Mwedge {}\\{}
 \tsaux{tcp\_drop\_and\_close} \;\tsvar{h}.\tstype{arch} (\Msome  \;\tscon{ETIMEDOUT}){}\\{}
\quad\quad (\tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsunknown{tcp\_sock}.\tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsfield{tt\_conn\_est} \Mass  * \Mmagicrrec  \Mmagicrrec ) \Mmagicrrec ) (\tsvar{sock}',\tsvar{outsegs}) \Mwedge {}\\{}
 \tsholcomm{ Note it should be the case that the socket is in $\tscon{SYN\_SENT}$, and so $\tsvar{outsegs}$ will be empty, but that is not definite. }{}\\{}
 \tsaux{enqueue\_and\_ignore\_fail} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{outsegs} \;\tsvar{oq} \;\tsvar{oq}'}
{\rulesubsection{Description}
   POSIX: says, in the \emph{INFORMATIVE} section \emph{APPLICATION USAGE},
   that the state of the socket is unspecified if \wasverb{connect()} fails.
   We could (in the POSIX "architecture") model this accurately.


\rrulepad }
}

\newcommand{\timerTttTfinTwaitTIITI}{\rrulecc{timerTttTfinTwaitTIITI}{timer\_tt\_fin\_wait\_2\_1}{tcp: misc nonurgent}{\tsholcomm{ $\tscon{FIN\_WAIT\_2}$ timer expires }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock})] \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock}')] \Mmagicrrec }
{\tsvar{sock}.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mwedge {}\\{}
 \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_fin\_wait\_2} = \Msome  (\Mtimed{()}{\tsvar{d}}) \Mwedge {}\\{}
 \tsaux{timer\_expires} \;\tsvar{d} \Mwedge {}\\{}
 \tsvar{sock}' = \tsaux{tcp\_close} \;\tsvar{h}.\tstype{arch} \;\tsvar{sock}}
{\rulesubsection{Description}
   This stops the timer and closes the socket.

   Unlike BSD, we take steps to ensure that this timer only fires when it is really time to close
   the socket.  Specifically, we reset it every time we receive a segment while in $\tscon{FIN\_WAIT\_2}$,
   to $\tsaux{TCPTV\_MAXIDLE}$.  This means we do not need any guarding conditions here; we just do it.

   This means that we do not directly model the BSD behaviour of "sleep for 10 minutes, then check
   every 75 seconds to see if the connection has been idle for 10 minutes".


\rrulepad }
}

\newcommand{\chapcommudpTinputTprocessing}{\chaptersection{ Host LTS: UDP Input Processing}
\label{udp_input_processing}%
\chapcomm{}
}

\newcommand{\seccommudpTinputTprocessingTsection}{\clustersection{(UDP only)}{Input Processing}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{deliver\_in\_udp\_1}$
& \textbf{udp: network nonurgent}
&  Get UDP datagram from host's in-queue and deliver it to a matching socket \\
$\tsrule{deliver\_in\_udp\_2}$
& \textbf{udp: network nonurgent}
&  Get UDP datagram from host's in-queue but generate ICMP, as no matching socket \\
$\tsrule{deliver\_in\_udp\_3}$
& \textbf{udp: network nonurgent}
&  Get UDP datagram from host's in-queue and drop as from a martian address \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\deliverTinTudpTI}{\rrulecc{deliverTinTudpTI}{deliver\_in\_udp\_1}{udp: network nonurgent}{\tsholcomm{ Get UDP datagram from host's in-queue and deliver it to a matching socket }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h}_{0} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}';{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock} \; \;\tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}'))] \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq};{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock} \; \;\tsvar{pr} \Mass  \tsaux{UDP\_Sock}(\tsvar{rcvq}))] \Mmagicrrec  \Mwedge {}\\{}
 \tsvar{rcvq}' = \Mappend{\tsvar{rcvq}}{[\tscon{Dgram\_msg}(\Mmagiclrec  \tsvar{data} \Mass  \tsvar{data}; \tsvar{is} \Mass  \Msome  \;\tsvar{i}_{3}; \tsvar{ps} \Mass  \tsvar{ps}_{3} \Mmagicrrec )]} \Mwedge {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{UDP}(\Mmagiclrec  \tsvar{is}_{1} \Mass  \Msome  \;\tsvar{i}_{3}; \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i}_{4}; \tsvar{ps}_{1} \Mass  \tsvar{ps}_{3}; \tsvar{ps}_{2} \Mass  \tsvar{ps}_{4}; \tsvar{data} \Mass  \tsvar{data} \Mmagicrrec ))) \Mwedge {}\\{}
 (\exists  (\tsvar{ifid},\tstype{ifd}) \Mcons  (\tsvar{h}_{0}.\tsvar{ifds}). \tsvar{i}_{4} \;\in  \;\tstype{ifd}.\tsvar{ipset} ) \Mwedge {}\\{}
 \tsvar{sid} \;\in  \;\tsaux{lookup\_udp} \;\tsvar{h}_{0}.\tsvar{socks} (\tsvar{i}_{3},\tsvar{ps}_{3},\tsvar{i}_{4},\tsvar{ps}_{4}) \tsvar{h}_{0}.\tsvar{bound} \;\tsvar{h}_{0}.\tstype{arch} \Mwedge {}\\{}
 \Mtrue  \Mwedge   \tsholcomm{ placeholder for  "not a link-layer multicast or broadcast" }{}\\{}
 \neg{}(\tsaux{is\_broadormulticast} \;\tsvar{h}_{0}.\tsvar{ifds} \;\tsvar{i}_{4}) \Mwedge   \tsholcomm{ seems unlikely, since $\tsvar{i}_{1} \;\in  \;\tsaux{local\_ips} \;\tsvar{h}.\tsvar{ifds}$ }{}\\{}
 \neg{}(\tsaux{is\_broadormulticast} \;\tsvar{h}_{0}.\tsvar{ifds} \;\tsvar{i}_{3})}
{\rulesubsection{Description}

     At the head of the host's in-queue is a UDP datagram with source address $(\Msome  \;\tsvar{i}_{3},\tsvar{ps}_{3})$,
     destination address $(\Msome  \;\tsvar{i}_{4},\tsvar{ps}_{4})$, and data $\tsvar{data}$. The destination IP address, $\tsvar{i}_{4}$,
     is an IP address for one of the host's interfaces and is not an IP- or link-layer broadcast or
     multicast address and neither is the source IP address, $\tsvar{i}_{3}$.

     The UDP socket $\tsvar{sid}$ matches the address quad of the datagram (see \ltslink{lookupTudp}{$\tsaux{lookup\_udp}$} for
     details). A $\MLhtau $ transition is made. The datagram is removed from the host's in-queue,
     $\tsvar{iq}$, and appended to the tail of the socket's receive queue, $\tsvar{rcvq}'$, leaving the host
     with in-queue $\tsvar{iq}'$ and the socket with receive queue $\tsvar{rcvq}'$.


\rrulepad }
}

\newcommand{\deliverTinTudpTII}{\rrulecc{deliverTinTudpTII}{deliver\_in\_udp\_2}{udp: network nonurgent}{\tsholcomm{ Get UDP datagram from host's in-queue but generate ICMP, as no matching socket }}
{\tsvar{h} \; \;\tsvar{iq} \Mass  \tsvar{iq}}
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}'; \tsvar{oq} \Mass  \Mif  \;\tsunknown{icmp\_to\_go} \;\Mthen  \;\tsvar{oq}' \;\Melse  \;\tsvar{h}.\tsvar{oq} \Mmagicrrec }
{\tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{UDP}(\Mmagiclrec  \tsvar{is}_{1} \Mass  \Msome  \;\tsvar{i}_{3}; \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i}_{4}; \tsvar{ps}_{1} \Mass  \tsvar{ps}_{3};{}\\{}
 \tsvar{ps}_{2} \Mass  \tsvar{ps}_{4}; \tsvar{data} \Mass  \tsvar{data} \Mmagicrrec ))) \Mwedge {}\\{}
 \tsaux{lookup\_udp} \;\tsvar{h}.\tsvar{socks} (\tsvar{i}_{3},\tsvar{ps}_{3},\tsvar{i}_{4},\tsvar{ps}_{4}) \tsvar{h}.\tsvar{bound} \;\tsvar{h}.\tstype{arch} = \emptyset  \Mwedge {}\\{}
 \tsvar{icmp} = \tscon{ICMP}(\Mmagiclrec  \tsvar{is}_{1} \Mass  \Msome  \;\tsvar{i}_{4}; \tsvar{is}_{2} \Mass  \Msome  \;\tsvar{i}_{3}; \tsvar{is}_{3} \Mass  \Msome  \;\tsvar{i}_{3}; \tsvar{is}_{4} \Mass  \Msome  \;\tsvar{i}_{4};{}\\{}
 \tsvar{ps}_{3} \Mass  \tsvar{ps}_{3}; \tsvar{ps}_{4} \Mass  \tsvar{ps}_{4}; \tsvar{proto} \Mass  \tscon{PROTO\_UDP}; \tsvar{seq} \Mass  *;{}\\{}
 \tsvar{t} \Mass  \tscon{ICMP\_UNREACH}(\tscon{PORT}) \Mmagicrrec ) \Mwedge {}\\{}
 (\tsaux{enqueue\_oq}(\tsvar{h}.\tsvar{oq},\tsvar{icmp},\tsvar{oq}',\Mtrue ) \Mvee  \tsunknown{icmp\_to\_go} = \Mfalse ) \tsholcomm{ non-deterministic ICMP generation } \Mwedge {}\\{}
 \tsvar{i}_{4} \;\in  \;\tsaux{local\_ips} \;\tsvar{h}.\tsvar{ifds} \Mwedge {}\\{}
 \Mtrue  \Mwedge   \tsholcomm{ placeholder for  "not a link-layer multicast or broadcast" }{}\\{}
 \neg{}(\tsaux{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{4}) \Mwedge   \tsholcomm{ seems unlikely, since $\tsvar{i}_{1} \;\in  \;\tsaux{local\_ips} \;\tsvar{h}.\tsvar{ifds}$ }{}\\{}
 \neg{}(\tsaux{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{3})}
{\rulesubsection{Description}

     At the head of the host's in-queue, $\tsvar{iq}$, is a UDP datagram with source address $(\Msome
\tsvar{i}_{3},\tsvar{ps}_{3})$, destination address $(\Msome  \;\tsvar{i}_{4},\tsvar{ps}_{4})$, and data $\tsvar{data}$. The destination IP
     address, $\tsvar{i}_{4}$, is an IP address for one of the host's interfaces and is neither a broadcast
     or multicast address; the source IP address, $\tsvar{i}_{3}$, is also not a broadcast or multicast
     address. None of the sockets in the host's finite map of sockets, $\tsvar{h}.\tsvar{socks}$, match the
     datagram (see \ltslink{lookupTudp}{$\tsaux{lookup\_udp}$} for details).

     A $\MLhtau $ transition is made. The datagram is removed from the host's in-queue, leaving it
     with in-queue $\tsvar{iq}'$. An ICMP Port-unreachable message may be generated and appended to the
     tail of the host's out-queue in response to the datagram.

\rrulepad }
}

\newcommand{\deliverTinTudpTIII}{\rrulecc{deliverTinTudpTIII}{deliver\_in\_udp\_3}{udp: network nonurgent}{\tsholcomm{ Get UDP datagram from host's in-queue and drop as from a martian address }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec }
{\tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{UDP} \;\tsvar{dgram})) \Mwedge {}\\{}
 \tsvar{dgram}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge {}\\{}
 \tsvar{is}_{1} = \tsvar{dgram}.\tsvar{is}_{1} \Mwedge {}\\{}
 \tsvar{i}_{2} \;\in  \;\tsaux{local\_ips}(\tsvar{h}.\tsvar{ifds}) \Mwedge {}\\{}
 (\Mfalse  \Mvee                   {}\\{}
 \neg{}(\Mtrue  \Mwedge   {}\\{}
\quad \neg{}(\tsaux{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{i}_{2}) \Mwedge   \tsholcomm{ seems unlikely, since $\tsvar{i}_{1} \;\in  \;\tsaux{local\_ips} \;\tsvar{h}.\tsvar{ifds}$ }{}\\{}
\quad \neg{}(\tsvar{is}_{1} = *) \Mwedge {}\\{}
\quad \neg{}\tsaux{is\_broadormulticast} \;\tsvar{h}.\tsvar{ifds} (\tsholop{THE} \;\tsvar{is}_{1}){}\\{}
 ){}\\{}
 )}
{\rulesubsection{Description}

    At the head of the host's in-queue, $\tsvar{iq}$, is a UDP datagram with destination IP address $\Msome
\tsvar{i}_{2}$ which is an IP address for one of the host's interfaces. Either $\tsvar{i}_{2}$ is an IP-layer
    broadcast or multicast address, or the source IP address, $\tsvar{is}_{1}$, is not set or is an IP-layer
    broadcast or multicast address.

    A $\MLhtau $ transition is made. The datagram is dropped from the host's in-queue, leaving it
    with in-queue $\tsvar{iq}'$.

\rrulepad }
}

\newcommand{\chapcommicmpTinputTprocessing}{\chaptersection{ Host LTS: ICMP Input Processing}
\label{icmp_input_processing}%
\chapcomm{}
}

\newcommand{\seccommicmpTinputTprocessingTsection}{\clustersection{(ICMP only)}{Input Processing}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{deliver\_in\_icmp\_1}$
& \textbf{all: network nonurgent}
&  Receive $\tsunknown{ICMP\_UNREACH\_NET}$ etc for known socket \\
$\tsrule{deliver\_in\_icmp\_2}$
& \textbf{all: network nonurgent}
&  Receive $\tsunknown{ICMP\_UNREACH\_NEEDFRAG}$ for known socket \\
$\tsrule{deliver\_in\_icmp\_3}$
& \textbf{all: network nonurgent}
&  Receive $\tsunknown{ICMP\_UNREACH\_PORT}$ etc for known socket \\
$\tsrule{deliver\_in\_icmp\_4}$
& \textbf{all: network nonurgent}
&  Receive $\tscon{ICMP\_PARAMPROB}$ etc for known socket \\
$\tsrule{deliver\_in\_icmp\_5}$
& \textbf{all: network nonurgent}
&  Receive $\tscon{ICMP\_SOURCE\_QUENCH}$ for known socket \\
$\tsrule{deliver\_in\_icmp\_6}$
& \textbf{all: network nonurgent}
&  Receive and ignore other ICMP \\
$\tsrule{deliver\_in\_icmp\_7}$
& \textbf{all: network nonurgent}
&  Receive and ignore invalid or unmatched ICMP \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\deliverTinTicmpTI}{\rrulecc{deliverTinTicmpTI}{deliver\_in\_icmp\_1}{all: network nonurgent}{\tsholcomm{ Receive $\tsunknown{ICMP\_UNREACH\_NET}$ etc for known socket }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}';{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec  \Mwedge {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{ICMP} \;\tsvar{icmp})) \Mwedge {}\\{}
 \tsvar{icmp}.\tsvar{t} \;\in  \{ \tscon{ICMP\_UNREACH} \;\tsunknown{c} \mid {}\\{}
\quad\quad\quad\quad\quad\quad \tsunknown{c} \;\in  \{\tscon{NET}; \tscon{HOST}; \tscon{SRCFAIL}; \tscon{NET\_UNKNOWN}; \tscon{HOST\_UNKNOWN}; \tscon{ISOLATED};{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tscon{TOSNET}; \tscon{TOSHOST}; \tscon{PREC\_VIOLATION}; \tscon{PREC\_CUTOFF}\}\} \Mwedge {}\\{}
 \tsvar{icmp}.\tsvar{is}_{3} = \Msome  \;\tsvar{i}_{3} \Mwedge {}\\{}
 \tsvar{i}_{3} \;\notin  \;\tsaux{IN\_MULTICAST} \Mwedge {}\\{}
 \tsvar{sid} \;\in  \;\tsaux{lookup\_icmp} \;\tsvar{h}_{0}.\tsvar{socks} \;\tsvar{icmp} \;\tsvar{h}_{0}.\tstype{arch} \;\tsvar{h}_{0}.\tsvar{bound} \Mwedge {}\\{}
 (\Mcase  \;\tsvar{sock}.\tsvar{pr} \;\Mof {}\\{}
\quad \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mtotype {}\\{}
\quad\quad (\exists {\tsvar{icmp}}_{\tsvar{seq}}. \tsvar{icmp}.\tsvar{seq} = \Msome  \;{\tsvar{icmp}}_{\tsvar{seq}} \Mwedge {}\\{}
\quad\quad \Mif  \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_una} \leq  {\tsvar{icmp}}_{\tsvar{seq}} \Mwedge  {\tsvar{icmp}}_{\tsvar{seq}} < \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_max} \;\Mthen  {}\\{}
\quad\quad\quad\quad \Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{ESTABLISHED} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge   \tsholcomm{ ignore transient error while connected }{}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{oq}' = \tsvar{oq}{}\\{}
\quad\quad\quad\quad \Melse  \;\Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT};\tscon{SYN\_RECEIVED}\} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_rexmt} \neq  * \Mwedge  \tsaux{shift\_of} \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_rexmt} > 3 \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{t\_softerror} \neq  * \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{tcp\_drop\_and\_close} \;\tsvar{h}.\tstype{arch} (\Msome  \;\tscon{EHOSTUNREACH}) \tsvar{sock} (\tsvar{sock}',\tsvar{outsegs}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsaux{enqueue\_and\_ignore\_fail} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{outsegs} \;\tsvar{oq} \;\tsvar{oq}'{}\\{}
\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{cb} \Mass  \tsunknown{tcp\_sock}.\tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsfield{t\_softerror} \Mass  \Msome  \;\tscon{EHOSTUNREACH} \Mmagicrrec  \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad \tsvar{oq}' = \tsvar{oq}{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsholcomm{ Note the case where it is a syncache entry is not dealt with here: a \wasverb{syncache\textunderscore{}unreach()} should be done instead }{}\\{}
\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge {}\\{}
\quad\quad\quad\quad \tsvar{oq}' = \tsvar{oq} ) \Mdpipe {}\\{}
\quad \tscon{UDP\_PROTO}(\tsunknown{udp\_sock}) \Mtotype {}\\{}
\quad\quad\quad \Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsunknown{udp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{rcvq} \Mass  \Mappend{\tsunknown{udp\_sock}.\tsvar{rcvq}}{[(\tscon{Dgram\_error}(\Mmagiclrec  \tsvar{e} \Mass  \tscon{ECONNRESET} \Mmagicrrec ))]} \Mmagicrrec ) \Mmagicrrec  \Mwedge  \tsvar{oq}' = \tsvar{oq}{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{es} \;\Mupdby  \;\Msome  \;\tscon{ECONNREFUSED}{}\\{}
 \tsholop{onlywhen} ((\tsvar{sock}.\tsvar{is}_{2} \neq  *) \Mvee  \neg{}(\tscon{SO\_BSDCOMPAT} \;\in  \;\tsvar{sock}.\tsvar{sf}.\tsvar{b})) \Mmagicrrec  \Mwedge  \tsvar{oq}' = \tsvar{oq})}
{\rulesubsection{Description}
   Corresponds to FreeBSD 4.6-RELEASE's PRC\_UNREACH\_NET.

\rrulepad }
}

\newcommand{\deliverTinTicmpTII}{\rrulecc{deliverTinTicmpTII}{deliver\_in\_icmp\_2}{all: network nonurgent}{\tsholcomm{ Receive $\tsunknown{ICMP\_UNREACH\_NEEDFRAG}$ for known socket }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}';{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec  \Mwedge {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{ICMP} \;\tsvar{icmp})) \Mwedge {}\\{}
 \tsvar{icmp}.\tsvar{t} = \tscon{ICMP\_UNREACH} (\tscon{NEEDFRAG} \;\tsvar{icmpmtu}) \Mwedge {}\\{}
 (\tsvar{icmp}.\tsvar{is}_{3} = * \Mvee  \tsholop{THE} \;\tsvar{icmp}.\tsvar{is}_{3} \;\notin  \;\tsaux{IN\_MULTICAST}) \Mwedge {}\\{}
 \tsvar{sid} \;\in  \;\tsaux{lookup\_icmp} \;\tsvar{h}_{0}.\tsvar{socks} \;\tsvar{icmp} \;\tsvar{h}_{0}.\tstype{arch} \;\tsvar{h}_{0}.\tsvar{bound} \Mwedge {}\\{}
 \Mlet  \;\tsunknown{nextmtu} = \Mif  \;\Mfalse  \Mwedge  \tsholcomm{ Note this is a placeholder for "there is a host (not net) route for icmp.is4" }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \Mfalse  \;\Mthen  \tsholcomm{ Note this is a placeholder for "\wasverb{rmx.mtu} not locked" }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mlet  \;\tsunknown{curmtu} = 1492 \;\Min  \tsholcomm{ Note this value should be taken from \wasverb{rmx.mtu} }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mlet  \;\tsunknown{nextmtu} = \Mcase  \;\tsvar{icmpmtu} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  \;\tsunknown{mtu} \Mtotype  \tsholop{w2n} \;\tsunknown{mtu}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mdpipe  *     \Mtotype  \tsaux{next\_smaller} (\tsaux{mtu\_tab} \;\tsvar{h}_{0}.\tstype{arch}) \tsunknown{curmtu} \;\Min {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mif  \;\tsunknown{nextmtu} < 296 \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ Note this should lock curmtu in rmxcache; and not change rmxcache MTU from curmtu }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  \;\tsunknown{curmtu}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ Note here, $\tsunknown{nextmtu}$ should be stored in rmxcache }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Msome  \;\tsunknown{nextmtu}{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad * \;\Min {}\\{}
 (\Mcase  \;\tsvar{sock}.\tsvar{pr} \;\Mof {}\\{}
\quad\quad \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mtotype {}\\{}
\quad\quad\quad (\exists {\tsvar{icmp}}_{\tsvar{seq}}. \tsvar{icmp}.\tsvar{seq} = \Msome  \;{\tsvar{icmp}}_{\tsvar{seq}} \Mwedge {}\\{}
\quad\quad\quad \Mif  \;\tsholop{IS\_SOME} \;\tsvar{icmp}.\tsvar{is}_{3} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad (\Mif  \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_una} \leq  {\tsvar{icmp}}_{\tsvar{seq}} \Mwedge  {\tsvar{icmp}}_{\tsvar{seq}} < \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_max} \;\Mthen  {}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mif  \;\tsunknown{nextmtu} = * \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{cb} \Mass  \tsunknown{tcp\_sock}.\tsvar{cb} \; \Mmagiclrec  \tsfield{t\_maxseg} \Mass  \tsaux{MSSDFLT} \Mmagicrrec  \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{oq}' = \tsvar{oq}{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mlet  \;\tsvar{mss} = \tsholop{MIN} (\tsvar{sock}.\tsvar{sf}.\tsvar{n}(\tscon{SO\_SNDBUF})){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsaux{rounddown} \;\tsaux{MCLBYTES}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\tsholop{THE} \;\tsunknown{nextmtu} - 40 - (\Mif  \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tf\_doing\_tstmp} \;\Mthen  \;12 \;\Melse  \;0))) \Min {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsholcomm{ BSD: TS, plus NOOP for alignment }{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mif  \;\tsvar{mss} \leq  \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{t\_maxseg} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Mlet  \;\tsvar{sock}'' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{cb} \Mass  \tsunknown{tcp\_sock}.\tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsfield{t\_maxseg} \Mass  \tsvar{mss};{}\\{}
 \tsfield{t\_rttseg} \Mass  *;{}\\{}
 \tsfield{snd\_nxt}  \Mass  \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_una}{}\\{}
 \Mmagicbolrrec  \Mmagicrrec ) \Mmagicrrec  \Min {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \exists \tsvar{sock}''' \;\tsvar{outsegs} \;\tsunknown{tcp\_sock'''}.{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}'''.\tsvar{pr} = \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock'''}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{tcp\_output\_perhaps} \;\tsvar{h}.\tstype{arch} (\tsaux{ticks\_of} \;\tsvar{h}.\tsvar{ticks}) \tsvar{h}.\tsvar{ifds} \;\tsvar{sock}'' (\tsvar{sock}''',\tsvar{outsegs}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsaux{enqueue\_or\_fail\_sock} (\tsunknown{tcp\_sock'''}.\tsvar{st} \;\notin  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT}\}){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{outsegs} \;\tsvar{oq}{}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}'' \;\tsvar{sock}''' (\tsvar{sock}',\tsvar{oq}'){}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge  \tsvar{oq}' = \tsvar{oq}{}\\{}
\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsholcomm{ Note the case where it is a syncache entry is not dealt with here: a \wasverb{syncache\textunderscore{}unreach()} should be done instead }{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge  \tsvar{oq}' = \tsvar{oq}){}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge  \tsvar{oq}' = \tsvar{oq} ) \Mdpipe {}\\{}
\quad\quad \tscon{UDP\_PROTO}(\tsunknown{udp\_sock}) \Mtotype {}\\{}
\quad\quad \Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsunknown{udp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{rcvq} \Mass  \Mappend{\tsunknown{udp\_sock}.\tsvar{rcvq}}{[(\tscon{Dgram\_error}(\Mmagiclrec  \tsvar{e} \Mass  \tscon{EMSGSIZE} \Mmagicrrec ))]} \Mmagicrrec ) \Mmagicrrec  \Mwedge  \tsvar{oq}' = \tsvar{oq}{}\\{}
\quad\quad \Melse {}\\{}
\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  \;\tscon{EMSGSIZE} \Mmagicrrec  \Mwedge  \tsvar{oq}' = \tsvar{oq})}
{\rulesubsection{Description}
   Corresponds to FreeBSD 4.6-RELEASE's PRC\_MSGSIZE.

\rrulepad }
}

\newcommand{\deliverTinTicmpTIII}{\rrulecc{deliverTinTicmpTIII}{deliver\_in\_icmp\_3}{all: network nonurgent}{\tsholcomm{ Receive $\tsunknown{ICMP\_UNREACH\_PORT}$ etc for known socket }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}';{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec  \Mwedge {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{ICMP} \;\tsvar{icmp})) \Mwedge {}\\{}
 \tsvar{icmp}.\tsvar{t} \;\in  \{ \tscon{ICMP\_UNREACH} \;\tsunknown{c} \mid {}\\{}
\quad\quad\quad\quad\quad\quad \tsunknown{c} \;\in  \{\tscon{PROTOCOL}; \tscon{PORT}; \tscon{NET\_PROHIB}; \tscon{HOST\_PROHIB}; \tscon{FILTER\_PROHIB}\}\} \Mwedge {}\\{}
 \tsvar{icmp}.\tsvar{is}_{3} = \Msome  \;\tsvar{i}_{3} \Mwedge {}\\{}
 \tsvar{i}_{3} \;\notin  \;\tsaux{IN\_MULTICAST} \Mwedge {}\\{}
 \tsvar{sid} \;\in  \;\tsaux{lookup\_icmp} \;\tsvar{h}_{0}.\tsvar{socks} \;\tsvar{icmp} \;\tsvar{h}_{0}.\tstype{arch} \;\tsvar{h}_{0}.\tsvar{bound} \Mwedge {}\\{}
 (\Mcase  \;\tsvar{sock}.\tsvar{pr} \;\Mof {}\\{}
\quad\quad \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mtotype {}\\{}
\quad\quad\quad (\exists {\tsvar{icmp}}_{\tsvar{seq}}. \tsvar{icmp}.\tsvar{seq} = \Msome  \;{\tsvar{icmp}}_{\tsvar{seq}} \Mwedge {}\\{}
\quad\quad\quad \Mif  \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_una} \leq  {\tsvar{icmp}}_{\tsvar{seq}} \Mwedge  {\tsvar{icmp}}_{\tsvar{seq}} < \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_max} \;\Mthen  {}\\{}
\quad\quad\quad\quad\quad \Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} = \tscon{SYN\_SENT} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{tcp\_drop\_and\_close} \;\tsvar{h}.\tstype{arch} (\Msome  \;\tscon{ECONNREFUSED}) \tsvar{sock} (\tsvar{sock}',[\,])  \tsholcomm{ know from definition of $\tsaux{tcp\_drop\_and\_close}$ that no segs will be emitted }{}\\{}
\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge  \tsvar{oq}' = \tsvar{oq}{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsholcomm{ Note the case where it is a syncache entry is not dealt with here: a \wasverb{syncache\textunderscore{}unreach()} should be done instead }{}\\{}
\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge  \tsvar{oq}' = \tsvar{oq} ) \Mdpipe {}\\{}
\quad\quad \tscon{UDP\_PROTO}(\tsunknown{udp\_sock}) \Mtotype {}\\{}
\quad\quad\quad\quad (\Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsunknown{udp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{rcvq} \Mass  \Mappend{\tsunknown{udp\_sock}.\tsvar{rcvq}}{[(\tscon{Dgram\_error}(\Mmagiclrec  \tsvar{e} \Mass  \tscon{ECONNRESET} \Mmagicrrec ))]} \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{oq}' = \tsvar{oq}{}\\{}
\quad\quad\quad\quad\quad \Melse  {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{es} \;\Mupdby  \;\Msome  (\tscon{ECONNREFUSED}){}\\{}
 \tsholop{onlywhen} ((\tsvar{sock}.\tsvar{is}_{2} \neq  *) \Mvee  \neg{}(\tscon{SO\_BSDCOMPAT} \;\in  \;\tsvar{sock}.\tsvar{sf}.\tsvar{b})) \Mmagicrrec  \Mwedge  \tsvar{oq}' = \tsvar{oq}))}
{\rulesubsection{Description}
   Corresponds to FreeBSD 4.6-RELEASE's PRC\_UNREACH\_PORT and PRC\_UNREACH\_ADMIN\_PROHIB.

\rrulepad }
}

\newcommand{\deliverTinTicmpTIV}{\rrulecc{deliverTinTicmpTIV}{deliver\_in\_icmp\_4}{all: network nonurgent}{\tsholcomm{ Receive $\tscon{ICMP\_PARAMPROB}$ etc for known socket }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}';{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec  \Mwedge {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{ICMP} \;\tsvar{icmp})) \Mwedge {}\\{}
 \tsvar{icmp}.\tsvar{t} \;\in  \{ \tscon{ICMP\_PARAMPROB} \;\tsunknown{c} \mid {}\\{}
\quad\quad\quad\quad\quad\quad \tsunknown{c} \;\in  \{\tscon{BADHDR}; \tscon{NEEDOPT}\}\} \Mwedge {}\\{}
 \tsvar{icmp}.\tsvar{is}_{3} = \Msome  \;\tsvar{i}_{3} \Mwedge {}\\{}
 \tsvar{i}_{3} \;\notin  \;\tsaux{IN\_MULTICAST} \Mwedge {}\\{}
 \tsvar{sid} \;\in  \;\tsaux{lookup\_icmp} \;\tsvar{h}_{0}.\tsvar{socks} \;\tsvar{icmp} \;\tsvar{h}_{0}.\tstype{arch} \;\tsvar{h}_{0}.\tsvar{bound} \Mwedge {}\\{}
 (\Mcase  \;\tsvar{sock}.\tsvar{pr} \;\Mof {}\\{}
\quad\quad \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mtotype {}\\{}
\quad\quad\quad (\exists {\tsvar{icmp}}_{\tsvar{seq}}. \tsvar{icmp}.\tsvar{seq} = \Msome  \;{\tsvar{icmp}}_{\tsvar{seq}} \Mwedge {}\\{}
\quad\quad\quad \Mif  \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_una} \leq  {\tsvar{icmp}}_{\tsvar{seq}} \Mwedge  {\tsvar{icmp}}_{\tsvar{seq}} < \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_max} \;\Mthen  {}\\{}
\quad\quad\quad\quad\quad \Mif  \;\tsunknown{tcp\_sock}.\tsvar{st} \;\in  \{\tscon{CLOSED};\tscon{LISTEN};\tscon{SYN\_SENT};\tscon{SYN\_RECEIVED}\} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_rexmt} \neq  * \Mwedge  \tsaux{shift\_of} \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{tt\_rexmt} > 3 \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{t\_softerror} \neq  * \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{tcp\_drop\_and\_close} \;\tsvar{h}.\tstype{arch} (\Msome  \;\tscon{ENOPROTOOPT}) \tsvar{sock} (\tsvar{sock}',\tsvar{outsegs}) \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{enqueue\_and\_ignore\_fail} \;\tsvar{h}.\tstype{arch} \;\tsvar{h}.\tsvar{rttab} \;\tsvar{h}.\tsvar{ifds} \;\tsvar{outsegs} \;\tsvar{oq} \;\tsvar{oq}'{}\\{}
\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{cb} \Mass  \tsunknown{tcp\_sock}.\tsvar{cb} \; \Mmagiclrec  \tsfield{t\_softerror} \Mass  \Msome  \;\tscon{ENOPROTOOPT} \Mmagicrrec  \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{oq}' = \tsvar{oq}{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad {}\\{}
\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \Mwedge  \tsvar{oq}' = \tsvar{oq} ) \Mdpipe {}\\{}
\quad\quad \tscon{UDP\_PROTO}(\tsunknown{udp\_sock}) \Mtotype {}\\{}
\quad\quad\quad\quad (\Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsunknown{udp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{rcvq} \Mass  \Mappend{\tsunknown{udp\_sock}.\tsvar{rcvq}}{[(\tscon{Dgram\_error}(\Mmagiclrec  \tsvar{e} \Mass  \tscon{ENOPROTOOPT} \Mmagicrrec ))]} \Mmagicrrec ) \Mmagicrrec  \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{oq}' = \tsvar{oq}{}\\{}
\quad\quad\quad\quad\quad \Melse  {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  (\tscon{ENOPROTOOPT}) \Mmagicrrec  \Mwedge  \tsvar{oq}' = \tsvar{oq}))}
{\rulesubsection{Description}
   Corresponds to FreeBSD 4.6-RELEASE's PRC\_PARAMPROB.

\rrulepad }
}

\newcommand{\deliverTinTicmpTV}{\rrulecc{deliverTinTicmpTV}{deliver\_in\_icmp\_5}{all: network nonurgent}{\tsholcomm{ Receive $\tscon{ICMP\_SOURCE\_QUENCH}$ for known socket }}
{\tsvar{h}_{0}}
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad\quad [(\tsvar{sid},\tsvar{sock}')] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec }
{\tsvar{h}_{0} = \tsvar{h} \; \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus {}\\{}
\quad [(\tsvar{sid},\tsvar{sock})] ;{}\\{}
 \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec  \Mwedge {}\\{}
 \tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{ICMP} \;\tsvar{icmp})) \Mwedge {}\\{}
 \tsvar{icmp}.\tsvar{t} = \tscon{ICMP\_SOURCE\_QUENCH} \;\tscon{QUENCH} \Mwedge {}\\{}
 \tsvar{icmp}.\tsvar{is}_{3} = \Msome  \;\tsvar{i}_{3} \Mwedge {}\\{}
 \tsvar{i}_{3} \;\notin  \;\tsaux{IN\_MULTICAST} \Mwedge {}\\{}
 \tsvar{sid} \;\in  \;\tsaux{lookup\_icmp} \;\tsvar{h}_{0}.\tsvar{socks} \;\tsvar{icmp} \;\tsvar{h}_{0}.\tstype{arch} \;\tsvar{h}_{0}.\tsvar{bound} \Mwedge {}\\{}
 (\Mcase  \;\tsvar{sock}.\tsvar{pr} \;\Mof {}\\{}
\quad\quad \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock}) \Mtotype {}\\{}
\quad\quad\quad (\exists {\tsvar{icmp}}_{\tsvar{seq}}. \tsvar{icmp}.\tsvar{seq} = \Msome  \;{\tsvar{icmp}}_{\tsvar{seq}} \Mwedge {}\\{}
\quad\quad\quad \Mif  \;\tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_una} \leq  {\tsvar{icmp}}_{\tsvar{seq}} \Mwedge  {\tsvar{icmp}}_{\tsvar{seq}} < \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{snd\_max} \;\Mthen  {}\\{}
\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{cb} \Mass  \tsunknown{tcp\_sock}.\tsvar{cb} \;{}\\{}
 \Mmagiclrec  \tsfield{snd\_cwnd} \Mass  1 * \tsunknown{tcp\_sock}.\tsvar{cb}.\tsfield{t\_maxseg} \Mmagicrrec  \Mmagicrrec ) \Mmagicrrec {}\\{}
\quad\quad\quad \tsholcomm{ Note the state of the TCP socket should be checked here. }{}\\{}
\quad\quad\quad \tsholcomm{ Note it might be necessary to make an allowance for local/remote connection? }{}\\{}
\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad \tsholcomm{ Note the case where it is a syncache entry is not dealt with here: a \wasverb{syncache\textunderscore{}unreach()} should be done instead }{}\\{}
\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} ) \Mdpipe {}\\{}
\quad\quad \tscon{UDP\_PROTO}(\tsunknown{udp\_sock}) \Mtotype {}\\{}
\quad\quad\quad\quad (\Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{pr} \Mass  \tscon{UDP\_PROTO}(\tsunknown{udp\_sock} \;{}\\{}
 \Mmagiclrec  \tsvar{rcvq} \Mass  \Mappend{\tsunknown{udp\_sock}.\tsvar{rcvq}}{[(\tscon{Dgram\_error}(\Mmagiclrec  \tsvar{e} \Mass  \tscon{EHOSTUNREACH} \Mmagicrrec ))]} \Mmagicrrec ) \Mmagicrrec {}\\{}
\quad\quad\quad\quad\quad \Melse  {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsvar{sock}' = \tsvar{sock} \; \Mmagiclrec  \tsvar{es} \Mass  \Msome  (\tscon{EHOSTUNREACH}) \Mmagicrrec ))}
{\rulesubsection{Description}
   Corresponds to FreeBSD 4.6-RELEASE's PRC\_QUENCH.

\rrulepad }
}

\newcommand{\deliverTinTicmpTVI}{\rrulecc{deliverTinTicmpTVI}{deliver\_in\_icmp\_6}{all: network nonurgent}{\tsholcomm{ Receive and ignore other ICMP }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec }
{\tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{ICMP} \;\tsvar{icmp})) \Mwedge {}\\{}
 (\tsvar{icmp}.\tsvar{t} \;\in  \{ \tscon{ICMP\_TIME\_EXCEEDED} \;\tscon{INTRANS}; \tscon{ICMP\_TIME\_EXCEEDED} \;\tscon{REASS} \} \Mvee {}\\{}
 \tsvar{icmp}.\tsvar{t} \;\in  \{ \tscon{ICMP\_UNREACH}       (\tscon{OTHER} \;\tsunknown{x}) \mid  \tsunknown{x} \;\in  \;\tsunknown{UNIV} \} \Mvee {}\\{}
 \tsvar{icmp}.\tsvar{t} \;\in  \{ \tscon{ICMP\_SOURCE\_QUENCH} (\tscon{OTHER} \;\tsunknown{x}) \mid  \tsunknown{x} \;\in  \;\tsunknown{UNIV} \} \Mvee {}\\{}
 \tsvar{icmp}.\tsvar{t} \;\in  \{ \tscon{ICMP\_TIME\_EXCEEDED} (\tscon{OTHER} \;\tsunknown{x}) \mid  \tsunknown{x} \;\in  \;\tsunknown{UNIV} \} \Mvee {}\\{}
 \tsvar{icmp}.\tsvar{t} \;\in  \{ \tscon{ICMP\_PARAMPROB}     (\tscon{OTHER} \;\tsunknown{x}) \mid  \tsunknown{x} \;\in  \;\tsunknown{UNIV} \})}
{\rulesubsection{Description}
   If ICMP\_TIME\_EXCEEDED (either INTRANS or REASS), or if a bad code is received, then ignore
   silently.

\rrulepad }
}

\newcommand{\deliverTinTicmpTVII}{\rrulecc{deliverTinTicmpTVII}{deliver\_in\_icmp\_7}{all: network nonurgent}{\tsholcomm{ Receive and ignore invalid or unmatched ICMP }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec }
{\Mtransition{ \MLhtau  }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec }
{\tsaux{dequeue\_iq}(\tsvar{iq},\tsvar{iq}',\Msome  (\tscon{ICMP} \;\tsvar{icmp})) \Mwedge {}\\{}
 (\tsvar{icmp}.\tsvar{t} \;\in  \{ \tscon{ICMP\_UNREACH} \;\tsunknown{c} \mid  \neg{}\exists \tsvar{x}. \tsunknown{c} = \tscon{OTHER} \;\tsvar{x} \} \Mvee {}\\{}
 \tsvar{icmp}.\tsvar{t} \;\in  \{ \tscon{ICMP\_PARAMPROB} \;\tsunknown{c} \mid  \tsunknown{c} \;\in  \{\tscon{BADHDR}; \tscon{NEEDOPT}\} \} \Mvee {}\\{}
 \tsvar{icmp}.\tsvar{t} = \tscon{ICMP\_SOURCE\_QUENCH} \;\tscon{QUENCH}) \Mwedge {}\\{}
 (\Mif  \exists \tsvar{icmpmtu}. \tsvar{icmp}.\tsvar{t} = \tscon{ICMP\_UNREACH} (\tscon{NEEDFRAG} \;\tsvar{icmpmtu}) \Mthen {}\\{}
\quad\quad \exists \tsvar{i}_{3}. \tsvar{icmp}.\tsvar{is}_{3} = \Msome  \;\tsvar{i}_{3} \Mwedge  \tsvar{i}_{3} \;\in  \;\tsaux{IN\_MULTICAST}{}\\{}
 \Melse {}\\{}
\quad\quad (\tsvar{icmp}.\tsvar{is}_{3} = * \Mvee {}\\{}
\quad\quad\quad \tsholop{THE} \;\tsvar{icmp}.\tsvar{is}_{3} \;\in  \;\tsaux{IN\_MULTICAST} \Mvee {}\\{}
\quad\quad\quad \neg{}(\exists (\tstype{sid},\tsunknown{s}) \Mcons  (\tsvar{h}.\tsvar{socks}).{}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsunknown{s}.\tsvar{is}_{1} = \tsvar{icmp}.\tsvar{is}_{3} \Mwedge  \tsunknown{s}.\tsvar{is}_{2} = \tsvar{icmp}.\tsvar{is}_{4} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsunknown{s}.\tsvar{ps}_{1} = \tsvar{icmp}.\tsvar{ps}_{3} \Mwedge  \tsunknown{s}.\tsvar{ps}_{2} = \tsvar{icmp}.\tsvar{ps}_{4} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad \tsaux{proto\_of} \;\tsunknown{s}.\tsvar{pr} = \tsvar{icmp}.\tsvar{proto})))}
{\rulesubsection{Description}
   If the ICMP is a type we handle, but the source IP is $\tsaux{IP} \;0 \;0 \;0
0$ or a multicast address, or there's no matching socket, then
   drop silently.  $\tscon{ICMP\_UNREACH} \;\tscon{NEEDFRAG}$ is handled specially,
   since we do not care if it's $\tsaux{IP} \;0 \;0 \;0 \;0$, only if it's multicast.

\rrulepad }
}

\newcommand{\chapcommnetworkTinputTandToutput}{\chaptersection{ Host LTS: Network Input and Output}
\label{network_input_and_output}%
\chapcomm{}
}

\newcommand{\seccommnetworkTinputTandToutputTsection}{\clustersection{(Network only)}{Input and Output}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{deliver\_in\_99}$
& \textbf{all: network nonurgent}
&  Really receive things \\
$\tsrule{deliver\_in\_99a}$
& \textbf{all: network nonurgent}
&  Ignore things not for us \\
$\tsrule{deliver\_out\_99}$
& \textbf{all: network nonurgent}
&  Really send things \\
$\tsrule{deliver\_loop\_99}$
& \textbf{all: network nonurgent}
&  Loop back a loopback message \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\deliverTinTXCIX}{\rrulecc{deliverTinTXCIX}{deliver\_in\_99}{all: network nonurgent}{\tsholcomm{ Really receive things }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec }
{\Mtransition{ \MLhrecvdatagram{\tsvar{msg}} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec }
{\tsaux{sane\_msg} \;\tsvar{msg} \Mwedge {}\\{}
 \Msome  \;\tsvar{i}_{1} = \tsvar{msg}.\tsvar{is}_{2} \Mwedge {}\\{}
 \tsvar{i}_{1} \;\in  \;\tsaux{local\_ips}(\tsvar{h}.\tsvar{ifds}) \Mwedge {}\\{}
 \tsaux{enqueue\_iq}(\tsvar{iq},\tsvar{msg},\tsvar{iq}',\tsvar{queued})}
{\rulesubsection{Description}
     Actually receive a message from the wire into the input queue.
     Note that if it cannot be queued (because the queue is full), it is
     silently dropped.

     We only accept messages that are for this host.  We also assert that any message we receive is
     well-formed (this excludes elements of type $\tsvar{msg}$ that have no physical realisation).

     Note the delay in in-queuing the datagram is not modelled here.

\rrulepad }
}

\newcommand{\deliverTinTXCIXa}{\rrulecc{deliverTinTXCIXa}{deliver\_in\_99a}{all: network nonurgent}{\tsholcomm{ Ignore things not for us }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq} \Mmagicrrec }
{\Mtransition{ \MLhrecvdatagram{\tsvar{msg}} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}' \Mmagicrrec }
{\Msome  \;\tsvar{i}_{1} = \tsvar{msg}.\tsvar{is}_{2} \Mwedge {}\\{}
 \tsvar{i}_{1} \;\notin  \;\tsaux{local\_ips}(\tsvar{h}.\tsvar{ifds}) \Mwedge {}\\{}
 \tsvar{iq} = \tsvar{iq}'}
{\rulesubsection{Description}
     Do not accept messages that are not for this host.


\rrulepad }
}

\newcommand{\deliverToutTXCIX}{\rrulecc{deliverToutTXCIX}{deliver\_out\_99}{all: network nonurgent}{\tsholcomm{ Really send things }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec }
{\Mtransition{ \MLhsenddatagram{\tsvar{msg}} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsaux{dequeue\_oq}(\tsvar{oq},\tsvar{oq}',\Msome  \;\tsvar{msg}) \Mwedge {}\\{}
 (\exists \tsvar{i}_{2}. \tsvar{msg}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{i}_{2} \;\notin  \;\tsaux{local\_ips} \;\tsvar{h}.\tsvar{ifds})}
{\rulesubsection{Description}
     Actually emit a segment from the output queue.

     Note the delay in dequeuing the datagram is not modelled here.


\rrulepad }
}

\newcommand{\deliverTloopTXCIX}{\rrulecc{deliverTloopTXCIX}{deliver\_loop\_99}{all: network nonurgent}{\tsholcomm{ Loop back a loopback message }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq};{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq} \Mmagicrrec }
{\Mtransition{ \tsvar{lbl} }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{iq} \Mass  \tsvar{iq}';{}\\{}
 \tsvar{oq} \Mass  \tsvar{oq}' \Mmagicrrec }
{\tsaux{dequeue\_oq}(\tsvar{oq},\tsvar{oq}',\Msome  \;\tsvar{msg}) \Mwedge {}\\{}
 (\exists \tsvar{i}_{2}. \tsvar{msg}.\tsvar{is}_{2} = \Msome  \;\tsvar{i}_{2} \Mwedge  \tsvar{i}_{2} \;\in  \;\tsaux{local\_ips} \;\tsvar{h}.\tsvar{ifds}) \Mwedge {}\\{}
 (\tsvar{lbl} = \Mif  \;\tsaux{windows\_arch} \;\tsvar{h}.\tstype{arch} \;\Mthen  \;\MLhtau {}\\{}
\quad\quad\quad \Melse  \MLhloopdatagram{\tsvar{msg}}) \Mwedge {}\\{}
 \tsaux{enqueue\_iq}(\tsvar{iq},\tsvar{msg},\tsvar{iq}',\tsvar{queued})}
{\rulesubsection{Description}
     Deliver a loopback message (for loopback address, or any of our
     addresses) from the outqueue to the inqueue.  (if we tagged each
     message in the outqueue with its interface, we'd just pick
     loopback-interface segments, but we do not, so we just discriminate
     on IP addresses).


\rrulepad }
}

\newcommand{\chapcommtraceTandTinterface}{\chaptersection{ Host LTS:  BSD Trace Records and Interface State Changes}
\label{trace_and_interface}%
\chapcomm{}
}

\newcommand{\seccommtraceTandTinterfaceTsection}{\clustersection{(BSD only)}{Trace Records and Interface State Changes}
\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{trace\_1}$
& \textbf{all: misc nonurgent}
&  Trace TCPCB state, $\tscon{ESTABLISHED}$ or later \\
$\tsrule{trace\_2}$
& \textbf{all: misc nonurgent}
&  Trace TCPCB state, pre-$\tscon{ESTABLISHED}$ \\
$\tsrule{interface\_1}$
& \textbf{all: misc nonurgent}
&  Change connectivity \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\traceTI}{\rrulecc{traceTI}{trace\_1}{all: misc nonurgent}{\tsholcomm{ Trace TCPCB state, $\tscon{ESTABLISHED}$ or later }}
{\tsvar{h}}
{\Mtransition{ \tscon{Lh\_trace} \;\tsvar{tr} }{1}}
{\tsvar{h}}
{\tsvar{sid} \;\in  \Mfdom{\tsvar{h}.\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{tr} = (\tsvar{flav},\tsvar{sid},\tsvar{quad},\tsvar{st},\tsvar{cb}) \Mwedge {}\\{}
 \tsvar{st} \;\in  \{\tscon{ESTABLISHED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}; \tscon{CLOSING};{}\\{}
\quad\quad\quad \tscon{CLOSE\_WAIT}; \tscon{LAST\_ACK}; \tscon{TIME\_WAIT}\} \Mwedge {}\\{}
 \Mlet  \;\tsvar{tr}' = (\tsvar{flav},\tsvar{sid},\tsvar{quad},\tsvar{st},\tsvar{cb}) \Min {}\\{}
 {}\\{}
 {}\\{}
 \tsaux{tracesock\_eq} \;\tsvar{tr}' \;\tsvar{sid} (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}})}
{\rulesubsection{Description}
     This rule exposes certain of the fields of the socket and TCPCB, to
     allow open-box testing.

     Note that although the label carries an entire TCPCB, only certain
     selected fields are constrained to be equal to the actual TCPCB.
     See \ltslink{tracesockTeq}{$\tsaux{tracesock\_eq}$} and \ltslink{tracecbTeq}{$\tsaux{tracecb\_eq}$} for
     details.

     Checking trace equality is problematic as BSD generates trace records that
     fall logically inbetween the atomic transitions in this model. This happens
     frequently when in a state before $\tscon{ESTABLISHED}$. We only check for equality
     when we are in $ \tscon{ESTABLISHED}$ or later states.


\rrulepad }
}

\newcommand{\traceTII}{\rrulecn{traceTII}{trace\_2}{all: misc nonurgent}{\tsholcomm{ Trace TCPCB state, pre-$\tscon{ESTABLISHED}$ }}
{\tsvar{h}}
{\Mtransition{ \tscon{Lh\_trace} \;\tsvar{tr} }{1}}
{\tsvar{h}}
{\tsvar{sid} \;\in  \Mfdom{\tsvar{h}.\tsvar{socks}} \Mwedge {}\\{}
 \tsvar{tr} = (\tsvar{flav},\tsvar{sid},\tsvar{quad},\tsvar{st},\tsvar{cb}) \Mwedge {}\\{}
 \tsvar{st} \;\notin  \{\tscon{ESTABLISHED}; \tscon{FIN\_WAIT\_1}; \tscon{FIN\_WAIT\_2}; \tscon{CLOSING};{}\\{}
\quad\quad\quad\quad\quad \tscon{CLOSE\_WAIT}; \tscon{LAST\_ACK}; \tscon{TIME\_WAIT}\} \Mwedge {}\\{}
 (\tsvar{st} = \tscon{CLOSED} \Mvee   \tsholcomm{ BSD emits one of these each time a tcpcb is created, eg at end of 3WHS }{}\\{}
 ((\exists \tsvar{sock} \;\tsunknown{tcp\_sock}.{}\\{}
\quad \tsvar{sock} = (\tsvar{h}.\tsvar{socks} \Mfapply{}{\tsvar{sid}}) \Mwedge {}\\{}
\quad \tsaux{proto\_of} \;\tsvar{sock}.\tsvar{pr} = \tscon{PROTO\_TCP} \Mwedge {}\\{}
\quad \tsunknown{tcp\_sock} = \tsaux{tcp\_sock\_of} \;\tsvar{sock} \Mwedge {}\\{}
\quad (\Mcase  \;\tsvar{quad} \;\Mof {}\\{}
\quad\quad \Msome  (\tsvar{is}_{1},\tsvar{ps}_{1},\tsvar{is}_{2},\tsvar{ps}_{2}) \Mtotype  \Mif  \;\tsvar{flav} = \tscon{TA\_DROP} \Mvee  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSED} \;\Mthen  \;\Mtrue {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \Melse {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \tsvar{is}_{1} = \tsvar{sock}.\tsvar{is}_{1} \Mwedge  \tsvar{ps}_{1} = \tsvar{sock}.\tsvar{ps}_{1} \Mwedge  \tsvar{is}_{2} = \tsvar{sock}.\tsvar{is}_{2} \Mwedge  \tsvar{ps}_{2} = \tsvar{sock}.\tsvar{ps}_{2} \Mdpipe {}\\{}
\quad\quad *                   \Mtotype  \Mtrue ) \Mwedge {}\\{}
\quad (\tsvar{st}  = \tsunknown{tcp\_sock}.\tsvar{st} \Mvee  \tsunknown{tcp\_sock}.\tsvar{st} = \tscon{CLOSED}))))}
{}
}

\newcommand{\interfaceTI}{\rrulecc{interfaceTI}{interface\_1}{all: misc nonurgent}{\tsholcomm{ Change connectivity }}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ifds} \Mass  \tsvar{ifds} \Mmagicrrec }
{\Mtransition{ \tscon{Lh\_interface} (\tsvar{ifid},\tsvar{up}) }{1}}
{\tsvar{h} \; \Mmagiclrec  \tsvar{ifds} \Mass  \tsvar{ifds}' \Mmagicrrec }
{\tsvar{ifid} \;\in  \Mfdom{\tsvar{ifds}} \Mwedge {}\\{}
 \tsvar{ifds}' = \tsvar{ifds} \oplus  (\tsvar{ifid}, (\tsvar{ifds} \Mfapply{}{\tsvar{ifid}})  \Mmagiclrec  \tsvar{up} \Mass  \tsvar{up} \Mmagicrrec )}
{\rulesubsection{Description}
     Allow interfaces to be externally brought up or taken down.


\rrulepad }
}

\newcommand{\chapcommtimeTpassage}{\chaptersection{ Host LTS:  Time Passage}
\label{time_passage}%
\chapcomm{}
}

\newcommand{\seccommtimeTpassageTauxsTsection}{\clustersection{(TCP and UDP)}{Time Passage auxiliaries}
\seccomm{
   Time passage is a \emph{function}, completely deterministic.
   Any nondeterminism must occur as a result of a tau
   (or other) transition.

   In the present semantics, time passage merely:
     \begin{enumerate}
     \item decrements all timers uniformly

     \item prevents time passage if a timer reaches zero

     \item prevents time passage if an urgent action is
        enabled.
     \end{enumerate}
   We model the first two points with functions $\tsunknown{Time\_Pass\_}*$, for various types
   $*$.  These functions return an option type: if the result is NONE then
   time may not pass for the given duration.  Essentially they pick out everything in a host state of type $\tsunknown{'a} \;\tstype{timed}$, and do something with it.

   We treat the last point in the rule \ltslink{epsilonTI}{$\tsrule{epsilon\_1}$} itself, below.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{Time\_Pass\_timedoption}$
&
&  time passes for an $\tsunknown{'a} \;\tstype{timed} \;\;\tstype{option}$ value \\
$\tsrule{Time\_Pass\_tcpcb}$
&
&  time passes for a tcp control block \\
$\tsrule{Time\_Pass\_socket}$
&
&  time passes for a socket \\
$\tsrule{fmap\_every}$
&
&  apply $\tsunknown{f}$ to range of finite map, and succeed if each application succeeds \\
$\tsrule{fmap\_every\_pred}$
&
&  apply $\tsunknown{f}$ to range of finite map, and succeed if each application succeeds \\
$\tsrule{Time\_Pass\_host}$
&
&  time passes for a host \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnTimeTPassTtimedoption}{\ddefnn{TimeTPassTtimedoption}{\iA{Time\_Pass\_timedoption}}{\subddefnA[{ time passes for an $\tsunknown{'a} \;\tstype{timed} \;\;\tstype{option}$ value }]{Time\_Pass\_timedoption}{(\tsaux{Time\_Pass\_timedoption} : \tsaux{duration} \Mtotype  \tsunknown{'a} \;\tstype{timed} \;\;\tstype{option} \Mtotype  \tsunknown{'a} \;\tstype{timed} \;\;\tstype{option} \;\;\tstype{option}){}\\{}
 \tsunknown{dur} \;\tsunknown{x0}{}\\{}
 = \Mcase  \;\tsunknown{x0} \;\Mof {}\\{}
\quad *   \Mtotype  \Msome  \;* \Mdpipe {}\\{}
\quad \Msome  \;\tsunknown{x} \Mtotype  (\Mcase  \;\tsaux{Time\_Pass\_timed} \;\tsunknown{dur} \;\tsunknown{x} \;\Mof {}\\{}
\quad\quad\quad\quad\quad\quad\quad * \Mtotype  * \Mdpipe {}\\{}
\quad\quad\quad\quad\quad\quad\quad \Msome  \;\tsunknown{x0'} \Mtotype  \Msome  (\Msome  \;\tsunknown{x0'}))}
}
{}
}

\newcommand{\defnTimeTPassTtcpcb}{\ddefnn{TimeTPassTtcpcb}{\iA{Time\_Pass\_tcpcb}}{\subddefnA[{ time passes for a tcp control block }]{Time\_Pass\_tcpcb}{(\tsaux{Time\_Pass\_tcpcb} : \tsaux{duration} \Mtotype  \tstype{tcpcb} \Mtotype  \tstype{tcpcb} \;\tstype{set} \;\;\tstype{option})  \tscomm{ recall: 'a set == 'a -\textgreater{} bool }{}\\{}
 \tsunknown{dur} \;\tsvar{cb}{}\\{}
 = \Mlet  \;\tsunknown{tt\_rexmt'}      = \tsaux{Time\_Pass\_timedoption} \;\tsunknown{dur} \;\tsvar{cb}.\tsfield{tt\_rexmt}{}\\{}
 \Mand  \;\tsunknown{tt\_keep'}       = \tsaux{Time\_Pass\_timedoption} \;\tsunknown{dur} \;\tsvar{cb}.\tsfield{tt\_keep}{}\\{}
 \Mand  \;\tsunknown{tt\_2msl'}       = \tsaux{Time\_Pass\_timedoption} \;\tsunknown{dur} \;\tsvar{cb}.\tsfield{tt\_2msl}{}\\{}
 \Mand  \;\tsunknown{tt\_delack'}     = \tsaux{Time\_Pass\_timedoption} \;\tsunknown{dur} \;\tsvar{cb}.\tsfield{tt\_delack}{}\\{}
 \Mand  \;\tsunknown{tt\_conn\_est'}   = \tsaux{Time\_Pass\_timedoption} \;\tsunknown{dur} \;\tsvar{cb}.\tsfield{tt\_conn\_est}{}\\{}
 \Mand  \;\tsunknown{tt\_fin\_wait\_2'} = \tsaux{Time\_Pass\_timedoption} \;\tsunknown{dur} \;\tsvar{cb}.\tsfield{tt\_fin\_wait\_2}{}\\{}
 \Mand  \;\tsunknown{ts\_recent's}    = \tsaux{Time\_Pass\_timewindow} \;\tsunknown{dur} \;\tsvar{cb}.\tsfield{ts\_recent}{}\\{}
 \Mand  \;\tsunknown{t\_badrxtwin's} = \tsaux{Time\_Pass\_timewindow} \;\tsunknown{dur} \;\tsvar{cb}.\tsfield{t\_badrxtwin}{}\\{}
 \Mand  \;\tsunknown{t\_idletime's}   = \tsaux{Time\_Pass\_stopwatch} \;\tsunknown{dur} \;\tsvar{cb}.\tsfield{t\_idletime}{}\\{}
 \Min {}\\{}
 \Mif  \;\tsholop{IS\_SOME} \;\tsunknown{tt\_rexmt'} \Mwedge {}\\{}
\quad \tsholop{IS\_SOME} \;\tsunknown{tt\_keep'} \Mwedge {}\\{}
\quad \tsholop{IS\_SOME} \;\tsunknown{tt\_2msl'} \Mwedge {}\\{}
\quad \tsholop{IS\_SOME} \;\tsunknown{tt\_delack'} \Mwedge {}\\{}
\quad \tsholop{IS\_SOME} \;\tsunknown{tt\_conn\_est'} \Mwedge {}\\{}
\quad \tsholop{IS\_SOME} \;\tsunknown{tt\_fin\_wait\_2'}{}\\{}
 \Mthen {}\\{}
\quad \Msome  (\lambda \tsvar{cb}'.{}\\{}
\quad\quad\quad\quad \tsholop{choose} \;\tsunknown{ts\_recent'} \Mcons  \tsunknown{ts\_recent's}.{}\\{}
\quad\quad\quad\quad \tsholop{choose} \;\tsunknown{t\_badrxtwin'} \Mcons  \tsunknown{t\_badrxtwin's} .{}\\{}
\quad\quad\quad\quad \tsholop{choose} \;\tsunknown{t\_idletime'} \Mcons  \tsunknown{t\_idletime's} .{}\\{}
\quad\quad\quad\quad \tsvar{cb}' ={}\\{}
\quad\quad\quad\quad \tsvar{cb} \; \Mmagiclrec  \tscomm{ not going to list everything here; too much! }{}\\{}
 \tsfield{tt\_rexmt}      \Mass  \tsholop{THE} \;\tsunknown{tt\_rexmt'};{}\\{}
 \tsfield{tt\_keep}       \Mass  \tsholop{THE} \;\tsunknown{tt\_keep'};{}\\{}
 \tsfield{tt\_2msl}       \Mass  \tsholop{THE} \;\tsunknown{tt\_2msl'};{}\\{}
 \tsfield{tt\_delack}     \Mass  \tsholop{THE} \;\tsunknown{tt\_delack'};{}\\{}
 \tsfield{tt\_conn\_est}   \Mass  \tsholop{THE} \;\tsunknown{tt\_conn\_est'};{}\\{}
 \tsfield{tt\_fin\_wait\_2} \Mass  \tsholop{THE} \;\tsunknown{tt\_fin\_wait\_2'};{}\\{}
 \tsfield{ts\_recent}     \Mass  \tsunknown{ts\_recent'};{}\\{}
 \tsfield{t\_badrxtwin}   \Mass  \tsunknown{t\_badrxtwin'};{}\\{}
 \tsfield{t\_idletime}    \Mass  \tsunknown{t\_idletime'}{}\\{}
 \Mmagicbolrrec ){}\\{}
 \Melse {}\\{}
\quad *}
}
{}
}

\newcommand{\defnTimeTPassTsocket}{\ddefnn{TimeTPassTsocket}{\iA{Time\_Pass\_socket}}{\subddefnA[{ time passes for a socket }]{Time\_Pass\_socket}{(\tsaux{Time\_Pass\_socket} : \tsaux{duration} \Mtotype  \tslib{socket} \Mtotype  \tslib{socket} \;\tstype{set} \;\;\tstype{option}){}\\{}
 \tsunknown{dur} \;\tsunknown{s}{}\\{}
 = \Mcase  \;\tsunknown{s}.\tsvar{pr} \;\Mof  \;\tscon{UDP\_PROTO}(\tsunknown{udp}) \Mtotype  \Msome  \{ \tsunknown{s} \}{}\\{}
 \Mdpipe  \tscon{TCP\_PROTO}(\tsunknown{tcp\_s}) \Mtotype {}\\{}
\quad \Mlet  \;\tsunknown{cb's} = \tsaux{Time\_Pass\_tcpcb} \;\tsunknown{dur} \;\tsunknown{tcp\_s}.\tsvar{cb}{}\\{}
\quad \Min {}\\{}
\quad \Mif  \;\tsholop{IS\_SOME} \;\tsunknown{cb's}{}\\{}
\quad \Mthen {}\\{}
\quad\quad \Msome  (\lambda \tsvar{s}'.{}\\{}
\quad\quad\quad\quad\quad \tsholop{choose} \;\tsvar{cb}' \Mcons  \tsholop{THE} \;\tsunknown{cb's}.{}\\{}
\quad\quad\quad\quad\quad \tsvar{s}' ={}\\{}
\quad\quad\quad\quad\quad \tsunknown{s} \; \Mmagiclrec  \tscomm{ fid unchanged }{}\\{}
 \tscomm{ sf unchanged }{}\\{}
 \tscomm{ is1,ps1,is2,ps2 unchanged }{}\\{}
 \tscomm{ es unchanged }{}\\{}
 \tsvar{pr} \Mass  \tscon{TCP\_PROTO}(\tsunknown{tcp\_s} \; \Mmagiclrec  \tsvar{cb} \Mass  \tsvar{cb}' \Mmagicrrec ){}\\{}
 \Mmagicbolrrec ){}\\{}
\quad \Melse {}\\{}
\quad\quad *}
}
{}
}

\newcommand{\defnfmapTevery}{\ddefnn{fmapTevery}{\iA{fmap\_every}}{\subddefnA[{ apply $\tsunknown{f}$ to range of finite map, and succeed if each application succeeds }]{fmap\_every}{(\tsaux{fmap\_every} : (\tsunknown{'a} \Mtotype  \tsunknown{'b} \;\;\tstype{option}) \Mtotype  (\tsunknown{'c} \mapsto  \tsunknown{'a}) \Mtotype  (\tsunknown{'c} \mapsto  \tsunknown{'b}) \;\tstype{option}){}\\{}
\quad\quad\quad\quad \tsunknown{f} \;\tsunknown{fm} ={}\\{}
 \Mlet  \;\tsunknown{fm'} = \tsunknown{f} \;\tsunknown{o\_f} \;\tsunknown{fm}{}\\{}
 \Min {}\\{}
 \Mif  \;* \;\in  \Mfrange{\tsunknown{fm'}}{}\\{}
 \Mthen  \;*{}\\{}
 \Melse  \;\Msome  (\tsholop{THE} \;\tsunknown{o\_f} \;\tsunknown{fm'})}
}
{}
}

\newcommand{\defnfmapTeveryTpred}{\ddefnn{fmapTeveryTpred}{\iA{fmap\_every\_pred}}{\subddefnA[{ apply $\tsunknown{f}$ to range of finite map, and succeed if each application succeeds }]{fmap\_every\_pred}{(\tsaux{fmap\_every\_pred} : (\tsunknown{'a} \Mtotype  \tsunknown{'b} \;\tstype{set} \;\;\tstype{option}) \Mtotype  (\tsunknown{'c} \mapsto  \tsunknown{'a}) \Mtotype  (\tsunknown{'c} \mapsto  \tsunknown{'b}) \tstype{set} \;\;\tstype{option}){}\\{}
\quad\quad\quad\quad \tsunknown{f} \;\tsunknown{fm} ={}\\{}
 \Mif  \exists \tsvar{y}. \tsvar{y} \;\in  \Mfrange{\tsunknown{fm}} \Mwedge  \tsunknown{f} \;\tsvar{y} = * \;\Mthen {}\\{}
\quad *{}\\{}
 \Melse {}\\{}
\quad \Msome  \{ \tsunknown{fm'} \mid  \Mfdom{\tsunknown{fm}} = \Mfdom{\tsunknown{fm'}} \Mwedge {}\\{}
\quad\quad\quad\quad\quad\quad\quad\quad \forall \tsvar{x}. \tsvar{x} \;\in  \Mfdom{\tsunknown{fm}} \implies  \tsunknown{fm'} \Mfapply{}{\tsvar{x}} \in  (\tsholop{THE} (\tsunknown{f} (\tsunknown{fm} \Mfapply{}{\tsvar{x}}))) \}}
}
{}
}

\newcommand{\defnTimeTPassThost}{\ddefnn{TimeTPassThost}{\iA{Time\_Pass\_host}}{\subddefnA[{ time passes for a host }]{Time\_Pass\_host}{(\tsaux{Time\_Pass\_host} : \tsaux{duration} \Mtotype  \tstype{host} \Mtotype  \tstype{host} \;\tstype{set} \;\;\tstype{option}){}\\{}
 \tsunknown{dur} \;\tsunknown{h}{}\\{}
 = \Mlet  \;\tsvar{ts}'     = \tsaux{fmap\_every} (\tsaux{Time\_Pass\_timed} \;\tsunknown{dur}) \tsunknown{h}.\tsvar{ts}{}\\{}
 \Mand  \;\tsunknown{socks's} = \tsaux{fmap\_every\_pred} (\tsaux{Time\_Pass\_socket} \;\tsunknown{dur}) \tsunknown{h}.\tsvar{socks}{}\\{}
 \Mand  \;\tsvar{iq}'     = \tsaux{Time\_Pass\_timed} \;\tsunknown{dur} \;\tsunknown{h}.\tsvar{iq}{}\\{}
 \Mand  \;\tsvar{oq}'     = \tsaux{Time\_Pass\_timed} \;\tsunknown{dur} \;\tsunknown{h}.\tsvar{oq}{}\\{}
 \Mand  \;\tsunknown{ticks's} = \tsaux{Time\_Pass\_ticker} \;\tsunknown{dur} \;\tsunknown{h}.\tsvar{ticks}{}\\{}
 \Min {}\\{}
 \Mif  \;\tsholop{IS\_SOME} \;\tsvar{ts}' \Mwedge {}\\{}
\quad \tsholop{IS\_SOME} \;\tsunknown{socks's} \Mwedge {}\\{}
\quad \tsholop{IS\_SOME} \;\tsvar{iq}' \Mwedge {}\\{}
\quad \tsholop{IS\_SOME} \;\tsvar{oq}'{}\\{}
 \Mthen {}\\{}
\quad \Msome  (\lambda \tsvar{h}'.{}\\{}
\quad\quad\quad\quad \tsholop{choose} \;\tsvar{socks}' \Mcons  \tsholop{THE} \;\tsunknown{socks's}.{}\\{}
\quad\quad\quad\quad \tsholop{choose} \;\tsvar{ticks}' \Mcons  \tsunknown{ticks's}.{}\\{}
\quad\quad\quad\quad \tsvar{h}' ={}\\{}
\quad\quad\quad\quad \tsunknown{h} \; \Mmagiclrec  \tscomm{ arch unchanged }{}\\{}
 \tscomm{ ifds unchanged }{}\\{}
 \tsvar{ts} \Mass  \tsholop{THE} \;\tsvar{ts}';{}\\{}
 \tscomm{ files unchanged }{}\\{}
 \tsvar{socks} \Mass  \tsvar{socks}';{}\\{}
 \tscomm{ listen unchanged }{}\\{}
 \tscomm{ bound unchanged }{}\\{}
 \tsvar{iq} \Mass  \tsholop{THE} \;\tsvar{iq}';{}\\{}
 \tsvar{oq} \Mass  \tsholop{THE} \;\tsvar{oq}';{}\\{}
 \tsvar{ticks} \Mass  \tsvar{ticks}'{}\\{}
 \tscomm{ fds unchanged }{}\\{}
 \Mmagicbolrrec ){}\\{}
 \Melse {}\\{}
\quad *}
}
{}
}

\newcommand{\seccommtimeTpassageTsection}{\clustersection{(TCP and UDP)}{Host transitions with time}
\seccomm{
We now build the relation $\Mtransition{ }{2XXXXX\Mtransitionerr{--=>}}$, which includes time transitions, from the relation $\Mtransition{ }{1XXXXX\Mtransitionerr{-->}}$,
which is instantaneous.  This avoids circularity (or at best inductiveness) in the definition of
the transition relation.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{epsilon\_1}$
& \textbf{all: misc nonurgent}
&  Time passes \\
$\tsrule{epsilon\_2}$
& \textbf{all: misc nonurgent}
&  Inductively defined time passage \\
$\tsrule{rn}$
& \textbf{rp: rc}
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\epsilonTI}{\rrulecc{epsilonTI}{epsilon\_1}{all: misc nonurgent}{\tsholcomm{ Time passes }}
{\tsvar{h}}
{\Mtransition{ \Meps{\tsvar{dur}} }{2}}
{\tsvar{h}'}
{\Mlet  \;\tsunknown{hs'} = \tsaux{Time\_Pass\_host} \;\tsvar{dur} \;\tsvar{h} \;\Min {}\\{}
\quad\quad \tsholop{IS\_SOME} \;\tsunknown{hs'} \Mwedge {}\\{}
\quad\quad \tsvar{h}' \;\in  (\tsholop{THE} \;\tsunknown{hs'}) \Mwedge {}\\{}
\quad\quad \neg{}(\exists \tsvar{rn} \;\tsvar{rp} \;\tsvar{rc} \;\tsvar{lbl} \;\tsvar{h}'. \tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{h} \Mtransition{\tsvar{lbl}}{1XXXXX\Mtransitionerr{-->}} \tsvar{h}' \Mwedge  \tsaux{is\_urgent} \;\tsvar{rc})}
{\rulesubsection{Description}
   Allow time to pass for $\tsvar{dur}$ seconds.  This is only enabled if the host state is not urgent, i.e.\ if no urgent rule can fire.
   Notice that, apart from when a timer becomes zero, a host state
   never becomes urgent due merely to time passage.  This means we need
   only test for urgency at the beginning of the time interval, not
   throughout it.


\rrulepad }
}

\newcommand{\epsilonTII}{\rrulecc{epsilonTII}{epsilon\_2}{all: misc nonurgent}{\tsholcomm{ Inductively defined time passage }}
{\tsvar{h}}
{\Mtransition{ \Meps{\tsvar{dur}} }{2}}
{\tsvar{h}'}
{(\exists \tsvar{h}_{1} \;\tsvar{h}_{2} \;\tsvar{dur}' \;\tsvar{dur}''.{}\\{}
\quad \tsvar{dur}' < \tsvar{dur} \Mwedge {}\\{}
\quad (\exists \tsvar{rn} \;\tsvar{rp} \;\tsvar{rc}. \tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{h} \Mtransition{\Meps{\tsvar{dur}'}}{2XXXXX\Mtransitionerr{--=>}} \tsvar{h}_{1}) \Mwedge {}\\{}
\quad (\exists \tsvar{rn} \;\tsvar{rp} \;\tsvar{rc}. \tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{h}_{1} \Mtransition{\MLhtau }{2XXXXX\Mtransitionerr{--=>}} \tsvar{h}_{2}) \Mwedge {}\\{}
\quad \tsvar{dur}' + \tsvar{dur}'' = \tsvar{dur} \Mwedge {}\\{}
\quad (\exists \tsvar{rn} \;\tsvar{rp} \;\tsvar{rc}. \tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{h}_{2} \Mtransition{\Meps{\tsvar{dur}''}}{2XXXXX\Mtransitionerr{--=>}} \tsvar{h}'){}\\{}
 )}
{\rulesubsection{Description}

     Combine time passage and $\MLhtau $ transitions.

     FIXME tjr22 this rule probably erroneous- remove from next version of spec. Refactor to avoid
     two relations- epsilon transitions can be made perfectly well in the original host0redn.

     Analysis: currently hosts are allowed to perform Tau transitions when something happens
     internally to the host. One could allow Tau transitions such that the host doesn't change
     state. This allows stuttering in a given state. However, adding Tau transitions in this manner
     is probably not the best approach: if you need this in a proof, you can rephrase the
     proof. Thus, I believe stuttering should not be explicitly added to a transition system.

     This rule seems to be trying to allow hosts to make Tau transitions whenever they like, so that
     they can stutter as described above. However, it is also mixed in with some notion of time
     passage. This notion is unclear, to me at least. At any rate, this rule is not necessary for
     trace checking, so it is practically unnecessary. Furthermore, I do not see the point of this
     rule, and believe it is theoretically unnecessary as well.

     FIXME as far as time transition is concerned, there is something else missing from the
     spec. The current model is of a host doing instantaneous transitions at a moment in time, with
     time passage between events which are separated in time. However, if we want to know the state
     of a host during time passage, there is nothing that tells us that it remains constant. So in
     effect we are modelling only the transitions, not the evolution of the system with time, even
     though there is clearly an attempt to model the system as it evolves through time.


\rrulepad }
}

\newcommand{\rn}{\rrulecc{rn}{rn}{rp: rc}{}
{\tsvar{h}}
{\Mtransition{ \tsvar{lbl} }{2}}
{\tsvar{h}'}
{\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */{}\\{}
 \tsvar{h}{}\\{}
 \Mtransition{\tsvar{lbl}}{1XXXXX\Mtransitionerr{-->}}{}\\{}
 \tsvar{h}'}
{\rulesubsection{Description}
   Embed all non-time transitions in the full LTS

\rrulepad }
}

\newcommand{\dumpallrules}{
\showrule{\chapcommsocketTcalls}
\showrule{\seccommaccept}
\showrule{\acceptTI}
\showrule{\acceptTII}
\showrule{\acceptTIII}
\showrule{\acceptTIV}
\showrule{\acceptTV}
\showrule{\acceptTVI}
\showrule{\acceptTVII}
\showrule{\seccommbind}
\showrule{\bindTI}
\showrule{\bindTII}
\showrule{\bindTIII}
\showrule{\bindTV}
\showrule{\bindTVII}
\showrule{\bindTIX}
\showrule{\seccommclose}
\showrule{\closeTI}
\showrule{\closeTII}
\showrule{\closeTIII}
\showrule{\closeTIV}
\showrule{\closeTV}
\showrule{\closeTVI}
\showrule{\closeTVII}
\showrule{\closeTVIII}
\showrule{\closeTX}
\showrule{\seccommconnect}
\showrule{\connectTI}
\showrule{\connectTII}
\showrule{\connectTIII}
\showrule{\connectTIV}
\showrule{\connectTIVa}
\showrule{\connectTV}
\showrule{\connectTVa}
\showrule{\connectTVb}
\showrule{\connectTVc}
\showrule{\connectTVd}
\showrule{\connectTVI}
\showrule{\connectTVII}
\showrule{\connectTVIII}
\showrule{\connectTIX}
\showrule{\connectTX}
\showrule{\seccommdisconnect}
\showrule{\disconnectTIV}
\showrule{\disconnectTV}
\showrule{\disconnectTI}
\showrule{\disconnectTII}
\showrule{\disconnectTIII}
\showrule{\seccommdup}
\showrule{\dupTI}
\showrule{\dupTII}
\showrule{\seccommdupfd}
\showrule{\dupfdTI}
\showrule{\dupfdTIII}
\showrule{\dupfdTIV}
\showrule{\seccommgetfileflags}
\showrule{\getfileflagsTI}
\showrule{\seccommgetifaddrs}
\showrule{\getifaddrsTI}
\showrule{\seccommgetpeername}
\showrule{\getpeernameTI}
\showrule{\getpeernameTII}
\showrule{\seccommgetsockbopt}
\showrule{\getsockboptTI}
\showrule{\getsockboptTII}
\showrule{\seccommgetsockerr}
\showrule{\getsockerrTI}
\showrule{\getsockerrTII}
\showrule{\seccommgetsocklistening}
\showrule{\getsocklisteningTI}
\showrule{\getsocklisteningTIII}
\showrule{\getsocklisteningTII}
\showrule{\seccommgetsockname}
\showrule{\getsocknameTI}
\showrule{\getsocknameTII}
\showrule{\getsocknameTIII}
\showrule{\seccommgetsocknopt}
\showrule{\getsocknoptTI}
\showrule{\getsocknoptTIV}
\showrule{\seccommgetsocktopt}
\showrule{\getsocktoptTI}
\showrule{\getsocktoptTIV}
\showrule{\seccommlisten}
\showrule{\listenTI}
\showrule{\listenTIb}
\showrule{\listenTIc}
\showrule{\listenTII}
\showrule{\listenTIII}
\showrule{\listenTIV}
\showrule{\listenTV}
\showrule{\listenTVII}
\showrule{\seccommpselect}
\showrule{\pselectTI}
\showrule{\defnsoreadable}
\showrule{\defnsowriteable}
\showrule{\defnsoexceptional}
\showrule{\pselectTII}
\showrule{\pselectTIII}
\showrule{\pselectTIV}
\showrule{\pselectTV}
\showrule{\pselectTVI}
\showrule{\seccommtcpTrecv}
\showrule{\recvTI}
\showrule{\recvTII}
\showrule{\recvTIII}
\showrule{\recvTIV}
\showrule{\recvTV}
\showrule{\recvTVI}
\showrule{\recvTVII}
\showrule{\recvTVIII}
\showrule{\recvTVIIIa}
\showrule{\recvTIX}
\showrule{\seccommudpTrecv}
\showrule{\recvTXI}
\showrule{\recvTXII}
\showrule{\recvTXIII}
\showrule{\recvTXIV}
\showrule{\recvTXV}
\showrule{\recvTXVI}
\showrule{\recvTXVII}
\showrule{\recvTXX}
\showrule{\recvTXXI}
\showrule{\recvTXXII}
\showrule{\recvTXXIII}
\showrule{\recvTXXIV}
\showrule{\seccommtcpTsend}
\showrule{\sendTI}
\showrule{\sendTII}
\showrule{\sendTIII}
\showrule{\sendTIIIa}
\showrule{\sendTIV}
\showrule{\sendTV}
\showrule{\sendTVa}
\showrule{\sendTVI}
\showrule{\sendTVII}
\showrule{\sendTVIII}
\showrule{\seccommudpTsend}
\showrule{\sendTIX}
\showrule{\sendTX}
\showrule{\sendTXI}
\showrule{\sendTXII}
\showrule{\sendTXIII}
\showrule{\sendTXIV}
\showrule{\sendTXV}
\showrule{\sendTXVI}
\showrule{\sendTXVII}
\showrule{\sendTXVIII}
\showrule{\sendTXIX}
\showrule{\sendTXXI}
\showrule{\sendTXXII}
\showrule{\sendTXXIII}
\showrule{\seccommsetfileflags}
\showrule{\setfileflagsTI}
\showrule{\seccommsetsockbopt}
\showrule{\setsockboptTI}
\showrule{\setsockboptTII}
\showrule{\seccommsetsocknopt}
\showrule{\setsocknoptTI}
\showrule{\setsocknoptTII}
\showrule{\setsocknoptTIV}
\showrule{\seccommsetsocktopt}
\showrule{\setsocktoptTI}
\showrule{\setsocktoptTIV}
\showrule{\setsocktoptTV}
\showrule{\seccommshutdown}
\showrule{\shutdownTI}
\showrule{\shutdownTII}
\showrule{\shutdownTIII}
\showrule{\shutdownTIV}
\showrule{\seccommsockatmark}
\showrule{\sockatmarkTI}
\showrule{\sockatmarkTII}
\showrule{\seccommsocket}
\showrule{\socketTI}
\showrule{\socketTII}
\showrule{\seccommmisc}
\showrule{\returnTI}
\showrule{\badfTI}
\showrule{\notsockTI}
\showrule{\intrTI}
\showrule{\resourcefailTI}
\showrule{\resourcefailTII}
\showrule{\chapcommtcpTinputTprocessing}
\showrule{\seccommtcpTinputTprocessing}
\showrule{\deliverTinTI}
\showrule{\deliverTinTIb}
\showrule{\deliverTinTII}
\showrule{\deliverTinTIIa}
\showrule{\deliverTinTIII}
\showrule{\defndiIIITtopstuff}
\showrule{\defndiIIITnewackstuff}
\showrule{\defndiIIITackstuff}
\showrule{\defndiIIITdatastuffTreally}
\showrule{\defndiIIITdatastuff}
\showrule{\defndiIIITststuff}
\showrule{\defndiIIITsocksTupdate}
\showrule{\deliverTinTIIIa}
\showrule{\deliverTinTIIIb}
\showrule{\deliverTinTIIIc}
\showrule{\deliverTinTIV}
\showrule{\deliverTinTV}
\showrule{\deliverTinTVI}
\showrule{\deliverTinTVII}
\showrule{\deliverTinTVIIa}
\showrule{\deliverTinTVIIb}
\showrule{\deliverTinTVIIc}
\showrule{\deliverTinTVIId}
\showrule{\deliverTinTVIII}
\showrule{\deliverTinTIX}
\showrule{\chapcommtcpToutput}
\showrule{\seccommtcpToutputTsection}
\showrule{\deliverToutTI}
\showrule{\chapcommtcpTtimers}
\showrule{\seccommtcpTtimersTsection}
\showrule{\timerTttTrexmtsynTI}
\showrule{\timerTttTrexmtTI}
\showrule{\timerTttTpersistTI}
\showrule{\timerTttTkeepTI}
\showrule{\timerTttTIImslTI}
\showrule{\timerTttTdelackTI}
\showrule{\timerTttTconnTestTI}
\showrule{\timerTttTfinTwaitTIITI}
\showrule{\chapcommudpTinputTprocessing}
\showrule{\seccommudpTinputTprocessingTsection}
\showrule{\deliverTinTudpTI}
\showrule{\deliverTinTudpTII}
\showrule{\deliverTinTudpTIII}
\showrule{\chapcommicmpTinputTprocessing}
\showrule{\seccommicmpTinputTprocessingTsection}
\showrule{\deliverTinTicmpTI}
\showrule{\deliverTinTicmpTII}
\showrule{\deliverTinTicmpTIII}
\showrule{\deliverTinTicmpTIV}
\showrule{\deliverTinTicmpTV}
\showrule{\deliverTinTicmpTVI}
\showrule{\deliverTinTicmpTVII}
\showrule{\chapcommnetworkTinputTandToutput}
\showrule{\seccommnetworkTinputTandToutputTsection}
\showrule{\deliverTinTXCIX}
\showrule{\deliverTinTXCIXa}
\showrule{\deliverToutTXCIX}
\showrule{\deliverTloopTXCIX}
\showrule{\chapcommtraceTandTinterface}
\showrule{\seccommtraceTandTinterfaceTsection}
\showrule{\traceTI}
\showrule{\traceTII}
\showrule{\interfaceTI}
\showrule{\chapcommtimeTpassage}
\showrule{\seccommtimeTpassageTauxsTsection}
\showrule{\defnTimeTPassTtimedoption}
\showrule{\defnTimeTPassTtcpcb}
\showrule{\defnTimeTPassTsocket}
\showrule{\defnfmapTevery}
\showrule{\defnfmapTeveryTpred}
\showrule{\defnTimeTPassThost}
\showrule{\seccommtimeTpassageTsection}
\showrule{\epsilonTI}
\showrule{\epsilonTII}
\showrule{\rn}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore net

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\newcommand{\chapcommnetTLTS}{\chaptersection{ Net LTS: some other}
\label{net_LTS}%
\chapcomm{
some text


}
}

\newcommand{\seccommnetTLTS}{\clustersection{(TCP only)}{Net LTS}
\seccomm{
some text


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{type\_abbrev\_msgs}$
&
& \\
$\tsrule{type\_abbrev\_hosts}$
&
& \\
$\tsrule{type\_abbrev\_net}$
&
& \\
$\tsrule{hosts\_to\_net}$
&
& \\
$\tsrule{Lnet0}$
&
&  Net transition labels \\
$\tsrule{tlang\_typing}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defntypeTabbrevTmsgs}{\ddefnn{typeTabbrevTmsgs}{\iA{type\_abbrev\_msgs}}{\subddefnA{type\_abbrev\_msgs}{\tsholop{type\_abbrev} \;\tsunknown{msgs} :\tstype{msg} \;\tstype{timed} \;\tsunknown{multiset}}
}
{}
}

\newcommand{\defntypeTabbrevThosts}{\ddefnn{typeTabbrevThosts}{\iA{type\_abbrev\_hosts}}{\subddefnA{type\_abbrev\_hosts}{\tsholop{type\_abbrev} \;\tsunknown{hosts} :\tstype{hostid} \mapsto  \tstype{host}}
}
{}
}

\newcommand{\defntypeTabbrevTnet}{\ddefnn{typeTabbrevTnet}{\iA{type\_abbrev\_net}}{\subddefnA{type\_abbrev\_net}{\tsholop{type\_abbrev} \;\tsunknown{net} :\tsunknown{hosts} \# \tsunknown{msgs}}
}
{}
}

\newcommand{\defnhostsTtoTnet}{\ddefnn{hostsTtoTnet}{\iA{hosts\_to\_net}}{\subddefnA{hosts\_to\_net}{\tsaux{hosts\_to\_net} (\tsunknown{h1}:\tstype{host},\tsunknown{h2}:\tstype{host}) = (\emptyset  \oplus  [(\tscon{Test},\tsunknown{h1});(\tscon{Aux},\tsunknown{h2})])}
}
{}
}

\newcommand{\defnLnetZ}{\ddefnn{LnetZ}{\iA{Lnet0}}{\subddefnA[{ Net transition labels }]{Lnet0}{\tstype{Lnet0} ={}\\{}
\quad\quad \tscomm{ library interface }{}\\{}
\quad\quad\quad \tscon{Ln0\_call} \;\Mof  \;\tstype{hostid} \# \tstype{tid} \# \tstype{LIB\_interface}                        \tsholcomm{ invocation of LIB call, written e.g.~$\MLhcall{\tstype{tid}}{(\tslib{socket} (\tstype{socktype}))}$ }{}\\{}
\quad\quad \mid  \tscon{Ln0\_return} \;\Mof  \;\tstype{hostid} \# \tstype{tid} \# \tstype{TLang}                              \tsholcomm{ return result of LIB call, written $\MLhreturn{\tstype{tid}}{\tsunknown{v}} $ }{}\\{}
 {}\\{}
\quad\quad \tscomm{ connectivity changes FIXME }{}\\{}
\quad\quad \mid  \tscon{Ln0\_interface} \;\Mof  \;\tstype{hostid} \# \tsvar{ifid} \# \tstype{bool}                         \tsholcomm{ set interface status to boolean $\tsvar{up}$, written $\tscon{Lh\_interface} (\tsvar{ifid},\tsvar{up})$ }{}\\{}
 {}\\{}
\quad\quad \tscomm{ miscellaneous }{}\\{}
\quad\quad \mid  \tscon{Ln0\_tau}                                              \tsholcomm{ internal transition, written $\MLhtau $ }{}\\{}
\quad\quad \mid  \tscon{Ln0\_epsilon} \;\Mof  \;\tsaux{duration}                              \tsholcomm{ time passage, written $\Meps{\tsunknown{dur}}$ }{}\\{}
\quad\quad \mid  \tscon{Ln0\_trace} \;\Mof  \;\tsunknown{tracerecord}                             \tsholcomm{ TCP trace record, written $\tscon{Lh\_trace} \;\tsunknown{tr}$ }}
}
{}
}

\newcommand{\defntlangTtyping}{\ddefnn{tlangTtyping}{\iA{tlang\_typing}}{\subddefnA{tlang\_typing}{(\forall  \tsvar{hs} \;\tsvar{hid} \;\tsvar{h} \;\tsvar{h}' \;\tsvar{tid} \;\tsvar{c} \;\tsvar{msgs}{}\\{}
\quad \tsvar{rn} \;\tsvar{rp} \;\tsvar{rc}.{}\\{}
 {}\\{}
 \tsvar{hid} \;\notin  \Mfdom{\tsvar{hs}} \Mwedge {}\\{}
 {}\\{}
 (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{h} \Mtransition{\MLhcall{\tsvar{tid}}{\tsvar{c}}}{2XXXXX\Mtransitionerr{--=>}} \tsvar{h}'){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net\_redn}{}\\{}
 ((\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}),\tsvar{msgs}):\tsunknown{net}){}\\{}
 (\tscon{Ln0\_call}(\tsvar{hid},\tsvar{tid},\tsvar{c})){}\\{}
 (\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}'),\tsvar{msgs}){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ A thread $\tsvar{tid}$ on host $\tsvar{h}$ executes a sockets call $\tsvar{c}$ }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{hs} \;\tsvar{hid} \;\tsvar{h} \;\tsvar{h}' \;\tsvar{tid} \;\tsvar{msgs} \;\tsvar{v}{}\\{}
\quad \tsvar{rn} \;\tsvar{rp} \;\tsvar{rc}.{}\\{}
 {}\\{}
 \tsvar{hid} \;\notin  \Mfdom{\tsvar{hs}} \Mwedge {}\\{}
 {}\\{}
 (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{h} \Mtransition{\MLhreturn{\tsvar{tid}}{\tsvar{v}}}{2XXXXX\Mtransitionerr{--=>}} \tsvar{h}'){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net\_redn}{}\\{}
 ((\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}),\tsvar{msgs}):\tsunknown{net}){}\\{}
 (\tscon{Ln0\_return}(\tsvar{hid},\tsvar{tid},\tsvar{v})){}\\{}
 (\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}'),\tsvar{msgs}){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ A thread $\tsvar{tid}$ on host $\tsvar{h}$ returns from a sockets call }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{hid} \;\tsvar{rn} \;\tsvar{rp} \;\tsvar{rc} \;\tsvar{h} \;\tsvar{hs} \;\tsvar{h}' \;\tsvar{msgs} \;\tsvar{msg} \;\tsunknown{new\_msgs}.{}\\{}
 {}\\{}
 \tsvar{hid} \;\notin  \Mfdom{\tsvar{hs}} \Mwedge {}\\{}
 {}\\{}
 (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{h} \Mtransition{\MLhsenddatagram{\tsvar{msg}}}{2XXXXX\Mtransitionerr{--=>}} \tsvar{h}') \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Zero, one, or many messages, with different lifetimes $\tsvar{dur}$, may be added to the network. }{}\\{}
 (\forall  \tsunknown{new\_msg}. \tsunknown{BAG\_IN} \;\tsunknown{new\_msg} \;\tsunknown{new\_msgs} \implies  \exists  \tsvar{dur}. \tsunknown{new\_msg} = (\Mtimed{\tsvar{msg}}{\tsaux{sharp\_timer} \;\tsvar{dur}})){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net\_redn}{}\\{}
 ((\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}),\tsvar{msgs}):\tsunknown{net}){}\\{}
 \tscon{Ln0\_tau}{}\\{}
 (\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}'),\tsunknown{BAG\_UNION} \;\tsvar{msgs} \;\tsunknown{new\_msgs}){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ A host sends a message to the network. The message may be lost or finitely duplicated. }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  (\tsvar{hid}:\tstype{hostid}) \tsvar{rn} \;\tsvar{rp} \;\tsvar{rc} \;\tsvar{h} \;\tsvar{hs} \;\tsunknown{d} \;\tsvar{h}' \;\tsvar{msgs} \;\tsvar{msg}.{}\\{}
 {}\\{}
 \tsvar{hid} \;\notin  \Mfdom{\tsvar{hs}} \Mwedge {}\\{}
 {}\\{}
 \tsaux{timer\_expires} (\tsaux{sharp\_timer} \;\tsunknown{d}) \Mwedge {}\\{}
 {}\\{}
 (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{h} \Mtransition{\MLhrecvdatagram{\tsvar{msg}}}{2XXXXX\Mtransitionerr{--=>}} \tsvar{h}'){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net\_redn}{}\\{}
 ((\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}),\tsunknown{BAG\_INSERT} (\Mtimed{\tsvar{msg}}{\tsaux{sharp\_timer} \;\tsunknown{d}}) \tsvar{msgs})){}\\{}
 \tscon{Ln0\_tau}{}\\{}
 (\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}'),\tsvar{msgs}){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ A host $\tsvar{h}$ receives a message $\tsunknown{m}$ from the network }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{hid} \;\tsvar{rn} \;\tsvar{rp} \;\tsvar{rc} \;\tsvar{h} \;\tsvar{hs} \;\tsvar{h}' \;\tsvar{msgs} \;\tsvar{msg}.{}\\{}
 {}\\{}
 \tsvar{hid} \;\notin  \Mfdom{\tsvar{hs}} \Mwedge {}\\{}
 {}\\{}
 (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{h} \Mtransition{\MLhloopdatagram{\tsvar{msg}}}{2XXXXX\Mtransitionerr{--=>}} \tsvar{h}'){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net\_redn}{}\\{}
 ((\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}),\tsvar{msgs}):\tsunknown{net}){}\\{}
 \tscon{Ln0\_tau}{}\\{}
 (\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}'),\tsvar{msgs}){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ A host $\tsvar{h}$ receives a message $\tsunknown{m}$ on loopback.
     FIXME N.B. timing consideration for loopback are not taken into
     account here (or elsewhere?) }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{hid} \;\tsvar{rn} \;\tsvar{rp} \;\tsvar{rc} \;\tsvar{h} \;\tsvar{hs} \;\tsvar{h}' \;\tsvar{msgs}{}\\{}
\quad \tsvar{ifid} \;\tsvar{up}.{}\\{}
 {}\\{}
 \tsvar{hid} \;\notin  \Mfdom{\tsvar{hs}} \Mwedge {}\\{}
 {}\\{}
 (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{h} \Mtransition{\tscon{Lh\_interface} (\tsvar{ifid},\tsvar{up})}{2XXXXX\Mtransitionerr{--=>}} \tsvar{h}'){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net\_redn}{}\\{}
 ((\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}),\tsvar{msgs}):\tsunknown{net}){}\\{}
 (\tscon{Ln0\_interface} (\tsvar{hid},\tsvar{ifid},\tsvar{up})){}\\{}
 (\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}'),\tsvar{msgs}){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Network interface change }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{hid} \;\tsvar{rn} \;\tsvar{rp} \;\tsvar{rc} \;\tsvar{h} \;\tsvar{hs} \;\tsvar{h}' \;\tsvar{msgs}.{}\\{}
 {}\\{}
 \tsvar{hid} \;\notin  \Mfdom{\tsvar{hs}} \Mwedge {}\\{}
 {}\\{}
 (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{h} \Mtransition{\MLhtau }{2XXXXX\Mtransitionerr{--=>}} \tsvar{h}'){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net\_redn}{}\\{}
 ((\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}),\tsvar{msgs}):\tsunknown{net}){}\\{}
 \tscon{Ln0\_tau}{}\\{}
 (\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}'),\tsvar{msgs}){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Allow a host to do a $\MLhtau $ transition }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{rn} \;\tsvar{rp} \;\tsvar{rc} \;\tsvar{hs} \;\tsvar{hs}' \;\tsvar{msgs} \;\tsvar{msgs}' \;\tsvar{dur} \;\tsvar{msgs}''.{}\\{}
 {}\\{}
 \tsholcomm{ Time passes for the hosts. }{}\\{}
 \Mfdom{\tsvar{hs}'} = \Mfdom{\tsvar{hs}} \Mwedge {}\\{}
 (\forall  \tsvar{h}. \tsvar{h} \;\in  \Mfdom{\tsvar{hs}} \implies  (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{hs} \Mfapply{}{\tsvar{h}} \Mtransition{\Meps{\tsvar{dur}}}{2XXXXX\Mtransitionerr{--=>}} \tsvar{hs}' \Mfapply{}{\tsvar{h}})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Time passes for the messages. }{}\\{}
 \tsvar{msgs}'' = \tsunknown{BAG\_IMAGE} (\tsaux{Time\_Pass\_timed} \;\tsvar{dur}) \tsvar{msgs} \Mwedge {}\\{}
 \neg{} (\tsunknown{BAG\_IN} \;* \;\tsvar{msgs}'') \Mwedge {}\\{}
 \tsvar{msgs}' = \tsunknown{BAG\_IMAGE} \;\tsholop{THE} \;\tsvar{msgs}''{}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net\_redn}{}\\{}
 ((\tsvar{hs},\tsvar{msgs}):\tsunknown{net}){}\\{}
 (\tscon{Ln0\_epsilon} \;\tsvar{dur}){}\\{}
 (\tsvar{hs}',\tsvar{msgs}'){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Allow time to pass for hosts and messages }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{hid} \;\tsvar{rn} \;\tsvar{rp} \;\tsvar{rc} \;\tsvar{h} \;\tsvar{hs} \;\tsvar{h}' \;\tsvar{msgs} \;\tsvar{tr}.{}\\{}
 {}\\{}
 \tsvar{hid} \;\notin  \Mfdom{\tsvar{hs}} \Mwedge {}\\{}
 {}\\{}
 (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{h} \Mtransition{\tscon{Lh\_trace} \;\tsvar{tr}}{2XXXXX\Mtransitionerr{--=>}} \tsvar{h}'){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net\_redn}{}\\{}
 ((\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}),\tsvar{msgs}):\tsunknown{net}){}\\{}
 (\tscon{Ln0\_trace} \;\tsvar{tr}){}\\{}
 (\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}'),\tsvar{msgs}){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Trace records }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \tsholcomm{ FIXME yet to do message loss. Also need to think about relation between network time passing and host time passing- aren't there urgent things that the host needs to do? }}
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommnetTLTS}
\showrule{\seccommnetTLTS}
\showrule{\defntypeTabbrevTmsgs}
\showrule{\defntypeTabbrevThosts}
\showrule{\defntypeTabbrevTnet}
\showrule{\defnhostsTtoTnet}
\showrule{\defnLnetZ}
\showrule{\defntlangTtyping}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore net1

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\newcommand{\chapcommnetTLTS}{\chaptersection{ Net LTS: detailed network semantics for Spec1}
\label{net_LTS}%
\chapcomm{
FIXME some text


}
}

\newcommand{\seccommnetTLTS}{\clustersection{(TCP only)}{Net LTS}
\seccomm{
FIXME some text


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{Lnet1}$
&
&  Net1 transition labels \\
$\tsrule{tlang\_typing}$
&
& \\
$\tsrule{is\_initial\_net}$
&
& \\
$\tsrule{is\_net1\_path}$
&
&  A trace of the system is a sequence of transitions, where the initial, i.e. $0$, state is drawn from a set of start states. \\
$\tsrule{Lnet1\_to\_Lnet0}$
&
& \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnLnetI}{\ddefnn{LnetI}{\iA{Lnet1}}{\subddefnA[{ Net1 transition labels }]{Lnet1}{\tstype{Lnet1} ={}\\{}
\quad\quad \tscomm{ host transition lifted to network }{}\\{}
 {}\\{}
\quad\quad \tsholcomm{ INVARIANT expect that Lhost0 is not $% TCP1_net1Script.sml:81:52-62:WARNING: curry parse failed: Lh_epsilon ==> \Meps 5: unexpected end of input.
\tscon{Lh\_epsilon}$: time passes for all hosts, not just
         a particular host FIXME restructure Spec1 to take account of this: epsilon removed from
         Lhost0, new message type Lhost1?

         FIXME do we want to allow hosts to make tau trans separately from the network? In hostLTS
         Tau transitions correspond to something actually happening, and presumably stuttering is
         handled elsewhere. So we have hosts that can make tau transitions on their own, but a
         network that cannot. }{}\\{}
 {}\\{}
\quad\quad\quad \tscon{Ln1\_host} \;\Mof  \;\tstype{hostid} \# \tstype{Lhost0}                            \tsholcomm{ invocation of call on host, written e.g.~$\tsunknown{Ln\_host} (\tsunknown{hid},\tsunknown{c})$ } {}\\{}
 {}\\{}
\quad\quad \tscomm{ miscellaneous }{}\\{}
\quad\quad \mid  \tscon{Ln1\_epsilon} \;\Mof  \;\tsaux{duration}                              \tsholcomm{ time passage, written $\Meps{\tsunknown{dur}}$ } }
}
{}
}

\newcommand{\defntlangTtyping}{\ddefnn{tlangTtyping}{\iA{tlang\_typing}}{\subddefnA{tlang\_typing}{(\forall  \tsvar{hs} \;\tsvar{hid} \;\tsvar{h} \;\tsvar{h}' \;\tsvar{lbl} \;\tsvar{msgs}{}\\{}
\quad \tsvar{rn} \;\tsvar{rp} \;\tsvar{rc}.{}\\{}
 {}\\{}
 \tsvar{hid} \;\notin  \Mfdom{\tsvar{hs}} \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Only handle labels $\tsvar{lbl}$ that do not affect the messages in the network. }{}\\{}
 (\neg{} \exists  \tsvar{m}. \tsvar{lbl} = (\MLhsenddatagram{\tsvar{m}})) \Mwedge {}\\{}
 (\neg{} \exists  \tsvar{m}. \tsvar{lbl} = (\MLhrecvdatagram{\tsvar{m}})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Do not allow $% TCP1_net1Script.sml:113:25-35:WARNING: curry parse failed: Lh_epsilon ==> \Meps 5: unexpected end of input.
\tscon{Lh\_epsilon}$ transitions for hosts. }{}\\{}
 ( \neg{} \exists  \tsvar{dur}. \tsvar{lbl} = (\Meps{\tsvar{dur}})) \Mwedge {}\\{}
 {}\\{}
 (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{h} \Mtransition{\tsvar{lbl}}{2XXXXX\Mtransitionerr{--=>}} \tsvar{h}'){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net1\_redn}{}\\{}
 ((\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}),\tsvar{msgs}):\tsunknown{net}){}\\{}
 (\tscon{Ln1\_host}(\tsvar{hid},\tsvar{lbl})){}\\{}
 (\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}'),\tsvar{msgs}){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ A host $\tsvar{h}$ executes a non $% TCP1_net1Script.sml:126:41-51:WARNING: curry parse failed: Lh_epsilon ==> \Meps 5: unexpected end of input.
\tscon{Lh\_epsilon}$ transition that does not affect the messages on
     the network. }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{hs} \;\tsvar{hid} \;\tsvar{h} \;\tsvar{h}' \;\tsvar{lbl} \;\tsvar{msgs} \;\tsvar{msg} \;\tsunknown{new\_msgs}{}\\{}
\quad \tsvar{rn} \;\tsvar{rp} \;\tsvar{rc}.{}\\{}
 {}\\{}
 \tsvar{hid} \;\notin  \Mfdom{\tsvar{hs}} \Mwedge {}\\{}
 {}\\{}
 (\tsvar{lbl} = (\MLhsenddatagram{\tsvar{msg}})) \Mwedge {}\\{}
 {}\\{}
 (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{h} \Mtransition{\tsvar{lbl}}{2XXXXX\Mtransitionerr{--=>}} \tsvar{h}') \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Zero, one, or many messages, with different lifetimes $\tsvar{dur}$, may be added to the network. }{}\\{}
 (\forall  \tsunknown{new\_msg}. \tsunknown{BAG\_IN} \;\tsunknown{new\_msg} \;\tsunknown{new\_msgs} \implies  \exists  \tsvar{dur}. \tsunknown{new\_msg} = (\Mtimed{\tsvar{msg}}{\tsaux{sharp\_timer} \;\tsvar{dur}})){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net1\_redn}{}\\{}
 ((\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}),\tsvar{msgs}):\tsunknown{net}){}\\{}
 (\tscon{Ln1\_host}(\tsvar{hid},\tsvar{lbl})){}\\{}
 (\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}'),\tsunknown{BAG\_UNION} \;\tsvar{msgs} \;\tsunknown{new\_msgs}){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ A host sends a message to the network. The message may be lost or finitely duplicated. }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{hs} \;\tsvar{hid} \;\tsvar{h} \;\tsvar{h}' \;\tsvar{lbl} \;\tsvar{msgs} \;\tsvar{msg} \;\tsvar{dur}{}\\{}
\quad \tsvar{rn} \;\tsvar{rp} \;\tsvar{rc}.{}\\{}
 {}\\{}
 \tsvar{hid} \;\notin  \Mfdom{\tsvar{hs}} \Mwedge {}\\{}
 {}\\{}
 \tsaux{timer\_expires} (\tsaux{sharp\_timer} \;\tsvar{dur}) \Mwedge {}\\{}
 {}\\{}
 (\tsvar{lbl} = (\MLhrecvdatagram{\tsvar{msg}})) \Mwedge {}\\{}
 {}\\{}
 (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{h} \Mtransition{\tsvar{lbl}}{2XXXXX\Mtransitionerr{--=>}} \tsvar{h}'){}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net1\_redn}{}\\{}
 ((\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}),\tsunknown{BAG\_INSERT} (\Mtimed{\tsvar{msg}}{\tsaux{sharp\_timer} \;\tsvar{dur}}) \tsvar{msgs}):\tsunknown{net}){}\\{}
 (\tscon{Ln1\_host}(\tsvar{hid},\tsvar{lbl})){}\\{}
 (\tsvar{hs} \oplus  (\tsvar{hid},\tsvar{h}'),\tsvar{msgs}){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ A host $\tsvar{h}$ receives a message $\tsvar{m}$ from the network }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \Mwedge {}\\{}
 {}\\{}
 (\forall  \tsvar{rn} \;\tsvar{rp} \;\tsvar{rc} \;\tsvar{hs} \;\tsvar{hs}' \;\tsvar{msgs} \;\tsvar{msgs}' \;\tsvar{dur} \;\tsvar{msgs}''.{}\\{}
 {}\\{}
 \tsholcomm{ Time passes for the hosts. }{}\\{}
 \Mfdom{\tsvar{hs}'} = \Mfdom{\tsvar{hs}} \Mwedge {}\\{}
 (\forall  \tsvar{h}. \tsvar{h} \;\in  \Mfdom{\tsvar{hs}} \implies  (\tsvar{rn} /* \tsvar{rp}, \tsvar{rc} */ \tsvar{hs} \Mfapply{}{\tsvar{h}} \Mtransition{\Meps{\tsvar{dur}}}{2XXXXX\Mtransitionerr{--=>}} \tsvar{hs}' \Mfapply{}{\tsvar{h}})) \Mwedge {}\\{}
 {}\\{}
 \tsholcomm{ Time passes for the messages. }{}\\{}
 \tsvar{msgs}'' = \tsunknown{BAG\_IMAGE} (\tsaux{Time\_Pass\_timed} \;\tsvar{dur}) \tsvar{msgs} \Mwedge {}\\{}
 \neg{} (\tsunknown{BAG\_IN} \;* \;\tsvar{msgs}'') \Mwedge {}\\{}
 \tsvar{msgs}' = \tsunknown{BAG\_IMAGE} \;\tsholop{THE} \;\tsvar{msgs}''{}\\{}
 {}\\{}
 \implies {}\\{}
 {}\\{}
 \tsunknown{net1\_redn}{}\\{}
 ((\tsvar{hs},\tsvar{msgs}):\tsunknown{net}){}\\{}
 (\tscon{Ln1\_epsilon} \;\tsvar{dur}){}\\{}
 (\tsvar{hs}',\tsvar{msgs}'){}\\{}
 {}\\{}
 {}\\{}
 \tsholcomm{ Allow time to pass for hosts and messages }{}\\{}
 {}\\{}
 ){}\\{}
 {}\\{}
 \tsholcomm{ FIXME tjr also need to consider interface changes- what happens here? (ICMP sent?) }}
}
{}
}

\newcommand{\defnisTinitialTnet}{\ddefnn{isTinitialTnet}{\iA{is\_initial\_net}}{\subddefnA{is\_initial\_net}{\tsaux{is\_initial\_net} (\tsunknown{net}:\tsunknown{net}) ={}\\{}
\quad \tsholcomm{ FIXME mn pull initial hosts into hostLTS from evalSupportScript, then use defn of initialhost in the following }{}\\{}
\quad \exists  \tsunknown{initial\_hosts}. \tsunknown{initial\_hosts} \;\in  \;\tsunknown{ARB} \Mwedge {}\\{}
\quad \Mlet  \;\tsunknown{initial\_msgs} = \tsunknown{EMPTY\_BAG} \;\Min {}\\{}
\quad\quad \tsunknown{net} = (\tsunknown{initial\_hosts}, \tsunknown{initial\_msgs})}
}
{}
}

\newcommand{\defnisTnetITpath}{\ddefnn{isTnetITpath}{\iA{is\_net1\_path}}{\subddefnA[{ A trace of the system is a sequence of transitions, where the initial, i.e. $0$, state is drawn from a set of start states. }]{is\_net1\_path}{\tsaux{is\_net1\_path} (\tsunknown{states}:\tstype{num}\Mtotype \tsunknown{net},\tsunknown{labels}:\tstype{num}\Mtotype \tstype{Lnet1}) ={}\\{}
\quad (\tsaux{is\_initial\_net} (\tsunknown{states} \;0) \Mwedge {}\\{}
\quad (\forall  \tsvar{n}. \tsunknown{net1\_redn} (\tsunknown{states} \;\tsvar{n}) (\tsunknown{labels} \;\tsvar{n}) (\tsunknown{states} (\tsunknown{SUC} \;\tsvar{n}))))}
}
{}
}

\newcommand{\defnLnetITtoTLnetZ}{\ddefnn{LnetITtoTLnetZ}{\iA{Lnet1\_to\_Lnet0}}{\subddefnA{Lnet1\_to\_Lnet0}{\tsaux{Lnet1\_to\_Lnet0} (\tsunknown{lbl1}:\tstype{Lnet1}) = (\Mcase  \;\tsunknown{lbl1} \;\Mof {}\\{}
\quad\quad \tscon{Ln1\_host} (\tsunknown{hid},\tsunknown{lbl0}) \Mtotype  (\Mcase  \;\tsunknown{lbl0} \;\Mof {}\\{}
\quad\quad\quad\quad \MLhsenddatagram{\tstype{msg}} \Mtotype  \tscon{Ln0\_tau}{}\\{}
\quad\quad\quad \Mdpipe  \MLhrecvdatagram{\tstype{msg}} \Mtotype  \tscon{Ln0\_tau}{}\\{}
\quad\quad\quad \Mdpipe  \MLhcall{\tstype{tid}}{\tsunknown{lib}} \Mtotype  \tscon{Ln0\_call} (\tsunknown{hid},\tstype{tid},\tsunknown{lib}){}\\{}
\quad\quad\quad \Mdpipe  \MLhreturn{\tstype{tid}}{\tsunknown{tlang}} \Mtotype  \tscon{Ln0\_return} (\tsunknown{hid},\tstype{tid},\tsunknown{tlang}){}\\{}
\quad\quad\quad \Mdpipe  \MLhloopdatagram{\tstype{msg}} \Mtotype  \tscon{Ln0\_tau}{}\\{}
\quad\quad\quad \Mdpipe  \tscon{Lh\_interface} (\tstype{ifid},\tsvar{b}) \Mtotype  \tscon{Ln0\_interface} (\tsunknown{hid},\tstype{ifid},\tsvar{b}){}\\{}
\quad\quad\quad \Mdpipe  \MLhtau  \Mtotype  \tscon{Ln0\_tau}{}\\{}
\quad\quad\quad \Mdpipe  \tscon{Lh\_trace} \;\tsunknown{tr} \Mtotype  \tscon{Ln0\_trace} \;\tsunknown{tr}{}\\{}
\quad\quad\quad \Mdpipe  \Meps{\tsunknown{dur}} \Mtotype  \tsunknown{ARB} \text{``Lnet1\textunderscore{}to\textunderscore{}Lnet0:1''}\tscomm{ Ln0\textunderscore{}epsilon dur }{}\\{}
\quad\quad\quad \Mdpipe  \tsunknown{\_1} \Mtotype  \tsunknown{ARB} \text{``Lnet1\textunderscore{}to\textunderscore{}Lnet0:2''}){}\\{}
\quad \Mdpipe  \tscon{Ln1\_epsilon} \;\tsunknown{dur} \Mtotype  \tscon{Ln0\_epsilon} \;\tsunknown{dur})}
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommnetTLTS}
\showrule{\seccommnetTLTS}
\showrule{\defnLnetI}
\showrule{\defntlangTtyping}
\showrule{\defnisTinitialTnet}
\showrule{\defnisTnetITpath}
\showrule{\defnLnetITtoTLnetZ}
}

%%%% END %%%%
\let\dumpallrules\relax

%% PART TCP1\protect\textunderscore evalSupport

\def\rulesrcsid{}
%%%% AUTOGENERATED FILE (from LTS source) -- DO NOT EDIT! %%%%
\def\rulesrcsid{\$Id: alldoc-inc.tex,v 1.1 2009/02/18 14:14:04 tjr22 Exp $}

\newcommand{\chapcommTCPITevalSupport}{\chaptersection{ Initial state}
\label{TCP1_evalSupport}%
\chapcomm{
This file defines a function to construct certain initial host states for use in automated trace checking, along with other
constants used in typical traces.
The interfaces, routing table and some host fields are taken from the \wasverb{initial\textunderscore{}host} line at the
  start of a valid trace.

}
}

\newcommand{\seccommevalsTfoo}{\clustersection{(TCP and UDP)}{Initial state}
\seccomm{
The initial state of a host.


}\clustersubsection{Summary}
\par\begin{ltstabulariii}
$\tsrule{simple\_ifd\_eth}$
&
&  simple ethernet interface \\
$\tsrule{simple\_ifd\_lo}$
&
&  simple loopback interface \\
$\tsrule{simple\_rttab}$
&
&  simple routing table \\
$\tsrule{tid\_initial}$
&
&  initial thread id \\
$\tsrule{simple\_host}$
&
&  simple host state \\
$\tsrule{dummy\_cb}$
&
& \\
$\tsrule{dummy\_socket}$
&
&  minimal socket \\
$\tsrule{dummy\_sockets}$
&
& \\
$\tsrule{initial\_host}$
&
&  function to construct an initial host for trace checking \end{ltstabulariii}\par
\clustersubsection{Rules}
~}

\newcommand{\defnsimpleTifdTeth}{\ddefnn{simpleTifdTeth}{\iA{simple\_ifd\_eth}}{\subddefnA[{ simple ethernet interface }]{simple\_ifd\_eth}{\tsaux{simple\_ifd\_eth} \;\tsunknown{i} = (\tscon{ETH} \;0, \Mmagiclrec  \tsvar{ipset} \Mass  \{\tsunknown{i}\}; \tsvar{primary} \Mass  \tsunknown{i}; \tsvar{netmask} \Mass  \tscon{NETMASK} \;24; \tsvar{up} \Mass  \Mtrue  \Mmagicrrec )}
}
{}
}

\newcommand{\defnsimpleTifdTlo}{\ddefnn{simpleTifdTlo}{\iA{simple\_ifd\_lo}}{\subddefnA[{ simple loopback interface }]{simple\_ifd\_lo}{\tsaux{simple\_ifd\_lo} = (\tscon{LO}, \Mmagiclrec  \tsvar{ipset} \Mass  \tsaux{LOOPBACK\_ADDRS}; \tsvar{primary} \Mass  \tsaux{ip\_localhost};{}\\{}
 \tsvar{netmask}\Mass  \tscon{NETMASK} \;8; \tsvar{up} \Mass  \Mtrue  \Mmagicrrec )}
}
{}
}

\newcommand{\defnsimpleTrttab}{\ddefnn{simpleTrttab}{\iA{simple\_rttab}}{\subddefnA[{ simple routing table }]{simple\_rttab}{\tsaux{simple\_rttab} = [\Mmagiclrec  \tsfield{destination\_ip} \Mass  \tsaux{ip\_localhost};{}\\{}
 \tsfield{destination\_netmask} \Mass  \tscon{NETMASK} \;8;{}\\{}
 \tsvar{ifid} \Mass  \tscon{LO} \Mmagicrrec ;{}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mmagiclrec  \tsfield{destination\_ip} \Mass  \tsaux{IP} \;0 \;0 \;0 \;0;{}\\{}
 \tsfield{destination\_netmask} \Mass  \tscon{NETMASK} \;0;{}\\{}
 \tsvar{ifid} \Mass  \tscon{ETH} \;0 \Mmagicrrec ]}
}
{}
}

\newcommand{\defntidTinitial}{\ddefnn{tidTinitial}{\iA{tid\_initial}}{\subddefnA[{ initial thread id }]{tid\_initial}{\tsaux{tid\_initial} = \tscon{TID} \;0}
}
{}
}

\newcommand{\defnsimpleThost}{\ddefnn{simpleThost}{\iA{simple\_host}}{\subddefnA[{ simple host state }]{simple\_host}{\tsaux{simple\_host} \;\tsunknown{i} \;\tsunknown{tick0} \;\tsunknown{remdr0} ={}\\{}
\quad \Mmagiclrec  \tstype{arch}  \Mass  \tscon{FreeBSD\_4\_6\_RELEASE} ;{}\\{}
 \tsvar{privs} \Mass  \Mfalse ;{}\\{}
 \tsvar{ifds}  \Mass  \emptyset  \oplus  [\tsaux{simple\_ifd\_lo}; \tsaux{simple\_ifd\_eth} \;\tsunknown{i}] ;{}\\{}
 \tsvar{rttab} \Mass  \tsaux{simple\_rttab};{}\\{}
 \tsvar{ts}    \Mass  \Mfupdate{\emptyset }{\tsaux{tid\_initial}}{ \Mtimed{\tscon{Run}}{\tsaux{never\_timer}}} ;{}\\{}
 \tsvar{files} \Mass  \emptyset  ;{}\\{}
 \tsvar{socks} \Mass  \emptyset  ;{}\\{}
 \tslib{listen} \Mass  [\,] ;{}\\{}
 \tsvar{bound} \Mass  [\,] ;{}\\{}
 \tsvar{iq}    \Mass  \Mtimed{[\,]}{\tsaux{never\_timer}} ;{}\\{}
 \tsvar{oq}    \Mass  \Mtimed{[\,]}{\tsaux{never\_timer}} ;{}\\{}
 \tsvar{bndlm} \Mass  \tsaux{bandlim\_state\_init} ;{}\\{}
 \tsvar{ticks} \Mass  \tscon{Ticker}(\tsunknown{tick0}, \tsunknown{remdr0}, \tsaux{tickintvlmin}, \tsaux{tickintvlmax}) ;{}\\{}
 \tsvar{fds}   \Mass  \emptyset ;{}\\{}
 \tsvar{params}\Mass  \Mmagiclrec  \tsfield{min\_eph\_port} \Mass  1024; \tsfield{max\_eph\_port} \Mass  5000 \Mmagicrrec {}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\defndummyTcb}{\ddefnn{dummyTcb}{\iA{dummy\_cb}}{\subddefnA{dummy\_cb}{\tsaux{dummy\_cb} = \Mmagiclrec  \tsfield{tt\_rexmt} \Mass  *;{}\\{}
 \tsfield{tt\_2msl} \Mass  *;{}\\{}
 \tsfield{tt\_conn\_est} \Mass  *;{}\\{}
 \tsfield{tt\_delack} \Mass  *;{}\\{}
 \tsfield{tt\_keep} \Mass  *;{}\\{}
 \tsfield{tt\_fin\_wait\_2} \Mass  *;{}\\{}
 \tsfield{t\_idletime} \Mass  \tscon{Stopwatch}(0, 1, 1);{}\\{}
 \tsfield{t\_badrxtwin} \Mass  \tscon{TimeWindowClosed};{}\\{}
 \tsfield{ts\_recent} \Mass  \tscon{TimeWindowClosed} \Mmagicrrec }
}
{}
}

\newcommand{\defndummyTsocket}{\ddefnc{dummyTsocket}{\iA{dummy\_socket}}{\subddefnA[{ minimal socket }]{dummy\_socket}{\tsaux{dummy\_socket} (\tsvar{is},\tsunknown{p}) ={}\\{}
\quad\quad\quad\quad\quad\quad\quad \Mmagiclrec  \tstype{fid} \Mass  *;{}\\{}
\quad\quad\quad\quad \tsvar{sf}  \Mass  \Mmagiclrec  \tsvar{b} \Mass  \lambda \tsvar{x}.\Mfalse ; \tsvar{n} \Mass  \lambda \tsvar{x}.0; \tsvar{t} \Mass  \lambda \tsvar{x}.\infty \Mmagicrrec ;{}\\{}
\quad\quad\quad\quad \tsvar{is}_{1} \Mass  \tsvar{is};{}\\{}
\quad\quad\quad\quad \tsvar{ps}_{1} \Mass  \Msome  \;\tsunknown{p};{}\\{}
\quad\quad\quad\quad \tsvar{is}_{2} \Mass  *;{}\\{}
\quad\quad\quad\quad \tsvar{ps}_{2} \Mass  *;{}\\{}
\quad\quad\quad\quad \tsvar{pr}  \Mass  \tscon{TCP\_PROTO}(\Mmagiclrec  \tsvar{st}  \Mass  \tscon{LISTEN};{}\\{}
 \tsvar{cb}  \Mass  \tsaux{dummy\_cb};{}\\{}
 \tsvar{lis} \Mass  \Msome  \Mmagiclrec  \tsvar{q}_{0} \Mass  [\,]; \tsvar{q} \Mass  [\,]; \tsvar{qlimit} \Mass  10 \Mmagicrrec {}\\{}
 \Mmagicbolrrec ){}\\{}
\quad\quad\quad \Mmagicbolrrec }
}
{\rulesubsection{Description}
This is a pretty minimally-defined socket, just enough to say
   "this port is bound".
\rrulepad }
}

\newcommand{\defndummyTsockets}{\ddefnn{dummyTsockets}{\iA{dummy\_sockets}}{\subddefnA{dummy\_sockets}{\tsaux{dummy\_sockets} \;\tsvar{n}     [\,]  = [\,] \Mwedge {}\\{}
 \tsaux{dummy\_sockets} \;\tsvar{n} (\tsunknown{p}\Mcons \tsvar{ps}) = (\tscon{SID} \;\tsvar{n},\tsaux{dummy\_socket} \;\tsunknown{p}) \Mcons  \tsaux{dummy\_sockets} (\tsvar{n}+1) \tsvar{ps}}
}
{}
}

\newcommand{\defninitialThost}{\ddefnn{initialThost}{\iA{initial\_host}}{\subddefnA[{ function to construct an initial host for trace checking }]{initial\_host}{\tsaux{initial\_host} (\tsunknown{i}:\tstype{ip}) (\tsvar{t}:\tstype{tid}) (\tstype{arch}:\tstype{arch}) (\tsunknown{ispriv}:\tstype{bool}){}\\{}
\quad\quad\quad\quad\quad (\tsunknown{heldports}:(\tstype{ip} \;\;\tstype{option} \# \tstype{port}) \tstype{list}) (\tsunknown{ifaces}: (\tsvar{ifid} \# \tstype{ifd}) \tstype{list}){}\\{}
\quad\quad\quad\quad\quad (\tsunknown{rt}: \tsunknown{routing\_table}){}\\{}
\quad\quad\quad\quad\quad (\tsunknown{prealloc\_fds}: \tstype{num} \;\tstype{list}){}\\{}
\quad\quad\quad\quad\quad (\tsunknown{init\_tick} : \tsaux{ts\_seq}){}\\{}
\quad\quad\quad\quad\quad (\tsunknown{init\_tick\_remdr} : \tsaux{duration}){}\\{}
\quad\quad\quad\quad\quad (\tsvar{params} : \tstype{hostParams}){}\\{}
 = \tsaux{simple\_host} \;\tsunknown{i} \;\tsunknown{init\_tick} \;\tsunknown{init\_tick\_remdr} \; \Mmagiclrec {}\\{}
 \tstype{arch} \Mass  \tstype{arch};{}\\{}
 \tsvar{privs} \Mass  \tsunknown{ispriv};{}\\{}
 \tsvar{ifds} \Mass  \emptyset  \oplus  \tsunknown{ifaces};{}\\{}
 \tsvar{rttab} \Mass  \tsunknown{rt};{}\\{}
 \tsvar{ts} \Mass  \Mfupdate{\emptyset }{\tsvar{t}}{ \Mtimed{\tscon{Run}}{\tsaux{never\_timer}}};{}\\{}
 \tslongcomm{ list of prealloacated fds is passed in as a list of ints, build the
     appropriate thing here }{}\\{}
 \tsvar{fds} \Mass  \emptyset  \oplus  (\tsholop{MAP} (\lambda \tsvar{x}. (\tscon{FD} \;\tsvar{x}, \tscon{FID} \;0)) \tsunknown{prealloc\_fds});{}\\{}
 \tslongcomm{
        fds := case arch of
                  (* per architecture, note down FDs preallocated for
                     internal use by OCaml or the test harness *)
                  Linux\textunderscore{}2\textunderscore{}4\textunderscore{}20\textunderscore{}8 -\textgreater{}
                    FEMPTY |++ [(FD 0, FID 0);
                                         (FD 1, FID 0);
                                         (FD 2, FID 0);
					 (FD 3, FID 0);
					 (FD 4, FID 0);
                                         (FD 5, FID 0);
                                         (FD 6, FID 0);
                                         (FD 1000, FID 0)
                                        ]
               || FreeBSD\textunderscore{}4\textunderscore{}6\textunderscore{}RELEASE -\textgreater{}
                    FEMPTY |++ [(FD 0, FID 0);
                                         (FD 1, FID 0);
                                         (FD 2, FID 0);
                                         (FD 3, FID 0);
                                         (FD 4, FID 0);
                                         (FD 5, FID 0);
                                         (FD 6, FID 0);
                                         (FD 7, FID 0)
                                        ]
               || WinXP\textunderscore{}Prof\textunderscore{}SP1 -\textgreater{}
                    FEMPTY;  (*: Windows FDs are not allocated in order, so
                                there's no need to specify anything here. :*)
        }{}\\{}
 \tsvar{files} \Mass  \emptyset  \oplus  (\tscon{FID} \;0,{}\\{}
 \tscon{File}(\tscon{FT\_Console}, \Mmagiclrec  \tsvar{b} \Mass  \lambda \tsvar{x}. \Mfalse  \Mmagicrrec ));{}\\{}
 \tsvar{socks} \Mass  \emptyset  \oplus  (\tsaux{dummy\_sockets} \;0 \;\tsunknown{heldports});{}\\{}
 \tsvar{params} \Mass  \tsvar{params}{}\\{}
 \Mmagicbolrrec }
}
{}
}

\newcommand{\dumpallrules}{
\showrule{\chapcommTCPITevalSupport}
\showrule{\seccommevalsTfoo}
\showrule{\defnsimpleTifdTeth}
\showrule{\defnsimpleTifdTlo}
\showrule{\defnsimpleTrttab}
\showrule{\defntidTinitial}
\showrule{\defnsimpleThost}
\showrule{\defndummyTcb}
\showrule{\defndummyTsocket}
\showrule{\defndummyTsockets}
\showrule{\defninitialThost}
}

%%%% END %%%%
\let\dumpallrules\relax

\def\rulesrcsid{}

