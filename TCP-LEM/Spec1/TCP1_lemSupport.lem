(* 

  todo:

  [ ] tidy up names eg IS_None

*)

open import List

let FILTER = List.filter
let MAP = List.map


open import Pervasives_extra

val FIXME: forall 'a. 'a
val ARB: forall 'a. 'a (* ARB is a constant available in HOL, typically used to model partial functions *)


let T = true
let F = false

let lem_transform T = true
let lem_transform F = false

declare pattern_match exhaustive bool = [ T; F ; ]

let FST = fst

let SND = snd

let MAX = max
let MIN = min

let num_MIN = min

let num_MAX = max

val I: forall 'a. 'a -> 'a
let I = fun x -> x

let failwith (s:string) = ARB


(******************************************************************************)
(* options maybe *)

let is_Some = isJust

let IS_None = isNothing

let THE = fromMaybe ARB

let option_case = maybe


type option 'a = maybe 'a
declare lem target_rep type option = `maybe` 

let lem_transform None = Nothing
let lem_transform Some = Just

declare pattern_match exhaustive maybe 'a = [ None; Some ; ]


(******************************************************************************)
(* nats *)

val shift_left: nat -> nat -> nat

val shift_right: nat -> nat -> nat



(******************************************************************************)
(* ints *)

type int = integer

val int_geq : int -> int -> bool (* FIXME these operations should be aliases for Lem's built in operations *)

val int_lt : int -> int -> bool

let rec EXP n m = if m = (0:nat) then (1:nat) else n * (EXP n (m-1))

val int_of_num : nat -> int

val num_of_int: int -> nat

val int_neg: int -> int

val int_DIV: int -> int -> int

val int_min: int -> int -> int


(******************************************************************************)
(* words *)

(* gives defns available in HOL but not available in Lem *)

(* following HOL model of words; the spec depends on the exact model
of words provided by HOL, so we don't reproduce these defns here *)

type word 'a = Word of 'a 

type word_size_16 = Word_size_16 of unit

type word_size_32 = Word_size_32 of unit

type word32 = word word_size_32 (* WORD32 of nat (* FIXME *) *)

let WORD32 (n:nat) = Word (Word_size_32 ())

type word16 = word word_size_16 (* WORD16 of nat (* FIXME *) *)

let WORD16 (n:nat) = Word (Word_size_16 ())

let n2w (n:nat) = WORD32 n

let n2w16 (n:nat) = WORD16 n

val w_minus: word32 -> word32 -> word32

val w_plus: word32 -> word32 -> word32

val w2n: forall 'a. word 'a -> nat

val word_zero: word32

val word16_zero: word16



(* following 3 defns from integer_word32 *)

val i2w: int -> word32

val w2i: word32 -> int

val INT32_SIGNED_MAX: word32 (* n2w 2147483647 *) (* FIXME lem fails to parse this as an int: failure int_of_string *)




(******************************************************************************)
(* reals *)

(* Lem does not support reals out-of-the-box, so we defined an isomorphic type here *)
type real = Real of (nat -> bool)

val real_from_numeral : numeral -> real

instance (Numeral real)
  let fromNumeral = real_from_numeral
end

val real_MAX: real -> real -> real

val real_MIN: real -> real -> real

val real_neg: real -> real
let ~ = real_neg (* FIXME *)


val real_gte: real -> real -> bool

val real_minus: real -> real -> real
val real_plus: real -> real -> real
val real_div: real -> real -> real 
val real_times: real -> real -> real

val real_gt: real -> real -> bool
val real_lt: real -> real -> bool
let real_lte (x:real) (y:real) = real_lt x y || (x=y)


instance (NumDivision real)
  let (/) = real_div
end

instance (NumMult real)
  let ( * ) = real_times
end


instance (NumAdd real)
  let (+) = real_plus
end


instance (NumMinus real)
  let (-) = real_minus
end


val duration_zero:real

let real_zero = (0:real)

val real_of_num: nat -> real

let real_compare (x:real) (y:real) = if real_lt x y then LT else if real_gt x y then GT else EQ

(* this also gives us Min and Max *)
instance (Ord real)
  let compare = real_compare
  let (<) = real_lt
  let (<=) = real_lte
  let (>) = real_gt
  let (>=) = real_gte
end

val abs: real -> real


(******************************************************************************)
(* lists *)

let LENGTH = List.length

let fold_left = foldl

let EVERY = all
(* val EVERY : forall 'a. ('a -> bool) -> list 'a -> bool *)

(* these HOL constants are not available in Lem, but could easily be defined here *)
val MAP2: forall 'a 'b 'c. ('a -> 'b -> 'c) -> list 'a -> list 'b -> list 'c

val EL: forall 'a. nat -> list 'a -> 'a



(******************************************************************************)
(* fmaps *)

(* various constants, most of which are not available in Lem currently *)

type fmap 'a 'b (* FIXME we should use Lem's built in fmaps *)
val FEMPTY : forall 'a 'b. fmap 'a 'b
val FUPDATE : forall 'a 'b. fmap 'a 'b -> ('a * 'b) -> fmap 'a 'b
val FAPPLY : forall 'a 'b. fmap 'a 'b -> 'a -> 'b
val FDOM : forall 'a 'b. fmap 'a 'b -> set 'a

val FRANGE : forall 'a 'b. fmap 'a 'b -> set 'b 

val domain: forall 'a 'b. fmap 'a 'b -> set 'a

val (|+) : forall 'a 'b. fmap 'a 'b -> 'a * 'b -> fmap 'a 'b

val (|++) : forall 'a 'b. fmap 'a 'b -> list ('a * 'b) -> fmap 'a 'b

val DRESTRICT: forall 'a 'b. fmap 'a 'b -> set 'a -> fmap 'a 'b

val o_f: forall 'a 'b 'c. ('b -> 'c) -> (fmap 'a 'b) -> (fmap 'a 'c)

val RRESTRICT : forall 'a 'b. fmap 'a 'b -> set 'b -> fmap 'a 'b

val DOMSUB: forall 'a 'b. fmap 'a 'b -> 'a -> fmap 'a 'b

val set_of_fmap: forall 'a 'b. fmap 'a 'b -> set ('a * 'b)



(******************************************************************************)
(* sets *)


val LEAST : set nat -> nat

let NOTIN x xs = not (x IN xs)

let BIGUNION s = { x | exists t. x IN t && (t IN s) }

val EMPTY: forall 'a. set 'a

val set_of_list: forall 'a. list 'a -> set 'a

val CARD : forall 'a. set 'a -> nat

val SET_CHOOSE : forall 'a. set 'a -> 'a

val UNIV: forall 'a. set 'a

val set_of_bool_fn: forall 'a. ('a -> bool) -> set 'a

val DIFF: forall 'a. set 'a -> set 'a -> set 'a



(******************************************************************************)
(* strings *)

type char = string (* FIXME FIXME *)

val CHR: nat -> char

val ORD: char -> nat

val IMPLODE: string -> string

val string_of_char_list: list char -> string

val STRLEN: string -> nat

