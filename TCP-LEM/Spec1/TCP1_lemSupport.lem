open import List
let FILTER = List.filter
let MAP = List.map


open import Pervasives_extra

type int = integer

(* contains defns available in HOL but not available in LEM, such as
word32; this comes before all other TCP1_xxx files; many FIXMEs *)

type char = string (* FIXME FIXME *)

val CHR: nat -> char
val ORD: char -> nat

type word32 = WORD32 of nat (* FIXME *)

type word16 = WORD16 of nat (* FIXME *)

let int_zero = 0 (* Int.int 0 *) (* FIXME remove this defn and occurrences in following *)

val int_geq : int -> int -> bool
val int_lt : int -> int -> bool

let FIXME_int = int_zero

let w2i w = FIXME_int

let n2w n = WORD32 n

let n2w16 n = WORD16 n

let FIXME_word32 = WORD32 0

let i2w i = FIXME_word32

let w_minus x y = FIXME_word32

let w_plus x y = FIXME_word32

let FIXME_num = 0

let w2n w = FIXME_num  (* FIXME needs a more specific type! *)

let INT32_SIGNED_MAX = FIXME_word32

let LENGTH = List.length

let T = true
let F = false

let rec EXP n m = if m = 0 then 1 else n * (EXP n (m-1))

let BIGUNION s = { x | exists t. x IN t && (t IN s) }

type fmap 'a 'b
val FEMPTY : forall 'a 'b. fmap 'a 'b
val FUPDATE : forall 'a 'b. fmap 'a 'b -> ('a * 'b) -> fmap 'a 'b
val FAPPLY : forall 'a 'b. fmap 'a 'b -> 'a -> 'b
val FDOM : forall 'a 'b. fmap 'a 'b -> set 'a

val FRANGE : forall 'a 'b. fmap 'a 'b -> set 'b 

val LEAST : set nat -> nat

let NOTIN x xs = not (x IN xs)


(* open Hol.Set_relation *)

val RRESTRICT : forall 'a 'b. fmap 'a 'b -> set 'b -> fmap 'a 'b

val CARD : forall 'a. set 'a -> nat

val SET_CHOOSE : forall 'a. set 'a -> 'a

val int_of_num : nat -> int

val FST : forall 'a 'b. ('a * 'b) -> 'a

val SND : forall 'a 'b. ('a * 'b) -> 'b

val EVERY : forall 'a. ('a -> bool) -> list 'a -> bool


val num_MIN: nat -> nat -> nat

val num_MAX: nat -> nat -> nat

val int_DIV: int -> int -> int

val int_min: int -> int -> int

val ARB: forall 'a. 'a

val shift_left: nat -> nat -> nat

val shift_right: nat -> nat -> nat

val set_of_bool_fn: forall 'a. ('a -> bool) -> set 'a

val DIFF: forall 'a. set 'a -> set 'a -> set 'a

val DOMSUB: forall 'a 'b. fmap 'a 'b -> 'a -> fmap 'a 'b

val set_of_fmap: forall 'a 'b. fmap 'a 'b -> set ('a * 'b)

val THE: forall 'a. maybe 'a -> 'a

val option_case: forall 'a 'b. 'b -> ('a -> 'b) -> maybe 'a -> 'b

val I: forall 'a. 'a -> 'a

let zero_w32 = WORD32 0

(* shadowed by definition elsewhere val Num: int -> num (* undefiend if int < 0*) *)

val num_of_int: int -> nat

val EL: forall 'a. nat -> list 'a -> 'a

(* FIXME this is a hack just to get a type for real *)
type real = Real of (nat -> bool)

val real_from_numeral : numeral -> real

let FIXME_real = Real (fun x -> true)


instance (Numeral real)
  let fromNumeral = real_from_numeral
end


val real_MAX: real -> real -> real

val real_MIN: real -> real -> real

val real_neg: real -> real

val real_gte: real -> real -> bool

let FIXME_real_div a b = FIXME_real

instance (NumDivision real)
  let (/) = FIXME_real_div
end

instance (NumAdd real)
  let (+) = fun x -> fun y -> FIXME_real
end





val int_neg: int -> int

val FIXME: forall 'a. 'a

val word_zero: word32

val word16_zero: word16

val duration_zero:real

val UNIV: forall 'a. set 'a

val is_Some: forall 'a. maybe 'a -> bool

val IS_None: forall 'a. maybe 'a -> bool

let fold_left = foldl

val domain: forall 'a 'b. fmap 'a 'b -> set 'a

val (|+) : forall 'a 'b. fmap 'a 'b -> 'a * 'b -> fmap 'a 'b

val (|++) : forall 'a 'b. fmap 'a 'b -> list ('a * 'b) -> fmap 'a 'b

val MAP2: forall 'a 'b 'c. ('a -> 'b -> 'c) -> list 'a -> list 'b -> list 'c


val DRESTRICT: forall 'a 'b. fmap 'a 'b -> set 'a -> fmap 'a 'b

val EMPTY: forall 'a. set 'a

val IMPLODE: string -> string

val string_of_char_list: list char -> string

val STRLEN: string -> nat

val o_f: forall 'a 'b 'c. ('b -> 'c) -> (fmap 'a 'b) -> (fmap 'a 'c)

val set_of_list: forall 'a. list 'a -> set 'a